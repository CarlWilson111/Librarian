{"globalvars": ["_ZN2gl16TexParameterIuivE", "_ZN2gl9GetFloatvE", "_ZTIN2cv12_OutputArrayE", "_ZN2gl22CheckFramebufferStatusE", "_ZN2gl10ReadBufferE", "_ZN2gl10ReadPixelsE", "_ZN2gl17CopyTexSubImage1DE", "_ZN2gl13TexParameteriE", "_ZN2gl22GetTexLevelParameterfvE", "sparse_mat_type", "_ZN2gl20EndConditionalRenderE", "_ZN2gl8GetErrorE", "_ZN2gl11PixelStoreiE", "_ZN2gl14CopyTexImage2DE", "_ZN2gl16VertexAttribI3ivE", "icv8x32fSqrTab", "_ZTVN2cv9MatOp_BinE", "_ZN2cv12g_Saturate8uE", "_ZN2gl18DeleteFramebuffersE", "_ZN2gl11GetTexImageE", "_ZN2gl10Uniform2uiE", "_ZN8CvModule4lastE", "_ZN2gl13ClearBufferivE", "_ZN2gl18GetAttachedShadersE", "_ZN2gl17GetVertexAttribfvE", "_ZN2gl16UniformMatrix3fvE", "_ZN2gl17VertexAttribI2uivE", "_ZN2gl9IsTextureE", "_ZN2gl17VertexAttribI4ubvE", "_ZN2gl17MultiDrawElementsE", "_ZTVN2cv16ParallelLoopBodyE", "_ZTVN2cv13BaseRowFilterE", "_ZN2gl19VertexAttribPointerE", "_ZTVN2cv12MatOp_InvertE", "_ZN2gl7DisableE", "_ZTIN2cv9MatOp_CmpE", "_ZN2cv13g_8x16uSqrTabE", "_ZN2gl15TexCoordPointerE", "_ZN2gl5OrthoE", "_ZN2gl30RenderbufferStorageMultisampleE", "_ZN2gl17VertexAttribI4usvE", "_ZN2gl19GetTexParameterIuivE", "icvSaturate8u_cv", "_ZN2gl35GetFramebufferAttachmentParameterivE", "_ZN2gl10ClearColorE", "_ZTVN2cv12FilterEngineE", "_ZTSN2cv11MatOp_AddExE", "_ZN2gl13GetUniformuivE", "_ZN2gl20CompressedTexImage3DE", "_ZN2gl16GetQueryObjectivE", "_ZN2gl9LineWidthE", "_ZN2gl17GetBufferPointervE", "_ZN2gl13CreateProgramE", "_ZTVN2cv12_OutputArrayE", "_ZTVN2cv16BaseColumnFilterE", "_ZN2gl20EndTransformFeedbackE", "_ZN2gl18GetTexParameterIivE", "_ZN2gl10BufferDataE", "_ZN2gl10BlendColorE", "_ZN2gl12GetUniformfvE", "_ZN2gl20CompressedTexImage2DE", "_ZN2gl5ClearE", "seq_type", "_ZN2gl15PointParameteriE", "_ZN2gl11GetBooleanvE", "_ZTVN2cv7MatOp_TE", "_ZN2gl17VertexAttribI4uivE", "_ZN2gl21BlendEquationSeparateE", "_ZTVN2cv11MatOp_AddExE", "_ZTIN2cv11FileStorageE", "_ZN2gl13TexSubImage1DE", "_ZN2gl13DeleteProgramE", "_ZN2gl18BindAttribLocationE", "_ZN2gl17CopyTexSubImage2DE", "_ZN2gl14BindBufferBaseE", "_ZTSN2cv11_InputArrayE", "_ZTVN2cv11MatOp_SolveE", "hist_type", "_ZN2gl18GetUniformLocationE", "_ZN2gl16VertexAttribI1uiE", "_ZN2gl9ColorMaskE", "_ZN2gl22BeginTransformFeedbackE", "_ZN2gl16VertexAttribI3uiE", "_ZN2gl16VertexAttribI4uiE", "_ZTSN2cv10MatOp_GEMME", "_ZN2gl13PolygonOffsetE", "_ZN2gl11GetPointervE", "_ZN2gl7EnableiE", "_ZN2gl10Uniform3fvE", "_ZTS15CvOpenGlFuncTab", "_ZTSN2cv16BaseColumnFilterE", "_ZN2gl11StencilMaskE", "_ZN2gl5FlushE", "_ZN2gl9Uniform1fE", "_ZN2gl7ScissorE", "_ZN2gl13IsVertexArrayE", "_ZN2gl6EnableE", "_ZN2cv15g_HersheyGlyphsE", "cxcore_module", "_ZN2gl22FlushMappedBufferRangeE", "_ZN2gl16GenRenderbuffersE", "_ZTIN2cv10MatOp_GEMME", "_ZTV15CvOpenGlFuncTab", "_ZN2gl17DrawRangeElementsE", "_ZN2gl19GetActiveUniformsivE", "_ZN2gl23CompressedTexSubImage1DE", "_ZN2gl13TexSubImage2DE", "_ZN2gl23FramebufferTextureLayerE", "_ZN2gl7Color3dE", "_ZN2gl13IsFramebufferE", "_ZTSN2cv12MatOp_InvertE", "_ZN2gl11PolygonModeE", "_ZN2gl15BindBufferRangeE", "_ZN2cv8USE_SSE2E", "_ZN2gl9GetStringE", "_ZN2cv10g_8x32fTabE", "_ZTIN2cv9MatOp_BinE", "_ZN2gl9Uniform3iE", "_ZN2gl13DeleteQueriesE", "_ZN2gl16UniformMatrix4fvE", "_ZTVN2cv17MatOp_InitializerE", "_ZN2gl10GetQueryivE", "_ZTSN2cv13BaseRowFilterE", "_ZN2gl13TexParameterfE", "_ZN2gl15BlitFramebufferE", "_ZTIN2cv16GeneralizedHoughE", "_ZN2gl10Uniform3uiE", "_ZN2gl11BindTextureE", "_ZN2gl10BindBufferE", "_ZN2gl9MapBufferE", "_ZN2gl9Uniform1iE", "_ZN2gl21DrawElementsInstancedE", "_ZN2gl15MultiDrawArraysE", "_ZN2gl17BlendFuncSeparateE", "_ZN2gl12DrawElementsE", "_ZN2gl9FrontFaceE", "_ZN2gl10ClearDepthE", "matnd_type", "_ZN2gl27GetTransformFeedbackVaryingE", "_ZN2gl10ColorMaskiE", "_ZN2gl10Uniform2fvE", "_ZTIN2cv11MatOp_AddExE", "_ZN2gl12GetUniformivE", "_ZN2gl12DeleteShaderE", "_ZN2gl11StencilFuncE", "_ZN2gl13VertexPointerE", "_ZN2gl9DepthMaskE", "_ZN2gl9IsProgramE", "_ZN2gl9Uniform4fE", "_ZN2gl17EnableClientStateE", "_ZN2gl20BindFragDataLocationE", "_ZN2gl11GetIntegervE", "_ZN2gl17GetUniformIndicesE", "_ZN2gl23FramebufferRenderbufferE", "_ZN2gl8EndQueryE", "_ZN2gl16VertexAttribI2uiE", "_ZN2gl17GetTexParameterivE", "_ZN2gl13TexSubImage3DE", "_ZN2gl9StencilOpE", "_ZN2gl9IsEnabledE", "_ZN2gl17GetVertexAttribdvE", "_ZN2gl15TexParameterIivE", "_ZTVN2cv14MatOp_IdentityE", "image_type", "_ZN2gl21GetCompressedTexImageE", "_ZN2gl23GetVertexAttribPointervE", "_ZTSN2cv7MatOp_TE", "_ZN2gl14GenerateMipmapE", "_ZN2gl13DeleteBuffersE", "_ZTSN2cv9MatOp_CmpE", "_ZN2gl10DrawArraysE", "_ZN2gl17StencilOpSeparateE", "_ZN2gl13ActiveTextureE", "_ZN2gl8IsBufferE", "_ZN2gl13CompileShaderE", "_ZN2gl14IsRenderbufferE", "_ZN2gl20GetBufferParameterivE", "_ZN2gl9Uniform2fE", "_ZN2gl22GetTexLevelParameterivE", "_ZN2gl17GetAttribLocationE", "_ZN2gl7IndexubE", "_ZN2gl11Uniform3uivE", "_ZN2gl16VertexAttribI2ivE", "_ZTIN2cv17MatOp_InitializerE", "_ZN2gl19DrawArraysInstancedE", "_ZN2gl15BindFramebufferE", "_ZN2gl15GetActiveAttribE", "_ZN2gl10Uniform1ivE", "_ZN2gl15g_initVariablesE", "_ZN2gl10Uniform3ivE", "_ZTVN2cv9AlgorithmE", "_ZN2gl11DrawBuffersE", "_ZN2gl16VertexAttribI1ivE", "_ZN2gl18UniformMatrix4x3fvE", "_ZN2gl12LoadIdentityE", "_ZN2gl20GetActiveUniformNameE", "_ZN2gl17GetQueryObjectuivE", "_ZTIN2cv11_InputArrayE", "_ZN2gl18GetVertexAttribIivE", "_ZN2gl11LinkProgramE", "_ZTSN2cv9MatOp_BinE", "_ZN2gl12GetProgramivE", "_ZN2gl13BlendEquationE", "_ZTSN2cv11FileStorageE", "_ZTSN2cv5MatOpE", "_ZTIN2cv12FilterEngineE", "_ZN2gl9BlendFuncE", "_ZN2gl9Uniform3fE", "_ZN2gl17GetTexParameterfvE", "_ZN2cv16useOptimizedFlagE", "_ZN2cv10USE_SSE4_2E", "_ZN2gl15PointParameterfE", "_ZN2gl10Uniform4ivE", "_ZN2gl16VertexAttribI4svE", "_ZN2gl10GetStringiE", "_ZTIN2cv9AlgorithmE", "_ZN2gl19RenderbufferStorageE", "_ZN2gl10Uniform4uiE", "_ZN2gl16GetBufferSubDataE", "_ZN2gl15GetShaderSourceE", "_ZN2cv21check_range_functionsE", "_ZN2gl16BindRenderbufferE", "_ZN2gl20GetUniformBlockIndexE", "_ZTIN2cv10BaseFilterE", "_ZN2gl18DisableClientStateE", "_ZN2gl10Uniform1uiE", "_ZN2gl17VertexAttribI1uivE", "_ZTI15CvOpenGlFuncTab", "_ZN2gl8DisableiE", "_ZN2gl20FramebufferTexture2DE", "_ZN2gl20CompressedTexImage1DE", "_ZTVN2cv11_InputArrayE", "_ZN2gl18UniformMatrix4x2fvE", "_ZN2gl10GenQueriesE", "_ZTSN2cv12_OutputArrayE", "mat_type", "_ZN2gl10GetDoublevE", "_ZN2gl11UnmapBufferE", "_ZTIN2cv14MatOp_IdentityE", "_ZN2gl19GetVertexAttribIuivE", "_ZN2gl13ClearBufferfvE", "_ZN2gl12ShaderSourceE", "_ZN2gl14TexParameterivE", "_ZTSN2cv12FilterEngineE", "_ZN2gl16GetActiveUniformE", "_ZN2gl16GetShaderInfoLogE", "_ZN2gl15GenVertexArraysE", "_ZN2gl23GetActiveUniformBlockivE", "_ZTSN2cv14MatOp_IdentityE", "_ZN2gl11Uniform1uivE", "_ZTSN2cv9ExceptionE", "_ZN2gl23CompressedTexSubImage3DE", "_ZN2gl8ViewportE", "_ZN2cv11copyMaskTabE", "_ZN2gl10TexImage1DE", "_ZN2gl10UseProgramE", "_ZTIN2cv13BaseRowFilterE", "_ZN2gl12ColorPointerE", "_ZN2gl25GetActiveUniformBlockNameE", "_ZN2gl15VertexAttribI4iE", "_ZN2gl7LogicOpE", "_ZN2gl4HintE", "_ZTSN2cv9AlgorithmE", "_ZN2gl13GetIntegeri_vE", "_ZN2gl17VertexAttribI3uivE", "_ZN2gl6FinishE", "_ZN2gl14DeleteTexturesE", "_ZTVN2cv11FileStorageE", "_ZN2gl10ClampColorE", "_ZTVN2cv10BaseFilterE", "_ZN2gl19DeleteRenderbuffersE", "_ZN2gl12ClearStencilE", "_ZN2gl10TexImage2DE", "_ZN2gl25TransformFeedbackVaryingsE", "_ZN2gl9Uniform4iE", "_ZN2gl10Uniform4fvE", "_ZN2gl10DrawBufferE", "_ZN2gl17CopyTexSubImage3DE", "_ZTSN2cv16GeneralizedHoughE", "_ZN2gl22BeginConditionalRenderE", "_ZN2gl18UniformMatrix2x3fvE", "_ZN2gl11Uniform2uivE", "_ZN2gl10GenBuffersE", "icv8x32fTab_cv", "_ZN2gl8CullFaceE", "_ZTVN2cv10MatOp_GEMME", "_ZN2gl9TexBufferE", "_ZN2gl14CopyTexImage1DE", "_ZN2gl24DisableVertexAttribArrayE", "_ZN2gl21PrimitiveRestartIndexE", "_ZN2gl7TexEnviE", "_ZTIN2cv5MatOpE", "_ZN2gl10DepthRangeE", "_ZN2gl8IndexubvE", "_ZN2gl16VertexAttribI4bvE", "_ZTSN2cv17MatOp_InitializerE", "_ZN2gl11Uniform4uivE", "_ZN2gl11GetShaderivE", "_ZN2gl26GetRenderbufferParameterivE", "_ZN2gl10IsEnablediE", "_ZN2gl15BindVertexArrayE", "_ZN2gl19StencilFuncSeparateE", "_ZN2gl10Uniform2ivE", "_ZN2gl20FramebufferTexture3DE", "_ZTIN2cv7MatOp_TE", "_ZN2gl23CompressedTexSubImage2DE", "_ZTSN2cv16ParallelLoopBodyE", "_ZN2gl14ClearBufferuivE", "seq_graph_type", "_ZN2gl8IsShaderE", "seq_tree_type", "_ZN2gl15ValidateProgramE", "_ZN2gl11PixelStorefE", "_ZN2gl13GetBooleani_vE", "_ZTIN2cv9ExceptionE", "_ZTVN2cv9MatOp_CmpE", "_ZN2gl16PointParameterivE", "_ZN2gl15GenFramebuffersE", "_ZN2gl16PointParameterfvE", "_ZN2gl18UniformMatrix2x4fvE", "_ZN2gl7IsQueryE", "_ZTVN2cv16GeneralizedHoughE", "_ZN2gl12AttachShaderE", "_ZN2gl19UniformBlockBindingE", "_ZN2gl17GetVertexAttribivE", "_ZN2gl19GetFragDataLocationE", "_ZN2gl10Uniform1fvE", "_ZN2gl9Uniform2iE", "_ZN2gl12DetachShaderE", "_ZN2gl14MapBufferRangeE", "_ZTSN2cv11MatOp_SolveE", "_ZTIN2cv16BaseColumnFilterE", "_ZN8CvModule5firstE", "_ZTVN2cv9ExceptionE", "_ZN2gl10MatrixModeE", "_ZN2gl16VertexAttribI4ivE", "_ZN2gl18UniformMatrix3x2fvE", "_ZN2gl13ClearBufferfiE", "_ZN2gl15VertexAttribI2iE", "_ZN2gl23EnableVertexAttribArrayE", "_ZN2gl15VertexAttribI3iE", "_ZTVN2cv5MatOpE", "_ZN2gl14TexParameterfvE", "_ZN2gl11GenTexturesE", "_ZN2gl17CopyBufferSubDataE", "_ZN2gl19StencilMaskSeparateE", "_ZTSN2cv10BaseFilterE", "_ZN2gl16UniformMatrix2fvE", "_ZN6CvType4lastE", "_ZN2gl10BeginQueryE", "_ZN2gl9PointSizeE", "_ZN2gl20FramebufferTexture1DE", "_ZN2cv7USE_AVXE", "_ZN2gl17GetProgramInfoLogE", "_ZN2gl13NormalPointerE", "_ZN2gl9DepthFuncE", "_ZN2gl12CreateShaderE", "_ZN2gl14SampleCoverageE", "_ZTIN2cv12MatOp_InvertE", "_ZN2gl18DeleteVertexArraysE", "_ZN6CvType5firstE", "_ZN2gl18UniformMatrix3x4fvE", "_ZN2gl15VertexAttribI1iE", "_ZTIN2cv11MatOp_SolveE", "_ZN2gl13BufferSubDataE", "_ZTIN2cv16ParallelLoopBodyE", "_ZN2gl20VertexAttribIPointerE"], "importedglobals": ["_ZNSt3__17num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE2idE", "_ZTVN10__cxxabiv117__class_type_infoE", "_ZTVN10__cxxabiv120__si_class_type_infoE", "_ZTVN10__cxxabiv121__vmi_class_type_infoE", "_ZTINSt3__18ios_baseE", "__sF", "_ZNSt3__15ctypeIcE2idE", "_ZTVSt12length_error", "_ctype_", "_toupper_tab_", "_ZTISt9exception", "_ZNSt3__14cerrE", "_ZTISt12out_of_range", "_ZTVSt12out_of_range", "_ZTISt12length_error", "_ZNSt3__17num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE2idE", "_ZNSt3__14coutE"], "importedfunctions": ["strncmp", "strrchr", "strlen", "malloc", "fflush", "gzputs", "_ZNSt3__16localeC1Ev", "_ZNSt3__18ios_base5clearEj", "strcmp", "opendir", "strcpy", "logf", "_ZNSt3__18ios_base4initEPv", "gzeof", "free", "pthread_mutex_lock", "strstr", "pthread_mutex_unlock", "_ZdlPv", "close", "_ZNSt9exceptionD2Ev", "mkstemp", "strtol", "closedir", "_Znaj", "pthread_getspecific", "atoi", "_ZdaPv", "readdir", "pthread_setspecific", "lrint", "memchr", "_Znwj", "printf", "sscanf", "_ZNSt11logic_errorC2EPKc", "fprintf", "cos", "pow", "sqrt", "pthread_mutex_destroy", "_ZNKSt3__18ios_base6getlocEv", "clock_gettime", "__gxx_personality_v0", "pthread_mutex_trylock", "gzclose", "strtod", "gzgets", "_ZNKSt3__16locale9use_facetERNS0_2idE", "pthread_mutex_init", "_ZNSt12length_errorD1Ev", "stat", "fseek", "fputs", "strncpy", "sprintf", "rewind", "vsprintf", "memcmp", "getenv", "_ZNSt3__18ios_baseD2Ev", "pthread_key_create", "remove", "sqrtf", "memcpy", "log", "pthread_once", "log10", "exp", "atan2", "_ZNSt3__16localeD1Ev", "expf", "ftell", "_ZSt9terminatev", "_ZNSt3__18ios_base33__set_badbit_and_consider_rethrowEv", "raise", "abort", "_ZSt18uncaught_exceptionv", "acos", "_ZNSt12out_of_rangeD1Ev", "__android_log_print", "fgets", "puts", "gzopen", "fopen", "asin", "gzrewind", "sin", "fclose", "powf", "strchr"], "exportedfunctions": ["_ZN2cv3PCAC1ERKNS_11_InputArrayES3_id", "_ZN2cv11bitwise_xorERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZNK2cv8Subdiv2D7symEdgeEi", "cvPointSeqFromMat", "_ZNK2cv11_InputArray9getGpuMatEv", "_ZNK2cv6KDTree9getPointsERKNS_11_InputArrayERKNS_12_OutputArrayES6_", "_ZN2cv13BaseRowFilterC1Ev", "cvSetImageCOI", "_ZN2cv15getCPUTickCountEv", "cvLoad", "_ZN2cvdvERKNS_7MatExprERKNS_3MatE", "_ZN2cv9GlTexture7releaseEv", "_ZN2cv16FileNodeIteratorC1EPK13CvFileStoragePK10CvFileNodej", "cvReleaseImage", "_ZN2cv11compareHistERKNS_11_InputArrayES2_i", "_ZNK2cv8FileNodeixEPKc", "_ZN2cv5eigenERKNS_11_InputArrayERKNS_12_OutputArrayES5_ii", "_Z15icvCheckGlErrorPKciS0_", "_ZN2cv11FileStorageC1EP13CvFileStorage", "_ZN2cv3ogl6Buffer11unmapDeviceEv", "cvGetSubRect", "_ZN2cv3PCAC2ERKNS_11_InputArrayES3_id", "_ZNK2cv9Algorithm9paramTypeEPKc", "_ZN2cv3gpu9getDeviceEv", "_ZN2cv8Subdiv2D12initDelaunayENS_5Rect_IiEE", "_ZN2cv3Mat5setToERKNS_11_InputArrayES3_", "_ZN2cv9fastAtan2EPKfS1_Pfib", "cvInsertNodeIntoTree", "_ZN2cv11determinantERKNS_11_InputArrayE", "__subdf3", "_ZNK2cv8Subdiv2D10rotateEdgeEii", "_ZN2cv3expEPKfPfi", "cvPtr2D", "_ZN2cv9Algorithm6setMatEPKcRKNS_3MatE", "cvPyrDown", "_ZNK2cv3Matcv7CvMatNDEv", "_ZN2cv3ogl6renderERKNS0_6ArraysERKNS_11_InputArrayEiNS_7Scalar_IdEE", "_ZN2cv9Algorithm3setEPKcRKNS_3PtrIS0_EE", "_ZN2cv11bitwise_andERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZN2cv5traceERKNS_11_InputArrayE", "_ZN2cv9GlTextureC2Eiii", "_ZN2cv3MataSERKNS_7Scalar_IdEE", "_ZN2cveoERKNS_3MatES2_", "_ZN2cv9SparseMat5eraseEPKiPj", "cvSolvePoly", "_ZN2cvmiERKNS_16MatConstIteratorES2_", "_ZN2cv4readERKNS_8FileNodeERNS_3MatERKS3_", "_ZN2cv20initWideAngleProjMapERKNS_11_InputArrayES2_NS_5Size_IiEEiiRKNS_12_OutputArrayES7_id", "_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv6dilateERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv4idftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv3Mat6createEiPKii", "_ZNK2cv13AlgorithmInfo3setEPNS_9AlgorithmEPKciPKvb", "_Unwind_Resume", "_ZN2cv5writeERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEf", "_ZN2cv8GlBufferC1EiiiNS0_5UsageE", "_ZN2cv8calcHistERKNS_11_InputArrayERKNSt3__16vectorIiNS3_9allocatorIiEEEES2_RKNS_12_OutputArrayES9_RKNS4_IfNS5_IfEEEEb", "_ZN2cv17CommandLineParserC1EiPKPKcS2_", "_ZN2cv8Subdiv2D6insertERKNSt3__16vectorINS_6Point_IfEENS1_9allocatorIS4_EEEE", "_ZN2cv3ogl6BufferC1EiiiNS1_6TargetEb", "_ZN2cv9GlTextureC1ERKNS_11_InputArrayEb", "_ZNK2cv5MatOp12augAssignXorERKNS_7MatExprERNS_3MatE", "_ZNK2cv7MatExpr3mulERKNS_3MatEd", "_ZN2cv19createHanningWindowERKNS_12_OutputArrayENS_5Size_IiEEi", "_ZN2cv16ParallelLoopBodyD0Ev", "_ZN2cv17accumulateProductERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZN2cv16MatConstIterator4seekEPKib", "cvSeqInsertSlice", "_ZNK2cv11MatOp_AddEx9transposeERKNS_7MatExprERS1_", "cvRandArr", "cvOpenFileStorage", "_ZN2cv3gpu6GpuMat6createEiii", "cvMakeHistHeaderForArray", "cvSetRealND", "_ZN2cv11HoughLinesPERKNS_11_InputArrayERKNS_12_OutputArrayEddidd", "_ZN2cv11MahalanobisERKNS_11_InputArrayES2_S2_", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRbbMS1_FivEMS1_FviERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_i", "cvCreateGraphScanner", "_ZN2cv5splitERKNS_3MatERNSt3__16vectorIS0_NS3_9allocatorIS0_EEEE", "_ZN2cv8GlArrays16setTexCoordArrayERKNS_11_InputArrayE", "_ZNK2cv3PCA7projectERKNS_11_InputArrayE", "cvFlip", "_ZN2cv14fillConvexPolyERKNS_12_OutputArrayERKNS_11_InputArrayERKNS_7Scalar_IdEEii", "_ZN2cv9AlgorithmD2Ev", "_ZN2cv3gpu16createContinuousEiiiRNS0_6GpuMatE", "_ZN2cv3expERKNS_11_InputArrayERKNS_12_OutputArrayE", "__gnu_Unwind_Resume_or_Rethrow", "_ZN2cv7MomentsC2ERK9CvMoments", "_ZNK2cv9SparseMat9convertToERNS_3MatEidd", "_ZN2cv18createLinearFilterEiiRKNS_11_InputArrayENS_6Point_IiEEdiiRKNS_7Scalar_IdEE", "__gnu_Unwind_Restore_WMMXC", "cvAndS", "_ZN2cv9normalizeERKNS_9SparseMatERS0_di", "_ZN2cv20createGaussianFilterEiNS_5Size_IiEEddi", "cvSeqRemoveSlice", "_ZN2cv17getOptimalDFTSizeEi", "_ZN2cv11convertMapsERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_ib", "cvGetAffineTransform", "cvSeqPushMulti", "_ZN2cv12useOptimizedEv", "_ZN2cv3ogl9Texture2DC2ENS_5Size_IiEENS1_6FormatEjb", "_ZN2cv7hconcatERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEbMS1_FSB_vEMS1_FvRKSB_ESG_", "_ZN2cv3maxERKNS_3MatES2_RS0_", "cvGetImageROI", "_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPS1_i", "_ZN2cv10fastMallocEj", "_ZN2cv3dftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv3LUTERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "_ZN2cv9Algorithm6setIntEPKci", "_ZNK2cv16MatConstIterator3posEPi", "_ZN2cv8GlBufferC1ERKNS_11_InputArrayENS0_5UsageE", "cvSplit", "_ZN2cv3gpu11TargetArchs9builtWithENS0_10FeatureSetE", "_ZNK2cv13AlgorithmInfo3getEPKNS_9AlgorithmEPKciPv", "cvSetErrMode", "cvReshape", "_ZN2cv3minERKNS_3MatEd", "cvMemStorageAllocString", "_ZN2cv25getMorphologyColumnFilterEiiii", "cvReadChainPoint", "_ZNK2cv3gpu6GpuMat9locateROIERNS_5Size_IiEERNS_6Point_IiEE", "_ZNK2cv6GlFont4drawEPKci", "_ZN2cv11RNG_MT199374nextEv", "_ZN2cv15setUseOptimizedEb", "_ZN2cv3ogl9Texture2DC2EiiNS1_6FormatEb", "cvCreateMemStorage", "cvGetImageCOI", "cvDFT", "cvRemoveNodeFromTree", "cvSeqRemove", "_ZN2cv8Subdiv2DC1ENS_5Rect_IiEE", "cvNorm", "_ZNK2cv3Mat1tEv", "_ZN2cv17createDerivFilterEiiiiii", "cvSetReal1D", "_ZNK2cv3gpu10DeviceInfo11totalMemoryEv", "_Z23icvApproximateChainTC89P7CvChainiP12CvMemStoragei", "_ZN2cvmiERKNS_3MatES2_", "_ZNK2cv9Algorithm5writeERNS_11FileStorageE", "_ZN2cv12buildPyramidERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv8Subdiv2D6VertexC2ENS_6Point_IfEEbi", "cvSeqElemIdx", "_ZN2cv8Subdiv2DC1Ev", "_ZN2cv9Algorithm6setMatERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS_3MatE", "_ZN2cv11writeScalarERNS_11FileStorageEf", "_Unwind_VRS_Get", "_ZNK2cv7MatExpr3mulERKS0_d", "_ZN2cv3gpu6GpuMatC2ERKNS_3MatE", "__umodsi3", "_ZNK2cv11_InputArray12getGlTextureEv", "_Unwind_Resume_or_Rethrow", "cvOr", "_ZN2cv12_OutputArrayC1ERKNS_3MatE", "cvGetModuleInfo", "_ZN2cv19getRotationMatrix2DENS_6Point_IfEEdd", "_ZN2cv3maxERKNS_3MatEdRS0_", "__gnu_uldivmod_helper", "cvStartNextStream", "_ZNK2cv3Mat3invEi", "_ZNK2cv3Matcv9_IplImageEv", "_ZN2cv9Formatter3getEPKc", "cvClearGraph", "_ZN2cv5eigenERKNS_11_InputArrayEbRKNS_12_OutputArrayES5_", "_ZN2cvmiERKNS_7MatExprES2_", "_ZN2cv12equalizeHistERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv3gpu6GpuMatC2ENS_5Size_IiEEiPvj", "_ZN2cv8GlCamera19setProjectionMatrixERKNS_3MatEb", "_ZN2cvorERKNS_7Scalar_IdEERKNS_3MatE", "_ZN2cv11MahalonobisERKNS_11_InputArrayES2_S2_", "_ZN2cv3PCA10computeVarERKNS_11_InputArrayES3_id", "_ZNK2cv12_OutputArray5clearEv", "_ZNK2cv11_InputArray4typeEi", "_Unwind_VRS_Set", "cvMoments", "_ZN2cv5CannyERKNS_11_InputArrayERKNS_12_OutputArrayEddib", "_ZN2cv3dctERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZNK2cv5MatOp6divideEdRKNS_7MatExprERS1_", "_ZN2cvgeERKNS_3MatEd", "_Z18icvIntersectLines3PdS_S_S_S_S_P12CvPoint2D32f", "_ZNK2cv11_InputArray6getMatEi", "_ZN2cv3gpu19printCudaDeviceInfoEi", "_ZN2cv3ogl6Arrays7releaseEv", "_ZN2cv11_InputArrayC1ERKNS_8GlBufferE", "cvSliceLength", "_ZN2cv7MatExprC1ERKNS_3MatE", "_Unwind_GetDataRelBase", "_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEPPKfdb", "_ZN2cv3ogl6Arrays15resetColorArrayEv", "_ZN2cvplERKNS_7MatExprERKNS_3MatE", "_ZN2cv11contourAreaERKNS_11_InputArrayEb", "_ZN2cv4normERKNS_11_InputArrayEiS2_", "_ZN2cv6kmeansERKNS_11_InputArrayEiRKNS_12_OutputArrayENS_12TermCriteriaEiiS5_", "cvCvtColor", "_ZNK2cv5MatOp12augAssignAndERKNS_7MatExprERNS_3MatE", "_ZNK2cv7MatOp_T6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cv23getPerspectiveTransformERKNS_11_InputArrayES2_", "_ZN2cv12FilterEngineD0Ev", "cvFlushSeqWriter", "cvThreshold", "_ZN2cv10bitwise_orERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZN2cv12approxPolyDPERKNS_11_InputArrayERKNS_12_OutputArrayEdb", "__gnu_ldivmod_helper", "_ZN2cv6invertERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv20checkHardwareSupportEi", "cvNormalizeHist", "_ZN2cv3gpu6GpuMat5setToENS_7Scalar_IdEERKS1_", "_ZN2cv3Mat8pop_backEj", "_ZN2cv3Mat5zerosEiPKii", "_ZN2cv4normERKNS_9SparseMatEi", "_ZN2cv5writeERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEi", "cvGetTextSize", "_ZNK2cv9Algorithm6getIntERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv13insertChannelERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvSetIPLAllocators", "_ZN2cvanERKNS_3MatERKNS_7Scalar_IdEE", "cvCalcBayesianProb", "_ZN2cv13setNumThreadsEi", "_ZNK2cv11MatOp_AddEx6divideEdRKNS_7MatExprERS1_", "_ZNK2cv3Mat9locateROIERNS_5Size_IiEERNS_6Point_IiEE", "_ZN2cv3ogl6Arrays16resetNormalArrayEv", "_ZNK2cv3ogl6Arrays4bindEv", "cvCountNonZero", "cvFillConvexPoly", "_ZN2cv3gpu15allocMatFromBufEiiiRNS0_6GpuMatE", "_ZN2cveqERKNS_3MatES2_", "_ZN2cv13AlgorithmInfoC2ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPFPNS_9AlgorithmEvE", "cvFree_", "_ZN2cv11RNG_MT199377uniformEdd", "_ZNK2cv3Mat3dotERKNS_11_InputArrayE", "_ZN2cv12FilterEngineD2Ev", "cvTypeOf", "_ZN2cv12FilterEngineC1ERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "cvLUT", "_ZN2cv15getLinearFilterEiiRKNS_11_InputArrayENS_6Point_IiEEdi", "_ZNK2cv5MatOp8multiplyERKNS_7MatExprES3_RS1_d", "cvGetImage", "_ZN2cv7putTextERNS_3MatERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS_6Point_IiEEidNS_7Scalar_IdEEiib", "_ZN2cveoERKNS_7Scalar_IdEERKNS_3MatE", "_ZN2cvgtERKNS_3MatES2_", "cvSeqInsert", "_ZN2cv3ogl6BufferC2Ev", "_ZN2cv8GlArrays14setVertexArrayERKNS_11_InputArrayE", "_ZN2cv8Subdiv2D11findNearestENS_6Point_IfEEPS2_", "_ZN2cv10HoughLinesERKNS_11_InputArrayERKNS_12_OutputArrayEddidd", "_ZN2cv14phaseCorrelateERKNS_11_InputArrayES2_S2_", "_ZN2cv5phaseERKNS_11_InputArrayES2_RKNS_12_OutputArrayEb", "_Z26icvGetRectSubPix_8u32f_C1RPKhi6CvSizePfiS1_12CvPoint2D32f", "_ZN2cv7vconcatERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN3GMMC1ERN2cv3MatE", "restore_core_regs", "_ZN2cv15calcCovarMatrixERKNS_11_InputArrayERKNS_12_OutputArrayES5_ii", "_ZN2cv12FilterEngineC2Ev", "_ZN2cv3MatC2ERKS0_RKNS_5RangeES5_", "_ZN2cv21pyrMeanShiftFilteringERKNS_11_InputArrayERKNS_12_OutputArrayEddiNS_12TermCriteriaE", "_ZN15CvOpenGlFuncTabD1Ev", "_ZN2cv9Algorithm3setEPKcb", "_ZN2cv3ogl6Arrays16setTexCoordArrayERKNS_11_InputArrayE", "cvCheckHardwareSupport", "cvGetRows", "_ZN2cv16FileNodeIteratormmEv", "_ZNK2cv12_OutputArray7releaseEv", "_ZNK2cv3gpu6GpuMat6copyToERS1_", "_ZN2cv3gpu11TargetArchs6hasPtxEii", "_ZNK2cv7MatExpr3dotERKNS_3MatE", "_ZN2cv8Subdiv2D6VertexC1ENS_6Point_IfEEbi", "_ZN2cv4lineERNS_3MatENS_6Point_IiEES3_RKNS_7Scalar_IdEEiii", "_ZN2cv11findNonZeroERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv3MatC1ERKNS_3gpu6GpuMatE", "_ZN2cv9Algorithm3setEPKcRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE", "cvGetRawData", "_ZN2cv12_OutputArrayC1ERNS_3ogl6BufferE", "_ZN2cv10BaseFilterC1Ev", "_ZN2cv9polylinesERNS_3MatEPPKNS_6Point_IiEEPKiibRKNS_7Scalar_IdEEiii", "_ZNK2cv10MatOp_GEMM9transposeERKNS_7MatExprERS1_", "_ZN2cv3MatC1ERKS0_RKNS_5RangeES5_", "_ZN2cv3sumERKNS_11_InputArrayE", "cvGraphRemoveEdgeByPtr", "_ZN2cv3minEdRKNS_3MatE", "cvTreeToNodeSeq", "_ZN2cv16GeneralizedHough11setTemplateERKNS_11_InputArrayEiNS_6Point_IiEE", "_ZN2cv3gpu11TargetArchs6hasBinEii", "_ZNK2cv3PCA7projectERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv21intersectConvexConvexERKNS_11_InputArrayES2_RKNS_12_OutputArrayEb", "cvCmp", "_ZN2cv17CommandLineParser9getStringERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv9GlTextureC2ERKNS_11_InputArrayEb", "cvSetSeqReaderPos", "_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayES5_iii", "_ZN2cv4gemmERKNS_11_InputArrayES2_dS2_dRKNS_12_OutputArrayEi", "_ZN2cv7ellipseERNS_3MatENS_6Point_IiEENS_5Size_IiEEdddRKNS_7Scalar_IdEEiii", "cvStartWriteStruct", "_ZN2cv10PCAProjectERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE", "_ZN2cv9Algorithm4readERKNS_8FileNodeE", "_ZN2cv17CommandLineParser12analyzeValueINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEET_RKS8_b", "_ZNK2cv11MatOp_AddEx8subtractERKNS_7Scalar_IdEERKNS_7MatExprERS5_", "_ZNK2cv3Mat5crossERKNS_11_InputArrayE", "_ZN2cv9SparseMatC2ERKNS_3MatE", "_ZN2cv6renderERKNS_8GlArraysEiNS_7Scalar_IdEE", "_ZN2cv10BaseFilterC2Ev", "_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPPhi", "cvGetSeqReaderPos", "_ZN2cv11_InputArrayC1ERKNS_7MatExprE", "cvFilter2D", "_ZN2cv3ogl6Buffer8copyFromERKNS_11_InputArrayENS1_6TargetEb", "cvInitImageHeader", "_ZN2cvcoERKNS_3MatE", "cvExp", "_ZN2cv3Mat7reserveEj", "cvBoundingRect", "_ZNK2cv11RotatedRect6pointsEPNS_6Point_IfEE", "_ZNK2cv8Subdiv2D8QuadEdge6isfreeEv", "cvCalcArrBackProject", "_ZN2cv14fillConvexPolyERNS_3MatEPKNS_6Point_IiEEiRKNS_7Scalar_IdEEii", "_Z19icvSetOpenGlFuncTabPK15CvOpenGlFuncTab", "_ZNK2cv3ogl6Buffer4bindENS1_6TargetE", "_ZN2cv3ogl6BufferC2Eiiijb", "cvGraphVtxDegreeByPtr", "cvRegisterType", "_ZN2cv13batchDistanceERKNS_11_InputArrayES2_RKNS_12_OutputArrayEiS5_iiS2_ib", "cvCreateSet", "_ZN2cv6formatEPKcz", "cvCreateGraph", "_ZN2cv9Algorithm3setERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorINS_3MatENS5_ISB_EEEE", "cvReleasePyramid", "cvReleaseMemStorage", "_ZN2cv11sepFilter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_S2_NS_6Point_IiEEdi", "_ZN2cv7MatExprC2ERKNS_3MatE", "cvFindNextContour", "_Z24VResizeLinearVec_32f_avxPPKhPhS0_i", "_ZN2cv16accumulateSquareERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN2cv8Subdiv2D19getVoronoiFacetListERKNSt3__16vectorIiNS1_9allocatorIiEEEERNS2_INS2_INS_6Point_IfEENS3_IS9_EEEENS3_ISB_EEEERSB_", "_ZN2cv11FileStorageC1ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEiS9_", "___Unwind_Resume", "_ZNK2cv3gpu10DeviceInfo10freeMemoryEv", "_ZNK2cv5MatOp15augAssignDivideERKNS_7MatExprERNS_3MatE", "_ZN2cv3PCAC2Ev", "_ZNK2cv8GlCamera20setupModelViewMatrixEv", "_ZN2cv3PtrI9_IplImageE10delete_objEv", "_ZN2cv3MatC1ERKS0_PKNS_5RangeE", "_ZN2cv17CommandLineParser12analyzeValueIjEET_RKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb", "cvReshapeMatND", "cvSeqPopMulti", "_ZN2cvmlERKNS_3MatEd", "cvInRangeS", "_ZN2cv5MutexD2Ev", "_ZN8CvModuleD2Ev", "_ZN2cv3gpu11TargetArchs17hasEqualOrGreaterEii", "_ZN2cv3gpu6GpuMatC2ERKS1_NS_5RangeES4_", "_ZN2cv10TLSStorageD2Ev", "_ZN2cv3ogl6Arrays18resetTexCoordArrayEv", "_ZNK2cv9SparseMat6copyToERNS_3MatE", "cvErrorFromIppStatus", "cvSetNumThreads", "_ZN2cv3addERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "_ZN2cv11polarToCartERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_b", "_ZN2cv24currentParallelFrameworkEv", "_ZN2cv15getNumberOfCPUsEv", "_ZN2cv5MutexC1Ev", "_ZN2cv5ParamC2EibiMNS_9AlgorithmEKFivEMS1_FviERKNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEE", "_ZN2cv9SparseMat3ptrEPKibPj", "_ZN2cv5writeERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEERKNS_9SparseMatE", "_ZN2cv5splitERKNS_3MatEPS0_", "_ZN2cv17CommandLineParser12analyzeValueIyEET_RKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb", "_ZN2cv8cubeRootEf", "_ZNK2cv12_OutputArray18getOGlTexture2DRefEv", "_ZN2cvdvEdRKNS_7MatExprE", "_ZN2cv3ogl9Texture2DC2ERKNS_11_InputArrayEb", "_ZN2cv23adaptiveBilateralFilterERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddNS_6Point_IiEEi", "_ZN2cv3gpu6GpuMat4swapERS1_", "_ZN2cv3minERKNS_3MatES2_RS0_", "cvCopyMakeBorder", "_ZNK2cv9GlTexture4bindEv", "cvEigenVV", "cvCreateHist", "_Z30icvGetQuadrangleSubPix_32f_C1RPKfi6CvSizePfiS1_S0_", "_ZN2cv5mergeEPKNS_3MatEjRKNS_12_OutputArrayE", "_ZN2cv9GlTexture6createEiii", "_ZN2cv12randShuffle_ERKNS_12_OutputArrayEd", "_ZN2cvgeEdRKNS_3MatE", "_ZNK3GMM14whichComponentEN2cv3VecIdLi3EEE", "cvSVD", "_ZN2cv11addWeightedERKNS_11_InputArrayEdS2_ddRKNS_12_OutputArrayEi", "_ZNK2cv7MatExpr4diagEi", "_ZNK2cv5MatOp11elementWiseERKNS_7MatExprE", "cvStartReadRawData", "cvGetRealND", "cvAvg", "_ZN2cv3MatC2ERKS0_RKNS_5Rect_IiEE", "cvXorS", "cvFindType", "cvCreateMatNDHeader", "_ZN2cv11RNG_MT19937clEj", "_ZN2cv3ogl6BufferC2ERKNS_11_InputArrayENS1_6TargetEb", "_ZN2cv11RNG_MT19937cvdEv", "_ZN2cv3ogl9Texture2DC1ENS_5Size_IiEENS1_6FormatEjb", "cvConvexityDefects", "_ZN2cv3MatC2ERKS0_PKNS_5RangeE", "cvRemap", "_ZN2cvorERKNS_3MatES2_", "_ZNK2cv13AlgorithmInfo4readEPNS_9AlgorithmERKNS_8FileNodeE", "_ZN2cv12_OutputArrayC2ERKNSt3__16vectorINS_3MatENS1_9allocatorIS3_EEEE", "_ZN2cv3MatC1EPK9_IplImageb", "cvSub", "__gnu_Unwind_Backtrace", "cvConvertScaleAbs", "_ZN2cv12cornerSubPixERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEES7_NS_12TermCriteriaE", "_Z17icvIntersectLinesddddddddPd", "_ZN2cv11_InputArrayC2ERKNS_9GlTextureE", "_ZN2cv6GlFontC1ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEiNS0_6WeightENS0_5StyleE", "_ZNK2cv5MatOp12augAssignAddERKNS_7MatExprERNS_3MatE", "cvSort", "_ZN2cv16convexityDefectsERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv15scalarToRawDataERKNS_7Scalar_IdEEPvii", "_ZN2cv15getDerivKernelsERKNS_12_OutputArrayES2_iiibi", "_ZN2cv9magnitudeEPKfS1_Pfi", "_ZN2cv9GlTextureC1ENS_5Size_IiEEi", "_ZN2cv11getTextSizeERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEidiPi", "_ZN2cv8GlBuffer7mapHostEv", "_ZN2cvmiERKNS_7Scalar_IdEERKNS_7MatExprE", "_ZN2cv5MutexC2Ev", "cvMemStorageAlloc", "_ZN2cv17CommandLineParser12analyzeValueIfEET_RKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb", "_ZN2cv7absdiffERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv14insertImageCOIERKNS_11_InputArrayEPvi", "cvPyrMeanShiftFiltering", "_ZN2cv9thresholdERKNS_11_InputArrayERKNS_12_OutputArrayEddi", "_ZN2cv17adaptiveThresholdERKNS_11_InputArrayERKNS_12_OutputArrayEdiiid", "_ZNK2cv3gpu6GpuMat9convertToERS1_idd", "_ZN2cv12FilterEngine5applyERKNS_3MatERS1_RKNS_5Rect_IiEENS_6Point_IiEEb", "cvSubstituteContour", "cvInitSparseMatIterator", "_ZN2cv3minERKNS_3MatEdRS0_", "_ZNK2cv11_InputArray15getOGlTexture2DEv", "_ZNK2cv7MatOp_T8multiplyERKNS_7MatExprEdRS1_", "_ZN2cv12mulSpectrumsERKNS_11_InputArrayES2_RKNS_12_OutputArrayEib", "_Unwind_ForcedUnwind", "_ZN2cv3PCAC2ERKNS_11_InputArrayES3_ii", "cvLinearPolar", "_ZN2cv13BaseRowFilterC2Ev", "cvTrace", "cvInRange", "_ZN2cv3logEPKfPfi", "_ZN2cvmlERKNS_7MatExprEd", "_ZN2cv3minERKNS_3MatES2_", "_ZN2cv10BaseFilterD0Ev", "_ZN2cv17phaseCorrelateResERKNS_11_InputArrayES2_S2_Pd", "_ZN2cv12_OutputArrayC2ERNS_3ogl6BufferE", "_ZN2cv9floodFillERKNS_12_OutputArrayENS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i", "_ZN2cv3ogl6BufferC1ENS_5Size_IiEEijb", "_ZNK2cv5MatOp8subtractERKNS_7MatExprES3_RS1_", "_ZN2cv8Subdiv2D8newPointENS_6Point_IfEEbi", "cvSquareAcc", "_ZNK2cv3Mat3mulERKNS_11_InputArrayEd", "cvGetSeqElem", "_ZN2cv12_OutputArrayC1ERKNS_3gpu6GpuMatE", "_ZN2cv9Algorithm9setDoubleERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEd", "_ZNK2cv5MatOp3absERKNS_7MatExprERS1_", "_ZN2cv8Subdiv2D6spliceEii", "cvWrite", "cvInitMatNDHeader", "cvSetData", "cvSetHistBinRanges", "_ZN2cv12FilterEngine5startERKNS_3MatERKNS_5Rect_IiEEbi", "cvSmooth", "_ZNK2cv10MatOp_GEMM8subtractERKNS_7MatExprES3_RS1_", "cv2DRotationMatrix", "_ZN2cv6reduceERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "_ZN2cv3ogl6BufferC2ENS_5Size_IiEEiNS1_6TargetEb", "_ZN2cv12_OutputArrayC2ERKNS_3MatE", "_ZN2cv3PtrI13CvFileStorageE10delete_objEv", "cvCalcProbDensity", "__gnu_Unwind_Restore_VFP_D", "_ZN2cv17borderInterpolateEiii", "_ZN2cv12getThreadNumEv", "_ZNK2cv9MatOp_Bin6divideEdRKNS_7MatExprERS1_", "_ZN2cv9Algorithm9setStringERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_", "_ZN2cv8Subdiv2D12connectEdgesEii", "_ZNK2cv11_InputArray5totalEi", "cvPerspectiveTransform", "_Unwind_Backtrace", "_ZN2cv12morphologyExERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZNK2cv9Algorithm12getMatVectorERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv5randuERKNS_12_OutputArrayERKNS_11_InputArrayES5_", "_ZN2cv5MutexaSERKS0_", "_ZN2cv8GlBuffer7releaseEv", "_ZNK2cv3gpu10DeviceInfo11queryMemoryERjS2_", "_ZN2cv8GlBufferC2ENS_5Size_IiEEiNS0_5UsageE", "_ZN2cv3ogl6Arrays16resetVertexArrayEv", "_ZN2cvneERKNS_3MatEd", "_ZN2cv16GeneralizedHoughD0Ev", "_ZN2cv16TLSDataContainerC2Ev", "_ZN2cv11normHammingEPKhS1_i", "cvCreateImageHeader", "_ZN2cv18getLinearRowFilterEiiRKNS_11_InputArrayEii", "_ZNK2cv11_InputArray8channelsEi", "_ZN2cv9ExceptionD0Ev", "_ZN2cv8GlBuffer11unmapDeviceEv", "_ZN2cv11setIdentityERKNS_12_OutputArrayERKNS_7Scalar_IdEE", "_ZNK2cv10MatOp_GEMM8multiplyERKNS_7MatExprEdRS1_", "_ZN2cv11FileStorageC2EP13CvFileStorage", "_ZN2cv11_InputArrayC2ERKd", "cvConvertScale", "_ZN2cv10getSeqElemEPK5CvSeqi", "_ZN2cv3ogl6ArraysC1Ev", "cvPolyLine", "cvReadRawData", "_ZNK2cv5MatOp11augAssignOrERKNS_7MatExprERNS_3MatE", "_ZN2cv3PtrINS_3ogl9Texture2D4ImplEE10delete_objEv", "_ZN2cv11mixChannelsEPKNS_3MatEjPS0_jPKij", "cvSeqPartition", "_ZN2cv16FileNodeIteratormmEi", "_ZN2cvmlERKNS_7MatExprES2_", "cvGraphRemoveVtxByPtr", "_ZN2cv8fastFreeEPv", "cvFindContours", "_ZN2cv3maxERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv3maxERKNS_3MatEd", "_ZNK2cv8FileNode7readObjEv", "_ZNK2cv3ogl6Buffer5cloneENS1_6TargetEb", "_Unwind_GetTextRelBase", "_ZNK2cv11_InputArray4kindEv", "cvAlloc", "_ZN2cv3gpu14deviceSupportsENS0_10FeatureSetE", "_ZN2cv7MomentsC2Edddddddddd", "_ZN2cv3PCAclERKNS_11_InputArrayES3_ii", "_ZN2cv11FileStorage19releaseAndGetStringEv", "_ZNK2cv9Algorithm9getStringERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv11matchShapesERKNS_11_InputArrayES2_id", "cvGet1D", "cvEllipse", "_ZN2cv12FilterEngine7proceedEPKhiiPhi", "_ZN2cv5eigenERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv11RNG_MT19937cvfEv", "___Unwind_Backtrace", "_ZN2cv8Subdiv2D9swapEdgesEi", "_ZN2cv11bitwise_notERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN2cv9FormattedC1ERKNS_3MatEPKNS_9FormatterEPKi", "cvSetZero", "_ZN2cv16GeneralizedHough11setTemplateERKNS_11_InputArrayES3_S3_NS_6Point_IiEE", "_Unwind_GetLanguageSpecificData", "_ZN2cv7hconcatEPKNS_3MatEjRKNS_12_OutputArrayE", "cvGraphAddEdge", "_ZN2cv5solveERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "cvCbrt", "_ZNK2cv5MatOp6matmulERKNS_7MatExprES3_RS1_", "_ZN2cv3gpu6GpuMatC1ERKS1_NS_5Rect_IiEE", "_ZNK2cv8Subdiv2D6Vertex9isvirtualEv", "_ZN2cv5writeERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEd", "_ZN2cv3SVDclERKNS_11_InputArrayEi", "_Unwind_GetRegionStart", "_ZN2cv3ogl9Texture2D6createEiiNS1_6FormatEb", "_ZN2cv8clearSeqEP5CvSeq", "_ZNK2cv5MatOp3addERKNS_7MatExprES3_RS1_", "_ZN2cv9Algorithm3setEPKcd", "__gnu_Unwind_Restore_VFP_D_16_to_31", "_ZN2cv6resizeERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi", "_ZNK2cv9MatOp_Cmp6assignERKNS_7MatExprERNS_3MatEi", "cvCloneMat", "_ZN2cv9ExceptionC2EiRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_S9_i", "_ZN2cv6GlFontC2ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEiNS0_6WeightENS0_5StyleE", "_ZN2cv17CommandLineParser3hasERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv7grabCutERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Rect_IiEES5_S5_ii", "_ZN2cv11RNG_MT199374seedEj", "_ZN2cv18WriteStructContextD2Ev", "_ZN2cv9GlTextureC1Ev", "cvHoughLines2", "_ZN2cv14copyMakeBorderERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiiRKNS_7Scalar_IdEE", "_ZN2cvngERKNS_7MatExprE", "_ZN2cv9AlgorithmC1Ev", "_ZN2cv6KDTreeC1ERKNS_11_InputArrayEb", "_ZN2cv3ogl9Texture2D14setAutoReleaseEb", "_ZN2cv15createBoxFilterEiiNS_5Size_IiEENS_6Point_IiEEbi", "_ZN2cv9Algorithm7setBoolERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEb", "_ZN2cv7sortIdxERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvSampleLine", "_ZN2cv11_InputArrayC2ERKNS_8GlBufferE", "cvApproxPoly", "_ZN2cv8clipLineENS_5Rect_IiEERNS_6Point_IiEES4_", "cvSetMemoryManager", "_ZN2cv3absERKNS_7MatExprE", "cvInitUndistortMap", "_ZN2cv9Algorithm3setEPKcRKNS_3MatE", "cvGoodFeaturesToTrack", "_ZN2cv16GeneralizedHoughD2Ev", "_ZN2cv11minAreaRectERKNS_11_InputArrayE", "_ZN2cv18minEnclosingCircleERKNS_11_InputArrayERNS_6Point_IfEERf", "cvGetPerspectiveTransform", "_ZNK2cv7MatExpr3colEi", "cvRectangleR", "_ZN2cv9transformERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN2cv12LineIteratorC1ERKNS_3MatENS_6Point_IiEES5_ib", "cvGetSpatialMoment", "_ZNK2cv12_OutputArray6createENS_5Size_IiEEiibi", "_ZNK2cv5MatOp8subtractERKNS_7Scalar_IdEERKNS_7MatExprERS5_", "_ZN2cv9Algorithm9setStringEPKcRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE", "_ZNK2cv11_InputArray12getOGlBufferEv", "_ZN2cv12completeSymmERKNS_12_OutputArrayEb", "_ZN2cv9SparseMat13resizeHashTabEj", "_ZN2cv5erodeERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv16BaseColumnFilterD1Ev", "_ZNK2cv8GlArrays4bindEv", "cvSetErrStatus", "_ZN2cv3ogl9Texture2DC1ENS_5Size_IiEENS1_6FormatEb", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEEPv", "_ZN2cv11FileStorage20getDefaultObjectNameERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv8GlCamera24setPerspectiveProjectionEdddd", "_ZN2cvplERKNS_7MatExprES2_", "cvCrossProduct", "_ZN2cv8GlBuffer8copyFromERKNS_11_InputArrayE", "cvMerge", "_ZN2cv11_InputArrayC1ERKNS_3gpu6GpuMatE", "_ZN2cv8Subdiv2D6locateENS_6Point_IfEERiS3_", "_ZNK2cv9Algorithm9paramHelpERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZNK2cv3Mat4diagEi", "_ZNK2cv16MatConstIterator4lposEv", "_ZN2cv12HoughCirclesERKNS_11_InputArrayERKNS_12_OutputArrayEiddddii", "_ZN2cv12_OutputArrayC2Ev", "_ZN2cv9Algorithm12setAlgorithmEPKcRKNS_3PtrIS0_EE", "_ZN2cv15NAryMatIteratorC2EPPKNS_3MatEPS1_i", "__gnu_unwind_execute", "cvGuiBoxReport", "_ZN2cv10BaseFilterD2Ev", "_ZN2cv19getMorphologyFilterEiiRKNS_11_InputArrayENS_6Point_IiEE", "cvClearSet", "_ZN2cvmiERKNS_3MatERKNS_7MatExprE", "_ZNK3GMMclEN2cv3VecIdLi3EEE", "_ZN2cv9crossCorrERKNS_3MatES2_RS0_NS_5Size_IiEEiNS_6Point_IiEEdi", "_ZN2cv8Subdiv2D6insertENS_6Point_IfEE", "_ZNK2cv12_OutputArray9getMatRefEi", "_ZN2cv3maxERKNS_3MatES2_", "_ZN2cv3gpu6GpuMataSERKS1_", "cvCreateSeq", "_ZN2cv9SparseMat6createEiPKii", "_ZN2cv20perspectiveTransformERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN2cv18getAffineTransformERKNS_11_InputArrayES2_", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRNS_3PtrIS1_EEbMS1_FS6_vEMS1_FvRKS6_ERKNSt3__112basic_stringIcNSE_11char_traitsIcEENSE_9allocatorIcEEEE", "_ZN2cv5Mutex7trylockEv", "_ZNK2cv10MatOp_GEMM3addERKNS_7MatExprES3_RS1_", "__addsf3", "cvScalarToRawData", "_ZN2cv8GlBufferC1ENS0_5UsageE", "_ZN2cv13parallel_for_ERKNS_5RangeERKNS_16ParallelLoopBodyEd", "_ZN2cv11RNG_MT19937cvjEv", "cvPrevTreeNode", "_ZNK2cv7MatExprclERKNS_5Rect_IiEE", "_ZN2cv7inRangeERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE", "_ZN2cv3Mat4onesEiPKii", "_ZN2cv12countNonZeroERKNS_11_InputArrayE", "__gnu_Unwind_Save_VFP_D", "_ZN2cv16TLSDataContainerD1Ev", "cvMulSpectrums", "___Unwind_ForcedUnwind", "_ZN2cv3maxEdRKNS_3MatE", "cvGetFileNodeByName", "_ZN2cv9Algorithm3setERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEd", "cvSetReal2D", "_ZN2cv10fitEllipseERKNS_11_InputArrayE", "cvSave", "cvCreateImage", "_ZN3GMM9addSampleEiN2cv3VecIdLi3EEE", "_ZN2cv9Algorithm9setDoubleEPKcd", "_Unwind_GetCFA", "__gnu_Unwind_Save_WMMXD", "cvCreateChildMemStorage", "cvSet3D", "cvLogPolar", "_Unwind_DeleteException", "_ZN2cv9patchNaNsERKNS_12_OutputArrayEd", "_ZN2cv12_OutputArrayC2ERKNS_3ogl9Texture2DE", "_ZNK2cv3Mat6copyToERKNS_12_OutputArrayERKNS_11_InputArrayE", "_ZN2cv9Algorithm7setBoolEPKcb", "_ZN2cv3gpu6GpuMatC2EiiiPvj", "_ZN2cv9SparseMat5eraseEiiPj", "cvRegisterModule", "_ZN2cv9SparseMat3ptrEibPj", "_ZN2cv6divideEdRKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv17CommandLineParserC2EiPKPKcS2_", "_ZN2cv12getTickCountEv", "__divdi3", "_ZN2cv3RNG8gaussianEd", "_ZN2cv17CommandLineParser12analyzeValueIdEET_RKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb", "_ZN2cv15calcCovarMatrixEPKNS_3MatEiRS0_S3_ii", "_ZN2cv16FileNodeIteratorC1ERKS0_", "_ZN2cv13BaseRowFilterD0Ev", "cvPointPolygonTest", "_ZNK2cv3gpu10DeviceInfo17sharedMemPerBlockEv", "_ZNK2cv11_InputArray5depthEi", "cvNulDevReport", "_ZN2cv3ogl9Texture2DC1ERKNS_11_InputArrayEb", "cvMaxS", "_ZNK2cv11FileStorageixEPKc", "cvStartWriteSeq", "_ZN2cv6KDTreeC2ERKNS_11_InputArrayES3_b", "_ZN2cv2LUEPdjiS0_ji", "_ZN2cv11writeScalarERNS_11FileStorageEd", "cvProjectPCA", "_ZN2cvmiERKNS_7Scalar_IdEERKNS_3MatE", "cvInitMatHeader", "_ZN2cv16getTickFrequencyEv", "_ZN2cv3Mat4onesEiii", "_ZNK2cv8GlBuffer6unbindEv", "__gnu_Unwind_Save_VFP", "_ZNK2cv8Subdiv2D7edgeOrgEiPNS_6Point_IfEE", "cvPutText", "cvLine", "_ZN2cv7noArrayEv", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRhbMS1_FhvEMS1_FvhERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZN2cv11FileStorageC2Ev", "_ZN2cv8fillPolyERKNS_12_OutputArrayERKNS_11_InputArrayERKNS_7Scalar_IdEEiiNS_6Point_IiEE", "_ZN2cv4flipERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvCalcPCA", "_ZN2cv9SparseMat10removeNodeEjjj", "_ZNK2cv13AlgorithmInfo9getParamsERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE", "_ZN2cv9watershedERKNS_11_InputArrayERKNS_12_OutputArrayE", "cvStartReadSeq", "_ZN2cv9ExceptionC1Ev", "cvInvert", "_ZN2cv16GeneralizedHough6detectERKNS_11_InputArrayES3_S3_RKNS_12_OutputArrayES6_", "cvPtr3D", "_ZN2cv9SparseMat3ptrEiiibPj", "_ZN2cv4swapERNS_3MatES1_", "cvHoughCircles", "_ZNK2cv11RotatedRect12boundingRectEv", "_ZN2cv3ogl6Buffer9mapDeviceEv", "cvAddS", "_ZN2cv12_OutputArrayC1Ev", "_ZN2cv3Mat3eyeEiii", "cvReleaseFileStorage", "_ZNK2cv8Subdiv2D9isRightOfENS_6Point_IfEEi", "_ZN2cv8tempfileEPKc", "_ZNK2cv11MatOp_AddEx6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cv6circleERNS_3MatENS_6Point_IiEEiRKNS_7Scalar_IdEEiii", "_ZNK2cv8GlCamera21setupProjectionMatrixEv", "cvRange", "_ZNK2cv9MatOp_Bin8multiplyERKNS_7MatExprEdRS1_", "_ZN2cv12_OutputArrayC1ERNS_3ogl9Texture2DE", "_ZN2cv3SVD7computeERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvReleaseMat", "_ZN2cv3gpu6GpuMat6uploadERKNS_3MatE", "cvReleaseHist", "_ZN2cv5SobelERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiddi", "_ZNK2cv7MatOp_T9transposeERKNS_7MatExprERS1_", "cvCartToPolar", "_ZN2cv10BaseFilterD1Ev", "_ZN3GMM11endLearningEv", "_ZNK2cv8Subdiv2D15getTriangleListERNSt3__16vectorINS_3VecIfLi6EEENS1_9allocatorIS4_EEEE", "_ZN2cv6renderERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS_3PtrINS_6GlFontEEENS_7Scalar_IdEENS_6Point_IdEE", "_ZNK2cv8FileNode4nameEv", "cvCanny", "cvWatershed", "_ZN2cv3ogl6Arrays14setVertexArrayERKNS_11_InputArrayE", "_ZN2cv25getDefaultNewCameraMatrixERKNS_11_InputArrayENS_5Size_IiEEb", "_ZN2cv9FormattedC2ERKNS_3MatEPKNS_9FormatterERKNSt3__16vectorIiNS7_9allocatorIiEEEE", "_ZN2cv9solvePolyERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv11_InputArrayC1ERKNS_9GlTextureE", "_ZN8CvModuleC2EP12CvModuleInfo", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZNK2cv14MatOp_Identity6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cv7MomentsC1Edddddddddd", "cvSVBkSb", "_ZN2cv3ogl9Texture2DC2Ev", "_ZN2cv5randnERKNS_12_OutputArrayERKNS_11_InputArrayES5_", "_ZN3GMMC2ERN2cv3MatE", "__gnu_unwind_frame", "_ZN2cv9AlgorithmD1Ev", "_ZNK2cv7MatExpr4sizeEv", "_ZN6CvTypeC1EPKcPFiPKvEPFvPPvEPFS6_P13CvFileStorageP10CvFileNodeEPFvSB_S1_S3_10CvAttrListEPFS6_S3_E", "_ZNK2cv3gpu6GpuMat8downloadERNS_3MatE", "cvSetReal3D", "_ZNK2cv6KDTree11findNearestERKNS_11_InputArrayEiiRKNS_12_OutputArrayES6_S6_S6_", "cvMul", "_ZN2cv9Algorithm7getListERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE", "_ZNK2cv8FileNodeixERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "cvMinMaxLoc", "_ZN2cv10accumulateERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZNK2cv3ogl9Texture2D4bindEv", "cvLog", "_ZNK2cv13AlgorithmInfo9paramTypeEPKc", "_ZN2cv3gpu6GpuMatC1ERKNS_3MatE", "_ZNK2cv8GlBuffer4bindEv", "_ZN2cv3PtrI11CvHistogramE10delete_objEv", "cvClearSeq", "_ZNK2cv8Subdiv2D6Vertex6isfreeEv", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRjbMS1_FjvEMS1_FvjERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "__modsi3", "_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEiS4_PPKfbb", "_ZN2cv3gpu6GpuMatC1ERKS1_NS_5RangeES4_", "cvCreateData", "_ZN2cv11_InputArrayC1Ev", "_ZN2cv11RNG_MT19937C1Ej", "_ZN2cv11mixChannelsERKNS_11_InputArrayES2_RKNSt3__16vectorIiNS3_9allocatorIiEEEE", "_ZN2cv8Subdiv2D6VertexC2Ev", "_ZN2cv3gpu24printShortCudaDeviceInfoEi", "cvReleaseImageHeader", "cvWarpAffine", "_ZN2cv3Mat6resizeEj", "_ZN2cv9GlTextureC2Ev", "_ZN2cv8CholeskyEPdjiS0_ji", "cvOrS", "_ZNK2cv3Mat7reshapeEiiPKi", "_ZN2cv16FileNodeIteratorppEv", "_ZN2cv3MatC1EiPKiiPvPKj", "_ZN2cvleERKNS_3MatES2_", "cvErode", "_ZN2cv23getPerspectiveTransformEPKNS_6Point_IfEES3_", "_ZN2cv7momentsERKNS_11_InputArrayEb", "_ZN2cv8GlCameraC2Ev", "_ZN2cv9SparseMat3ptrEiibPj", "cvCreateMatND", "_ZN2cv5errorERKNS_9ExceptionE", "_ZN2cv15NAryMatIteratorC1Ev", "_ZN2cv16pointPolygonTestERKNS_11_InputArrayENS_6Point_IfEEb", "cvCloneSparseMat", "cvWriteReal", "_ZN2cv3Mat3eyeENS_5Size_IiEEi", "_ZN2cv9Algorithm3setEPKci", "_ZN2cv22getMorphologyRowFilterEiiii", "_ZNK2cv5MatOp4diagERKNS_7MatExprEiRS1_", "_ZN2cv3MatC1EPK7CvMatNDb", "_ZN2cv3ogl6Arrays14setNormalArrayERKNS_11_InputArrayE", "_ZN2cv9AlgorithmD0Ev", "_ZN2cv11FileStorageD0Ev", "cvFloodFill", "_ZNK2cv16MatConstIterator3posEv", "_ZN2cvdvERKNS_3MatES2_", "_ZNK2cv9Algorithm6getMatERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv3ogl6Arrays14setAutoReleaseEb", "_ZN2cv8GlCamera6lookAtENS_7Point3_IdEES2_S2_", "_ZN2cv9Algorithm3setERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS_3MatE", "__udivsi3", "_ZN2cv15NAryMatIterator4initEPPKNS_3MatEPS1_PPhi", "_ZN2cv3ogl9Texture2DC1Ev", "cvUndistortPoints", "_ZN2cv5ParamC2Ev", "_ZN2cv15getCopyMaskFuncEj", "_ZNK2cv11MatOp_AddEx3absERKNS_7MatExprERS1_", "_ZN2cv7fitLineERKNS_11_InputArrayERKNS_12_OutputArrayEiddd", "_ZN2cv11writeScalarERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE", "_ZN2cv3ogl6BufferC1Ev", "_ZN2cvmlEdRKNS_7MatExprE", "cvGetDimSize", "_ZN2cv3gpu9convertToERKNS0_6GpuMatERS1_", "cvAbsDiff", "cvCreateStructuringElementEx", "_ZN2cv8Subdiv2D7newEdgeEv", "_ZN2cv3ogl9Texture2D7releaseEv", "_Z23VResizeCubicVec_32f_avxPPKhPhS0_i", "_ZN2cvltERKNS_3MatEd", "cvCreateSparseMat", "_ZN2cv9AlgorithmC2Ev", "cvCreateMatHeader", "_ZN2cv9SparseMat3HdrC2EiPKii", "cvSolveCubic", "_ZN2cv9floodFillERKNS_12_OutputArrayES2_NS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i", "_ZN2cv3Mat10deallocateEv", "_ZN2cv19getConvertScaleElemEii", "_ZN2cv16BaseColumnFilterC1Ev", "_ZN2cvanERKNS_7Scalar_IdEERKNS_3MatE", "cvFindGraphEdgeByPtr", "_ZN2cv10normL2Sqr_EPKfS1_i", "_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_9SparseMatERKNS_12_OutputArrayEPPKfdb", "cvGetTickCount", "__subsf3", "_ZN2cv3MatC1EPK5CvMatb", "_ZN2cv4normERKNS_11_InputArrayES2_iS2_", "_ZNK2cv16TLSDataContainer7getDataEv", "_ZN2cv5splitERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv7vconcatERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv9Algorithm7_createERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv8GlBufferC2ERKNS_11_InputArrayENS0_5UsageE", "_ZN2cv9SparseMatC1ERKNS_3MatE", "_ZNK2cv12MatOp_Invert6matmulERKNS_7MatExprES3_RS1_", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEE", "_ZN2cvplERKNS_7MatExprERKNS_7Scalar_IdEE", "cvIntegral", "cvGetRectSubPix", "_ZN2cv3EMDERKNS_11_InputArrayES2_iS2_PfRKNS_12_OutputArrayE", "___Unwind_Resume_or_Rethrow", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRNS_3MatEbMS1_FS5_vEMS1_FvRKS5_ERKNSt3__112basic_stringIcNSD_11char_traitsIcEENSD_9allocatorIcEEEE", "cvMultiplyAcc", "_ZN8CvModuleC1EP12CvModuleInfo", "_ZNK2cv13AlgorithmInfo5writeEPKNS_9AlgorithmERNS_11FileStorageE", "_ZNK2cv5MatOp17augAssignMultiplyERKNS_7MatExprERNS_3MatE", "_ZN2cv11_InputArrayC1ERKNS_3MatE", "_ZNK2cv8Subdiv2D9getVertexEiPi", "_ZN2cv18WriteStructContextC2ERNS_11FileStorageERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEiSB_", "_ZN2cv9LaplacianERKNS_11_InputArrayERKNS_12_OutputArrayEiiddi", "cvNormalize", "_ZN2cv3MatC2EPK9_IplImageb", "_ZN2cv16GeneralizedHough7releaseEv", "_ZN2cv8eigen2x2EPKfPfi", "_ZN2cv11cartToPolarERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_b", "_ZN2cvmlERKNS_3MatES2_", "_ZN2cv17getGaussianKernelEidi", "cvGraphRemoveEdge", "cvInitNArrayIterator", "_ZN2cv12_OutputArrayC2ERNS_3gpu6GpuMatE", "cvGetNormalizedCentralMoment", "cvFitEllipse2", "_ZN2cv4readERKNS_8FileNodeERNS_9SparseMatERKS3_", "_ZN2cv3ogl6renderERKNS0_6ArraysEiNS_7Scalar_IdEE", "cvSeqSort", "_ZN2cv3gpu6GpuMat9adjustROIEiiii", "_ZN2cv3PtrINS_8GlBuffer4ImplEE10delete_objEv", "cvReleaseSparseMat", "_ZN2cv5ParamC1EibiMNS_9AlgorithmEKFivEMS1_FviERKNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEE", "_ZN2cv19getBuildInformationEv", "_ZN2cv3MatC2ERKNS_3gpu6GpuMatE", "_ZNK2cv13AlgorithmInfo4nameEv", "cvMinEnclosingCircle", "_ZN2cv5MutexD1Ev", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRybMS1_FyvEMS1_FvyERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZNK2cv9SparseMat9convertToERS0_id", "cvConvertMaps", "_ZN2cv3ogl6ArraysC2Ev", "cvWriteString", "_ZNK2cv8Subdiv2D11checkSubdivEv", "_ZN2cvplERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv5mergeERKNSt3__16vectorINS_3MatENS0_9allocatorIS2_EEEERKNS_12_OutputArrayE", "_ZNK2cv7MatExprclERKNS_5RangeES3_", "_ZN2cv8Subdiv2D8QuadEdgeC1Ev", "_ZN2cv11RNG_MT19937C1Ev", "cvChangeSeqBlock", "_ZN2cv9transposeERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZNK2cv5MatOp6invertERKNS_7MatExprEiRS1_", "cvMorphologyEx", "_ZN2cv11compareHistERKNS_9SparseMatES2_i", "_ZN2cv3powERKNS_11_InputArrayEdRKNS_12_OutputArrayE", "cvRead", "_ZN2cv6divideERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi", "cvCreateMat", "_ZN2cv3ogl6Buffer14setAutoReleaseEb", "_ZNK2cv3gpu6GpuMat6copyToERS1_RKS1_", "_ZN2cv12FilterEngineC1Ev", "__gnu_Unwind_Save_VFP_D_16_to_31", "cvCompareHist", "cvRandShuffle", "_ZN2cv9Algorithm3setERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEb", "_ZN2cv12_OutputArrayC1ERKNS_3ogl6BufferE", "_ZN2cv22convertAndUnrollScalarERKNS_3MatEiPhj", "_ZN2cvplERKNS_7Scalar_IdEERKNS_7MatExprE", "__extendsfdf2", "_ZN2cvmlERKNS_3MatERKNS_7MatExprE", "_ZN2cv5ParamC1Ev", "cvInitLineIterator", "cvMax", "_ZN2cv8GlCamera8setScaleENS_7Point3_IdEE", "_Z20icvSepConvSmall3_32fPfiS_i6CvSizePKfS2_S_", "cvLaplace", "_ZN2cv9rectangleERNS_3MatENS_6Point_IiEES3_RKNS_7Scalar_IdEEiii", "_ZN2cv4sortERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv16GeneralizedHough6createEi", "cvConvexHull2", "_ZN2cv11seqPopFrontEP5CvSeqPv", "cvGetErrMode", "cvPtrND", "_ZN2cv11_InputArrayC2ERKNS_3MatE", "cvDistTransform", "_ZN2cv7seqPushEP5CvSeqPKv", "_ZN2cv9minMaxIdxERKNS_11_InputArrayEPdS3_PiS4_S2_", "_ZNK2cv11MatOp_Solve6assignERKNS_7MatExprERNS_3MatEi", "cvClearMemStorage", "_ZN2cv9Exception13formatMessageEv", "_ZN2cv5pyrUpERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi", "_ZNK2cv9Algorithm9getDoubleERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZNK2cv12MatOp_Invert6assignERKNS_7MatExprERNS_3MatEi", "_ZNK2cv3ogl6Buffer6copyToERKNS_12_OutputArrayENS1_6TargetEb", "_ZN2cv16GeneralizedHoughD1Ev", "_ZN2cv6theRNGEv", "cvGetHuMoments", "_ZNK2cv3PCA11backProjectERKNS_11_InputArrayE", "_ZN2cv10convexHullERKNS_11_InputArrayERKNS_12_OutputArrayEbb", "_ZN2cv9HuMomentsERKNS_7MomentsERKNS_12_OutputArrayE", "_ZN2cv3Mat5zerosEiii", "cvGetFileNode", "___Unwind_RaiseException", "_ZN2cv14seqRemoveSliceEP5CvSeq7CvSlice", "_ZN2cvplERKNS_3MatES2_", "_ZN2cv6KDTreeC1Ev", "_ZN2cv14getGaborKernelENS_5Size_IiEEdddddi", "cvGetErrStatus", "_ZN2cv15preCornerDetectERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_Unwind_VRS_Pop", "_ZN2cv3RNG4fillERKNS_12_OutputArrayEiRKNS_11_InputArrayES6_b", "_ZN2cv17CommandLineParser3getIbEET_RKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb", "_ZN2cv5writeERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEERKNS_3MatE", "_ZN2cv3PtrINS_3ogl6Buffer4ImplEE10delete_objEv", "_ZN2cv9HuMomentsERKNS_7MomentsEPd", "__fixunsdfsi", "_ZN2cvgtEdRKNS_3MatE", "_ZN2cv12seqPushFrontEP5CvSeqPKv", "cvSetND", "_ZN2cv3gpu6GpuMatC2ERKS1_", "_ZN2cv5remapERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_iiRKNS_7Scalar_IdEE", "_ZN2cv3Mat10push_back_EPKv", "_ZN2cv9boxFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiNS_5Size_IiEENS_6Point_IiEEbi", "_ZN2cv3gpu11setGlDeviceEi", "_ZN2cv8Subdiv2D11deletePointEi", "cvSetAdd", "_ZNK2cv11_InputArray5emptyEv", "_ZNK2cv6KDTree14findOrthoRangeERKNS_11_InputArrayES3_RKNS_12_OutputArrayES6_S6_", "cvDCT", "_ZNK2cv3PCA11backProjectERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZNK2cv9SparseMatcvP11CvSparseMatEv", "_ZN2cv12FilterEngineD1Ev", "_ZN2cv12FilterEngineC2ERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "_ZN2cv3minERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv11writeScalarERNS_11FileStorageEi", "cvSolve", "cvMin", "cvWriteRawData", "_ZN2cv3ogl9Texture2DC2ENS_5Size_IiEENS1_6FormatEb", "_ZN2cv16BaseColumnFilterD2Ev", "_ZN2cv3PCAC1Ev", "_ZN2cv19getConvertScaleFuncEii", "_ZN2cv13getNumThreadsEv", "_ZN2cv9SparseMat7newNodeEPKij", "_ZN2cv3ogl6renderERKNS0_9Texture2DENS_5Rect_IdEES5_", "_ZN2cv22createMorphologyFilterEiiRKNS_11_InputArrayENS_6Point_IiEEiiRKNS_7Scalar_IdEE", "cvGet2D", "_ZN2cv8filter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEdi", "_ZN2cv13AlgorithmInfoC1ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPFPNS_9AlgorithmEvE", "_ZN2cv9Algorithm3setEPKcRKNSt3__16vectorINS_3MatENS3_9allocatorIS5_EEEE", "_ZN2cv15isContourConvexERKNS_11_InputArrayE", "_ZN2cv22SparseMatConstIteratorppEv", "_ZN2cveoERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv10PCAComputeERKNS_11_InputArrayERKNS_12_OutputArrayES5_i", "_ZN2cv21getStructuringElementEiNS_5Size_IiEENS_6Point_IiEE", "_ZN2cv15NAryMatIteratorC2Ev", "_ZN2cv3absERKNS_3MatE", "_ZN2cv8fillPolyERNS_3MatEPPKNS_6Point_IiEEPKiiRKNS_7Scalar_IdEEiiS3_", "_ZN2cv27createSeparableLinearFilterEiiRKNS_11_InputArrayES2_NS_6Point_IiEEdiiRKNS_7Scalar_IdEE", "cvGraphVtxDegree", "cvDiv", "_ZNK2cv8FileNodeixEi", "_ZNK2cv9Exception4whatEv", "_ZN2cv11FileStorage8writeRawERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKhj", "_ZN2cv8SVDecompERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_i", "cvResetImageROI", "_ZN2cv8GlBufferC2EiiiNS0_5UsageE", "cvSet1D", "_ZN2cv8GlBuffer9unmapHostEv", "_ZN2cv8cvtColorERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZNK2cv12_OutputArray9fixedSizeEv", "_ZN2cv9undistortERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_", "cvUndistort2", "cvRelease", "_ZN2cv9Algorithm12setMatVectorEPKcRKNSt3__16vectorINS_3MatENS3_9allocatorIS5_EEEE", "cvGetTickFrequency", "_ZN2cv8GlArrays13setColorArrayERKNS_11_InputArrayEb", "_ZNK2cv3Mat9convertToERKNS_12_OutputArrayEidd", "cvGet3D", "_ZN2cv3Mat4onesENS_5Size_IiEEi", "_ZN2cv8GlBufferC1ENS_5Size_IiEEiNS0_5UsageE", "_ZN2cv3ogl6Arrays13setColorArrayERKNS_11_InputArrayE", "_ZN2cv16GeneralizedHough6detectERKNS_11_InputArrayERKNS_12_OutputArrayES6_i", "_ZN2cv12cornerHarrisERKNS_11_InputArrayERKNS_12_OutputArrayEiidi", "cvEqualizeHist", "cvSetSeqBlockSize", "cvSeqPushFront", "cvCloneMatND", "_ZN2cv3gpu11TargetArchs3hasEii", "_ZN2cvplERKNS_3MatERKNS_7MatExprE", "_ZN2cv7hconcatERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN6CvTypeD1Ev", "cvMatchTemplate", "cvResize", "_ZN2cv11RNG_MT199377uniformEii", "cvGetReal1D", "_ZN2cv11RNG_MT19937C2Ej", "_ZN2cvdvERKNS_3MatERKNS_7MatExprE", "cvSum", "cvXor", "cvSet", "_ZN2cv3gpu6GpuMat7releaseEv", "cvCornerMinEigenVal", "_ZN2cv3Mat8copySizeERKS0_", "cvApproxChains", "_ZN2cv3ogl9Texture2DC2EiiNS1_6FormatEjb", "cvAdaptiveThreshold", "_ZN2cv9Formatter10setDefaultEPKS0_", "cvArcLength", "_ZN2cv13BaseRowFilterD2Ev", "_ZN2cv8GlCamera12setCameraPosENS_7Point3_IdEEddd", "__muldf3", "cvMatchShapes", "cvGetSize", "_ZN2cv12_OutputArrayC2ERNS_3ogl9Texture2DE", "_ZN2cv9GlTexture8copyFromERKNS_11_InputArrayEb", "cvCopyHist", "_Z29icvGetQuadrangleSubPix_8u_C1RPKhi6CvSizePhiS1_PKf", "_ZN2cv3Mat5zerosENS_5Size_IiEEi", "_ZN2cv9GlTextureC2ENS_5Size_IiEEi", "cvAbsDiffS", "_ZN2cv15warpPerspectiveERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE", "_ZNK2cv11MatOp_AddEx8multiplyERKNS_7MatExprEdRS1_", "_ZN2cv13mulTransposedERKNS_11_InputArrayERKNS_12_OutputArrayEbS2_di", "cvClone", "_ZN2cvleEdRKNS_3MatE", "cvFastArctan", "_ZN2cv9Algorithm3setERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_", "_ZN2cv9normalizeERKNS_11_InputArrayERKNS_12_OutputArrayEddiiS2_", "_ZNK2cv12_OutputArray9fixedTypeEv", "_ZN2cv15NAryMatIteratorppEi", "_ZN2cv6KDTreeC2Ev", "_ZNK2cv7MatExpr3rowEi", "cvCreatePyramid", "_ZNK2cv3gpu10DeviceInfo8supportsENS0_10FeatureSetE", "_ZN2cv8subtractERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "_ZN2cv5writeERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA_", "cvSeqPop", "_Z32icvGetQuadrangleSubPix_8u32f_C1RPKhi6CvSizePfiS1_PKf", "cvColorToScalar", "_ZN2cv8CholeskyEPfjiS0_ji", "_ZN2cv8Subdiv2D12clearVoronoiEv", "_ZN2cv15calcBackProjectERKNS_11_InputArrayERKNSt3__16vectorIiNS3_9allocatorIiEEEES2_RKNS_12_OutputArrayERKNS4_IfNS5_IfEEEEd", "_ZN2cvgeERKNS_3MatES2_", "cvGetDims", "cvReduce", "cvCheckContourConvexity", "_ZN2cv8multiplyERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi", "_ZN2cvdvERKNS_7MatExprEd", "_ZN2cv4idctERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvEndWriteSeq", "_ZN2cv9polylinesERKNS_12_OutputArrayERKNS_11_InputArrayEbRKNS_7Scalar_IdEEiii", "_ZNK2cv7MatExpr1tEv", "_ZN2cv12_OutputArrayC2ERKNS_3ogl6BufferE", "_ZN2cv10TLSStorageD1Ev", "_ZN2cv6repeatERKNS_11_InputArrayEiiRKNS_12_OutputArrayE", "_ZN2cv11normHammingEPKhS1_ii", "cvMaxRect", "_ZN2cv3gpu6GpuMatC1ENS_5Size_IiEEiPvj", "_ZN2cv16BaseColumnFilter5resetEv", "cvDrawContours", "_ZN2cv10warpAffineERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv12_OutputArrayC1ERKNSt3__16vectorINS_3MatENS1_9allocatorIS3_EEEE", "_ZN2cvdvERKNS_3MatEd", "_ZN2cv9GlTextureC1Eiii", "_Z23icvGetRectSubPix_8u_C1RPKhi6CvSizePhiS1_12CvPoint2D32f", "_ZN15CvOpenGlFuncTabD2Ev", "cvStdErrReport", "_ZN2cv9SparseMat5clearEv", "cvCircle", "_ZN2cv9ExceptionD2Ev", "_ZN2cv3ogl6BufferC2ENS_5Size_IiEEijb", "_ZN2cv9FormattedC2ERKNS_3MatEPKNS_9FormatterEPKi", "_ZNK2cv12FilterEngine18remainingInputRowsEv", "_ZNK2cv3Mat11checkVectorEiib", "_ZN2cv3Mat6resizeEjRKNS_7Scalar_IdEE", "cvFindGraphEdge", "_ZN2cv11_InputArrayC2ERKNS_3ogl9Texture2DE", "cvGetMinMaxHistValue", "_ZNK2cv12_OutputArray15getOGlBufferRefEv", "cvAnd", "_ZNK2cv12_OutputArray6createEiPKiiibi", "_ZN2cv3gpu9setDeviceEi", "_ZN2cvmiERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv15getRowSumFilterEiiii", "_ZN2cv11FileStorageD1Ev", "cvContourArea", "_ZN2cv7normL1_EPKhS1_i", "_ZNK2cv9Algorithm7getBoolERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "cvTransform", "__divsi3", "_ZN2cv8Subdiv2D11calcVoronoiEv", "__gnu_Unwind_Restore_WMMXD", "_ZN2cv3ogl9Texture2DC1EiiNS1_6FormatEjb", "cvClearHist", "_ZN2cv18preprocess2DKernelERKNS_3MatERNSt3__16vectorINS_6Point_IiEENS3_9allocatorIS6_EEEERNS4_IhNS7_IhEEEE", "_ZN2cv12FilterEngine5startENS_5Size_IiEENS_5Rect_IiEEi", "cvSeqInvert", "__gnu_Unwind_Restore_VFP", "_ZN2cv9minMaxLocERKNS_9SparseMatEPdS3_PiS4_", "cvThreshHist", "_ZN2cv9arcLengthERKNS_11_InputArrayEb", "_ZN2cv8Subdiv2D13setEdgePointsEiii", "_ZN2cv16MatConstIterator4seekEib", "_ZN2cv11randShuffleERKNS_12_OutputArrayEdPNS_3RNGE", "_ZN2cv2LUEPfjiS0_ji", "cvError", "cvEndFindContours", "cvEllipse2Poly", "cvMahalanobis", "_ZN2cv10BaseFilter5resetEv", "cvMinS", "_ZN2cv19goodFeaturesToTrackERKNS_11_InputArrayERKNS_12_OutputArrayEiddS2_ibd", "_Z27VResizeLinearVec_32s8u_avx2PPKhPhS0_i", "_ZN2cvanERKNS_3MatES2_", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRibMS1_FivEMS1_FviERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZN2cv3gpu25getCudaEnabledDeviceCountEv", "_ZN2cv3MatC2EPK5CvMatb", "_ZN2cv7MomentsC1Ev", "cvCalcArrBackProjectPatch", "_ZN2cv16TLSDataContainerD2Ev", "_ZN2cv5mergeERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv6KDTree5buildERKNS_11_InputArrayEb", "__fixunsdfdi", "_ZN2cv3ogl6Buffer9unmapHostEv", "_ZN2cv3ogl6BufferC2EiiiNS1_6TargetEb", "_ZN2cv12boundingRectERKNS_11_InputArrayE", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEERKS1_Pv", "_ZN2cv8Subdiv2D8QuadEdgeC1Ei", "cvSeqSearch", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRdbMS1_FdvEMS1_FvdERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZN2cv11_InputArrayC2ERKNS_3ogl6BufferE", "_ZNK2cv12_OutputArray6createEiiiibi", "_ZN2cv3PtrI14_IplConvKernelE10delete_objEv", "cvWriteComment", "_ZNK2cv7Momentscv9CvMomentsEv", "cvUnregisterType", "_ZN2cv9SparseMat5eraseEiiiPj", "_ZN2cv16BaseColumnFilterC2Ev", "_ZN2cvleERKNS_3MatEd", "cvCompleteSymm", "_ZN2cv16FileNodeIteratorC2Ev", "_ZN2cv16ParallelLoopBodyD2Ev", "_ZN2cv9Algorithm3setERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEi", "_ZN2cv4sqrtERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv5Mutex6unlockEv", "_ZN2cv6GlFont3getERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEiNS0_6WeightENS0_5StyleE", "cvAcc", "_ZN2cv12_OutputArrayC2ERNS_3MatE", "_ZN2cv8Subdiv2D8QuadEdgeC2Ev", "cvGetHashedKey", "_ZN2cv8GlCameraC1Ev", "_ZN2cv9rectangleERNS_3MatENS_5Rect_IiEERKNS_7Scalar_IdEEiii", "_ZN2cvlsERNS_11FileStorageERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE", "cvGetReal3D", "_ZNK2cv9GlTexture6unbindEv", "_ZN2cv9FormattedC1ERKNS_3MatEPKNS_9FormatterERKNSt3__16vectorIiNS7_9allocatorIiEEEE", "_ZN2cv11_InputArrayC1ERKNS_3ogl9Texture2DE", "__gnu_Unwind_Resume", "cvGetFileNodeName", "_ZN2cv8Subdiv2D10deleteEdgeEi", "_ZN2cv6ScharrERKNS_11_InputArrayERKNS_12_OutputArrayEiiiddi", "cvMulTransposed", "cvSet2D", "_ZN2cv12_OutputArrayC1ERNS_3gpu6GpuMatE", "_ZN2cv6KDTreeC2ERKNS_11_InputArrayEb", "_ZN2cv9Algorithm6setIntERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEi", "cvCheckTermCriteria", "cvGetNumThreads", "_ZNK2cv12_OutputArray6neededEv", "_ZN2cvplERKNS_7Scalar_IdEERKNS_3MatE", "_ZN2cv11FileStorage4openERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEiS9_", "cvCornerEigenValsAndVecs", "_ZN2cv8GlBufferC2ENS0_5UsageE", "_ZN2cv3SVD9backSubstERKNS_11_InputArrayES3_S3_S3_RKNS_12_OutputArrayE", "_ZN2cvngERKNS_3MatE", "_ZN2cv14seqInsertSliceEP5CvSeqiPKv", "cvPolarToCart", "_ZN2cvneEdRKNS_3MatE", "cvAvgSdv", "_ZN2cv22SparseMatConstIteratorC1EPKNS_9SparseMatE", "_ZN2cv22cornerEigenValsAndVecsERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "_Unwind_Complete", "_ZN2cv3Mat9adjustROIEiiii", "_ZN2cv16FileNodeIterator7readRawERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPhj", "_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERNS_9SparseMatEiS4_PPKfbb", "_ZNK2cv12_OutputArray12getGpuMatRefEv", "_ZNK3GMMclEiN2cv3VecIdLi3EEE", "_ZN2cvneERKNS_3MatES2_", "cvSeqSlice", "cvSeqPopFront", "_ZN2cv11_InputArrayC1ERKNSt3__16vectorINS_3MatENS1_9allocatorIS3_EEEE", "_ZN2cv13AlgorithmInfoD2Ev", "_Z24icvGetRectSubPix_32f_C1RPKfi6CvSizePfiS1_12CvPoint2D32f", "_ZN2cv11FileStorage8writeObjERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKv", "_ZN2cv11RNG_MT19937cviEv", "_ZN2cv6renderERKNS_9GlTextureENS_5Rect_IdEES4_", "_ZN2cv18getColumnSumFilterEiiiid", "cvGraphRemoveVtx", "cvWarpPerspective", "_ZN2cvmlERKNS_7MatExprERKNS_3MatE", "_ZN6CvTypeD2Ev", "_ZN2cv3PtrI5CvMatE10delete_objEv", "_ZN2cvltERKNS_3MatES2_", "cvDotProduct", "_ZN2cv3gpu6GpuMatC1EiiiPvj", "_ZN2cv3ogl9Texture2DC1EiiNS1_6FormatEb", "_ZNK2cv9Algorithm9getParamsERNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE", "_ZN2cv13getRectSubPixERKNS_11_InputArrayENS_5Size_IiEENS_6Point_IfEERKNS_12_OutputArrayEi", "_ZN2cv3MatC2EiPKiiPvPKj", "_ZN2cvmiERKNS_7MatExprERKNS_3MatE", "_ZN2cv16FileNodeIteratorC2EPK13CvFileStoragePK10CvFileNodej", "cvClearND", "_ZN2cv12_OutputArrayC2ERKNS_3gpu6GpuMatE", "cvCreateSeqBlock", "_ZN2cv8GlBuffer6createEiiiNS0_5UsageE", "_ZNK2cv3SVD9backSubstERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv3ogl6BufferC1ERKNS_11_InputArrayENS1_6TargetEb", "_ZN2cv16FileNodeIteratorC2ERKS0_", "cvClipLine", "cvDilate", "_ZN2cv15NAryMatIteratorC2EPPKNS_3MatEPPhi", "cvBoxPoints", "_ZN2cv8GlCamera18setOrthoProjectionEdddddd", "_ZN2cv23initUndistortRectifyMapERKNS_11_InputArrayES2_S2_S2_NS_5Size_IiEEiRKNS_12_OutputArrayES7_", "_ZN2cv8Subdiv2DC2ENS_5Rect_IiEE", "cvInitUndistortRectifyMap", "_ZNK2cv8Subdiv2D7getEdgeEii", "_ZN2cv9SparseMatC1EPK11CvSparseMat", "cvGraphAddEdgeByPtr", "_ZN2cv6seqPopEP5CvSeqPv", "_ZN2cv3gpu18ensureSizeIsEnoughEiiiRNS0_6GpuMatE", "_ZNK2cv5MatOp4typeERKNS_7MatExprE", "_ZN2cv3MatC1ERKS0_RKNS_5Rect_IiEE", "_ZN2cv3ogl6Buffer6unbindENS1_6TargetE", "cvGraphAddVtx", "_ZN2cv9fastAtan2Eff", "_ZN2cv12_OutputArrayC1ERKNS_3ogl9Texture2DE", "cvCloneImage", "_ZN2cv16TLSDataContainerC1Ev", "__adddf3", "__fixunssfdi", "_ZN2cv3gpu6GpuMatC2ERKS1_NS_5Rect_IiEE", "_ZN2cv14PCABackProjectERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE", "cvDet", "_ZN2cv9SparseMat3HdrC1EiPKii", "cvSeqPush", "_ZN2cv12ellipse2PolyENS_6Point_IiEENS_5Size_IiEEiiiiRNSt3__16vectorIS1_NS4_9allocatorIS1_EEEE", "_ZN2cv10checkRangeERKNS_11_InputArrayEbPNS_6Point_IiEEdd", "cvCvtSeqToArray", "cvAdd", "_ZN2cv3gpu11TargetArchs20hasEqualOrGreaterBinEii", "_ZNK2cv7MatExpr4typeEv", "_ZN2cvgtERKNS_3MatEd", "_ZN2cv6KDTree5buildERKNS_11_InputArrayES3_b", "_ZN2cv15extractImageCOIEPKvRKNS_12_OutputArrayEi", "_ZNK2cv3gpu10DeviceInfo12isCompatibleEv", "_ZNK2cv9Algorithm12getAlgorithmERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZNK2cv9Algorithm4nameEv", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRsbMS1_FivEMS1_FviERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZNK2cv3Mat6copyToERKNS_12_OutputArrayE", "_ZN2cv11_InputArrayC1ERKNS_3ogl6BufferE", "_ZN2cv9seqRemoveEP5CvSeqi", "_Z26VResizeCubicVec_32s8u_avx2PPKhPhS0_i", "_ZNK2cv5MatOp8multiplyERKNS_7MatExprEdRS1_", "cvTranspose", "_ZNK2cv6KDTree4dimsEv", "_ZN2cv10cvarrToMatEPKvbbi", "_ZN2cv10meanStdDevERKNS_11_InputArrayERKNS_12_OutputArrayES5_S2_", "cvSetImageROI", "cvGetND", "_ZN2cv3gpu10DeviceInfo5queryEv", "cvMakeSeqHeaderForArray", "cvScaleAdd", "cvGetMat", "cvReleaseStructuringElement", "_ZN2cv18WriteStructContextD1Ev", "_ZN2cv9minMaxLocERKNS_11_InputArrayEPdS3_PNS_6Point_IiEES6_S2_", "_ZN2cv11_InputArrayC2Ev", "_ZN2cvmlEdRKNS_3MatE", "_ZN2cv16FileNodeIteratorppEi", "_ZN2cv3ogl9Texture2D8copyFromERKNS_11_InputArrayEb", "_ZN2cv7normL1_EPKfS1_i", "cvRunningAvg", "cvCalcEMD2", "_ZN2cv9Algorithm3setERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS_3PtrIS0_EE", "cvGEMM", "_ZN2cv11FileStorageD2Ev", "_ZN2cv18accumulateWeightedERKNS_11_InputArrayERKNS_12_OutputArrayEdS2_", "_ZNK2cv3gpu6GpuMat7reshapeEii", "_ZN2cv10solveCubicERKNS_11_InputArrayERKNS_12_OutputArrayE", "cvSetIdentity", "__gnu_Unwind_Save_WMMXC", "_ZN2cv12_OutputArrayC1ERNSt3__16vectorINS_3MatENS1_9allocatorIS3_EEEE", "cvCornerHarris", "_ZN2cv13matchTemplateERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "cvGetDiag", "_ZNK2cv11FileStorage4rootEi", "_ZNK2cv9MatOp_Bin6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cvltEdRKNS_3MatE", "_ZN2cv11createCLAHEEdNS_5Size_IiEE", "_ZN2cv3logERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZNK2cv13AlgorithmInfo9paramHelpEPKc", "_ZN2cv9ExceptionC1EiRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_S9_i", "_ZNK2cv3ogl9Texture2D5texIdEv", "_ZN2cv9Algorithm12setAlgorithmERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS_3PtrIS0_EE", "cvCloneGraph", "_ZN2cv8Subdiv2D6VertexC1Ev", "_ZN2cvorERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cvmiERKNS_7MatExprERKNS_7Scalar_IdEE", "_ZN3GMM23calcInverseCovAndDetermEi", "_ZN2cv13BaseRowFilterD1Ev", "cvStartFindContours", "_ZN2cv9SparseMat3Hdr5clearEv", "_ZN2cv9magnitudeERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv3gpu11TargetArchs20hasEqualOrGreaterPtxEii", "_ZN2cv5MutexC1ERKS0_", "_ZN2cv15convertScaleAbsERKNS_11_InputArrayERKNS_12_OutputArrayEdd", "cvReadRawDataSlice", "cvSaveMemStoragePos", "_ZN2cv3ogl6Buffer7mapHostENS1_6AccessE", "cvKMeans2", "cvFirstType", "_ZN2cv3PtrI11CvSparseMatE10delete_objEv", "cvInitTreeNodeIterator", "_ZN2cv13redirectErrorEPFiiPKcS1_S1_iPvES2_PS2_", "cvNextGraphItem", "_ZN2cv9ExceptionC2Ev", "_ZN2cv11arrowedLineERNS_3MatENS_6Point_IiEES3_RKNS_7Scalar_IdEEiiid", "_ZN2cv12drawContoursERKNS_12_OutputArrayERKNS_11_InputArrayEiRKNS_7Scalar_IdEEiiS5_iNS_6Point_IiEE", "cvRectangle", "cvGetRootFileNode", "cvInitFont", "_ZN2cv11_InputArrayC2ERKNS_7MatExprE", "_ZN2cv15undistortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_S2_", "_ZNK2cv8Subdiv2D11getEdgeListERNSt3__16vectorINS_3VecIfLi4EEENS1_9allocatorIS4_EEEE", "cvGetThreadNum", "_ZN2cv3Mat9push_backERKS0_", "_ZN2cv21invertAffineTransformERKNS_11_InputArrayERKNS_12_OutputArrayE", "__udivdi3", "_ZN2cv3PtrI12CvMemStorageE10delete_objEv", "_ZN2cv12findContoursERKNS_12_OutputArrayES2_S2_iiNS_6Point_IiEE", "_ZNK2cv5MatOp3roiERKNS_7MatExprERKNS_5RangeES6_RS1_", "_ZN2cv3ogl6BufferC1ENS_5Size_IiEEiNS1_6TargetEb", "_ZN2cv7ellipseERNS_3MatERKNS_11RotatedRectERKNS_7Scalar_IdEEii", "_ZN2cv3MatC2EPK7CvMatNDb", "_ZNK2cv11_InputArray11getGlBufferEv", "cvNextTreeNode", "_ZN2cv3gpu6GpuMatC1ERKS1_", "_ZNK2cv5MatOp3addERKNS_7MatExprERKNS_7Scalar_IdEERS1_", "_ZNK2cv5MatOp6divideERKNS_7MatExprES3_RS1_d", "_ZN2cv8GlArrays14setNormalArrayERKNS_11_InputArrayE", "cvStartReadChainPoints", "cvGetCols", "_ZN2cv9SparseMatC2EPK11CvSparseMat", "__restore_core_regs", "cvFillPoly", "_ZNK2cv5MatOp17augAssignSubtractERKNS_7MatExprERNS_3MatE", "_ZNK2cv17MatOp_Initializer6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cvdvERKNS_7MatExprES2_", "cvWriteInt", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEERKS1_", "_ZN2cv3PtrINS_9GlTexture4ImplEE10delete_objEv", "_ZN2cv9ExceptionD1Ev", "cvGetCentralMoment", "_ZN2cv17cornerMinEigenValERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRfbMS1_FfvEMS1_FvfERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZNK2cv8GlArrays6unbindEv", "cvRepeat", "cvNextNArraySlice", "cvRawDataToScalar", "cvRestoreMemStoragePos", "_ZN2cv13AlgorithmInfoD1Ev", "cvCopy", "_ZNK2cv7MatExpr5crossERKNS_3MatE", "cvEndWriteStruct", "_ZN2cv14getConvertElemEii", "_ZN2cv7MomentsC2Ev", "cvStartAppendToSeq", "_ZNK2cv9Algorithm9paramTypeERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "_ZN2cv3gpu11resetDeviceEv", "_ZN2cv7vconcatEPKNS_3MatEjRKNS_12_OutputArrayE", "_ZN2cv3gpu11TargetArchs17hasEqualOrLessPtxEii", "_ZN2cv12LineIteratorC2ERKNS_3MatENS_6Point_IiEES5_ib", "_ZNK2cv3ogl6Buffer5bufIdEv", "cvMinAreaRect2", "_ZN2cv11SVBackSubstERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayE", "_ZN2cv5MutexC2ERKS0_", "_ZNK2cv17MatOp_Initializer8multiplyERKNS_7MatExprEdRS1_", "_ZN2cv4meanERKNS_11_InputArrayES2_", "_ZN2cv8scaleAddERKNS_11_InputArrayEdS2_RKNS_12_OutputArrayE", "_ZNK2cv12FilterEngine19remainingOutputRowsEv", "_ZN2cv4blurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEENS_6Point_IiEEi", "_ZN2cv7compareERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "_ZN2cv22SparseMatConstIteratorC2EPKNS_9SparseMatE", "cvSetRemove", "_ZN2cv14getConvertFuncEii", "cvPow", "_ZN2cv11_InputArrayC1ERKd", "_ZNK2cv8Subdiv2D8nextEdgeEi", "_ZN2cv12GaussianBlurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi", "_ZNK2cv11MatOp_AddEx3addERKNS_7MatExprERKNS_7Scalar_IdEERS1_", "cvCalcArrHist", "cvUseOptimized", "cvPtr1D", "_ZN2cv11_InputArrayC2ERKNSt3__16vectorINS_3MatENS1_9allocatorIS3_EEEE", "_ZNK2cv10MatOp_GEMM6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cv5Mutex4lockEv", "cvSobel", "cvAttrValue", "_ZN6CvTypeC2EPKcPFiPKvEPFvPPvEPFS6_P13CvFileStorageP10CvFileNodeEPFvSB_S1_S3_10CvAttrListEPFS6_S3_E", "_ZN2cv15setBreakOnErrorEb", "_ZNK2cv7MatExpr3invEi", "cvGetElemType", "_ZN2cveqEdRKNS_3MatE", "_ZN2cv17CommandLineParser12analyzeValueIiEET_RKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEb", "_ZN2cv18getAffineTransformEPKNS_6Point_IfEES3_", "_ZN2cv11mixChannelsERKNSt3__16vectorINS_3MatENS0_9allocatorIS2_EEEERS5_PKij", "_ZN2cv17CommandLineParser11printParamsEv", "_ZN2cv11FileStorage7releaseEv", "cvPyrUp", "_ZN2cv14extractChannelERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvGetOptimalDFTSize", "cvWriteFileNode", "_ZN2cv16FileNodeIteratorpLEi", "cvCmpS", "_ZN2cv3PCAC1ERKNS_11_InputArrayES3_ii", "_ZN2cv4globENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERNS0_6vectorIS6_NS4_IS6_EEEEb", "_ZN2cv12findContoursERKNS_12_OutputArrayES2_iiNS_6Point_IiEE", "_ZN2cv8Subdiv2D8QuadEdgeC2Ei", "_ZN2cv11_InputArrayC2ERKNS_3gpu6GpuMatE", "_ZN2cv13getKernelTypeERKNS_11_InputArrayENS_6Point_IiEE", "__gnu_Unwind_RaiseException", "cvCheckArr", "_ZN2cv4PSNRERKNS_11_InputArrayES2_", "_ZN2cv7MomentsC1ERK9CvMoments", "_ZN2cveqERKNS_3MatEd", "_ZN2cv3ogl6BufferC1Eiiijb", "_ZN2cv8Subdiv2DC2Ev", "_ZN2cv10medianBlurERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvReleaseGraphScanner", "_ZN2cv3ogl6Buffer6createEiiiNS1_6TargetEb", "_ZNK2cv11FileStorageixERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE", "cvReleaseData", "cvGetReal2D", "_ZN2cv12FilterEngine4initERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "_ZN2cv8clipLineENS_5Size_IiEERNS_6Point_IiEES4_", "_ZN2cv12_OutputArrayC1ERNS_3MatE", "_ZN2cv3SVD7computeERKNS_11_InputArrayERKNS_12_OutputArrayES6_S6_i", "_ZNK2cv5MatOp4sizeERKNS_7MatExprE", "_ZN2cv3ogl10checkErrorEPKciS2_", "cvBackProjectPCA", "_ZNK2cv3Mat7reshapeEii", "_ZN2cv12_OutputArrayC2ERNSt3__16vectorINS_3MatENS1_9allocatorIS3_EEEE", "cvSubRS", "_ZNK2cv6KDTree8getPointEiPi", "_ZN3GMM12initLearningEv", "_ZN2cv6repeatERKNS_3MatEii", "_ZN2cv11FileStorageC1Ev", "_ZN2cv21getLinearColumnFilterEiiRKNS_11_InputArrayEiidi", "_ZN2cv8GlBuffer9mapDeviceEv", "cvGetQuadrangleSubPix", "_ZN2cv13PCAComputeVarERKNS_11_InputArrayERKNS_12_OutputArrayES5_d", "_ZN2cv16ParallelLoopBodyD1Ev", "cvAddWeighted", "_ZN2cv15NAryMatIteratorppEv", "_ZNK2cv11_InputArray12getMatVectorERNSt3__16vectorINS_3MatENS1_9allocatorIS3_EEEE", "cvNot", "cvCalcCovarMatrix", "_ZN2cv16FileNodeIteratormIEi", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_i", "_ZN2cv9Algorithm12setMatVectorERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorINS_3MatENS5_ISB_EEEE", "_ZNK2cv5MatOp9transposeERKNS_7MatExprERS1_", "_ZN2cv3PtrI7CvMatNDE10delete_objEv", "cvFindCornerSubPix", "_ZN2cv11RNG_MT19937C2Ev", "_ZN2cvdvEdRKNS_3MatE", "cvPreCornerDetect", "_ZNK2cv11FileStorage8isOpenedEv", "_ZNK2cv3ogl9Texture2D6copyToERKNS_12_OutputArrayEib", "_ZN2cv15bilateralFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiddi", "_ZN2cv3gpu5errorEPKcS2_iS2_", "_ZN2cv16BaseColumnFilterD0Ev", "cvRedirectError", "_ZN2cv11FileStorageC2ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEiS9_", "_ZN8CvModuleD1Ev", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRNSt3__16vectorINS_3MatENS5_9allocatorIS7_EEEEbMS1_FSA_vEMS1_FvRKSA_ERKNS5_12basic_stringIcNS5_11char_traitsIcEENS8_IcEEEE", "_ZN2cv7pyrDownERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi", "_ZN2cv3ogl6Buffer7releaseEv", "cvFitLine", "_ZNK2cv11_InputArray4sizeEi", "_Unwind_RaiseException", "_ZNK2cv8Subdiv2D7edgeDstEiPNS_6Point_IfEE", "_ZN15CvOpenGlFuncTabD0Ev", "_ZN2cv11RNG_MT19937clEv", "_ZN2cv11RNG_MT199377uniformEff", "_ZN2cv18WriteStructContextC1ERNS_11FileStorageERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEiSB_", "cvGetErrInfo", "cvMixChannels", "__divdf3", "_ZN2cv16FileNodeIteratorC1Ev", "_ZN2cv13AlgorithmInfo9addParam_ERNS_9AlgorithmEPKciPvbMS1_KFivEMS1_FviERKNSt3__112basic_stringIcNSA_11char_traitsIcEENSA_9allocatorIcEEEE", "_ZN2cv6KDTreeC1ERKNS_11_InputArrayES3_b", "_ZN2cv3gpu9convertToERKNS0_6GpuMatERS1_ddPv", "cvErrorStr", "_ZNK2cv9SparseMat6copyToERS0_"], "allstrings": ["name", "unknown/unsupported type of '%s' parameter == %d", "void cv::AlgorithmInfo::write(const cv::Algorithm *, cv::FileStorage &) const", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/algorithm.cpp", "!nestedAlgo.empty()", "void cv::AlgorithmInfo::read(cv::Algorithm *, const cv::FileNode &) const", "No parameter '%s' is found", "<NULL>", "void cv::AlgorithmInfo::set(cv::Algorithm *, const char *, int, const void *, bool) const", "Parameter '%s' is readonly", "Wrong argument type in the setter", "Wrong parameter type in the setter", "Unknown/unsupported parameter type", "void cv::AlgorithmInfo::get(const cv::Algorithm *, const char *, int, void *) const", "Wrong argument type", "int cv::AlgorithmInfo::paramType(const char *) const", "string cv::AlgorithmInfo::paramHelp(const char *) const", "argType == Param::INT || argType == Param::BOOLEAN || argType == Param::REAL || argType == Param::STRING || argType == Param::MAT || argType == Param::MAT_VECTOR || argType == Param::ALGORITHM || argType == Param::SHORT || argType == Param::FLOAT || argType == Param::UNSIGNED_INT || argType == Param::UINT64 || argType == Param::UCHAR", "void cv::AlgorithmInfo::addParam_(cv::Algorithm &, const char *, int, void *, bool, Algorithm::Getter, Algorithm::Setter, const string &)", "i == 0 || vec[i].first != vec[i-1].first", "void cv::sorted_vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, cv::Param>::add(const _KeyTp &, const _ValueTp &) [_KeyTp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, _ValueTp = cv::Param]", "vector", "void cv::sorted_vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, cv::Algorithm *(*)()>::add(const _KeyTp &, const _ValueTp &) [_KeyTp = std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, _ValueTp = cv::Algorithm *(*)()]", "basic_string", "Argument error: the getter", " method was called for the parameter '", "' of the algorithm '", "', the parameter has ", " type, ", "so it should be get as integer, unsigned integer, uint64, boolean, unsigned char, float or double value, ", "so it should be get as integer, unsigned integer, uint64, unsigned char, float or double value, ", "so it should be get as integer value, ", "so it should be get as float or double value, ", "but the getter was called to get a ", " value", "integer", "short", "boolean", "double", "string", "cv::Mat", "std::vector<cv::Mat>", "algorithm", "float", "unsigned int", "unsigned int64", "unsigned char", "string cv::getNameOfType(int)", "Argument error: the setter", "so it should be set by integer, unsigned integer, uint64, unsigned char, boolean, float or double value, ", "so it should be set by integer value, ", "but the setter was called with ", "Custom memory allocator is not supported", "void cvSetMemoryManager(CvAllocFunc, CvFreeFunc, void *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/alloc.cpp", "Failed to allocate %lu bytes", "void *cv::OutOfMemoryError(size_t)", "void cv::convertAndUnrollScalar(const cv::Mat &, int, uchar *, size_t)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/arithm.cpp", "op == CMP_LT || op == CMP_LE || op == CMP_EQ || op == CMP_NE || op == CMP_GE || op == CMP_GT", "void cv::compare(InputArray, InputArray, OutputArray, int)", "The operation is neither 'array op array' (where arrays have the same size and the same type), nor 'array op scalar', nor 'scalar op array'", "The lower bounary is neither an array of the same size and same type as src, nor a scalar", "void cv::inRange(InputArray, InputArray, InputArray, OutputArray)", "The upper bounary is neither an array of the same size and same type as src, nor a scalar", "((int)lbScalar ^ (int)ubScalar) == 0", "lb.type() == ub.type()", "src.size == dst.size && src.type() == dst.type()", "void cvNot(const CvArr *, CvArr *)", "src1.size == dst.size && src1.type() == dst.type()", "void cvAnd(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvOr(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvXor(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvAndS(const CvArr *, CvScalar, CvArr *, const CvArr *)", "void cvOrS(const CvArr *, CvScalar, CvArr *, const CvArr *)", "void cvXorS(const CvArr *, CvScalar, CvArr *, const CvArr *)", "src1.size == dst.size && src1.channels() == dst.channels()", "void cvAdd(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvSub(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvAddS(const CvArr *, CvScalar, CvArr *, const CvArr *)", "void cvSubRS(const CvArr *, CvScalar, CvArr *, const CvArr *)", "void cvMul(const CvArr *, const CvArr *, CvArr *, double)", "src2.size == dst.size && src2.channels() == dst.channels()", "void cvDiv(const CvArr *, const CvArr *, CvArr *, double)", "void cvAddWeighted(const CvArr *, double, const CvArr *, double, double, CvArr *)", "void cvAbsDiff(const CvArr *, const CvArr *, CvArr *)", "void cvAbsDiffS(const CvArr *, CvArr *, CvScalar)", "src1.size == dst.size && dst.type() == CV_8U", "void cvInRange(const void *, const void *, const void *, void *)", "void cvInRangeS(const void *, CvScalar, CvScalar, void *)", "void cvCmp(const void *, const void *, void *, int)", "void cvCmpS(const void *, double, void *, int)", "void cvMin(const void *, const void *, void *)", "void cvMax(const void *, const void *, void *)", "void cvMinS(const void *, double, void *)", "void cvMaxS(const void *, double, void *)", "The operation is neither 'array op array' (where arrays have the same size and the same number of channels), nor 'array op scalar', nor 'scalar op array'", "void cv::arithm_op(InputArray, InputArray, OutputArray, InputArray, int, BinaryFunc *, bool, void *)", "src2.type() == CV_64F && (src2.rows == 4 || src2.rows == 1)", "When the input arrays in add/subtract/multiply/divide functions have different types, the output array type must be explicitly specified", "(mask.type() == CV_8UC1 || mask.type() == CV_8SC1)", "mask.size == src1.size", "The operation is neither 'array op array' (where arrays have the same size and type), nor 'array op scalar', nor 'scalar op array'", "void cv::binary_op(InputArray, InputArray, OutputArray, InputArray, const BinaryFunc *, bool)", "Either all the pointers should be null or they all should be non-null", "void cvSetIPLAllocators(Cv_iplCreateImageHeader, Cv_iplAllocateImageData, Cv_iplDeallocate, Cv_iplCreateROI, Cv_iplCloneImage)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/array.cpp", "Non-positive width or height", "CvMat *cvCreateMatHeader(int, int, int)", "Invalid matrix type", "CvMat *cvInitMatHeader(CvMat *, int, int, int, void *, int)", "Non-positive cols or rows", "void cvReleaseMat(CvMat **)", "Bad CvMat header", "CvMat *cvCloneMat(const CvMat *)", "NULL matrix header pointer", "CvMatND *cvInitMatNDHeader(CvMatND *, int, const int *, int, void *)", "invalid array data type", "NULL <sizes> pointer", "non-positive or too large number of dimensions", "one of dimesion sizes is non-positive", "The array is too big", "CvMatND *cvCreateMatNDHeader(int, const int *, int)", "Bad CvMatND header", "CvMatND *cvCloneMatND(const CvMatND *)", "src->dims <= CV_MAX_DIM", "_dst.data == data0", "Incorrect number of arrays", "int cvInitNArrayIterator(int, CvArr **, const CvArr *, CvMatND *, CvNArrayIterator *, int)", "Some of required array pointers is NULL", "Iterator pointer is NULL", "COI set is not allowed here", "Number of dimensions is the same for all arrays", "Data type is not the same for all arrays", "Number of channels is not the same for all arrays", "Depth is not the same for all arrays", "Mask should have 8uC1 or 8sC1 data type", "Dimension sizes are the same for all arrays", "CvSparseMat *cvCreateSparseMat(int, const int *, int)", "bad number of dimensions", "void cvReleaseSparseMat(CvSparseMat **)", "Invalid sparse array header", "CvSparseMat *cvCloneSparseMat(const CvSparseMat *)", "Invalid sparse matrix header", "CvSparseNode *cvInitSparseMatIterator(const CvSparseMat *, CvSparseMatIterator *)", "NULL iterator pointer", "Data is already allocated", "void cvCreateData(CvArr *)", "Too big buffer is allocated", "unrecognized or unsupported array type", "void cvSetData(CvArr *, void *, int)", "For multidimensional array only CV_AUTOSTEP is allowed here", "void cvReleaseData(CvArr *)", "Only continuous nD arrays are supported here", "void cvGetRawData(const CvArr *, uchar **, int *, CvSize *)", "int cvGetElemType(const CvArr *)", "int cvGetDims(const CvArr *, int *)", "bad dimension index", "int cvGetDimSize(const CvArr *, int)", "Array should be CvMat or IplImage", "CvSize cvGetSize(const CvArr *)", "CvMat *cvGetSubRect(const CvArr *, CvMat *, CvRect)", "CvMat *cvGetRows(const CvArr *, CvMat *, int, int, int)", "CvMat *cvGetCols(const CvArr *, CvMat *, int, int)", "CvMat *cvGetDiag(const CvArr *, CvMat *, int)", "The number of channels must be 1, 2, 3 or 4", "void cvScalarToRawData(const CvScalar *, void *, int, int)", "void cvRawDataToScalar(const void *, int, CvScalar *)", "index is out of range", "uchar *cvPtr1D(const CvArr *, int, int *)", "uchar *cvPtr2D(const CvArr *, int, int, int *)", "COI must be non-null in case of planar images", "uchar *cvPtr3D(const CvArr *, int, int, int, int *)", "NULL pointer to indices", "uchar *cvPtrND(const CvArr *, const int *, int *, int, unsigned int *)", "CvScalar cvGet1D(const CvArr *, int)", "CvScalar cvGet2D(const CvArr *, int, int)", "double cvGetReal1D(const CvArr *, int)", "cvGetReal* support only single-channel arrays", "double cvGetReal2D(const CvArr *, int, int)", "double cvGetReal3D(const CvArr *, int, int, int)", "double cvGetRealND(const CvArr *, const int *)", "void cvSet1D(CvArr *, int, CvScalar)", "void cvSet2D(CvArr *, int, int, CvScalar)", "void cvSetReal1D(CvArr *, int, double)", "cvSetReal* support only single-channel arrays", "void cvSetReal2D(CvArr *, int, int, double)", "void cvSetReal3D(CvArr *, int, int, int, double)", "void cvSetRealND(CvArr *, const int *, double)", "NULL array pointer is passed", "CvMat *cvGetMat(const CvArr *, CvMat *, int *, int)", "The matrix has NULL data pointer", "The image has NULL data pointer", "Images with planar data layout should be used with COI selected", "The image is interleaved and has over CV_CN_MAX channels", "Pixel order should be used with coi == 0", "Input array has NULL data pointer", "Unrecognized or unsupported array type", "NULL pointer to array or destination header", "CvArr *cvReshapeMatND(const CvArr *, int, CvArr *, int, int, int *)", "None of array parameters is changed: dummy call?", "Non-positive or too large number of dimensions", "New dimension sizes are not specified", "The output header should be CvMat or CvMatND", "The matrix is not continuous so the number of rows can not be changed", "The total number of matrix elements is not divisible by the new number of rows", "The total matrix width is not divisible by the new number of columns", "The output header should be CvMatND", "The input array must be CvMatND", "The last dimension full size is not divisible by new number of channels", "Simultaneous change of shape and number of channels is not supported. Do it by 2 separate calls", "Non-continuous nD arrays are not supported", "One of new dimension sizes is non-positive", "Number of elements in the original and reshaped array is different", "COI is not supported by this operation", "CvMat *cvReshape(const CvArr *, CvMat *, int, int)", "COI is not supported", "The matrix is not continuous, thus its number of rows can not be changed", "Bad new number of rows", "The total width is not divisible by the new number of channels", "IplImage *cvGetImage(const CvArr *, IplImage *)", "null pointer to header", "IplImage *cvInitImageHeader(IplImage *, CvSize, int, int, int, int)", "Bad input roi", "Unsupported format", "Bad input origin", "Bad input align", "void cvReleaseImageHeader(IplImage **)", "void cvReleaseImage(IplImage **)", "void cvSetImageROI(IplImage *, CvRect)", "rect.width >= 0 && rect.height >= 0 && rect.x < image->width && rect.y < image->height && rect.x + rect.width >= (int)(rect.width > 0) && rect.y + rect.height >= (int)(rect.height > 0)", "void cvResetImageROI(IplImage *)", "Null pointer to image", "CvRect cvGetImageROI(const IplImage *)", "void cvSetImageCOI(IplImage *, int)", "int cvGetImageCOI(const IplImage *)", "Bad image header", "IplImage *cvCloneImage(const IplImage *)", "Unknown type of term criteria", "CvTermCriteria cvCheckTermCriteria(CvTermCriteria, double, int)", "Iterations flag is set and maximum number of iterations is <= 0", "Accuracy flag is set and epsilon is < 0", "Neither accuracy nor maximum iterations number flags are set in criteria type", "GRAY", "BGRA", "One of indices is out of range", "void icvDeleteNode(CvSparseMat *, const int *, unsigned int *)", "uchar *icvGetNodePtr(CvSparseMat *, const int *, int *, int, unsigned int *)", "CvMatND *cvGetMatND(const CvArr *, CvMatND *, int *)", "false", "true", ", --", "func != 0", "void cv::split(const cv::Mat &, cv::Mat *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/convert.cpp", "!_mv.fixedType() || CV_MAT_TYPE(_mv.flags) == m.depth()", "void cv::split(InputArray, OutputArrayOfArrays)", "mv && n > 0", "void cv::merge(const cv::Mat *, size_t, OutputArray)", "mv[i].size == mv[0].size && mv[i].depth() == depth", "0 < cn && cn <= CV_CN_MAX", "src && nsrcs > 0 && dst && ndsts > 0 && fromTo && npairs > 0", "void cv::mixChannels(const cv::Mat *, size_t, cv::Mat *, size_t, const int *, size_t)", "j < nsrcs && src[j].depth() == depth", "i1 >= 0 && j < ndsts && dst[j].depth() == depth", "fromTo.size()%2 == 0 && nsrc > 0 && ndst > 0", "void cv::mixChannels(InputArrayOfArrays, InputArrayOfArrays, const vector<int> &)", "0 <= coi && coi < src.channels()", "void cv::extractChannel(InputArray, OutputArray, int)", "src.size == dst.size && src.depth() == dst.depth()", "void cv::insertChannel(InputArray, InputOutputArray, int)", "0 <= coi && coi < dst.channels() && src.channels() == 1", "void cv::convertScaleAbs(InputArray, OutputArray, double, double)", "void cv::Mat::convertTo(OutputArray, int, double, double) const", "interpolation == 0", "void cv::LUT(InputArray, InputArray, OutputArray, int)", "(lutcn == cn || lutcn == 1) && lut.total() == 256 && lut.isContinuous() && (src.depth() == CV_8U || src.depth() == CV_8S)", "Unknown/unsupported norm type", "void cv::normalize(InputArray, OutputArray, double, double, int, int, InputArray)", "nz > 0", "void cvSplit(const void *, void *, void *, void *, void *)", "dvec[j].size() == src.size()", "dvec[j].depth() == src.depth()", "dvec[j].channels() == 1", "i < src.channels()", "void cvMerge(const void *, const void *, const void *, const void *, void *)", "svec[j].size == dst.size && svec[j].depth() == dst.depth() && svec[j].channels() == 1 && i < dst.channels()", "src.size == dst.size && dst.type() == CV_8UC(src.channels())", "void cvConvertScaleAbs(const void *, void *, double, double)", "src.size == dst.size && src.channels() == dst.channels()", "void cvConvertScale(const void *, void *, double, double)", "dst.size() == src.size() && dst.type() == CV_MAKETYPE(lut.depth(), src.channels())", "void cvLUT(const void *, void *, const void *)", "dst.size() == src.size() && src.channels() == dst.channels()", "void cvNormalize(const CvArr *, CvArr *, double, double, int, const CvArr *)", "channels() == CV_MAT_CN(dtype)", "void cv::Mat::copyTo(OutputArray) const", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/copy.cpp", "mask.depth() == CV_8U && (mcn == 1 || mcn == cn)", "void cv::Mat::copyTo(OutputArray, InputArray) const", "size() == mask.size()", "checkScalar(value, type(), _value.kind(), _InputArray::MAT )", "cv::Mat &cv::Mat::setTo(InputArray, InputArray)", "mask.empty() || mask.type() == CV_8U", "src.dims <= 2", "void cv::flip(InputArray, OutputArray, int)", "void cv::repeat(InputArray, int, int, OutputArray)", "ny > 0 && nx > 0", "maskarr == 0", "void cvCopy(const void *, void *, const void *)", "src.depth() == dst.depth() && src.size == dst.size", "(coi1 != 0 || src.channels() == 1) && (coi2 != 0 || dst.channels() == 1)", "src.channels() == dst.channels()", "src.type() == dst.type() && src.size() == dst.size()", "void cvFlip(const CvArr *, CvArr *, int)", "src.type() == dst.type() && dst.rows % src.rows == 0 && dst.cols % src.cols == 0", "void cvRepeat(const CvArr *, CvArr *)", "CvMemStorage *cvCreateChildMemStorage(CvMemStorage *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/datastructs.cpp", "void cvReleaseMemStorage(CvMemStorage **)", "void cvClearMemStorage(CvMemStorage *)", "void cvSaveMemStoragePos(const CvMemStorage *, CvMemStoragePos *)", "void cvRestoreMemStoragePos(CvMemStorage *, CvMemStoragePos *)", "NULL storage pointer", "void *cvMemStorageAlloc(CvMemStorage *, size_t)", "Too large memory block is requested", "requested size is negative or too big", "CvSeq *cvCreateSeq(int, size_t, size_t, CvMemStorage *)", "Specified element size doesn't match to the size of the specified element type (try to use 0 for element type)", "void cvSetSeqBlockSize(CvSeq *, int)", "Storage block size is too small to fit the sequence elements", "int cvSeqElemIdx(const CvSeq *, const void *, CvSeqBlock **)", "void *cvCvtSeqToArray(const CvSeq *, void *, CvSlice)", "CvSeq *cvMakeSeqHeaderForArray(int, int, int, void *, int, CvSeq *, CvSeqBlock *)", "Element size doesn't match to the size of predefined element type (try to use 0 for sequence element type)", "void cvStartAppendToSeq(CvSeq *, CvSeqWriter *)", "void cvStartWriteSeq(int, int, int, CvMemStorage *, CvSeqWriter *)", "void cvFlushSeqWriter(CvSeqWriter *)", "CvSeq *cvEndWriteSeq(CvSeqWriter *)", "void cvCreateSeqBlock(CvSeqWriter *)", "void cvStartReadSeq(const CvSeq *, CvSeqReader *, int)", "void cvChangeSeqBlock(void *, int)", "int cvGetSeqReaderPos(CvSeqReader *)", "void cvSetSeqReaderPos(CvSeqReader *, int, int)", "schar *cvSeqPush(CvSeq *, const void *)", "void cvSeqPop(CvSeq *, void *)", "schar *cvSeqPushFront(CvSeq *, const void *)", "void cvSeqPopFront(CvSeq *, void *)", "schar *cvSeqInsert(CvSeq *, int, const void *)", "void cvSeqRemove(CvSeq *, int)", "Invalid index", "NULL sequence pointer", "void cvSeqPushMulti(CvSeq *, const void *, int, int)", "number of removed elements is negative", "void cvSeqPopMulti(CvSeq *, void *, int, int)", "void cvClearSeq(CvSeq *)", "Invalid sequence header", "CvSeq *cvSeqSlice(const CvSeq *, CvSlice, CvMemStorage *, int)", "Bad sequence slice", "void cvSeqRemoveSlice(CvSeq *, CvSlice)", "start slice index is out of range", "Invalid destination sequence header", "void cvSeqInsertSlice(CvSeq *, int, const CvArr *)", "Source is not a sequence nor matrix", "The source array must be 1d coninuous vector", "Source and destination sequence element sizes are different.", "Bad input sequence", "void cvSeqSort(CvSeq *, CvCmpFunc, void *)", "Null compare function", "schar *cvSeqSearch(CvSeq *, const void *, CvCmpFunc, int, int *, void *)", "Null element pointer", "int cvSeqPartition(const CvSeq *, CvMemStorage *, CvSeq **, CvCmpFunc, void *)", "CvSet *cvCreateSet(int, int, int, CvMemStorage *)", "int cvSetAdd(CvSet *, CvSetElem *, CvSetElem **)", "void cvSetRemove(CvSet *, int)", "CvGraph *cvCreateGraph(int, int, int, int, CvMemStorage *)", "void cvClearGraph(CvGraph *)", "int cvGraphAddVtx(CvGraph *, const CvGraphVtx *, CvGraphVtx **)", "int cvGraphRemoveVtxByPtr(CvGraph *, CvGraphVtx *)", "The vertex does not belong to the graph", "int cvGraphRemoveVtx(CvGraph *, int)", "The vertex is not found", "CvGraphEdge *cvFindGraphEdgeByPtr(const CvGraph *, const CvGraphVtx *, const CvGraphVtx *)", "graph pointer is NULL", "CvGraphEdge *cvFindGraphEdge(const CvGraph *, int, int)", "int cvGraphAddEdgeByPtr(CvGraph *, CvGraphVtx *, CvGraphVtx *, const CvGraphEdge *, CvGraphEdge **)", "vertex pointers coinside (or set to NULL)", "int cvGraphAddEdge(CvGraph *, int, int, const CvGraphEdge *, CvGraphEdge **)", "void cvGraphRemoveEdgeByPtr(CvGraph *, CvGraphVtx *, CvGraphVtx *)", "void cvGraphRemoveEdge(CvGraph *, int, int)", "int cvGraphVtxDegreeByPtr(const CvGraph *, const CvGraphVtx *)", "int cvGraphVtxDegree(const CvGraph *, int)", "Null graph pointer", "CvGraphScanner *cvCreateGraphScanner(CvGraph *, CvGraphVtx *, int)", "graph->storage != 0", "Null double pointer to graph scanner", "void cvReleaseGraphScanner(CvGraphScanner **)", "Null graph scanner", "int cvNextGraphItem(CvGraphScanner *)", "Invalid graph pointer", "CvGraph *cvCloneGraph(const CvGraph *, CvMemStorage *)", "CvSeq *cvTreeToNodeSeq(const void *, int, CvMemStorage *)", "void cvInsertNodeIntoTree(void *, void *, void *)", "void cvRemoveNodeFromTree(void *, void *)", "frame node could not be deleted", "void cvInitTreeNodeIterator(CvTreeNodeIterator *, const void *, int)", "void *cvNextTreeNode(CvTreeNodeIterator *)", "void *cvPrevTreeNode(CvTreeNodeIterator *)", "_points.type() == CV_32F && !_points.empty()", "void cv::KDTree::build(InputArray, InputArray, bool)", "nlabels == n", "vecmat.isContinuous() && vecmat.type() == CV_32F && vecmat.total() == (size_t)points.cols", "int cv::KDTree::findNearest(InputArray, int, int, OutputArray, OutputArray, OutputArray, OutputArray) const", "K > 0 && (normType == NORM_L2 || normType == NORM_L1)", "lowerBound.size == upperBound.size && lowerBound.isContinuous() && upperBound.isContinuous() && lowerBound.type() == upperBound.type() && lowerBound.type() == CV_32F && lowerBound.total() == (size_t)ptdims", "void cv::KDTree::findOrthoRange(InputArray, InputArray, OutputArray, OutputArray, OutputArray) const", "idxmat.isContinuous() && idxmat.type() == CV_32S && (idxmat.cols == 1 || idxmat.rows == 1)", "void cv::KDTree::getPoints(InputArray, OutputArray, OutputArray) const", "labelsmat.isContinuous()", "(unsigned)k < (unsigned)points.rows", "(unsigned)ptidx < (unsigned)points.rows", "const float *cv::KDTree::getPoint(int, int *) const", "vals[ofs[k]] <= pivot", "float cv::medianPartition(size_t *, int, int, const float *)", "vals[ofs[k]] >= pivot", "std::abs(more - less) <= 1", "schar *icvSeqFindNextElem(CvSeq *, int, int, int, int *)", "void icvSeqElemsClearFlags(CvSeq *, int, int)", "void icvGrowSeq(CvSeq *, int)", "The sequence has NULL storage pointer", "void icvGoNextMemBlock(CvMemStorage *)", "void icvDestroyMemStorage(CvMemStorage *)", "void icvInitMemStorage(CvMemStorage *, int)", "connectivity == 8 || connectivity == 4", "cv::LineIterator::LineIterator(const cv::Mat &, Point, Point, int, bool)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/drawing.cpp", "0 <= thickness && thickness <= 255", "void cv::line(cv::Mat &, Point, Point, const Scalar &, int, int, int)", "0 <= shift && shift <= XY_SHIFT", "thickness <= 255", "void cv::rectangle(cv::Mat &, Point, Point, const Scalar &, int, int, int)", "void cv::rectangle(cv::Mat &, Rect, const Scalar &, int, int, int)", "radius >= 0 && thickness <= 255 && 0 <= shift && shift <= XY_SHIFT", "void cv::circle(cv::Mat &, Point, int, const Scalar &, int, int, int)", "axes.width >= 0 && axes.height >= 0 && thickness <= 255 && 0 <= shift && shift <= XY_SHIFT", "void cv::ellipse(cv::Mat &, Point, Size, double, double, double, const Scalar &, int, int, int)", "box.size.width >= 0 && box.size.height >= 0 && thickness <= 255", "void cv::ellipse(cv::Mat &, const cv::RotatedRect &, const Scalar &, int, int)", "void cv::fillConvexPoly(cv::Mat &, const Point *, int, const Scalar &, int, int)", "pts && npts && ncontours >= 0 && 0 <= shift && shift <= XY_SHIFT", "void cv::fillPoly(cv::Mat &, const Point **, const int *, int, const Scalar &, int, int, Point)", "pts && npts && ncontours >= 0 && 0 <= thickness && thickness <= 255 && 0 <= shift && shift <= XY_SHIFT", "void cv::polylines(cv::Mat &, const Point **, const int *, int, bool, const Scalar &, int, int, int)", "points.checkVector(2, CV_32S) >= 0", "void cv::fillConvexPoly(InputOutputArray, InputArray, const Scalar &, int, int)", "p.checkVector(2, CV_32S) >= 0", "void cv::fillPoly(InputOutputArray, InputArrayOfArrays, const Scalar &, int, int, Point)", "void cv::polylines(InputOutputArray, InputArrayOfArrays, bool, const Scalar &, int, int, int)", "void cvDrawContours(void *, CvSeq *, CvScalar, CvScalar, int, int, int, CvPoint)", "elem_type == CV_32SC2", "pt1 && pt2", "int cvClipLine(CvSize, CvPoint *, CvPoint *)", "iterator != 0", "int cvInitLineIterator(const CvArr *, CvPoint, CvPoint, CvLineIterator *, int, int)", "text != 0 && _font != 0", "void cvPutText(CvArr *, const char *, CvPoint, const CvFont *, CvScalar)", "font != 0 && hscale > 0 && vscale > 0 && thickness >= 0", "void cvInitFont(CvFont *, int, double, double, double, int, int)", "void cvGetTextSize(const char *, const CvFont *, CvSize *, int *)", "Unknown font type", "const int *cv::getFontData(int)", "0 <= shift && shift <= XY_SHIFT && thickness >= 0", "void cv::PolyLine(cv::Mat &, const Point *, int, bool, const void *, int, int, int)", "type == CV_32FC1 || type == CV_32FC2 || type == CV_64FC1 || type == CV_64FC2", "void cv::dft(InputArray, OutputArray, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/dxt.cpp", "This mode (using nonzero_rows with a single-column matrix) breaks the function's logic, so it is prohibited.\nFor fast convolution/correlation use 2-column matrix or single-row matrix instead", "type == srcB.type() && srcA.size() == srcB.size()", "void cv::mulSpectrums(InputArray, InputArray, OutputArray, int, bool)", "type == CV_32FC1 || type == CV_64FC1", "void cv::dct(InputArray, OutputArray, int)", "Odd-size DCT's are not implemented", "src.size == dst.size", "void cvDFT(const CvArr *, CvArr *, int, int)", "dst.data == dst0.data", "srcA.size == dst.size && srcA.type() == dst.type()", "void cvMulSpectrums(const CvArr *, const CvArr *, CvArr *, int)", "void cvDCT(const CvArr *, CvArr *, int)", "factors[0] == factors[nf-1]", "void cv::DFT(const Complex<T> *, Complex<T> *, int, int, const int *, const int *, const Complex<T> *, int, const void *, Complex<T> *, int, double) [T = double]", "void cv::DFT(const Complex<T> *, Complex<T> *, int, int, const int *, const int *, const Complex<T> *, int, const void *, Complex<T> *, int, double) [T = float]", "The library is compiled without OpenGL support", "void *IntGetProcAddress(const char *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/gl_core_3_1.cpp", "could not open directory: %s", "void glob_rec(const cv::String &, const cv::String &, std::vector<cv::String> &, bool)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/glob.cpp", "0 <= _rowRange.start && _rowRange.start <= _rowRange.end && _rowRange.end <= m.rows", "cv::gpu::GpuMat::GpuMat(const cv::gpu::GpuMat &, cv::Range, cv::Range)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/gpumat.cpp", "0 <= _colRange.start && _colRange.start <= _colRange.end && _colRange.end <= m.cols", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows", "cv::gpu::GpuMat::GpuMat(const cv::gpu::GpuMat &, Rect)", "cv::gpu::GpuMat cv::gpu::GpuMat::reshape(int, int) const", "mask.empty() || mask.type() == CV_8UC1", "cv::gpu::GpuMat &cv::gpu::GpuMat::setTo(Scalar, const cv::gpu::GpuMat &)", "unknown function", "OpenCV Error: ", ") in ", ", file ", ", line ", "virtual void EmptyFuncTable::mallocPitch(void **, size_t *, size_t, size_t) const", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/dynamicuda/include/opencv2/dynamicuda/dynamicuda.hpp", "virtual void EmptyFuncTable::setTo(cv::gpu::GpuMat &, cv::Scalar, const cv::gpu::GpuMat &, cudaStream_t) const", "virtual void EmptyFuncTable::convert(const cv::gpu::GpuMat &, cv::gpu::GpuMat &) const", "virtual void EmptyFuncTable::convert(const cv::gpu::GpuMat &, cv::gpu::GpuMat &, double, double, cudaStream_t) const", "virtual void EmptyFuncTable::copyWithMask(const cv::gpu::GpuMat &, cv::gpu::GpuMat &, const cv::gpu::GpuMat &) const", "virtual void EmptyFuncTable::copy(const cv::gpu::GpuMat &, cv::gpu::GpuMat &) const", "virtual void EmptyFuncTable::copy(const cv::gpu::GpuMat &, cv::Mat &) const", "virtual void EmptyFuncTable::copy(const cv::Mat &, cv::gpu::GpuMat &) const", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrGreaterBin(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrGreaterPtx(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrGreater(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrLessPtx(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::hasBin(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::hasPtx(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::has(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::builtWith(cv::gpu::FeatureSet) const", "virtual bool EmptyDeviceInfoFuncTable::deviceSupports(cv::gpu::FeatureSet) const", "virtual void EmptyDeviceInfoFuncTable::resetDevice() const", "virtual int EmptyDeviceInfoFuncTable::getDevice() const", "virtual void EmptyDeviceInfoFuncTable::setDevice(int) const", "virtual int EmptyDeviceInfoFuncTable::multiProcessorCount(int) const", "virtual int EmptyDeviceInfoFuncTable::minorVersion(int) const", "virtual int EmptyDeviceInfoFuncTable::majorVersion(int) const", "virtual std::string EmptyDeviceInfoFuncTable::name(int) const", "virtual bool EmptyDeviceInfoFuncTable::isCompatible(int) const", "virtual bool EmptyDeviceInfoFuncTable::supports(int, cv::gpu::FeatureSet) const", "virtual size_t EmptyDeviceInfoFuncTable::totalMemory(int) const", "virtual size_t EmptyDeviceInfoFuncTable::freeMemory(int) const", "virtual void EmptyDeviceInfoFuncTable::queryMemory(int, size_t &, size_t &) const", "virtual size_t EmptyDeviceInfoFuncTable::sharedMemPerBlock(int) const", "mat.rows == mat.cols && (type == CV_32F || type == CV_64F)", "double cv::determinant(InputArray)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/lapack.cpp", "type == CV_32F || type == CV_64F", "double cv::invert(InputArray, OutputArray, int)", "m == n", "method == DECOMP_LU || method == DECOMP_CHOLESKY", "type == _src2.type() && (type == CV_32F || type == CV_64F)", "bool cv::solve(InputArray, InputArray, OutputArray, int)", "(method != DECOMP_LU && method != DECOMP_CHOLESKY) || is_normal || src.rows == src.cols", "The function can not solve under-determined linear systems", "src.rows == src.cols", "bool cv::eigen(InputArray, bool, OutputArray, OutputArray)", "w.type() == u.type() && u.type() == vt.type() && u.data && vt.data && w.data", "static void cv::SVD::backSubst(InputArray, InputArray, InputArray, InputArray, OutputArray)", "u.cols >= nm && vt.rows >= nm && (w.size() == Size(nm, 1) || w.size() == Size(1, nm) || w.size() == Size(vt.rows, u.cols))", "rhs.data == 0 || (rhs.type() == type && rhs.rows == m)", "rows == mat->cols", "double cvDet(const CvArr *)", "src.type() == dst.type() && src.rows == dst.cols && src.cols == dst.rows", "double cvInvert(const CvArr *, CvArr *, int)", "A.type() == x.type() && A.cols == x.rows && x.cols == b.cols", "int cvSolve(const CvArr *, const CvArr *, CvArr *, int)", "p == evects0.data", "void cvEigenVV(CvArr *, CvArr *, CvArr *, double, int, int)", "p == evals0.data", "w.type() == type && (w.size() == cv::Size(nm,1) || w.size() == cv::Size(1, nm) || w.size() == cv::Size(nm, nm) || w.size() == cv::Size(n, m))", "void cvSVD(CvArr *, CvArr *, CvArr *, CvArr *, int)", "u.type() == type", "v.type() == type", "u.size() == svd.u.size()", "v.size() == svd.vt.size()", "void cvSVBkSb(const CvArr *, const CvArr *, const CvArr *, const CvArr *, CvArr *, int)", "void cv::_SVDcompute(InputArray, OutputArray, OutputArray, OutputArray, int)", "X.size == Y.size && type == Y.type() && (depth == CV_32F || depth == CV_64F)", "void cv::magnitude(InputArray, InputArray, OutputArray)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/mathfuncs.cpp", "void cv::phase(InputArray, InputArray, OutputArray, bool)", "void cv::cartToPolar(InputArray, InputArray, OutputArray, OutputArray, bool)", "Mag.empty() || (Angle.size == Mag.size && type == Mag.type() && (depth == CV_32F || depth == CV_64F))", "void cv::polarToCart(InputArray, InputArray, OutputArray, OutputArray, bool)", "depth == CV_32F || depth == CV_64F", "void cv::exp(InputArray, OutputArray)", "void cv::log(InputArray, OutputArray)", "void cv::pow(InputArray, double, OutputArray)", "the value at (%d, %d)=%g is out of range", "bool cv::checkRange(InputArray, bool, Point *, double, double)", "a.depth() == CV_32F", "void cv::patchNaNs(InputOutputArray, double)", "Mag.size() == X.size() && Mag.type() == X.type()", "void cvCartToPolar(const CvArr *, const CvArr *, CvArr *, CvArr *, int)", "Angle.size() == X.size() && Angle.type() == X.type()", "Mag.size() == Angle.size() && Mag.type() == Angle.type()", "void cvPolarToCart(const CvArr *, const CvArr *, CvArr *, CvArr *, int)", "X.size() == Angle.size() && X.type() == Angle.type()", "Y.size() == Angle.size() && Y.type() == Angle.type()", "src.type() == dst.type() && src.size == dst.size", "void cvExp(const CvArr *, CvArr *)", "void cvLog(const CvArr *, CvArr *)", "void cvPow(const CvArr *, CvArr *, double)", "ctype == CV_32F || ctype == CV_64F", "int cv::solveCubic(InputArray, OutputArray)", "(coeffs.size() == Size(n0, 1) || coeffs.size() == Size(n0+1, 1) || coeffs.size() == Size(1, n0) || coeffs.size() == Size(1, n0+1))", "CV_MAT_DEPTH(ctype) >= CV_32F && CV_MAT_CN(ctype) <= 2", "double cv::solvePoly(InputArray, OutputArray, int)", "coeffs0.rows == 1 || coeffs0.cols == 1", "_roots.data == _roots0.data", "int cvSolveCubic(const CvMat *, CvMat *)", "_r.data == _r0.data", "void cvSolvePoly(const CvMat *, CvMat *, int, int)", "type == B.type() && (type == CV_32FC1 || type == CV_64FC1 || type == CV_32FC2 || type == CV_64FC2)", "void cv::gemm(InputArray, InputArray, double, InputArray, double, OutputArray, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/matmul.cpp", "a_size.width == len", "a_size.height == len", "C.type() == type && (((flags&GEMM_3_T) == 0 && C.rows == d_size.height && C.cols == d_size.width) || ((flags&GEMM_3_T) != 0 && C.rows == d_size.width && C.cols == d_size.height))", "type == CV_64FC2", "scn == m.cols || scn + 1 == m.cols", "void cv::transform(InputArray, OutputArray, InputArray)", "scn + 1 == m.cols && (depth == CV_32F || depth == CV_64F)", "void cv::perspectiveTransform(InputArray, OutputArray, InputArray)", "src1.type() == src2.type()", "void cv::scaleAdd(InputArray, double, InputArray, OutputArray)", "data && nsamples > 0", "void cv::calcCovarMatrix(const cv::Mat *, int, cv::Mat &, cv::Mat &, int, int)", "_mean.size() == size", "data[i].size() == size && data[i].type() == type", "src.size() > 0", "void cv::calcCovarMatrix(InputArray, OutputArray, InputOutputArray, int, int)", "(*each).size() == size && (*each).type() == type", "((flags & CV_COVAR_ROWS) != 0) ^ ((flags & CV_COVAR_COLS) != 0)", "nsamples > 0", "mean.size() == size", "type == v2.type() && type == icovar.type() && sz == v2.size() && len == icovar.rows && len == icovar.cols", "double cv::Mahalanobis(InputArray, InputArray, InputArray)", "src.channels() == 1", "void cv::mulTransposed(InputArray, OutputArray, bool, InputArray, double, int)", "delta.channels() == 1 && (delta.rows == src.rows || delta.rows == 1) && (delta.cols == src.cols || delta.cols == 1)", "mat.type() == type() && mat.size == size && func != 0", "double cv::Mat::dot(InputArray) const", "data.channels() == 1", "cv::PCA &cv::PCA::operator()(InputArray, InputArray, int, int)", "_mean.size() == mean_sz", "cv::PCA &cv::PCA::computeVar(InputArray, InputArray, int, double)", "retainedVariance > 0 && retainedVariance <= 1", "mean.data && eigenvectors.data && ((mean.rows == 1 && mean.cols == data.cols) || (mean.cols == 1 && mean.rows == data.rows))", "void cv::PCA::project(InputArray, OutputArray) const", "mean.data && eigenvectors.data && ((mean.rows == 1 && eigenvectors.rows == data.cols) || (mean.cols == 1 && eigenvectors.rows == data.rows))", "void cv::PCA::backProject(InputArray, OutputArray) const", "(D.rows == ((flags & CV_GEMM_A_T) == 0 ? A.rows : A.cols)) && (D.cols == ((flags & CV_GEMM_B_T) == 0 ? B.cols : B.rows)) && D.type() == A.type()", "void cvGEMM(const CvArr *, const CvArr *, double, const CvArr *, double, CvArr *, int)", "dst.depth() == src.depth() && dst.channels() == m.rows", "void cvTransform(const CvArr *, CvArr *, const CvMat *, const CvMat *)", "dst.type() == src.type() && dst.channels() == m.rows-1", "void cvPerspectiveTransform(const CvArr *, CvArr *, const CvMat *)", "void cvScaleAdd(const CvArr *, CvScalar, const CvArr *, CvArr *)", "vecarr != 0 && count >= 1", "void cvCalcCovarMatrix(const CvArr **, int, CvArr *, CvArr *, int)", "(evals0.cols == 1 || evals0.rows == 1) && ecount0 <= ecount && evects0.cols == evects.cols && evects0.rows == ecount0", "void cvCalcPCA(const CvArr *, CvArr *, CvArr *, CvArr *, int)", "mean0.data == mean.data", "dst.cols <= evects.rows && dst.rows == data.rows", "void cvProjectPCA(const CvArr *, const CvArr *, const CvArr *, CvArr *)", "dst.rows <= evects.rows && dst.cols == data.cols", "dst0.data == dst.data", "data.cols <= evects.rows && dst.rows == data.rows", "void cvBackProjectPCA(const CvArr *, const CvArr *, const CvArr *, CvArr *)", "data.rows <= evects.rows && dst.cols == data.cols", "CV_MAT_CN(_type) == e.a.channels()", "virtual void cv::MatOp_Identity::assign(const cv::MatExpr &, cv::Mat &, int) const", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/matop.cpp", "Unknown operation", "virtual void cv::MatOp_Bin::assign(const cv::MatExpr &, cv::Mat &, int) const", "Invalid matrix initializer type", "virtual void cv::MatOp_Initializer::assign(const cv::MatExpr &, cv::Mat &, int) const", "0 <= d && d <= CV_MAX_DIM && _sizes", "void cv::Mat::create(int, const int *, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/matrix.cpp", "step[dims-1] == (size_t)CV_ELEM_SIZE(flags)", "m.dims >= 2", "cv::Mat::Mat(const cv::Mat &, const cv::Range &, const cv::Range &)", "m.dims <= 2", "cv::Mat::Mat(const cv::Mat &, const Rect &)", "ranges", "cv::Mat::Mat(const cv::Mat &, const cv::Range *)", "r == Range::all() || (0 <= r.start && r.start < r.end && r.end <= m.size[i])", "dims <= 2", "cv::Mat cv::Mat::diag(int) const", "img->dataOrder == IPL_DATA_ORDER_PIXEL", "cv::Mat::Mat(const IplImage *, bool)", "img->dataOrder == IPL_DATA_ORDER_PIXEL || img->roi->coi != 0", "IplImage cv::Mat::operator _IplImage() const", "nelems <= (size_t)size.p[0]", "void cv::Mat::pop_back(size_t)", "(int)nelems >= 0", "void cv::Mat::reserve(size_t)", "void cv::Mat::resize(size_t)", "void cv::Mat::push_back(const cv::Mat &)", "COI is not supported by the function", "cv::Mat cv::cvarrToMat(const CvArr *, bool, bool, int)", "seq->total > 0 && CV_ELEM_SIZE(seq->flags) == seq->elem_size", "Unknown array type", "dims <= 2 && step[0] > 0", "void cv::Mat::locateROI(Size &, Point &) const", "cv::Mat &cv::Mat::adjustROI(int, int, int, int)", "CV_IS_IMAGE(arr)", "void cv::extractImageCOI(const CvArr *, OutputArray, int)", "0 <= coi && coi < mat.channels()", "void cv::insertImageCOI(InputArray, CvArr *, int)", "ch.size == mat.size && ch.depth() == mat.depth() && 0 <= coi && coi < mat.channels()", "cv::Mat cv::Mat::reshape(int, int) const", "cn <= 4", "void cv::scalarToRawData(const Scalar &, void *, int, int)", "i < 0", "virtual cv::Mat cv::_InputArray::getMat(int) const", "0 <= i && i < (int)vv.size()", "This method is not implemented for oclMat yet", "k == STD_VECTOR_MAT", "0 <= i && i < (int)v.size()", "virtual void cv::_InputArray::getMatVector(vector<cv::Mat> &) const", "This function in deprecated, do not use it", "virtual cv::GlBuffer cv::_InputArray::getGlBuffer() const", "virtual cv::GlTexture cv::_InputArray::getGlTexture() const", "k == GPU_MAT", "virtual gpu::GpuMat cv::_InputArray::getGpuMat() const", "k == OPENGL_BUFFER", "ogl::Buffer cv::_InputArray::getOGlBuffer() const", "k == OPENGL_TEXTURE", "ogl::Texture2D cv::_InputArray::getOGlTexture2D() const", "virtual Size cv::_InputArray::size(int) const", "i < (int)vv.size()", "virtual size_t cv::_InputArray::total(int) const", "virtual int cv::_InputArray::type(int) const", "virtual bool cv::_InputArray::empty() const", "!fixedSize() || ((Mat*)obj)->size.operator()() == _sz", "virtual void cv::_OutputArray::create(Size, int, int, bool, int) const", "!fixedType() || ((Mat*)obj)->type() == mtype", "!fixedSize() || ((gpu::GpuMat*)obj)->size() == _sz", "!fixedType() || ((gpu::GpuMat*)obj)->type() == mtype", "!fixedSize() || ((ogl::Buffer*)obj)->size() == _sz", "!fixedType() || ((ogl::Buffer*)obj)->type() == mtype", "!fixedSize() || ((Mat*)obj)->size.operator()() == Size(cols, rows)", "virtual void cv::_OutputArray::create(int, int, int, int, bool, int) const", "!fixedSize() || ((gpu::GpuMat*)obj)->size() == Size(cols, rows)", "!fixedSize() || ((ogl::Buffer*)obj)->size() == Size(cols, rows)", "virtual void cv::_OutputArray::create(int, const int *, int, int, bool, int) const", "!fixedType() && !fixedSize()", "CV_MAT_TYPE(mtype) == m.type()", "m.dims == dims", "m.size[j] == sizes[j]", "mtype == type0 || (CV_MAT_CN(mtype) == 1 && ((1 << type0) & fixedDepthMask) != 0)", "dims == 2 && ((sizes[0] == sz.height && sizes[1] == sz.width) || (allowTransposed && sizes[0] == sz.width && sizes[1] == sz.height))", "dims == 2 && (sizes[0] == 1 || sizes[1] == 1 || sizes[0]*sizes[1] == 0)", "!fixedSize() || len == vv.size()", "mtype == type0 || (CV_MAT_CN(mtype) == CV_MAT_CN(type0) && ((1 << type0) & fixedDepthMask) != 0)", "!fixedSize() || len == ((vector<uchar>*)v)->size() / esz", "Vectors with element size %d are not supported. Please, modify OutputArray::create()\n", "create() called for the missing output array", "!fixedSize() || len == len0", "v[j].empty()", "i < (int)v.size()", "!fixedType() || (CV_MAT_CN(mtype) == m.channels() && ((1 << CV_MAT_TYPE(flags)) & fixedDepthMask) != 0)", "!fixedSize()", "virtual void cv::_OutputArray::release() const", "virtual void cv::_OutputArray::clear() const", "virtual cv::Mat &cv::_OutputArray::getMatRef(int) const", "gpu::GpuMat &cv::_OutputArray::getGpuMatRef() const", "ogl::Buffer &cv::_OutputArray::getOGlBufferRef() const", "ogl::Texture2D &cv::_OutputArray::getOGlTexture2DRef() const", "!src[i].empty() && src[i].dims <= 2 && src[i].rows == src[0].rows && src[i].type() == src[0].type()", "void cv::hconcat(const cv::Mat *, size_t, OutputArray)", "!src[i].empty() && src[i].dims <= 2 && src[i].cols == src[0].cols && src[i].type() == src[0].type()", "void cv::vconcat(const cv::Mat *, size_t, OutputArray)", "void cv::setIdentity(InputOutputArray, const Scalar &)", "cv::Scalar cv::trace(InputArray)", "src.dims <= 2 && esz <= (size_t)32", "void cv::transpose(InputArray, OutputArray)", "src.size() == dst.size() && (src.cols == 1 || src.rows == 1)", "m.dims <= 2 && m.rows == m.cols", "void cv::completeSymm(InputOutputArray, bool)", "dims <= 2 && m.dims <= 2 && size() == m.size() && tp == m.type() && ((rows == 3 && cols == 1) || (cols*channels() == 3 && rows == 1))", "cv::Mat cv::Mat::cross(InputArray) const", "void cv::reduce(InputArray, OutputArray, int, int, int)", "op == CV_REDUCE_SUM || op == CV_REDUCE_MAX || op == CV_REDUCE_MIN || op == CV_REDUCE_AVG", "Unsupported combination of input and output array formats", "src.dims <= 2 && src.channels() == 1 && func != 0", "void cv::sort(InputArray, OutputArray, int)", "void cv::sortIdx(InputArray, OutputArray, int)", "data0.dims <= 2 && type == CV_32F && K > 0", "double cv::kmeans(InputArray, int, InputOutputArray, cv::TermCriteria, int, int, OutputArray)", "N >= K", "(best_labels.cols == 1 || best_labels.rows == 1) && best_labels.cols*best_labels.rows == N && best_labels.type() == CV_32S && best_labels.isContinuous()", "(unsigned)labels[i] < (unsigned)K", "counters[k] != 0", "src.rows == dst.cols && src.cols == dst.rows && src.type() == dst.type()", "void cvTranspose(const CvArr *, CvArr *)", "srcA.size() == dst.size() && srcA.type() == dst.type()", "void cvCrossProduct(const CvArr *, const CvArr *, CvArr *)", "The reduced dimensionality index is out of range", "void cvReduce(const CvArr *, CvArr *, int, int)", "The output array size is incorrect", "Input and output arrays must have the same number of channels", "The function only supports 32sC1 and 32fC1 datatypes", "CvArr *cvRange(CvArr *, double, double)", "src.size() == idx.size() && idx.type() == CV_32S && src.data != idx.data", "void cvSort(const CvArr *, CvArr *, CvArr *, int)", "idx0.data == idx.data", "src.size() == dst.size() && src.type() == dst.type()", "!centers.empty()", "int cvKMeans2(const CvArr *, int, CvArr *, CvTermCriteria, int, CvRNG *, int, CvArr *, double *)", "centers.rows == cluster_count", "centers.cols == data.cols", "centers.depth() == data.depth()", "labels.isContinuous() && labels.type() == CV_32S && (labels.cols == 1 || labels.rows == 1) && labels.cols + labels.rows - 1 == data.rows", "cv::Mat cv::Mat::reshape(int, int, const int *) const", "_arrays && (_ptrs || _planes)", "void cv::NAryMatIterator::init(const cv::Mat **, cv::Mat *, uchar **, int)", "narrays <= 1000", "arrays[i] != 0", "A.size == arrays[i0]->size", "A.step[d-1] == A.elemSize()", "m != 0 && _idx", "void cv::MatConstIterator::pos(int *) const", "ConvertData cv::getConvertElem(int, int)", "ConvertScaleData cv::getConvertScaleElem(int, int)", "cv::SparseMat::SparseMat(const CvSparseMat *)", "_sizes && 0 < d && d <= CV_MAX_DIM", "void cv::SparseMat::create(int, const int *, int)", "_sizes[i] > 0", "void cv::SparseMat::copyTo(cv::Mat &) const", "void cv::SparseMat::convertTo(cv::SparseMat &, int, double) const", "void cv::SparseMat::convertTo(cv::Mat &, int, double, double) const", "hdr && hdr->dims == 1", "uchar *cv::SparseMat::ptr(int, bool, size_t *)", "hdr && hdr->dims == 2", "uchar *cv::SparseMat::ptr(int, int, bool, size_t *)", "hdr && hdr->dims == 3", "uchar *cv::SparseMat::ptr(int, int, int, bool, size_t *)", "uchar *cv::SparseMat::ptr(const int *, bool, size_t *)", "void cv::SparseMat::erase(int, int, size_t *)", "void cv::SparseMat::erase(int, int, int, size_t *)", "void cv::SparseMat::erase(const int *, size_t *)", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2", "double cv::norm(const cv::SparseMat &, int)", "Only 32f and 64f are supported", "void cv::minMaxLoc(const cv::SparseMat &, double *, double *, int *, int *)", "void cv::normalize(const cv::SparseMat &, cv::SparseMat &, double, int)", "src.data != dst.data", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = double]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = float]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = int]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = short]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = unsigned short]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = signed char]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = unsigned char]", "0 <= _dims && _dims <= CV_MAX_DIM", "void cv::setSize(cv::Mat &, int, const int *, const size_t *, bool)", "s >= 0", "The total matrix size does not fit to \"size_t\" type", "cn == 2 || cn == 3 || cn == 4", "void cv::ogl::Arrays::setVertexArray(InputArray)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/opengl_interop.cpp", "depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "cn == 3 || cn == 4", "void cv::ogl::Arrays::setColorArray(InputArray)", "cn == 3", "void cv::ogl::Arrays::setNormalArray(InputArray)", "depth == CV_8S || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "cn >= 1 && cn <= 4", "void cv::ogl::Arrays::setTexCoordArray(InputArray)", "void (anonymous namespace)::throw_nogl()", "void icvSetOpenGlFuncTab(const CvOpenGlFuncTab *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/opengl_interop_deprecated.cpp", "cv::GlBuffer::GlBuffer(cv::GlBuffer::Usage)", "cv::GlBuffer::GlBuffer(int, int, int, cv::GlBuffer::Usage)", "cv::GlBuffer::GlBuffer(Size, int, cv::GlBuffer::Usage)", "cv::GlBuffer::GlBuffer(InputArray, cv::GlBuffer::Usage)", "void cv::GlBuffer::create(int, int, int, cv::GlBuffer::Usage)", "void cv::GlBuffer::copyFrom(InputArray)", "void cv::GlBuffer::bind() const", "void cv::GlBuffer::unbind() const", "cv::Mat cv::GlBuffer::mapHost()", "void cv::GlBuffer::unmapHost()", "cv::gpu::GpuMat cv::GlBuffer::mapDevice()", "void cv::GlBuffer::unmapDevice()", "cv::GlTexture::GlTexture()", "cv::GlTexture::GlTexture(int, int, int)", "cv::GlTexture::GlTexture(Size, int)", "cv::GlTexture::GlTexture(InputArray, bool)", "void cv::GlTexture::create(int, int, int)", "void cv::GlTexture::copyFrom(InputArray, bool)", "void cv::GlTexture::bind() const", "void cv::GlTexture::unbind() const", "void cv::GlArrays::setVertexArray(InputArray)", "void cv::GlArrays::setColorArray(InputArray, bool)", "void cv::GlArrays::setNormalArray(InputArray)", "void cv::GlArrays::setTexCoordArray(InputArray)", "void cv::GlArrays::bind() const", "void cv::GlArrays::unbind() const", "cv::GlFont::GlFont(const string &, int, cv::GlFont::Weight, cv::GlFont::Style)", "void cv::GlFont::draw(const char *, int) const", "static Ptr<cv::GlFont> cv::GlFont::get(const std::string &, int, cv::GlFont::Weight, cv::GlFont::Style)", "void cv::render(const cv::GlTexture &, Rect_<double>, Rect_<double>)", "void cv::render(const cv::GlArrays &, int, Scalar)", "void cv::render(const string &, const Ptr<cv::GlFont> &, Scalar, Point2d)", "cv::GlCamera::GlCamera()", "void cv::GlCamera::lookAt(Point3d, Point3d, Point3d)", "void cv::GlCamera::setCameraPos(Point3d, double, double, double)", "void cv::GlCamera::setScale(Point3d)", "void cv::GlCamera::setProjectionMatrix(const cv::Mat &, bool)", "void cv::GlCamera::setPerspectiveProjection(double, double, double, double)", "void cv::GlCamera::setOrthoProjection(double, double, double, double, double, double)", "void cv::GlCamera::setupProjectionMatrix() const", "void cv::GlCamera::setupModelViewMatrix() const", "bool icvCheckGlError(const char *, const int, const char *)", "MATLAB", "PYTHON", "NUMPY", "Unknown formatter", "static const cv::Formatter *cv::Formatter::get(const char *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/out.cpp", "void cv::writeElems(std::ostream &, const void *, int, int, char)", "void cv::writeMat(std::ostream &, const cv::Mat &, char, char, bool)", "uint8", "int8", "uint16", "int16", "int32", "float32", "float64", "uint64", "array([", "], type='", "/sys/devices/system/cpu/possible", "%d-%d", "Invalid filename", "static cv::string cv::FileStorage::getDefaultObjectName(const string &)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/persistence.cpp", "NULL double pointer to file storage", "void cvReleaseFileStorage(CvFileStorage **)", "Invalid pointer to file storage", "CvFileNode *cvGetFileNode(CvFileStorage *, CvFileNode *, const CvStringHashNode *, int)", "Null key element", "The node is neither a map nor an empty collection", "Duplicated key", "CvFileNode *cvGetFileNodeByName(const CvFileStorage *, const CvFileNode *, const char *)", "Null element name", "CvFileNode *cvGetRootFileNode(const CvFileStorage *, int)", "NULL or empty filename", "NULL or empty buffer", "CvFileStorage *cvOpenFileStorage(const char *, CvMemStorage *, int, const char *)", "CV_STORAGE_APPEND and CV_STORAGE_MEMORY are not currently compatible", "Appending data to compressed file is not implemented", ".xml", ".XML", ".Xml", "UTF-16", "utf-16", "Utf-16", "UTF-16 XML encoding is not supported! Use 8-bit encoding\n", "strlen(encoding) < 1000", "<?xml version=\"1.0\" encoding=\"%s\"?>\n", "<?xml version=\"1.0\"?>\n", "<opencv_storage>\n", "</opencv_storage>", "Could not find </opencv_storage> in the end of file.\n", " <!-- resumed -->", "%YAML:1.0\n", "...\n---\n", "%YAML:", "void cvStartWriteStruct(CvFileStorage *, const char *, int, const char *, CvAttrList)", "The file storage is opened for reading", "void cvEndWriteStruct(CvFileStorage *)", "void cvWriteInt(CvFileStorage *, const char *, int)", "void cvWriteReal(CvFileStorage *, const char *, double)", "void cvWriteString(CvFileStorage *, const char *, const char *, int)", "void cvWriteComment(CvFileStorage *, const char *, int)", "void cvStartNextStream(CvFileStorage *)", "void cvWriteRawData(CvFileStorage *, const void *, int, const char *)", "Negative number of elements", "Null data pointer", "void cvStartReadRawData(const CvFileStorage *, const CvFileNode *, CvSeqReader *)", "Null pointer to source file node or reader", "The file node should be a numerical scalar or a sequence", "void cvReadRawDataSlice(const CvFileStorage *, CvSeqReader *, int, void *, const char *)", "Null pointer to reader or destination array", "The readed sequence is a scalar, thus len must be 1", "The sequence element is not a numerical scalar", "The sequence slice does not fit an integer number of records", "Null pointers to source file node or destination array", "void cvReadRawData(const CvFileStorage *, const CvFileNode *, void *, const char *)", "void cvWriteFileNode(CvFileStorage *, const char *, const CvFileNode *, int)", "opencv-sequence", "opencv-sequence-tree", "opencv-graph", "opencv-sparse-matrix", "opencv-image", "opencv-matrix", "opencv-nd-matrix", "Invalid type info", "void cvRegisterType(const CvTypeInfo *)", "Some of required function pointers (is_instance, release, read or write) are NULL", "Type name should start with a letter or _", "Type name should contain only letters, digits, - and _", "NULL double pointer", "void cvRelease(void **)", "Unknown object type", "release function pointer is NULL", "NULL structure pointer", "void *cvClone(const void *)", "clone function pointer is NULL", "void *cvRead(CvFileStorage *, CvFileNode *, CvAttrList *)", "The node does not represent a user object (unknown type?)", "void cvWrite(CvFileStorage *, const char *, const void *, CvAttrList)", "Null pointer to the written object", "Unknown object", "The object does not have write function", "NULL object pointer", "void cvSave(const char *, const void *, const char *, const char *, CvAttrList)", "Could not open the file storage. Check the path and permissions", "Could not find the/an object in file storage", "void *cvLoad(const char *, CvMemStorage *, const char *, const char **)", "NULL memory storage is passed - the loaded dynamic structure can not be stored", "Extra closing '%c'", "cv::FileStorage &cv::operator<<(cv::FileStorage &, const string &)", "The closing '%c' does not match the opening '%c'", "Incorrect element name %s", "Invalid fs.state", "len % elemSize == 0", "void cv::FileStorage::writeRaw(const string &, const uchar *, size_t)", "elem_size > 0", "cv::FileNodeIterator &cv::FileNodeIterator::readRaw(const string &, uchar *, size_t)", "void cv::read(const cv::FileNode &, cv::Mat &, const cv::Mat &)", "CV_IS_SPARSE_MAT(m)", "void cv::read(const cv::FileNode &, cv::SparseMat &, const cv::SparseMat &)", "sizes", "data", "%d%c", "Some of essential matrix attributes are absent", "void *icvReadMatND(CvFileStorage *, CvFileNode *)", "Could not determine the matrix dimensionality", "The matrix data is not found in file storage", "The matrix size does not match to the number of stored elements", "Too complex format for the matrix", "int icvDecodeSimpleFormat(const char *)", "rows", "cols", "void *icvReadMat(CvFileStorage *, CvFileNode *)", "Images with planar data layout are not supported", "void icvWriteImage(CvFileStorage *, const char *, const void *, CvAttrList)", "width", "height", "origin", "top-left", "bottom-left", "layout", "planar", "interleaved", "Some of essential image attributes are absent", "void *icvReadImage(CvFileStorage *, CvFileNode *)", "Only interleaved images can be read", "The image data is not found in file storage", "void *icvReadSparseMat(CvFileStorage *, CvFileNode *)", "Could not determine sparse matrix dimensionality", "Sparse matrix data is corrupted", "flags", "oriented", "vertex_count", "vertex_dt", "edge_count", "edge_dt", "2if%s", "vertices", "edges", "header_dt", "The size of header calculated from \"header_dt\" is greater than header_size", "void icvWriteHeaderData(CvFileStorage *, const CvSeq *, CvAttrList *, int)", "rect", "color", "header_user_data", "The size of element calculated from \"dt\" and the elem_size do not match", "char *icvGetFormat(const CvSeq *, const char *, CvAttrList *, int, char *)", "Size of sequence element (elem_size) is inconsistent with seq->flags", "Some of essential graph attributes are absent", "void *icvReadGraph(CvFileStorage *, CvFileNode *)", "The sequence flags are invalid", "One of \"header_dt\" and \"header_user_data\" is there, while the other is not", "Graph edges should start with 2 integers and a float", "%df%s", "No edges data", "No vertices data", "Some of stored vertex indices are out of range", "Duplicated edge has occured", "void icvReleaseGraph(void **)", "sequences", "opencv-sequence-tree instance should contain a field \"sequences\" that should be a sequence", "void *icvReadSeqTree(CvFileStorage *, CvFileNode *)", "level", "All the sequence tree nodes should contain \"level\" field", "recursive", "False", "FALSE", " hole", " curve", " untyped", "count", "Some of essential sequence attributes are absent", "void *icvReadSeq(CvFileStorage *, CvFileNode *)", "curve", "closed", "hole", "untyped", "Only one of \"header_user_data\", \"rect\" and \"origin\" tags may occur", "The number of stored elements does not match to \"count\"", "void icvReleaseSeq(void **)", "Unknown type of file node", "void icvWriteFileNode(CvFileStorage *, const char *, const CvFileNode *)", "An attempt to add element without a key to a map, or add element with key to sequence", "void icvYMLWrite(CvFileStorage *, const char *, const char *)", "The key is an empty", "The key is too long", "Key must start with a letter or _", "Key names may only contain alphanumeric characters [a-zA-Z0-9], '-', '_' and ' '", "elements with keys can not be written to sequence", "void icvXMLWriteScalar(CvFileStorage *, const char *, const char *, int)", "void icvXMLWriteTag(CvFileStorage *, const char *, int, CvAttrList)", "A single _ is a reserved tag name", "Closing tag should not include any attributes", "Key should start with a letter or _", "Key name may only contain alphanumeric characters [a-zA-Z0-9], '-' and '_'", "%.16e", ".Nan", "-.Inf", ".Inf", "%.8e", "Invalid data type specification", "int icvDecodeFormat(const char *, int *, int)", "Too long data type specification", "%YAML:1.", "void icvYMLParse(CvFileStorage *)", "Unsupported YAML version (it must be 1.x)", "The YAML streams must start with '---', except the first one", "Invalid or unsupported syntax", "Only collections as YAML streams are supported by this parser", "char *icvYMLParseValue(CvFileStorage *, char *, CvFileNode *, int, int)", "Empty type name", "Invalid numeric value (inconsistent explicit type specification?)", "Invalid character", "Too long string literal", "The wrong closing bracket", "Missing , between the elements", "Complex keys are not supported", "Multi-line text literals are not supported", "Block sequence elements must be preceded with '-'", "Incorrect indentation", "char *icvYMLParseKey(CvFileStorage *, char *, CvFileNode *, CvFileNode **)", "Key may not start with '-'", "Missing ':'", "An empty key", "void icvFSCreateCollection(CvFileStorage *, int, CvFileNode *)", "Sequence element should not have name (use <_></_>)", "void icvProcessSpecialDouble(CvFileStorage *, char *, double *, char **)", "Bad format of floating-point constant", "char *icvYMLSkipSpaces(CvFileStorage *, char *, int, int)", "Too long string or a last string w/o newline", "Tabs are prohibited in YAML!", "<?xml", "void icvXMLParse(CvFileStorage *)", "Valid XML should start with '<?xml ...?>'", "opencv_storage", "<opencv_storage> tag is missing", "</opencv_storage> tag is missing", "char *icvXMLParseValue(CvFileStorage *, char *, CvFileNode *, int)", "Directive tags are not allowed here", "Empty tags are not supported", "type_id", "Map element should have a name", "Mismatched closing tag", "There should be space between literals", "Literal \" is not allowed within a string. Use &quot;", "Closing \" is expected", "Literal ' or > are not allowed. Use &apos; or &gt;", "Invalid numeric value in the string", "Invalid character in the symbol entity name", "apos", "quot", "The actual type is different from the specified type", "char *icvXMLParseTag(CvFileStorage *, char *, CvStringHashNode **, CvAttrList **, int *)", "Preliminary end of the stream", "Tag should start with '<'", "Unknown tag type", "Name should start with a letter or underscore", "Closing tag should not contain any attributes", "Attribute name should be followed by '='", "Attribute value should be put into single or double quotes", "Invalid closing tag for <?xml ...", "There should be space between attributes", "char *icvXMLSkipSpaces(CvFileStorage *, char *, int)", "Comments are not allowed here", "Invalid character in the stream", "...\n", "---\n", "Null comment", "void icvYMLWriteComment(CvFileStorage *, const char *, int)", "Null string pointer", "void icvYMLWriteString(CvFileStorage *, const char *, const char *, int)", "The written string is too long", "x%02x", "EndWriteStruct w/o matching StartWriteStruct", "void icvYMLEndWriteStruct(CvFileStorage *)", "Some collection type - CV_NODE_SEQ or CV_NODE_MAP, must be specified", "void icvYMLStartWriteStruct(CvFileStorage *, const char *, int, const char *)", "!!%s %c", "!!%s", "\n<!-- next stream -->\n", "void icvXMLWriteComment(CvFileStorage *, const char *, int)", "Double hyphen '--' is not allowed in the comments", "<!-- %s -->", "<!--", "void icvXMLWriteString(CvFileStorage *, const char *, const char *, int)", "#x%02x", "An extra closing tag", "void icvXMLEndWriteStruct(CvFileStorage *)", "Some collection type: CV_NODE_SEQ or CV_NODE_MAP must be specified", "void icvXMLStartWriteStruct(CvFileStorage *, const char *, int, const char *)", "The storage is not opened", "char *icvGets(CvFileStorage *, char *, int)", "void icvPuts(CvFileStorage *, const char *)", "%s(%d): %s", "void icvClose(CvFileStorage *, std::string *)", "</opencv_storage>\n", "_param1.channels() == 1 && (_param1.rows == 1 || _param1.cols == 1) && (_param1.rows + _param1.cols - 1 == cn || _param1.rows + _param1.cols - 1 == 1 || (_param1.size() == Size(1, 4) && _param1.type() == CV_64F && cn <= 4))", "void cv::RNG::fill(InputOutputArray, int, InputArray, InputArray, bool)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/rand.cpp", "_param2.channels() == 1 && (((_param2.rows == 1 || _param2.cols == 1) && (_param2.rows + _param2.cols - 1 == cn || _param2.rows + _param2.cols - 1 == 1 || (_param1.size() == Size(1, 4) && _param1.type() == CV_64F && cn <= 4))) || (_param2.rows == cn && _param2.cols == cn && disttype == NORMAL))", "scaleFunc != 0", "Unknown distribution type", "dst.elemSize() <= 32", "void cv::randShuffle(InputOutputArray, double, cv::RNG *)", "errcode == 0", "void cv::makeRNGKey()", "cn <= 4 && func != 0", "cv::Scalar cv::sum(InputArray)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/stat.cpp", "src.channels() == 1 && func != 0", "int cv::countNonZero(InputArray)", "cv::Scalar cv::mean(InputArray, InputArray)", "void cv::meanStdDev(InputArray, OutputArray, OutputArray, InputArray)", "dst.type() == CV_64F && dst.isContinuous() && (dst.cols == 1 || dst.rows == 1) && dcn >= cn", "(cn == 1 && (mask.empty() || mask.type() == CV_8U)) || (cn >= 1 && mask.empty() && !minIdx && !maxIdx)", "void cv::minMaxIdx(InputArray, double *, double *, int *, int *, InputArray)", "img.dims <= 2", "void cv::minMaxLoc(InputArray, double *, double *, Point *, Point *, InputArray)", "bad cell size (not 1, 2 or 4) in normHamming", "int cv::normHamming(const uchar *, const uchar *, int, int)", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && src.type() == CV_8U)", "double cv::norm(InputArray, int, InputArray)", "src1.size == src2.size && src1.type() == src2.type()", "double cv::norm(InputArray, InputArray, int, InputArray)", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && src1.type() == CV_8U)", "type == src2.type() && src1.cols == src2.cols && (type == CV_32F || type == CV_8U)", "void cv::batchDistance(InputArray, InputArray, OutputArray, int, OutputArray, int, int, InputArray, int, bool)", "_nidx.needed() == (K > 0)", "(type == CV_8U && dtype == CV_32S) || dtype == CV_32F", "K == 1 && update == 0 && mask.empty()", "The combination of type=%d, dtype=%d and normType=%d is not supported", "src.type() == CV_8UC1", "void cv::findNonZero(InputArray, OutputArray)", "idx.isContinuous()", "0 < coi && coi <= 4", "CvScalar cvSum(const CvArr *)", "CvScalar cvAvg(const void *, const void *)", "void cvAvgSdv(const CvArr *, CvScalar *, CvScalar *, const void *)", "%s:%d: error: (%d) %s in function %s\n", "%s:%d: error: (%d) %s\n", "\nGeneral configuration for OpenCV 2.4.11 =====================================\n  Version control:               unknown\n\n  Platform:\n    Host:                        Darwin 14.4.0 x86_64\n    Target:                      Android 1 armv7-a\n    CMake:                       3.3.1\n    CMake generator:             Unix Makefiles\n    CMake build tool:            /usr/bin/make\n    Configuration:               Release\n\n  C/C++:\n    Built as dynamic libs?:      NO\n    C++ Compiler:                /Users/fedir.poliakov/Development/android-ndk-r10/toolchains/llvm-3.5/prebuilt/darwin-x86_64/bin/clang++  (ver 3.5)\n    C++ flags (Release):         -fexceptions -frtti -fpic -gcc-toolchain /Users/fedir.poliakov/Development/android-ndk-r10/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64 -target armv7-none-linux-androideabi -Qunused-arguments --sysroot=/Users/fedir.poliakov/Development/android-ndk-r10/platforms/android-8/arch-arm -funwind-tables -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Xclang -mnoexecstack    -fsigned-char -W -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -fomit-frame-pointer -mthumb -fomit-frame-pointer -fno-strict-aliasing -O3 -DNDEBUG  -DNDEBUG\n    C++ flags (Debug):           -fexceptions -frtti -fpic -gcc-toolchain /Users/fedir.poliakov/Development/android-ndk-r10/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64 -target armv7-none-linux-androideabi -Qunused-arguments --sysroot=/Users/fedir.poliakov/Development/android-ndk-r10/platforms/android-8/arch-arm -funwind-tables -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Xclang -mnoexecstack    -fsigned-char -W -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -fomit-frame-pointer -marm -fno-omit-frame-pointer -fno-strict-aliasing -O0 -g -DDEBUG -D_DEBUG  -O0 -DDEBUG -D_DEBUG\n    C Compiler:                  /Users/fedir.poliakov/Development/android-ndk-r10/toolchains/llvm-3.5/prebuilt/darwin-x86_64/bin/clang\n    C flags (Release):           -fexceptions -fpic -gcc-toolchain /Users/fedir.poliakov/Development/android-ndk-r10/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64 -target armv7-none-linux-androideabi -Qunused-arguments --sysroot=/Users/fedir.poliakov/Development/android-ndk-r10/platforms/android-8/arch-arm -funwind-tables -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Xclang -mnoexecstack    -fsigned-char -W -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -fomit-frame-pointer -mthumb -fomit-frame-pointer -fno-strict-aliasing -O3 -DNDEBUG  -DNDEBUG\n    C flags (Debug):             -fexceptions -fpic -gcc-toolchain /Users/fedir.poliakov/Development/android-ndk-r10/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64 -target armv7-none-linux-androideabi -Qunused-arguments --sysroot=/Users/fedir.poliakov/Development/android-ndk-r10/platforms/android-8/arch-arm -funwind-tables -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Xclang -mnoexecstack    -fsigned-char -W -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -fomit-frame-pointer -marm -fno-omit-frame-pointer -fno-strict-aliasing -O0 -g -DDEBUG -D_DEBUG  -O0 -DDEBUG -D_DEBUG\n    Linker flags (Release):      -Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,--gc-sections -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now \n    Linker flags (Debug):        -Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,--gc-sections -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now \n    Precompiled headers:         NO\n\n  OpenCV modules:\n    To be built:                 core flann imgproc highgui features2d calib3d ml video legacy objdetect photo gpu ocl nonfree contrib stitching superres ts videostab\n    Disabled:                    androidcamera world\n    Disabled by dependency:      -\n    Unavailable:                 dynamicuda java python viz\n\n  Android: \n    Android ABI:                 armeabi-v7a\n    STL type:                    c++_shared\n    Native API level:            android-8\n    SDK target:                  android_sdk_target_status-NOTFOUND\n    Android NDK:                 /Users/fedir.poliakov/Development/android-ndk-r10 (toolchain: arm-linux-androideabi-4.9)\n    android tool:                NO\n    Google Play package:         NO\n    Android examples:            NO\n\n  GUI: \n    GTK+ 2.x:                    NO\n    GThread :                    NO\n    GtkGlExt:                    NO\n    OpenGL support:              NO\n    VTK support:                 NO\n\n  Media I/O: \n    ZLib:                        z (ver 1.2.3)\n    JPEG:                        build (ver 62)\n    PNG:                         build (ver 1.5.12)\n    TIFF:                        build (ver 42 - 4.0.2)\n    JPEG 2000:                   build (ver 1.900.1)\n    OpenEXR:                     build (ver 1.7.1)\n\n  Video I/O:\n    AndroidNativeCamera:         NO (native camera requires Android API level 8 or higher)\n\n  Other third-party libraries:\n    Use IPP:                     NO\n    Use Eigen:                   NO\n    Use TBB:                     NO\n    Use OpenMP:                  NO\n    Use GCD                      NO\n    Use Concurrency              NO\n    Use C=:                      NO\n    Use Cuda:                    NO\n    Use OpenCL:                  YES\n\n  OpenCL:\n    Version:                     dynamic\n    Include path:                /Users/fedir.poliakov/Development/opencv-2.4.11/3rdparty/include/opencl/1.2\n    Use AMD FFT:                 NO\n    Use AMD BLAS:                NO\n\n  Python:\n    Interpreter:                 /usr/bin/python (ver 2.7.6)\n\n  Java:\n    ant:                         NO\n    Java tests:                  NO\n\n  Documentation:\n    Build Documentation:         NO\n    Sphinx:                      NO\n    PdfLaTeX compiler:           NO\n    Doxygen:                     NO\n\n  Tests and samples:\n    Tests:                       YES\n    Performance tests:           YES\n    C/C++ Examples:              NO\n\n  Install path:                  /Users/fedir.poliakov/Development/opencv-2.4.11/platforms/build_android_arm/install\n\n  cvconfig.h is in:              /Users/fedir.poliakov/Development/opencv-2.4.11/platforms/build_android_arm\n-----------------------------------------------------------------\n\n", "OPENCV_TEMP_PATH", "/data/local/tmp/__opencv_temp.XXXXXX", "__opencv_temp.XXXXXX", "OpenCV Error: %s (%s) in %s, file %s, line %d", "cv::error()", "No Error", "Backtrace", "Unspecified error", "Internal error", "Insufficient memory", "Bad argument", "Iterations do not converge", "Autotrace call", "Incorrect size of input array", "Null pointer", "Division by zero occured", "Image step is wrong", "Inplace operation is not supported", "Requested object was not found", "Input image depth is not supported by function", "Formats of input arguments do not match", "Sizes of input arguments do not match", "One of arguments' values is out of range", "Unsupported format or combination of formats", "Input COI is not supported", "Bad number of channels", "Bad flag (parameter or structure field)", "Bad parameter of type CvPoint", "Bad type of mask argument", "Parsing error", "The function/feature is not implemented", "Memory block has been corrupted", "Assertion failed", "No GPU support", "Gpu API call", "No OpenGL support", "OpenGL API call", "Unknown %s code %d", "status", "error", "module != 0 && module->name != 0 && module->version != 0", "int cvRegisterModule(const CvModuleInfo *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/src/system.cpp", "The module is not found", "void cvGetModuleInfo(const char *, const char **, const char **)", "%s: %s%s", "key_ >= 0", "void *cv::TLSDataContainer::getData() const", "tlsContainers_[id] == pContainer", "void cv::TLSContainerStorage::releaseKey(int, cv::TLSDataContainer *)", "void cv::makeKey()", "cxcore", "2.4.11", "MWRMNV RMVV PSTS", "MWOMOV OMSMUNUPSQ OQSQURUUSVOV", "MXVNTMRMPNOPOSPURVTVVU", "MWOMOV OMRMTNUPUSTURVOV", "MWOMOV OMUM OQSQ OVUV", "MVOMOV OMUM OQSQ", "MXVNTMRMPNOPOSPURVTVVUVR SRVR", "MWOMOV UMUV OQUQ", "PTRMRV", "NUSMSTRVPVOTOS", "MWOMOV UMOS QQUV", "MVOMOV OVUV", "LXNMNV NMRV VMRV VMVV", "MWOMOV OMUV UMUV", "MXRMPNOPOSPURVSVUUVSVPUNSMRM", "MWOMOV OMSMUNUQSROR", "MXRMPNOPOSPURVSVUUVSVPUNSMRM STVW", "MWOMOV OMSMUNUQSROR RRUV", "MWUNSMQMONOOPPTRUSUUSVQVOU", "MWRMRV NMVM", "MXOMOSPURVSVUUVSVM", "MWNMRV VMRV", "LXNMPV RMPV RMTV VMTV", "MWOMUV UMOV", "MWNMRQRV VMRQ", "MWUMOV OMUM OVUV", "MVOMOV OMUM", "MWRMNV RMVV NVVV", "MXRMPNOPOSPURVSVUUVSVPUNSMRM QQTR TQQR", "MWRMNV RMVV", "MWOMUM PQTR TQPR OVUV", "MWOMOV UMUV OMUM", "MWOMRQOV OMUM OVUV", "MWNONNOMPMQNRPRV VOVNUMTMSNRP", "LXRMRV PONPNSPTTTVSVPTOPO", "LXRMRV NOOPOSQTSTUSUPVO", "MXOVQVOROPPNRMSMUNVPVRTVVV", "MWSMMV SMUV OSTS", "MWQMNV QMTMVNVPSQPQ SQURUTTURVNV", "LXVPUNTMRMPNOONQNSOUPVRVTUUT", "MXQMNV QMUMVOVQUTTURVNV", "MVQMNV QMVM PQSQ NVSV", "MVQMNV QMVM PQSQ", "LXVPUNTMRMPNOONQNSOUPVRVTUUSRS", "MXQMNV WMTV PQUQ", "PUTMQV", "OVUMSSRUQVPVOUOT", "MVQMNV VMOS RQTV", "NVRMOV OVTV", "LYPMMV PMQV XMQV XMUV", "MXQMNV QMTV WMTV", "LXRMPNOONQNSOUPVRVTUUTVRVPUNTMRM", "MWQMNV QMUMVNVPUQSRPR", "LXRMPNOONQNSOUPVRVTUUTVRVPUNTMRM QVPUPTQSRSSTTVUWVW", "MWQMNV QMUMVNVPUQSRPR QRRUSVTVUU", "MWVNTMRMPNPPQQTRUSUUSVPVNU", "MVSMPV PMVM", "LXPMNSNUOVRVTUUSWM", "MWOMQV WMQV", "KXNMNV SMNV SMSV XMSV", "NWQMTV WMNV", "NWQMSQQV WMSQ", "MWQMWMNVTV", "LXNMRV VMRV NMVM", "MWNLVX", "LXRONU ROVU", "MWNVVV", "PVRMUQ", "MWMMOKQKTMVMWK", "NWQPTPUQUV URQSPTPUQVSVUU", "MWOMOV OSPURVTUUSTQRPPQOS", "MWUQSPRPPQOSPURVSVUU", "MWUMUV USTQRPPQOSPURVTUUS", "MWOSUSTQRPPQOSPURVTV", "NVUNTMSMRNRV PPTP", "MWUPUVTXRYPY USTQRPPQOSPURVTUUS", "MWOMOV OSPQRPTQUSUV", "PTRLQMRNSMRL RPRV", "PUSLRMSNTMSL SPSXRYQYPX", "NWPMPV UPPT RSUV", "KYMPMV MSNQOPPPQQRSRV RSSQTPUPVQWSWV", "MWOPOV OSPQRPTQUSUV", "MWRPPQOSPURVTUUSTQRP", "MWOPOY OSPURVTUUSTQRPPQOS", "MWUPUY USTQRPPQOSPURVTUUS", "NVPPPV PSQQSPTP", "NWUQTPQPPQPRQSTSUTUUTVQVPU", "NVRMRUSVTVUU PPTP", "MWUPUV OPOSPURVTUUS", "NVOPRV UPRV", "LXNPPV RPPV RPTV VPTV", "MWOPUV UPOV", "MWOPRV UPRVQXPYOY", "MWOPUPOVUV", "MXVPUSTURVPUOSPQRPTQUUVV", "MWOTQVSVTUTSSRPQRQTPUOUNTMRMQNPPOTNY", "MXNQOPQPRQRSQW VPURSTQWPY", "MWTNSMRMQNQORPTQUSTURVPUOSPQRP", "NWUQSPQPPQPRQS SSQSPTPUQVSVUU", "NWTMSNSOTP UPSPQQPSPUQVSWSXRYQY", "LXNQOPPPQQQSPV QSRQTPUPVQVSUVTY", "LXNQOPPPQQQURVSVTUUSVPVNUMTMSNSPTRUSWT", "OVRPQSQURVSVTU", "MWQPOV UPTPRQPS PSQUSVTV", "MWOMPMQNRPUV RPOV", "LYPPMY UPTSSUQVPVOUOS TSTUUVVVWU", "MWNPOPOV UPTSRUOV", "NWTMSNSOTP UPSPQQQRRSTS SSQTPUPVQWSXSYRZQZ", "MXOQQPVP QPQRPV TPTRUV", "MWOSPURVTUUSTQRPPQOSNY", "MXVPRPPQOSPURVTUUSTQRP", "MXOQQPVP SPRV", "KXMQNPOPPQPUQVSVTUUSVP", "MXPPOQOSPURVSVUUVSVQUPTPSQRSQY", "MWOPPPQQSXTYUY UPTRPWOY", "KYTMRY MQNPOPPQPUQVTVUUVSWP", "LXOPNRNTOVQVRTRR UPVRVTUVSVRT", "LWTSSQQPOQNSOUQVSUTS UPTSTUUVVV", "MWQMOSPURVTUUSTQRPPQOS", "MWUQSPRPPQOSPURVTV", "LWTSSQQPOQNSOUQVSUTS VMTSTUUVVV", "MWOSTSURUQSPRPPQOSPURVTV", "OVVMUMTNSPQVPXOYNY QPUP", "MXUSTQRPPQOSPURVTUUS VPTVSXRYPYOX", "MVQMNV OSPQQPSPTQTRSTSUTVUV", "PUSMSNTNTMSM QPRPSQSRRTRUSVTV", "OUSMSNTNTMSM QPRPSQSRRVQXPYOYNX", "NVRMOV UPTPRQPS PSQUSVTV", "OTSMQSQURVSV", "JYKPLPMQMSLV MSNQOPQPRQRSQV RSSQTPVPWQWRVTVUWVXV", "MWNPOPPQPSOV PSQQRPTPUQURTTTUUVVV", "MXNPOPPQPSNY PSQUSVUUVSUQSPQQPS", "MXUSTQRPPQOSPURVTUUS VPSY", "MVOPPPQQQSPV UQTPSPRQQS", "NVTQSPQPPQPRQSRSSTSURVPVOU", "NUSMQSQURVSV PPTP", "MWNPOPPQPROTOUPVRVSUTS UPTSTUUVVV", "MWNPOPPQPROTOUPVRVTUURUP", "KYLPMPNQNRMTMUNVPVQURSSP RSRUSVUVVUWRWP", "MWOQPPQPRQRUSVTVUU VQUPTPSQQUPVOVNU", "MWNPOPPQPROTOUPVRVSUTS UPSVRXQYOYNX", "NVUPOV PQQPSPTQ PUQVSVTU", "MWUSTQRPPQOSPURVTUUSUPTNRMQM", "MWUQSPRPPQOSPURVSVUU OSSS", "MWRMQNPPOSOVPWRWSVTTUQUNTMRM PRTR", "MWTMQY RPPQOSPURVSVUUVSUQSPRP", "MWUQSPQPOQOSPTRUSVSWRXQX", "KYTPTSUTVTWSWQVOUNSMQMONNOMQMSNUOVQWSWUV TQSPQPPQPSQTSTTS", "MWUNORUV", "MWONUROV", "OUTKQKQYTY", "OUPKSKSYPY", "OUTKSLRNROSQQRSSRURVSXTY", "OUPKQLRNROQQSRQSRURVQXPY", "LYPMQNQOPPOPNONNOMPMSNUNWMNV USTTTUUVVVWUWTVSUS", "MWRMPNOPOSPURVTUUSUPTNRM", "MWPORMRV", "MWONQMSMUNUPTROVUV", "MWONQMSMUNUPSQ RQSQURUUSVQVOU", "MWSMSV SMNSVS", "MWPMOQQPRPTQUSTURVQVOU PMTM", "MWTMRMPNOPOSPURVTUUSTQRPPQOS", "MWUMQV OMUM", "MWQMONOPQQSQUPUNSMQM QQOROUQVSVUUURSQ", "MWUPTRRSPROPPNRMTNUPUSTURVPV", "PURURVSVSURU", "PUSVRVRUSUSWRY", "PURPRQSQSPRP RURVSVSURU", "PURPRQSQSPRP SVRVRUSUSWRY", "PURMRR SMSR RURVSVSURU", "NWPNRMSMUNUPRQRRSRSQUP RURVSVSURU", "PTRMRQ", "NVPMPQ TMTQ", "NVQMPNPPQQSQTPTNSMQM", "MWRKRX UNSMQMONOPQQTRUSUUSVQVOU", "MWVLNX", "OUTKRNQQQSRVTY", "OUPKRNSQSSRVPY", "PTRKRY", "LXNRVR", "LXRNRV NRVR", "LXNPVP NTVT", "MWOOUU UOOU", "MWRORU OPUT UPOT", "PURQRRSRSQRQ", "PUSMRORQSQSPRP", "PUSNRNRMSMSORQ", "LXSOVRSU NRVR", "MXQLQY TLTY OQVQ OTVT", "LXVRURTSSURVOVNUNSORRQSPSNRMPMONOPQSSUUVVV", "LXNNOQOSNV VNUQUSVV NNQOSOVN NVQUSUVV", "LYRQQPOPNQNSOTQTRSSQTPVPWQWSVTTTSSRQ", "H\\NRMQLRMSNR VRWQXRWSVR", "H\\MPLQLRMSNSOROQNPMP MQMRNRNQMQ WPVQVRWSXSYRYQXPWP WQWRXRXQWQ", "I[KRYR", "H\\RUJPRTZPRU", "F^ISJQLPNPPQTTVUXUZT[Q ISJPLONOPPTSVTXTZS[Q IYJWLVNVPWTZV[X[ZZ[W IYJVLUNUPVTYVZXZZY[W", "F^ISJQLPNPPQTTVUXUZT[Q ISJPLONOPPTSVTXTZS[Q IW[W I[[[", "CaGO]OXI L[GU]U", "D`F^^^^FFFF^", "KYQVOUNSNQOOQNSNUOVQVSUUSVQV SVVS QVVQ OUUO NSSN NQQN", "H\\IR[R", "H\\IR[R IQ[Q", "LYPFSCSP RDRP OPVP MRXR OVOWNWNVOUQTTTVUWWVYTZQ[O\\N^Na TTUUVWUYTZ N`O_P_S`V`W_ P_SaVaW_W^", "LYPFSCSP RDRP OPVP MRXR OVOWNWNVOUQTTTVUWWVYTZ TTUUVWUYTZ RZTZV[W]W^V`TaQaO`N_N^O^O_ TZU[V]V^U`Ta", "LYPFSCSP RDRP OPVP MRXR VVVWWWWVVUTTRTPUOVNYN^O`QaTaV`W^W\\VZTYQYN[ RTPVOYO^P`Qa TaU`V^V\\UZTY", "LYPFSCSP RDRP OPVP MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYOEOFNFNEODQCTCVDWFVHTIQJOKNMNP TCUDVFUHTI NOONPNSOVOWN PNSPVPWNWM MRXR OVOWNWNVOUQTTTVUWWVYTZ TTUUVWUYTZ RZTZV[W]W^V`TaQaO`N_N^O^O_ TZU[V]V^U`Ta", "LYOEOFNFNEODQCTCVDWFVHTI TCUDVFUHTI RITIVJWLWMVOTPQPOONNNMOMON TIUJVLVMUOTP MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYOCNI OCVC ODSDVC NIOHQGTGVHWJWMVOTPQPOONNNMOMON TGUHVJVMUOTP MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYNCNG VERLPP WCTIQP NEPCRCUE NEPDRDUEVE MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYOCNI OCVC ODSDVC NIOHQGTGVHWJWMVOTPQPOONNNMOMON TGUHVJVMUOTP MRXR VVVWWWWVVUTTRTPUOVNYN^O`QaTaV`W^W\\VZTYQYN[ RTPVOYO^P`Qa TaU`V^V\\UZTY", "LYPFSCSP RDRP OPVP MRXR SVSa TTTa TTM]X] QaVa", "LYOEOFNFNEODQCTCVDWFVHTI TCUDVFUHTI RITIVJWLWMVOTPQPOONNNMOMON TIUJVLVMUOTP MRXR SVSa TTTa TTM]X] QaVa", "F^YXWZU[R[PZMXKWIWHXHZI[K[MZOWPURQTKWGYFZF[G\\H[IZH[G[FZFYFWGVHTLRPPVNZMZ OPUP", "E^P[MZJXHUGRGOHLJIMGPFTFWGYI[L\\O\\R[UYXVZS[P[ NJNW OJOW LJSJVKWMWNVPSQOQ SJUKVMVNUPSQ LWQW SQTRUVVWWWXV SQURVVWW", "E^P[MZJXHUGRGOHLJIMGPFTFWGYI[L\\O\\R[UYXVZS[P[ UKVJVNUKSJPJNKMLLOLRMUNVPWSWUVVT PJNLMOMRNUPW", "E_IM[M IR[R IW[W K[YI", "CaHQGRHSIRHQ RQQRRSSRRQ \\Q[R\\S]R\\Q", "E_NWLTIRLPNM LPJRLT JRZR VWXT[RXPVM XPZRXT", "JZWNTLRIPLMN PLRJTL RJRZ WVTXR[PXMV PXRZTX", "F^ZJSJOKMLKNJQJSKVMXOYSZZZ SFS^", "F^JJQJUKWLYNZQZSYVWXUYQZJZ QFQ^", "F^JJQJUKWLYNZQZSYVWXUYQZJZ ORZR", "H\\LBL[ RBR[ XBX[", "I[RFJ[ RFZ[ MTWT", "G\\KFK[ KFTFWGXHYJYLXNWOTP KPTPWQXRYTYWXYWZT[K[", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZV", "G\\KFK[ KFRFUGWIXKYNYSXVWXUZR[K[", "H[LFL[ LFYF LPTP L[Y[", "HZLFL[ LFYF LPTP", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZVZS USZS", "G]KFK[ YFY[ KPYP", "NVRFR[", "JZVFVVUYTZR[P[NZMYLVLT", "G\\KFK[ YFKT POY[", "HYLFL[ L[X[", "F^JFJ[ JFR[ ZFR[ ZFZ[", "G]KFK[ KFY[ YFY[", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF", "G\\KFK[ KFTFWGXHYJYMXOWPTQKQ", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF SWY]", "G\\KFK[ KFTFWGXHYJYLXNWOTPKP RPY[", "H\\YIWGTFPFMGKIKKLMMNOOUQWRXSYUYXWZT[P[MZKX", "JZRFR[ KFYF", "G]KFKULXNZQ[S[VZXXYUYF", "I[JFR[ ZFR[", "F^HFM[ RFM[ RFW[ \\FW[", "H\\KFY[ YFK[", "I[JFRPR[ ZFRP", "H\\YFK[ KFYF K[Y[", "HYLFL[ LFXF", "I[RFJ[ RFZ[ J[Z[", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF OPUP", "I[RFJ[ RFZ[", "I[KFYF OPUP K[Y[", "G]KFK[ YFY[ KFYF", "I[KFRPK[ KFYF K[Y[", "I[KKKILGMFOFPGQIRMR[ YKYIXGWFUFTGSIRM", "H\\RFR[ PKMLLMKOKRLTMUPVTVWUXTYRYOXMWLTKPK", "H\\KFY[ K[YF", "G]RFR[ ILJLKMLQMSNTQUSUVTWSXQYMZL[L", "H\\K[O[LTKPKLLINGQFSFVGXIYLYPXTU[Y[", "G[G[IZLWOSSLVFV[UXSUQSNQLQKRKTLVNXQZT[Y[", "F]SHTITLSPRSQUOXMZK[J[IZIWJRKOLMNJPHRGUFXFZG[I[KZMYNWOTP SPTPWQXRYTYWXYWZU[R[PZOX", "H\\TLTMUNWNYMZKZIYGWFTFQGOIMLLNKRKVLYMZO[Q[TZVXWV", "G^TFRGQIPMOSNVMXKZI[G[FZFXGWIWKXMZP[S[VZXXZT[O[KZHYGWFTFRHRJSMUPWRZT\\U", "H\\VJVKWLYLZKZIYGVFRFOGNINLONPOSPPPMQLRKTKWLYMZP[S[VZXXYV", "H\\RLPLNKMINGQFTFXG[G]F XGVNTTRXPZN[L[JZIXIVJULUNV QPZP", "G^G[IZMVPQQNRJRGQFPFOGNINLONQOUOXNYMZKZQYVXXVZS[O[LZJXIVIT", "F^MMKLJJJIKGMFNFPGQIQKPONULYJ[H[GZGX MRVOXN[L]J^H^G]F\\FZHXLVRUWUZV[W[YZZY\\V", "IZWVUTSQROQLQIRGSFUFVGWIWLVQTVSXQZO[M[KZJXJVKUMUOV", "JYT^R[PVOPOJPGRFTFUGVJVMURR[PaOdNfLgKfKdLaN^P\\SZWX", "F^MMKLJJJIKGMFNFPGQIQKPONULYJ[H[GZGX ^I^G]F\\FZGXIVLTNROPO ROSQSXTZU[V[XZYY[V", "I\\MRORSQVOXMYKYHXFVFUGTISNRSQVPXNZL[J[IZIXJWLWNXQZT[V[YZ[X", "@aEMCLBJBICGEFFFHGIIIKHPGTE[ GTJLLHMGOFPFRGSISKRPQTO[ QTTLVHWGYFZF\\G]I]K\\PZWZZ[[\\[^Z_YaV", "E]JMHLGJGIHGJFKFMGNINKMPLTJ[ LTOLQHRGTFVFXGYIYKXPVWVZW[X[ZZ[Y]V", "H]TFQGOIMLLNKRKVLYMZO[Q[TZVXXUYSZOZKYHXGVFTFRHRKSNUQWSZU\\V", "F_SHTITLSPRSQUOXMZK[J[IZIWJRKOLMNJPHRGUFZF\\G]H^J^M]O\\PZQWQUPTO", "H^ULTNSOQPOPNNNLOIQGTFWFYGZIZMYPWSSWPYNZK[I[HZHXIWKWMXPZS[V[YZ[X", "F_SHTITLSPRSQUOXMZK[J[IZIWJRKOLMNJPHRGUFYF[G\\H]J]M\\O[PYQVQSPTQUSUXVZX[ZZ[Y]V", "H\\H[JZLXOTQQSMTJTGSFRFQGPIPKQMSOVQXSYUYWXYWZT[P[MZKXJVJT", "H[RLPLNKMINGQFTFXG[G]F XGVNTTRXPZN[L[JZIXIVJULUNV", "E]JMHLGJGIHGJFKFMGNINKMOLRKVKXLZN[P[RZSYUUXMZF XMWQVWVZW[X[ZZ[Y]V", "F]KMILHJHIIGKFLFNGOIOKNOMRLVLYM[O[QZTWVTXPYMZIZGYFXFWGVIVKWNYP[Q", "C_HMFLEJEIFGHFIFKGLILLK[ UFK[ UFS[ aF_G\\JYNVTS[", "F^NLLLKKKILGNFPFRGSISLQUQXRZT[V[XZYXYVXUVU ]I]G\\FZFXGVITLPUNXLZJ[H[GZGX", "F]KMILHJHIIGKFLFNGOIOKNOMRLVLXMZN[P[RZTXVUWSYM [FYMVWT]RbPfNgMfMdNaP^S[VY[V", "H]ULTNSOQPOPNNNLOIQGTFWFYGZIZMYPWTTWPZN[K[JZJXKWNWPXQYR[R^QaPcNfLgKfKdLaN^Q[TYZV", "I[JFR[ ZFR[ JFZF", "G]IL[b", "E_RJIZ RJ[Z", "I[J[Z[", "I[J[Z[ZZJZJ[", "I\\XMX[ XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "H[LFL[ LPNNPMSMUNWPXSXUWXUZS[P[NZLX", "I[XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "I\\XFX[ XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "I[LSXSXQWOVNTMQMONMPLSLUMXOZQ[T[VZXX", "MYWFUFSGRJR[ OMVM", "I\\XMX]W`VaTbQbOa XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "I\\MFM[ MQPNRMUMWNXQX[", "NVQFRGSFREQF RMR[", "MWRFSGTFSERF SMS^RaPbNb", "IZMFM[ WMMW QSX[", "CaGMG[ GQJNLMOMQNRQR[ RQUNWMZM\\N]Q][", "I\\MMM[ MQPNRMUMWNXQX[", "I\\QMONMPLSLUMXOZQ[T[VZXXYUYSXPVNTMQM", "H[LMLb LPNNPMSMUNWPXSXUWXUZS[P[NZLX", "I\\XMXb XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "KXOMO[ OSPPRNTMWM", "J[XPWNTMQMNNMPNRPSUTWUXWXXWZT[Q[NZMX", "MYRFRWSZU[W[ OMVM", "I\\MMMWNZP[S[UZXW XMX[", "JZLMR[ XMR[", "G]JMN[ RMN[ RMV[ ZMV[", "J[MMX[ XMM[", "JZLMR[ XMR[P_NaLbKb", "J[XMM[ MMXM M[X[", "H]QMONMPLRKUKXLZN[P[RZUWWTYPZM QMSMTNUPWXXZY[Z[", "I\\UFSGQIOMNPMTLZKb UFWFYHYKXMWNUORO ROTPVRWTWWVYUZS[Q[OZNYMV", "I\\JPLNNMOMQNROSRSVR[ ZMYPXRR[P_Ob", "I[TMQMONMPLSLVMYNZP[R[TZVXWUWRVOTMRKQIQGRFTFVGXI", "JZWOVNTMQMONOPPRSS SSOTMVMXNZP[S[UZWX", "JYTFRGQHQIRJUKXK XKTMQONRMUMWNYP[S]T_TaSbQbP`", "H\\IQJOLMNMONOPNTL[ NTPPRNTMVMXOXRWWTb", "G\\HQIOKMMMNNNPMUMXNZO[Q[SZUWVUWRXMXJWGUFSFRHRJSMUPWRZT", "LWRMPTOXOZP[R[TYUW", "I[OMK[ YNXMWMUNQROSNS NSPTQUSZT[U[VZ", "JZKFMFOGPHX[ RML[", "H]OMIb NQMVMYO[Q[SZUXWT YMWTVXVZW[Y[[Y\\W", "I[LMOMNSMXL[ YMXPWRUURXOZL[", "JZTFRGQHQIRJUKXK UKRLPMOOOQQSTTVT TTPUNVMXMZO\\S^T_TaRbPb", "J[RMPNNPMSMVNYOZQ[S[UZWXXUXRWOVNTMRM", "G]PML[ UMVSWXX[ IPKNNM[M", "I[MSMVNYOZQ[S[UZWXXUXRWOVNTMRMPNNPMSIb", "I][MQMONMPLSLVMYNZP[R[TZVXWUWRVOUNSM", "H\\SMP[ JPLNOMZM", "H\\IQJOLMNMONOPMVMYO[Q[TZVXXTYPYM", "G]ONMOKQJTJWKYLZN[Q[TZWXYUZRZOXMVMTORSPXMb", "I[KMMMOOU`WbYb ZMYOWRM]K`Jb", "F]VFNb GQHOJMLMMNMPLULXMZO[Q[TZVXXUZP[M", "F]NMLNJQITIWJZK[M[OZQW RSQWRZS[U[WZYWZTZQYNXM", "L\\UUTSRRPRNSMTLVLXMZO[Q[SZTXVRUWUZV[W[YZZY\\V", "M[MVOSRNSLTITGSFQGPIOMNTNZO[P[RZTXUUURVVWWYW[V", "MXTTTSSRQROSNTMVMXNZP[S[VYXV", "L\\UUTSRRPRNSMTLVLXMZO[Q[SZTXZF VRUWUZV[W[YZZY\\V", "NXOYQXRWSUSSRRQROSNUNXOZQ[S[UZVYXV", "OWOVSQUNVLWIWGVFTGSIQQNZKaJdJfKgMfNcOZP[R[TZUYWV", "L[UUTSRRPRNSMTLVLXMZO[Q[SZTY VRTYPdOfMgLfLdMaP^S\\U[XY[V", "M\\MVOSRNSLTITGSFQGPIOMNSM[ M[NXOVQSSRURVSVUUXUZV[W[YZZY\\V", "PWSMSNTNTMSM PVRRPXPZQ[R[TZUYWV", "PWSMSNTNTMSM PVRRLdKfIgHfHdIaL^O\\Q[TYWV", "M[MVOSRNSLTITGSFQGPIOMNSM[ M[NXOVQSSRURVSVUTVQV QVSWTZU[V[XZYY[V", "OWOVQSTNULVIVGUFSGRIQMPTPZQ[R[TZUYWV", "E^EVGSIRJSJTIXH[ IXJVLSNRPRQSQTPXO[ PXQVSSURWRXSXUWXWZX[Y[[Z\\Y^V", "J\\JVLSNROSOTNXM[ NXOVQSSRURVSVUUXUZV[W[YZZY\\V", "LZRRPRNSMTLVLXMZO[Q[SZTYUWUUTSRRQSQURWTXWXYWZV", "KZKVMSNQMUGg MUNSPRRRTSUUUWTYSZQ[ MZO[R[UZWYZV", "L[UUTSRRPRNSMTLVLXMZO[Q[SZ VRUUSZPaOdOfPgRfScS\\U[XY[V", "MZMVOSPQPSSSTTTVSYSZT[U[WZXYZV", "NYNVPSQQQSSVTXTZR[ NZP[T[VZWYYV", "OXOVQSSO VFPXPZQ[S[UZVYXV PNWN", "L[LVNRLXLZM[O[QZSXUU VRTXTZU[V[XZYY[V", "L[LVNRMWMZN[O[RZTXUUUR URVVWWYW[V", "I^LRJTIWIYJ[L[NZPX RRPXPZQ[S[UZWXXUXR XRYVZW\\W^V", "JZJVLSNRPRQSQZR[U[XYZV WSVRTRSSOZN[L[KZ", "L[LVNRLXLZM[O[QZSXUU VRPdOfMgLfLdMaP^S\\U[XY[V", "LZLVNSPRRRTTTVSXQZN[P\\Q^QaPdOfMgLfLdMaP^S\\WYZV", "J\\K[NZQXSVUSWOXKXIWGUFSGRHQJPOPTQXRZT[V[XZYY", "I[WUWRVOUNSMQMONMPLSLVMYNZP[R[TZVXWUXPXKWHVGTFRFPGNI", "JZWNUMRMPNNPMSMVNYOZQ[T[VZ MTUT", "J[TFRGPJOLNOMTMXNZO[Q[SZUWVUWRXMXIWGVFTF NPWP", "H\\VFNb QMNNLPKSKVLXNZQ[S[VZXXYUYRXPVNSMQM", "I[XOWNTMQMNNMOLQLSMUOWSZT\\T^S_Q_", "DaWNVLTKQKOLNMMOMRNTOUQVTVVUWS WKWSXUYV[V\\U]S]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYY", "F^ZIJRZ[", "F^JIZRJ[", "KYOBOb OBVB ObVb", "KYUBUb NBUB NbUb", "KYTBQEPHPJQMSOSPORSTSUQWPZP\\Q_Tb", "KYPBSETHTJSMQOQPURQTQUSWTZT\\S_Pb", "F^[FYGVHSHPGNFLFJGIIIKKMMMOLPJPHNF [FI[ YTWTUUTWTYV[X[ZZ[X[VYT", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF", "H\\NJPISFS[", "H\\LKLJMHNGPFTFVGWHXJXLWNUQK[Y[", "H\\MFXFRNUNWOXPYSYUXXVZS[P[MZLYKW", "H\\UFKTZT UFU[", "H\\WFMFLOMNPMSMVNXPYSYUXXVZS[P[MZLYKW", "H\\XIWGTFRFOGMJLOLTMXOZR[S[VZXXYUYTXQVOSNRNOOMQLT", "H\\YFO[ KFYF", "H\\PFMGLILKMMONSOVPXRYTYWXYWZT[P[MZLYKWKTLRNPQOUNWMXKXIWGTFPF", "H\\XMWPURRSQSNRLPKMKLLINGQFRFUGWIXMXRWWUZR[P[MZLX", "MWRYQZR[SZRY", "MWSZR[QZRYSZS\\R^Q_", "MWRMQNROSNRM RYQZR[SZRY", "MWRMQNROSNRM SZR[QZRYSZS\\R^Q_", "MWRFRT RYQZR[SZRY", "I[LKLJMHNGPFTFVGWHXJXLWNVORQRT RYQZR[SZRY", "NVRFRM", "JZNFNM VFVM", "KYQFOGNINKOMQNSNUMVKVIUGSFQF", "H\\PBP_ TBT_ YIWGTFPFMGKIKKLMMNOOUQWRXSYUYXWZT[P[MZKX", "G][BIb", "KYVBTDRGPKOPOTPYR]T`Vb", "KYNBPDRGTKUPUTTYR]P`Nb", "NVRBRb", "E_IR[R", "E_RIR[ IR[R", "E_IO[O IU[U", "G]KKYY YKKY", "JZRLRX MOWU WOMU", "MWRQQRRSSRRQ", "MWSFRGQIQKRLSKRJ", "MWRHQGRFSGSIRKQL", "E_UMXP[RXTUW IR[R", "G]OFOb UFUb JQZQ JWZW", "E_\\O\\N[MZMYNXPVUTXRZP[L[JZIYHWHUISJRQNRMSKSIRGPFNGMIMKNNPQUXWZY[[[\\Z\\Y", "G]IIJKKOKUJYI[ [IZKYOYUZY[[ IIKJOKUKYJ[I I[KZOYUYYZ[[", "F_\\Q[OYNWNUOTPQTPUNVLVJUISIQJOLNNNPOQPTTUUWVYV[U\\S\\Q", "KYOBO[ UBU[", "F^RBR[ I[[[", "F^[BI[[[", "E_RIQJRKSJRI IYHZI[JZIY [YZZ[[\\Z[Y", "F^RHNLKPJSJUKWMXOXQWRU RHVLYPZSZUYWWXUXSWRU RUQYP\\ RUSYT\\ P\\T\\", "F^RNQKPINHMHKIJKJOKRLTNWR\\ RNSKTIVHWHYIZKZOYRXTVWR\\", "F^RGPJLOIR RGTJXO[R IRLUPZR] [RXUTZR]", "F^RTTWVXXXZW[U[SZQXPVPSQ SQUOVMVKUISHQHOINKNMOOQQ QQNPLPJQISIUJWLXNXPWRT RTQYP\\ RTSYT\\ P\\T\\", "F^RRR[Q\\ RVQ\\ RIQHOHNINKONRR RISHUHVIVKUNRR RRNOLNJNIOIQJR RRVOXNZN[O[QZR RRNULVJVIUISJR RRVUXVZV[U[SZR", "F^ISJSLTMVMXLZ ISIRJQLQMRNTNWMYLZ RGPIOLOOQUQXPZR\\ RGTIULUOSUSXTZR\\ [S[RZQXQWRVTVWWYXZ [SZSXTWVWXXZ KVYV", "PSSRRSQSPRPQQPRPSQSSRUQV QQQRRRRQQQ", "PTQPPQPSQTSTTSTQSPQP RQQRRSSRRQ", "NVPOTU TOPU NRVR", "MWRKQMOPMR RKSMUPWR RMOQ RMUQ ROPQ ROTQ QQSQ MRWR", "MWMRMQNOONQMSMUNVOWQWR PNTN OOUO NPVP NQVQ MRWR", "LRLFLRRRLF LIPQ LLOR LOMQ", "MWRKQMOPMR RKSMUPWR", "MWWRWQVOUNSMQMONNOMQMR", "G]]R]P\\MZJWHTGPGMHJJHMGPGR", "MWMRMSNUOVQWSWUVVUWSWR", "LXLPNRQSSSVRXP", "RURUTTURTPRO", "RVRRUPVNVLUKTK", "NRRROPNNNLOKPK", "MWWHVGTFQFOGNHMJMLNNOOUSVTWVWXVZU[S\\P\\N[MZ", "G]IWHVGTGQHOINKMMMONPOTUUVWWYW[V\\U]S]P\\N[M", "G]RRTUUVWWYW[V\\U]S]Q\\O[NYMWMUNTOPUOVMWKWIVHUGSGQHOINKMMMONPORR", "H\\KFK[ HF[FQP[Z ZV[Y\\[ ZVZY WYZY WYZZ\\[", "KYUARBPCNELHKLKRLUNWQXSXVWXUYR KPLMNKQJSJVKXMYPYVXZV]T_R`Oa", ">f>RfR", "D`D``D", "RRR>Rf", "D`DD``", "D`DR`R", "F^FY^K", "KYK^YF", "KYKFY^", "F^FK^Y", "KYKRYR", "MWMWWM", "MWMMWW", "D`DOGQKSPTTTYS]Q`O", "PUUDSGQKPPPTQYS]U`", "OTODQGSKTPTTSYQ]O`", "D`DUGSKQPPTPYQ]S`U", "KYRJYNKVRZ", "JZJRNKVYZR", "KYKVKNYVYN", "JZLXJPZTXL", "JZJ]L]O\\Q[TXUVVSVOULTJSIQIPJOLNONSOVPXS[U\\X]Z]", "I]]Z]X\\U[SXPVOSNONLOJPIQISJTLUOVSVVUXT[Q\\O]L]J", "JZZGXGUHSIPLONNQNUOXPZQ[S[TZUXVUVQUNTLQIOHLGJG", "G[GJGLHOIQLTNUQVUVXUZT[S[QZPXOUNQNNOLPISHUGXGZ", "E[EPFRHTJUMVQVUUXSZP[NZLWLSMQNNPLSKVKYL\\M^", "EYETHVKWPWSVVTXQYNYLXKVKSLPNNQMTMYN\\P_", "OUQOOQOSQUSUUSUQSOQO QPPQPSQTSTTSTQSPQP RQQRRSSRRQ", "D`DRJR ORUR ZR`R", "D`DUDO`O`U", "JZRDJR RDZR", "D`DR`R JYZY P`T`", "D`DR`R DRRb `RRb", "KYQKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK", "LXLLLXXXXLLL", "KYRJKVYVRJ", "LXRHLRR\\XRRH", "JZRIPOJOOSMYRUWYUSZOTORI", "KYRKRY KRYR", "MWMMWW WMMW", "MWRLRX MOWU WOMU", "NVQNOONQNSOUQVSVUUVSVQUOSNQN OQOS PPPT QOQU RORU SOSU TPTT UQUS", "NVNNNVVVVNNN OOOU POPU QOQU RORU SOSU TOTU UOUU", "MWRLMUWURL ROOT ROUT RRQT RRST", "LULRUWUMLR ORTU ORTO RRTS RRTQ", "MWRXWOMORX RUUP RUOP RRSP RRQP", "OXXROMOWXR URPO URPU RRPQ RRPS", "LXRLNWXPLPVWRL RRRL RRLP RRNW RRVW RRXP", "MWRLRX OOUO MUOWQXSXUWWU", "LXRLRX LQMOWOXQ PWTW", "KYMNWX WNMX OLLOKQ ULXOYQ", "I[NII[ VI[[ MM[[ WMI[ NIVI MMWM", "I[RGRV MJWP WJMP IVL\\ [VX\\ IV[V L\\X\\", "G[MJSV KPSL G\\[\\[RG\\", "LXPLPPLPLTPTPXTXTTXTXPTPTLPL", "KYYPXNVLSKQKNLLNKQKSLVNXQYSYVXXVYT YPWNUMSMQNPOOQOSPUQVSWUWWVYT", "KYRJKVYVRJ RZYNKNRZ", "G]PIPGQFSFTGTI GZHXJVKTLPLKMJOIUIWJXKXPYTZV\\X]Z GZ]Z QZP[Q\\S\\T[SZ", "JZRMRS RSQ\\ RSS\\ Q\\S\\ RMQJPHNG QJNG RMSJTHVG SJVG RMNKLKJM PLLLJM RMVKXKZM TLXLZM RMPNOOOR RMPOOR RMTNUOUR RMTOUR", "JZRIRK RNRP RSRU RYQ\\ RYS\\ Q\\S\\ RGQIPJ RGSITJ PJRITJ RKPNNOMN RKTNVOWN NOPORNTOVO RPPSNTLTKRKSLT RPTSVTXTYRYSXT NTPTRSTTVT RUPXOYMZLZKYJWJYLZ RUTXUYWZXZYYZWZYXZ MZOZRYUZWZ", "JZRYQ\\ RYS\\ Q\\S\\ RYUZXZZXZUYTWTYRZOYMWLUMVJUHSGQGOHNJOMMLKMJOKRMTKTJUJXLZOZRY", "JZRYQ\\ RYS\\ Q\\S\\ RYVXVVXUXRZQZLYIXHVHTGPGNHLHKIJLJQLRLUNVNXRY", "I[IPKR LKNP RGRO XKVP [PYR", "QSRQQRRSSRRQ", "PTQPPQPSQTSTTSTQSPQP", "NVQNOONQNSOUQVSVUUVSVQUOSNQN", "MWQMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM", "G]PGMHJJHMGPGTHWJZM\\P]T]W\\ZZ\\W]T]P\\MZJWHTGPG", "AcPALBJCGEEGCJBLAPATBXCZE]G_JaLbPcTcXbZa]__]aZbXcTcPbLaJ_G]EZCXBTAPA", "<hP<K=G?DAAD?G=K<P<T=Y?]A`DcGeKgPhThYg]e`cc`e]gYhThPgKeGcD`A]?Y=T<P<", "){O)I*E+@-;073370;-@+E*I)O)U*[+_-d0i3m7q;t@wEyIzO{U{[z_ydwitmqqmtiwdy_z[{U{OzIyEw@t;q7m3i0d-_+[*U)O)", ">fRAPCMDJDGCEA>H@JAMAZB]D_G`M`PaRc RATCWDZD]C_AfHdJcMcZb]`_]`W`TaRc", "AcRAPCMDJDGCEABGAKAPBTDXG\\L`Rc RATCWDZD]C_AbGcKcPbT`X]\\X`Rc BHbH", "H[WPVQWRXQXPVNTMQMNNLPKSKULXNZQ[S[VZXX QMONMPLSLUMXOZQ[ LbXF", "KYRKMX RNVX RKWX OTTT KXPX TXYX", "JZNKNX OKOX LKSKVLWNVPSQ SKULVNUPSQ OQSQVRWTWUVWSXLX SQURVTVUUWSX", "KYVLWKWOVLTKQKOLNMMPMSNVOWQXTXVWWU QKOMNPNSOVQX", "JZNKNX OKOX LKSKVLWMXPXSWVVWSXLX SKULVMWPWSVVUWSX", "JYNKNX OKOX SOSS LKVKVOUK OQSQ LXVXVTUX", "JXNKNX OKOX SOSS LKVKVOUK OQSQ LXQX", "K[VLWKWOVLTKQKOLNMMPMSNVOWQXTXVW QKOMNPNSOVQX TXUWVU VSVX WSWX TSYS", "J[NKNX OKOX VKVX WKWX LKQK TKYK OQVQ LXQX TXYX", "NWRKRX SKSX PKUK PXUX", "LXSKSURWQX TKTUSWQXPXNWMUNTOUNV QKVK", "JZNKNX OKOX WKOS QQVX RQWX LKQK TKYK LXQX TXYX", "KXOKOX PKPX MKRK MXWXWTVX", "I\\MKMX NNRX NKRU WKRX WKWX XKXX KKNK WKZK KXOX UXZX", "JZNKNX OMVX OKVV VKVX LKOK TKXK LXPX", "KZQKOLNMMPMSNVOWQXTXVWWVXSXPWMVLTKQK QKOMNPNSOVQX TXVVWSWPVMTK", "JYNKNX OKOX LKSKVLWNWOVQSROR SKULVNVOUQSR LXQX", "KZQKOLNMMPMSNVOWQXTXVWWVXSXPWMVLTKQK QKOMNPNSOVQX TXVVWSWPVMTK PWPUQTSTTUUZV[W[XZ TUUXVZW[", "JZNKNX OKOX LKSKVLWNWOVQSROR SKULVNVOUQSR LXQX SRTSUWVXWXXW SRUSVWWX", "KZVMWKWOVMULSKQKOLNMNOOPQQTRVSWT NNOOQPTQVRWSWVVWTXRXPWOVNTNXOV", "KZRKRX SKSX NKMOMKXKXOWK PXUX", "J[NKNUOWQXTXVWWUWK OKOUPWQX LKQK UKYK", "KYMKRX NKRU WKRX KKPK TKYK", "I[LKOX MKOT RKOX RKUX SKUT XKUX JKOK VKZK", "KZNKVX OKWX WKNX LKQK TKYK LXQX TXYX", "LYNKRRRX OKSR WKSRSX LKQK TKYK PXUX", "LYVKNX WKOX OKNONKWK NXWXWTVX", "KXOKOX PKPX MKWKWOVK MXRX", "KYRKLX RMWX RKXX MWVW LXXX", "KZQKOLNMMPMSNVOWQXTXVWWVXSXPWMVLTKQK QKOMNPNSOVQX TXVVWSWPVMTK QOQT TOTT QQTQ QRTR", "KYRKMX RNVX RKWX KXPX TXYX", "JZMJLM XJWM PPOS UPTS MVLY XVWY MKWK MLWL PQTQ PRTR MWWW MXWX", "J[NKNX OKOX VKVX WKWX LKYK LXQX TXYX", "K[MKRQ NKSQMX MKWKXOVK NWWW MXWXXTVX", "KZMONLOKPKQLRORX XOWLVKUKTLSOSX MONMOLPLQMRO XOWMVLULTMSO PXUX", "KZRKRX SKSX QNNOMQMRNTQUTUWTXRXQWOTNQN QNOONQNROTQU TUVTWRWQVOTN PKUK PXUX", "J[RKRX SKSX LPMONOOSQU TUVSWOXOYP MONROTQUTUVTWRXO PKUK PXUX", "KZMVNXQXMRMONMOLQKTKVLWMXOXRTXWXXV OUNRNOOMQK TKVMWOWRVU NWPW UWWW", "KYTKKX SMTX TKUX NTTT IXNX RXWX", "JYPKLX QKMX NKUKWLWNVPSQ UKVLVNUPSQ OQRQTRUSUUTWQXJX RQTSTUSWQX", "KXVLWLXKWNVLTKRKPLOMNOMRMUNWPXRXTWUU RKPMOONRNVPX", "JYPKLX QKMX NKTKVLWNWQVTUVTWQXJX TKULVNVQUTTVSWQX", "JYPKLX QKMX SORS NKXKWNWK OQRQ JXTXUUSX", "JXPKLX QKMX SORS NKXKWNWK OQRQ JXOX", "KYVLWLXKWNVLTKRKPLOMNOMRMUNWPXRXTWUVVS RKPMOONRNVPX RXTVUS SSXS", "J[PKLX QKMX XKTX YKUX NKSK VK[K OQVQ JXOX RXWX", "NWTKPX UKQX RKWK NXSX", "LXUKRUQWPX VKSURWPXOXMWLUMTNUMV SKXK", "JZPKLX QKMX YKOR RPTX SPUX NKSK VK[K JXOX RXWX", "KXQKMX RKNX OKTK KXUXVUTX", "I\\OKKX OMPX PKQV YKPX YKUX ZKVX MKPK YK\\K IXMX SXXX", "JZPKLX PKTX QKTU XKTX NKQK VKZK JXNX", "KYRKPLOMNOMRMUNWPXRXTWUVVTWQWNVLTKRK RKPMOONRNVPX RXTVUTVQVMTK", "JYPKLX QKMX NKUKWLXMXOWQTROR UKWMWOVQTR JXOX", "KYRKPLOMNOMRMUNWPXRXTWUVVTWQWNVLTKRK RKPMOONRNVPX RXTVUTVQVMTK OWOVPUQURVRZS[T[UZ RVSZT[", "JZPKLX QKMX NKUKWLXMXOWQTROR UKWMWOVQTR SRTWUXVXWW SRTSUWVX JXOX", "KZWLXLYKXNWLUKRKPLOMOOPPUSVT ONPOURVSVVUWSXPXNWMULXMWNW", "KZTKPX UKQX PKNNOKZKYNYK NXSX", "J[PKMUMWOXSXUWVUYK QKNUNWOX NKSK WK[K", "KYOKPX PKQV YKPX MKRK VK[K", "I[NKMX OKNV TKMX TKSX UKTV ZKSX LKQK XK\\K", "KZPKTX QKUX YKLX NKSK VK[K JXOX RXWX", "LYPKRQPX QKSQ YKSQQX NKSK VK[K NXSX", "LYXKLX YKMX QKONPKYK LXUXVUTX", "KZMHX\\", "JZRMLW RMXW", "LZQOPPPQOQOPQOTOVQVWWXXX TOUQUWWX URRSPTOUOWPXSXTWUU RSPUPWQX", "JYNKNX OKOX ORPPROTOVPWRWUVWTXRXPWOU TOUPVRVUUWTX LKOK", "LXVQUQURVRVQUPSOQOOPNRNUOWQXSXUWVV QOPPOROUPWQX", "L[VKVX WKWX VRUPSOQOOPNRNUOWQXSXUWVU QOPPOROUPWQX TKWK VXYX", "LXOSVSVRUPSOQOOPNRNUOWQXSXUWVV USUQSO QOPPOROUPWQX", "LWTKULUMVMVLTKRKPMPX RKQMQX NOSO NXSX", "LYQOOQOSQUSUUSUQSOQO QOPQPSQU SUTSTQSO TPUOVO PTOUOXPYTYVZ OWPXTXVYV[T\\P\\N[NYPX", "J[NKNX OKOX ORPPROTOVPWRWX TOUPVRVX LKOK LXQX TXYX", "NWRKRLSLSKRK RORX SOSX POSO PXUX", "NWSKSLTLTKSK SOSZR\\ TOTZR\\P\\O[OZPZP[O[ QOTO", "JZNKNX OKOX WOOU RSVX SSWX LKOK TOYO LXQX TXYX", "NWRKRX SKSX PKSK PXUX", "F_JOJX KOKX KRLPNOPORPSRSX POQPRRRX SRTPVOXOZP[R[X XOYPZRZX HOKO HXMX PXUX XX]X", "J[NONX OOOX ORPPROTOVPWRWX TOUPVRVX LOOO LXQX TXYX", "LYQOOPNRNUOWQXTXVWWUWRVPTOQO QOPPOROUPWQX TXUWVUVRUPTO", "JYNON\\ OOO\\ ORPPROTOVPWRWUVWTXRXPWOU TOUPVRVUUWTX LOOO L\\Q\\", "KYUOU\\ VOV\\ URTPROPONPMRMUNWPXRXTWUU POOPNRNUOWPX S\\X\\", "KXOOOX POPX PRQPSOUOVPVQUQUPVP MOPO MXRX", "LYTOUPUQVQVPTOQOOPORQSTTVU OQQRTSVTVWTXQXOWOVPVPWQX", "LWPKPVRXTXUWUV QKQVRX NOTO", "J[NONUOWQXSXUWVU OOOUPWQX VOVX WOWX LOOO TOWO VXYX", "KYNORX OORV VORX LOQO TOXO", "I[LOOX MOOU ROOX ROUX SOUU XOUX JOOO VOZO", "KYNOUX OOVX VONX LOQO TOXO LXPX SXXX", "KYNORX OORV VORXP[N\\M\\L[LZMZM[L[ LOQO TOXO", "LXUONX VOOX OONQNOVO NXVXVVUX", "K[QOOPNQMSMUNWPXQXSWUUWRXO QOOQNSNUOWPX QOSOUPWWXX SOTPVWXXYX", "KXRKPMOOMUK\\ QLPNNTL\\ RKTKVLVNUPRQ TKULUNTPRQ RQTRUTUVTWRXQXOWNT RQSRTTTVRX", "KYLQNOPORPSSSXR\\ LQNPPPRQSS WOVRSXQ\\", "KYSOQOOPNQMSMUNWPXRXTWUVVTVRUPRNQLQKRJTJUKVM QOOQNSNVPX RXTVUTUQSO QLRKTKVM", "LXVPTOQOOPOQPRRS QOPPPQRS RSOTNUNWPXSXUW RSPTOUOWPX", "LWRKQLQMSNVNVMSNPOOPNRNTOVPWRXSYS[R\\P\\O[ SNQOPPOROTPVRX", "IYJRKPLONOOPOQMX MONPNQLX OQPPROTOVPVRS\\ TOUPURR\\", "IYJSKQLPNPOQOVPX MPNQNUOWPXQXSWTVUTVQVNULTKRKQLQNRPURWS QXSVTTUQUNTK", "NWROPVPWQXSXUWVU SOQVQWRX", "KYOOLX POMX UOVPWPVOTORQOR ORPSRWTXVWWU ORQSSWTX", "LXLKNKPLWX NKOLVX RPMX RPNX", "KZOOK\\ POL\\ NUNWOXQXSWTV VOTVTWUXWXXWYU WOUVUWVX", "JYNOMX OONUMX VRVOWOVRTUQWNXMX LOOO", "MXRKQLQMSNVN TNQOPPPRRSUS TNROQPQRRS SSPTOUOWQXSYTZT[S\\Q\\ SSQTPUPWQX", "KXQOOPNQMSMUNWPXRXTWUVVTVRUPSOQO QOOQNSNVPX RXTVUTUQSO", "IZPPMX PPNX TPSX TPTX KQMOXO KQMPXP", "JXSOQOOPNQMSJ\\ QOOQNSK\\ SOUPVRVTUVTWRXPXNWMU SOUQUTTVRX", "K[YOQOOPNQMSMUNWPXRXTWUVVTVRUPYP QOOQNSNVPX RXTVUTUQSO", "KZSPQX SPRX MQOOXO MQOPXP", "JXKRLPMOOOPPPROUOWPX NOOPORNUNWPXQXSWUUVRVOUOVP", "KZOPNQMSMUNWPXRXUWWUXRXPWOUOTPSRRUO\\ MUNVPWRWUVWTXR XQWPUPSR RUQXP\\", "KXMONOPPS[T\\ NOOPR[T\\U\\ VOTRNYL\\", "I[TKQ\\ UKP\\ JRKPLONOOPOVPWSWUVWT MONPNTOWPXSXUWWTXRYO", "JZNPPPPONPMQLSLUMWNXPXQWRUSR LUNWPWRU RRRWSXUXWVXTXRWPVOVPWP RUSWUWWV", "KZVOTVTWUXWXXWYU WOUVUWVX USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX", "JXOKMR PKNRNVPX NROPQOSOUPVRVTUVTWRXPXNWMUMR SOUQUTTVRX MKPK", "KXUPUQVQUPSOQOOPNQMSMUNWPXRXTWUV QOOQNSNVPX", "KZWKTVTWUXWXXWYU XKUVUWVX USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX UKXK", "KWNURTTSURUPSOQOOPNQMSMUNWPXRXTWUV QOOQNSNVPX", "MXWKXLXKVKTLSNPYO[N\\ VKULTNQYP[N\\L\\L[M\\ POVO", "KYVOTVSYR[ WOUVTYR[P\\M\\L[M[N\\ USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX", "KZPKLX QKMX OQPPROTOVPVRUUUWVX TOUPURTUTWUXWXXWYU NKQK", "MWSKSLTLTKSK NROPPOROSPSRRURWSX QORPRRQUQWRXTXUWVU", "MWTKTLULUKTK ORPPQOSOTPTRRYQ[O\\M\\M[N\\ ROSPSRQYP[O\\", "KXPKLX QKMX VPUQVQVPUOTORQPROR ORPSQWRXTXUWVU ORQSRWSX NKQK", "NVSKPVPWQXSXTWUU TKQVQWRX QKTK", "F^GRHPIOKOLPLQJX JOKPKQIX LQMPOOQOSPSQQX QORPRQPX SQTPVOXOZPZRYUYWZX XOYPYRXUXWYX[X\\W]U", "J[KRLPMOOOPPPQNX NOOPOQMX PQQPSOUOWPWRVUVWWX UOVPVRUUUWVXXXYWZU", "JYKRLPMOOOPPPQM\\ NOOPOQL\\ PQROTOVPWRWTVVUWSXQXOVOT TOVQVTUVSX J\\O\\", "KYVOR\\ WOS\\ USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX P\\U\\", "LXMRNPOOQORPRQPX POQPQQOX RQSPUOVOWPWQVQWP", "LYVPVQWQVPTOQOOPORQSTTVU OQQRTSVTVWTXQXOWNVOVOW", "NWSKPVPWQXSXTWUU TKQVQWRX POUO", "IZJRKPLONOOPORNUNWOX MONPNRMUMWOXQXSWTV VOTVTWUXWXXWYU WOUVUWVX", "H\\IRJPKOMONPNRMUMWNX LOMPMRLULWNXOXQWRV TORVRWTX UOSVSWTXUXWWYUZRZOYOZP", "JZMRNPPOROSPSR QORPRRQUPWNXMXLWLVMVLW XPWQXQXPWOVOTPSRRURWSX QUQWRXTXVWWU", "IYJRKPLONOOPORNUNWOX MONPNRMUMWOXQXSWTV VOTVSYR[ WOUVTYR[P\\M\\L[M[N\\", "KYWOWPVQNVMWMX NQOOROUQ OPRPUQVQ NVOVRWUW OVRXUXVV", "H[RKSLSMTMTLRKOKMLLNLX OKNLMNMX XKYLYMZMZLXKVKTMTX VKUMUX JOWO JXOX RXWX", "J[UKVLWLWKQKOLNNNX QKPLONOX VOVX WOWX LOWO LXQX TXYX", "J[WKQKOLNNNX QKPLONOX UKVLVX WKWX LOVO LXQX TXYX", "F_PKQLQMRMRLPKMKKLJNJX MKLLKNKX YKZL[L[KUKSLRNRX UKTLSNSX ZOZX [O[X HO[O HXMX PXUX XX]X", "F_PKQLQMRMRLPKMKKLJNJX MKLLKNKX [KUKSLRNRX UKTLSNSX YKZLZX [K[X HOZO HXMX PXUX XX]X", "NWRORX SOSX POSO PXUX", "LXVPTOROPPOQNSNUOWQXSXUW ROPQOSOVQX OSSS", "LYSKQLPMOONRNUOWPXRXTWUVVTWQWNVLUKSK SKQMPOOSOVPX RXTVUTVPVMUK OQVQ", "KZTKQ\\ UKP\\ QONPMRMUNWQXTXWWXUXRWPTOQO QOOPNRNUOWQX TXVWWUWRVPTO", "LXUPVRVQUPSOQOOPNRNTOVRX QOOQOTPVRXSYS[R\\P\\", "I[VKWLXLVKSKQLPMOOLYK[J\\ SKQMPOMYL[J\\H\\H[I\\ ZK[L[KYKWLVNSYR[Q\\ YKXLWNTYS[Q\\O\\O[P\\ LOYO", "IZVKWLXLXKSKQLPMOOLYK[J\\ SKQMPOMYL[J\\H\\H[I\\ VOTVTWUXWXXWYU WOUVUWVX LOWO", "IZVKWL XKSKQLPMOOLYK[J\\ SKQMPOMYL[J\\H\\H[I\\ WKTVTWUXWXXWYU XKUVUWVX LOVO", "F^SKTLTM ULSKPKNLMMLOIYH[G\\ PKNMMOJYI[G\\E\\E[F\\ ZK[L\\L\\KWKUL TMSOPYO[N\\ WKUMTOQYP[N\\L\\L[M\\ ZOXVXWYX[X\\W]U [OYVYWZX IO[O", "F^SKTLTM ULSKPKNLMMLOIYH[G\\ PKNMMOJYI[G\\E\\E[F\\ ZK[L \\KWKUL TMSOPYO[N\\ WKUMTOQYP[N\\L\\L[M\\ [KXVXWYX[X\\W]U \\KYVYWZX IOZO", "MWNROPPOROSPSRRURWSX QORPRRQUQWRXTXUWVU", "LYQKOLNONTOWQXTXVWWTWOVLTKQK QKPLOOOTPWQX TXUWVTVOULTK", "LYPNSKSX RLRX OXVX", "LYOMONNNNMOLQKTKVLWNVPTQQROSNUNX TKULVNUPTQ NWOVPVSWVWWV PVSXVXWVWU", "LYOMONNNNMOLQKTKVLWNVPTQ TKULVNUPTQ RQTQVRWTWUVWTXQXOWNVNUOUOV TQURVTVUUWTX", "LYSMSX TKTX TKMTXT QXVX", "LYOKNQ OKVK OLSLVK NQOPQOTOVPWRWUVWTXQXOWNVNUOUOV TOUPVRVUUWTX", "LYVMVNWNWMVLTKRKPLOMNPNUOWQXTXVWWUWSVQTPQPNR RKPMOPOUPWQX TXUWVUVSUQTP", "LYNKNO VMRTPX WKTQQX NMPKRKUM NMPLRLUMVM", "LYQKOLNNOPQQTQVPWNVLTKQK QKPLONPPQQ TQUPVNULTK QQORNTNUOWQXTXVWWUWTVRTQ QQPROTOUPWQX TXUWVUVTURTQ", "LYOVOUNUNVOWQXSXUWVVWSWNVLTKQKOLNNNPORQSTSWQ SXUVVSVNULTK QKPLONOPPRQS", "NVRVQWRXSWRV", "NVSWRXQWRVSWSYQ[", "NVROQPRQSPRO RVQWRXSWRV", "NVROQPRQSPRO SWRXQWRVSWSYQ[", "NVRKQLRSSLRK RLRO RVQWRXSWRV", "LYNNONOONONNOLQKTKVLWNWOVQSRRSRTST TKVMVPUQSR RWRXSXSWRW", "OVRKRP SKRP", "LXOKOP PKOP UKUP VKUP", "MWQKPLPNQOSOTNTLSKQK", "MWRJRP OKUO UKOO", "KZXHM\\", "MWUHSJQMPPPTQWSZU\\ SJRLQPQTRXSZ", "MWOHQJSMTPTTSWQZO\\ QJRLSPSTRXQZ", "MWPHP\\ QHQ\\ PHUH P\\U\\", "MWSHS\\ THT\\ OHTH O\\T\\", "LWSHRIQKQMRORPPRRTRUQWQYR[S\\ RIQM QKRO RUQY QWR[", "MXQHRISKSMRORPTRRTRUSWSYR[Q\\ RISM SKRO RUSY SWR[", "MWTHPRT\\", "MWPHTRP\\", "OURHR\\", "MWPHP\\ THT\\", "I[LRXR", "I[RLRX LRXR", "JZRMRX MRWR MXWX", "JZRMRX MMWM MRWR", "JZMMWW WMMW", "NVRQQRRSSRRQ", "I[RLQMRNSMRL LRXR RVQWRXSWRV", "I[LPXP LTXT", "I[WLMX LPXP LTXT", "I[LNXN LRXR LVXV", "JZWLMRWX", "JZMLWRMX", "JZWKMOWS MTWT MXWX", "JZMKWOMS MTWT MXWX", "H[YUWUUTTSRPQOONNNLOKQKRLTNUOUQTRSTPUOWNYN", "JZLTLRMPOPUSWSXR LRMQOQUTWTXRXP", "JZMSRPWS MSRQWS", "NVSKPO SKTLPO", "NVQKTO QKPLTO", "LXNKOMQNSNUMVK NKONQOSOUNVK", "NVSLRMQLRKSLSNQP", "NVSKQMQORPSORNQO", "NVQLRMSLRKQLQNSP", "NVQKSMSORPQORNSO", "JZWMQMONNOMQMSNUOVQWWW", "JZMMMSNUOVQWSWUVVUWSWM", "JZMMSMUNVOWQWSVUUVSWMW", "JZMWMQNOONQMSMUNVOWQWW", "JZWMQMONNOMQMSNUOVQWWW MRUR", "I[TOUPXRUTTU UPWRUT LRWR", "MWRMRX OPPORLTOUP PORMTO", "I[POOPLROTPU OPMROT MRXR", "MWRLRW OTPURXTUUT PURWTU", "KYVSUPSOQOOPNQMSMUNWPXRXTWUVVTWQWNVLTKQKPLQLRK QOOQNSNVPX RXTVUTVQVNULTK", "JZLKRX MKRV XKRX LKXK NLWL", "G[IOLORW KORX [FRX", "I[XIXJYJYIXHVHTJSLROQUPYO[ UITKSORUQXPZN\\L\\K[KZLZL[", "I[XIXJYJYIXHVHTJSLROQUPYO[ UITKSORUQXPZN\\L\\K[KZLZL[ QNOONQNSOUQVSVUUVSVQUOSNQN", "H\\ZRYTWUVUTTSSQPPONNMNKOJQJRKTMUNUPTQSSPTOVNWNYOZQZR", "JZXKLX OKPLPNOOMOLNLLMKOKSLVLXK UTTUTWUXWXXWXUWTUT", "J[YPXPXQYQYPXOWOVPUTTVSWQXOXMWLVLTMSORRPSNSLRKPKOLONPQUWWXXXYW OXMVMTOR ONPPVWWX", "J[UPSOQOPQPRQTSTUS UOUSVTXTYRYQXNVLSKRKOLMNLQLRMUOWRXSXVW", "KZQHQ\\ THT\\ WLVLVMWMWLUKPKNLNNOPVSWT NNOOVRWTWVVWTXQXOWNVNUOUOVNV", "KYPKP[ TKT[ MQWQ MUWU", "LXTLSLSMTMTLSKQKPLPNQPTRUS PNQOTQUSUUSW QPOROTPVSXTY OTPUSWTYT[S\\Q\\P[PZQZQ[P[", "LXRKQLRMSLRK RMRQ RQQSRVSSRQ RVR\\ POONNOOPPOTOUNVOUPTO", "LXRMSLRKQLRMRQQRSURV RQSRQURVRZQ[R\\S[RZ POONNOOPPOTOUNVOUPTO PXOWNXOYPXTXUWVXUYTX", "LYVKVX NKVK QQVQ NXVX", "H\\QKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK RQQRRSSRRQ", "LYQKPLPMQN TKULUMTN RNPOOQORPTRUSUUTVRVQUOSNRN RURY SUSY OWVW", "LYRKPLONOOPQRRSRUQVOVNULSKRK RRRX SRSX OUVU", "H\\QKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK RKRY KRYR", "JYRRPQOQMRLTLUMWOXPXRWSUSTRR WMRR RMWMWR RMVNWR", "JZLLMKOKQLRNRPQRPSNT OKPLQNQQPS VKUX WKTX NTXT", "JYNKNU OKNR NROPQOSOUPVQVTTVTXUYVYWX SOUQUTTV LKOK", "LYONRKRQ VNSKSQ RQPROTOUPWRXSXUWVUVTURSQ RTRUSUSTRT", "JZRKRY MKMPNRPSTSVRWPWK LMMKNM QMRKSM VMWKXM OVUV", "JYNKNX OKOX LKSKVLWNWOVQSROR SKULVNVOUQSR LXVXVUUX", "LYWKTKQLONNQNSOVQXTYWY WKTLRNQQQSRVTXWY", "JZRRPQOQMRLTLUMWOXPXRWSUSTRR SLQQ WMRR XQSS", "KYPMTW TMPW MPWT WPMT", "J[OUMULVLXMYOYPXPVNTMRMONMOLQKTKVLWMXOXRWTUVUXVYXYYXYVXUVU NMPLULWM", "J[OOMOLNLLMKOKPLPNNPMRMUNWOXQYTYVXWWXUXRWPUNULVKXKYLYNXOVO NWPXUXWW", "F^KHK\\ LHL\\ XHX\\ YHY\\ HH\\H H\\O\\ U\\\\\\", "H]KHRQJ\\ JHQQ JHYHZMXH K[X[ J\\Y\\ZWX\\", "KYVBTDRGPKOPOTPYR]T`Vb TDRHQKPPPTQYR\\T`", "KYNBPDRGTKUPUTTYR]P`Nb PDRHSKTPTTSYR\\P`", "KYOBOb PBPb OBVB ObVb", "KYTBTb UBUb NBUB NbUb", "JYTBQEPHPJQMSOSPORSTSUQWPZP\\Q_Tb RDQGQKRN RVQYQ]R`", "KZPBSETHTJSMQOQPURQTQUSWTZT\\S_Pb RDSGSKRN RVSYS]R`", "KYU@RCPFOIOLPOSVTYT\\S_Ra RCQEPHPKQNTUUXU[T^RaOd", "KYO@RCTFUIULTOQVPYP\\Q_Ra RCSETHTKSNPUOXO[P^RaUd", "AXCRGRR` GSRa FSRb X:Rb", "F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` VDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia", "H\\RFK[ RFY[ RIX[ MUVU I[O[ U[[[", "G]LFL[ MFM[ IFUFXGYHZJZLYNXOUP UFWGXHYJYLXNWOUP MPUPXQYRZTZWYYXZU[I[ UPWQXRYTYWXYWZU[", "G\\XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXXYV QFOGMILKKNKSLVMXOZQ[", "G]LFL[ MFM[ IFSFVGXIYKZNZSYVXXVZS[I[ SFUGWIXKYNYSXVWXUZS[", "G\\LFL[ MFM[ SLST IFYFYLXF MPSP I[Y[YUX[", "G[LFL[ MFM[ SLST IFYFYLXF MPSP I[P[", "G^XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXX QFOGMILKKNKSLVMXOZQ[ XSX[ YSY[ US\\S", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F LPXP H[O[ U[\\[", "MXRFR[ SFS[ OFVF O[V[", "KZUFUWTZR[P[NZMXMVNUOVNW TFTWSZR[ QFXF", "F\\KFK[ LFL[ YFLS QOY[ POX[ HFOF UF[F H[O[ U[[[", "I[NFN[ OFO[ KFRF K[Z[ZUY[", "F_KFK[ LFRX KFR[ YFR[ YFY[ ZFZ[ HFLF YF]F H[N[ V[][", "G^LFL[ MFYY MHY[ YFY[ IFMF VF\\F I[O[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF QFOGMILKKOKRLVMXOZQ[ S[UZWXXVYRYOXKWIUGSF", "G]LFL[ MFM[ IFUFXGYHZJZMYOXPUQMQ UFWGXHYJYMXOWPUQ I[P[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF QFOGMILKKOKRLVMXOZQ[ S[UZWXXVYRYOXKWIUGSF NYNXOVQURUTVUXV_W`Y`Z^Z] UXV\\W^X_Y_Z^", "G]LFL[ MFM[ IFUFXGYHZJZLYNXOUPMP UFWGXHYJYLXNWOUP I[P[ RPTQURXYYZZZ[Y TQUSWZX[Z[[Y[X", "H\\XIYFYLXIVGSFPFMGKIKKLMMNOOUQWRYT KKMMONUPWQXRYTYXWZT[Q[NZLXKUK[LX", "I\\RFR[ SFS[ LFKLKFZFZLYF O[V[", "F^KFKULXNZQ[S[VZXXYUYF LFLUMXOZQ[ HFOF VF\\F", "H\\KFR[ LFRX YFR[ IFOF UF[F", "F^JFN[ KFNV RFN[ RFV[ SFVV ZFV[ GFNF WF]F", "H\\KFX[ LFY[ YFK[ IFOF UF[F I[O[ U[[[", "H]KFRQR[ LFSQS[ ZFSQ IFOF VF\\F O[V[", "H\\XFK[ YFL[ LFKLKFYF K[Y[YUX[", "I[NFN[ OFO[ KFZFZLYF K[R[", "H\\RFJ[ RFZ[ RIY[ KZYZ J[Z[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF QFOGMILKKOKRLVMXOZQ[ S[UZWXXVYRYOXKWIUGSF OMOT UMUT OPUP OQUQ", "H\\RFK[ RFY[ RIX[ I[O[ U[[[", "G]KEJJ ZEYJ ONNS VNUS KWJ\\ ZWY\\ KGYG KHYH OPUP OQUQ KYYY KZYZ", "F^KFK[ LFL[ XFX[ YFY[ HF\\F H[O[ U[\\[", "H]KFRPJ[ JFQP JFYFZLXF KZXZ J[Y[ZUX[", "I\\KKKILGMFOFPGQIRMR[ KIMGOGQI ZKZIYGXFVFUGTISMS[ ZIXGVGTI O[V[", "H]RFR[ SFS[ PKMLLMKOKRLTMUPVUVXUYTZRZOYMXLUKPK PKNLMMLOLRMTNUPV UVWUXTYRYOXMWLUK OFVF O[V[", "G^RFR[ SFS[ IMJLLMMQNSOTQU JLKMLQMSNTQUTUWTXSYQZM[L TUVTWSXQYM[L\\M OFVF O[V[", "G]JXK[O[MWKSJPJLKIMGPFTFWGYIZLZPYSWWU[Y[ZX MWLTKPKLLINGPF TFVGXIYLYPXTWW KZNZ VZYZ", "H\\UFH[ UFV[ THU[ LUUU F[L[ R[X[", "F^OFI[ PFJ[ LFWFZG[I[KZNYOVP WFYGZIZKYNXOVP MPVPXQYSYUXXVZR[F[ VPWQXSXUWXUZR[", "H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV TFRGPINLMOLSLVMYNZP[", "F]OFI[ PFJ[ LFUFXGYHZKZOYSWWUYSZO[F[ UFWGXHYKYOXSVWTYRZO[", "F]OFI[ PFJ[ TLRT LF[FZLZF MPSP F[U[WVT[", "F\\OFI[ PFJ[ TLRT LF[FZLZF MPSP F[M[", "H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT TFRGPINLMOLSLVMYNZP[ R[TZVXXT UT\\T", "E_NFH[ OFI[ [FU[ \\FV[ KFRF XF_F LPXP E[L[ R[Y[", "LYUFO[ VFP[ RFYF L[S[", "I[XFSWRYQZO[M[KZJXJVKULVKW WFRWQYO[ TF[F", "F]OFI[ PFJ[ ]FLS SOW[ ROV[ LFSF YF_F F[M[ S[Y[", "H\\QFK[ RFL[ NFUF H[W[YUV[", "E`NFH[ NFO[ OFPY \\FO[ \\FV[ ]FW[ KFOF \\F`F E[K[ S[Z[", "F_OFI[ OFVX OIV[ \\FV[ LFOF YF_F F[L[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF SFQGOIMLLOKSKVLYN[ Q[SZUXWUXRYNYKXHVF", "F]OFI[ PFJ[ LFXF[G\\I\\K[NYPUQMQ XFZG[I[KZNXPUQ F[M[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF SFQGOIMLLOKSKVLYN[ Q[SZUXWUXRYNYKXHVF LYLXMVOUPURVSXS_T`V`W^W] SXT^U_V_W^", "F^OFI[ PFJ[ LFWFZG[I[KZNYOVPMP WFYGZIZKYNXOVP RPTQURVZW[Y[ZYZX URWYXZYZZY F[M[", "G^ZH[H\\F[L[JZHYGVFRFOGMIMKNMONVRXT MKOMVQWRXTXWWYVZS[O[LZKYJWJUI[JYKY", "H]UFO[ VFP[ OFLLNF]F\\L\\F L[S[", "F_NFKQJUJXKZN[R[UZWXXU\\F OFLQKUKXLZN[ KFRF YF_F", "H\\NFO[ OFPY \\FO[ LFRF XF^F", "E_MFK[ NFLY UFK[ UFS[ VFTY ]FS[ JFQF ZF`F", "G]NFU[ OFV[ \\FH[ LFRF XF^F F[L[ R[X[", "H]NFRPO[ OFSPP[ ]FSP LFRF YF_F L[S[", "G][FH[ \\FI[ OFLLNF\\F H[V[XUU[", "H\\KILKXWYYY[ LLXX KIKKLMXYY[ PPLTKVKXLZK[ KVMZ LTLVMXMZK[ SSXN VIVLWNYNYLWKVI VIWLYN", "H\\QIK[ SIY[ RIX[ MUVU I[O[ U[[[ QBOCNENGOIQJSJUIVGVEUCSBQB", "G]IB[b", "F^RJIZ RJ[Z", "I]NONPMPMONNPMTMVNWOXQXXYZZ[ WOWXXZZ[[[ WQVRPSMTLVLXMZP[S[UZWX PSNTMVMXNZP[", "G\\LFL[ MFM[ MPONQMSMVNXPYSYUXXVZS[Q[OZMX SMUNWPXSXUWXUZS[ IFMF", "H[WPVQWRXQXPVNTMQMNNLPKSKULXNZQ[S[VZXX QMONMPLSLUMXOZQ[", "H]WFW[ XFX[ WPUNSMQMNNLPKSKULXNZQ[S[UZWX QMONMPLSLUMXOZQ[ TFXF W[[[", "H[LSXSXQWOVNTMQMNNLPKSKULXNZQ[S[VZXX WSWPVN QMONMPLSLUMXOZQ[", "KXUGTHUIVHVGUFSFQGPIP[ SFRGQIQ[ MMUM M[T[", "I\\QMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM ONNPNTOV UVVTVPUN VOWNYMYNWN NUMVLXLYM[P\\U\\X]Y^ LYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[", "G]LFL[ MFM[ MPONRMTMWNXPX[ TMVNWPW[ IFMF I[P[ T[[[", "MXRFQGRHSGRF RMR[ SMS[ OMSM O[V[", "MXSFRGSHTGSF TMT_SaQbObNaN`O_P`Oa SMS_RaQb PMTM", "G\\LFL[ MFM[ WMMW RSX[ QSW[ IFMF TMZM I[P[ T[Z[", "MXRFR[ SFS[ OFSF O[V[", "BcGMG[ HMH[ HPJNMMOMRNSPS[ OMQNRPR[ SPUNXMZM]N^P^[ ZM\\N]P][ DMHM D[K[ O[V[ Z[a[", "G]LML[ MMM[ MPONRMTMWNXPX[ TMVNWPW[ IMMM I[P[ T[[[", "H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM QMONMPLSLUMXOZQ[ S[UZWXXUXSWPUNSM", "G\\LMLb MMMb MPONQMSMVNXPYSYUXXVZS[Q[OZMX SMUNWPXSXUWXUZS[ IMMM IbPb", "H\\WMWb XMXb WPUNSMQMNNLPKSKULXNZQ[S[UZWX QMONMPLSLUMXOZQ[ Tb[b", "IZNMN[ OMO[ OSPPRNTMWMXNXOWPVOWN KMOM K[R[", "J[WOXMXQWOVNTMPMNNMOMQNRPSUUWVXW MPNQPRUTWUXVXYWZU[Q[OZNYMWM[NY", "KZPFPWQZS[U[WZXX QFQWRZS[ MMUM", "G]LMLXMZP[R[UZWX MMMXNZP[ WMW[ XMX[ IMMM TMXM W[[[", "I[LMR[ MMRY XMR[ JMPM TMZM", "F^JMN[ KMNX RMN[ RMV[ SMVX ZMV[ GMNM WM]M", "H\\LMW[ MMX[ XML[ JMPM TMZM J[P[ T[Z[", "H[LMR[ MMRY XMR[P_NaLbKbJaK`La JMPM TMZM", "I[WML[ XMM[ MMLQLMXM L[X[XWW[", "G^QMNNLPKRJUJXKZN[P[RZUWWTYPZM QMONMPLRKUKXLZN[ QMSMUNVPXXYZZ[ SMTNUPWXXZZ[[[", "G\\TFQGOIMMLPKTJZIb TFRGPINMMPLTKZJb TFVFXGYHYKXMWNTOPO VFXHXKWMVNTO POTPVRWTWWVYUZR[P[NZMYLV POSPURVTVWUYTZR[", "H\\IPKNMMOMQNROSRSVRZOb JOLNPNRO ZMYPXRSYP^Nb YMXPWRSY", "I\\VNTMRMONMQLTLWMYNZP[R[UZWWXTXQWOSJRHRFSEUEWFYH RMPNNQMTMXNZ R[TZVWWTWPVNTKSISGTFVFYH", "I[XPVNTMPMNNNPPRSS PMONOPQRSS SSNTLVLXMZP[S[UZWX SSOTMVMXNZP[", "I[TFRGQHQIRJUKZKZJWKSMPOMRLULWMYP[S]T_TaSbQbPa ULQONRMUMWNYP[", "G]HQIOKMNMONOPNTL[ MMNNNPMTK[ NTPPRNTMVMXNYOYRXWUb VMXOXRWWTb", "F]GQHOJMMMNNNPMUMXNZO[ LMMNMPLULXMZO[Q[SZUXWUXRYMYIXGVFTFRHRJSMUPWRZT SZUWVUWRXMXIWGVF", "LXRMPTOXOZP[S[UYVW SMQTPXPZQ[", "H\\NMJ[ OMK[ XMYNZNYMWMUNQROSMS OSQTSZT[ OSPTRZS[U[WZYW", "H\\KFMFOGPHQJWXXZY[ MFOHPJVXWZY[Z[ RMJ[ RMK[", "F]MMGb NMHb MPLVLYN[P[RZTXVU XMUXUZV[Y[[Y\\W YMVXVZW[", "H\\NML[ OMNSMXL[ YMXQVU ZMYPXRVUTWQYOZL[ KMOM", "IZTFRGQHQIRJUKXK UKQLOMNONQPSSTVT UKRLPMOOOQQSST STOUMVLXLZN\\S^T_TaRbPb STPUNVMXMZO\\S^", "I[RMONMQLTLWMYNZP[R[UZWWXTXQWOVNTMRM RMPNNQMTMXNZ R[TZVWWTWPVN", "G]PNL[ PNM[ VNV[ VNW[ IPKNNM[M IPKONN[N", "H[LVMYNZP[R[UZWWXTXQWOVNTMRMONMQLTHb R[TZVWWTWPVN RMPNNQMTIb", "H][MQMNNLQKTKWLYMZO[Q[TZVWWTWQVOUNSM QMONMQLTLXMZ Q[SZUWVTVPUN UN[N", "H\\SNP[ SNQ[ JPLNOMZM JPLOONZN", "H\\IQJOLMOMPNPPNVNYP[ NMONOPMVMYNZP[Q[TZVXXUYRYOXMWNXOYR XUYO", "G]ONMOKQJTJWKYLZN[Q[TZWXYUZRZOXMVMTORSPXMb JWLYNZQZTYWWYU ZOXNVNTPRSPYNb", "I[KMMMONPPU_VaWb MMNNOPT_UaWbYb ZMYOWRM]K`Jb", "F]UFOb VFNb GQHOJMMMNNNPMUMXOZRZTYWVYS LMMNMPLULXMZO[R[TZVXXUYS[M", "F]JQLOONNMLNJQITIWJZK[M[OZQWRT IWJYKZMZOYQW QTQWRZS[U[WZYWZTZQYNXMWNYOZQ QWRYSZUZWYYW", "H]XMVTUXUZV[Y[[Y\\W YMWTVXVZW[ VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ", "H[PFLSLVMYNZ QFMS MSNPPNRMTMVNWOXQXTWWUZR[P[NZMWMS VNWPWTVWTZR[ MFQF", "I[WPWQXQXPWNUMRMONMQLTLWMYNZP[R[UZWW RMPNNQMTMXNZ", "H]ZFVTUXUZV[Y[[Y\\W [FWTVXVZW[ VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ WF[F", "I[MVQUTTWRXPWNUMRMONMQLTLWMYNZP[R[UZWX RMPNNQMTMXNZ", "KZZGYHZI[H[GZFXFVGUHTJSMP[O_Na XFVHUJTNRWQ[P^O`NaLbJbIaI`J_K`Ja OMYM", "H\\YMU[T^RaObLbJaI`I_J^K_J` XMT[S^QaOb VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ", "H]PFJ[ QFK[ MTOPQNSMUMWNXOXQVWVZW[ UMWOWQUWUZV[Y[[Y\\W MFQF", "LYUFTGUHVGUF MQNOPMSMTNTQRWRZS[ RMSNSQQWQZR[U[WYXW", "LYVFUGVHWGVF NQOOQMTMUNUQR[Q^P`OaMbKbJaJ`K_L`Ka SMTNTQQ[P^O`Mb", "H\\PFJ[ QFK[ XNWOXPYOYNXMWMUNQROSMS OSQTSZT[ OSPTRZS[U[WZYW MFQF", "MYUFQTPXPZQ[T[VYWW VFRTQXQZR[ RFVF", "AbBQCOEMHMINIPHTF[ GMHNHPGTE[ HTJPLNNMPMRNSOSQP[ PMRORQO[ RTTPVNXMZM\\N]O]Q[W[Z\\[ ZM\\O\\QZWZZ[[^[`YaW", "F]GQHOJMMMNNNPMTK[ LMMNMPLTJ[ MTOPQNSMUMWNXOXQVWVZW[ UMWOWQUWUZV[Y[[Y\\W", "G\\HQIOKMNMONOPNTJb MMNNNPMTIb NTOQQNSMUMWNXOYQYTXWVZS[Q[OZNWNT WNXPXTWWUZS[ FbMb", "H\\XMRb YMSb VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ ObVb", "IZJQKOMMPMQNQPPTN[ OMPNPPOTM[ PTRPTNVMXMYNYOXPWOXN", "J[XOXPYPYOXNUMRMONNONQORVVWW NPOQVUWVWYVZS[P[MZLYLXMXMY", "KYTFPTOXOZP[S[UYVW UFQTPXPZQ[ NMWM", "F]GQHOJMMMNNNQLWLYN[ LMMNMQKWKYLZN[P[RZTXVT XMVTUXUZV[Y[[Y\\W YMWTVXVZW[", "H\\IQJOLMOMPNPQNWNYP[ NMONOQMWMYNZP[Q[TZVXXUYQYMXMYO", "C`DQEOGMJMKNKQIWIYK[ IMJNJQHWHYIZK[M[OZQXRV TMRVRYSZU[W[YZ[X\\V]R]M\\M]O UMSVSYU[", "H\\KQMNOMRMSOSR QMRORRQVPXNZL[K[JZJYKXLYKZ QVQYR[U[WZYW YNXOYPZOZNYMXMVNTPSRRVRYS[", "G\\HQIOKMNMONOQMWMYO[ MMNNNQLWLYMZO[Q[SZUXWT ZMV[U^SaPbMbKaJ`J_K^L_K` YMU[T^RaPb", "H\\YMXOVQNWLYK[ LQMOOMRMVO MOONRNVOXO LYNYRZUZWY NYR[U[WYXW", "G^VGUHVIWHWGUFRFOGMILLL[ RFPGNIMLM[ \\G[H\\I]H]G\\FZFXGWIW[ ZFYGXIX[ IM[M I[P[ T[[[", "G]WGVHWIXHWGUFRFOGMILLL[ RFPGNIMLM[ WMW[ XMX[ IMXM I[P[ T[[[", "G]VGUHVIWHWGUF XFRFOGMILLL[ RFPGNIMLM[ WHW[ XFX[ IMWM I[P[ T[[[", "BcRGQHRISHRGPFMFJGHIGLG[ MFKGIIHLH[ ]G\\H]I^H]G[FXFUGSIRLR[ XFVGTISLS[ ]M][ ^M^[ DM^M D[K[ O[V[ Z[a[", "BcRGQHRISHRGPFMFJGHIGLG[ MFKGIIHLH[ \\G[H\\I]H]G[F ^FXFUGSIRLR[ XFVGTISLS[ ]H][ ^F^[ DM]M D[K[ O[V[ Z[a[", "MXRMR[ SMS[ OMSM O[V[", "IZWNUMRMONMPLSLVMYNZQ[T[VZ RMPNNPMSMVNYOZQ[ MTUT", "I\\TFQGOJNLMOLTLXMZO[Q[TZVWWUXRYMYIXGVFTF TFRGPJOLNOMTMXNZO[ Q[SZUWVUWRXMXIWGVF NPWP", "G]UFOb VFNb QMMNKPJSJVKXMZP[S[WZYXZUZRYPWNTMQM QMNNLPKSKVLXNZP[ S[VZXXYUYRXPVNTM", "I[TMVNXPXOWNTMQMNNMOLQLSMUOWSZ QMONNOMQMSNUSZT\\T^S_Q_", "G]LMKNJPJRKUOYP[ JRKTOXP[P]O`MbLbKaJ_J\\KXMTOQRNTMVMYNZPZTYXWZU[T[SZSXTWUXTY VMXNYPYTXXWZ", "E_YGXHYIZHYGWFTFQGOINKMNLRJ[I_Ha TFRGPIOKNNLWK[J^I`HaFbDbCaC`D_E`Da _G^H_I`H`G_F]F[GZHYJXMU[T_Sa ]F[HZJYNWWV[U^T`SaQbObNaN`O_P`Oa IM^M", "F^[GZH[I\\H[GXFUFRGPIOKNNMRK[J_Ia UFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea YMWTVXVZW[Z[\\Y]W ZMXTWXWZX[ JMZM", "F^YGXHYIZHZGXF \\FUFRGPIOKNNMRK[J_Ia UFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea [FWTVXVZW[Z[\\Y]W \\FXTWXWZX[ JMYM", "@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca OFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a `G_H`IaH`G]FZFWGUITKSNRRP[O_Na ZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja ^M\\T[X[Z\\[_[aYbW _M]T\\X\\Z][ DM_M", "@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca OFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a ^G]H^I_H_G]F aFZFWGUITKSNRRP[O_Na ZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja `F\\T[X[Z\\[_[aYbW aF]T\\X\\Z][ DM^M", "LYMQNOPMSMTNTQRWRZS[ RMSNSQQWQZR[U[WYXW", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF QFOGNHMJLOLRMWNYOZQ[ S[UZVYWWXRXOWJVHUGSF", "H\\NJPISFS[ RGR[ N[W[", "H\\LJMKLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ TFVGWHXJXLWNTPPR KYLXNXSZVZXYYX NXS[W[XZYXYV", "H\\LJMKLLKKKJLHMGPFTFWGXIXLWNTOQO TFVGWIWLVNTO TOVPXRYTYWXYWZT[P[MZLYKWKVLUMVLW WQXTXWWYVZT[", "H\\THT[ UFU[ UFJUZU Q[X[", "H\\MFKP KPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMVLW SMUNWPXSXUWXUZS[ MFWF MGRGWF", "H\\WIVJWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNRNOOMQLT RFPGNIMKLOLUMXOZQ[ S[UZWXXUXTWQUOSN", "H\\KFKL KJLHNFPFUIWIXHYF LHNGPGUI YFYIXLTQSSRVR[ XLSQRSQVQ[", "H\\PFMGLILLMNPOTOWNXLXIWGTFPF PFNGMIMLNNPO TOVNWLWIVGTF POMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO PONPMQLSLWMYNZP[ T[VZWYXWXSWQVPTO", "H\\XMWPURRSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNWMX QSORMPLMLLMIOGQF SFUGWIXLXRWVVXTZR[", "MWR[QZRYSZS\\R^Q_", "MWRMQNROSNRM R[QZRYSZS\\R^Q_", "MWRFQHRTSHRF RHRN RYQZR[SZRY", "I[MJNKMLLKLJMHNGPFSFVGWHXJXLWNVORQRT SFUGVHWJWLVNTP RYQZR[SZRY", "NVRFQM SFQM", "JZNFMM OFMM VFUM WFUM", "JZRFRR MIWO WIMO", "KYUBNRUb", "KYOBVROb", "KYOBOb UBUb", "F^RJR[ JRZR J[Z[", "F^RJR[ JJZJ JRZR", "MWQQQSSSSQQQ RQRS QRSR", "E_RIQJRKSJRI IR[R RYQZR[SZRY", "E_YIK[ IO[O IU[U", "E_IM[M IR[R IW[W", "F^ZFJMZT JVZV J[Z[", "F^JFZMJT JVZV J[Z[", "F_[WYWWVUTRPQOONMNKOJQJSKUMVOVQURTUPWNYM[M", "F^IUISJPLONOPPTSVTXTZS[Q ISJQLPNPPQTTVUXUZT[Q[O", "G]JTROZT JTRPZT", "LXTFOL TFUGOL", "LXPFUL PFOGUL", "H\\KFLHNJQKSKVJXHYF KFLINKQLSLVKXIYF", "MWRHSGRFQGQIRKSL", "MWQFRGSISKRLQKRJ", "E[HMLMRY KMR[ [BR[", "F^ZJSJOKMLKNJQJSKVMXOYSZZZ", "F^JJJQKULWNYQZSZVYXWYUZQZJ", "F^JJQJUKWLYNZQZSYVWXUYQZJZ", "F^JZJSKOLMNKQJSJVKXMYOZSZZ", "F^ZJSJOKMLKNJQJSKVMXOYSZZZ JRVR", "E_XP[RXT UMZRUW IRZR", "JZPLRITL MORJWO RJR[", "E_LPIRLT OMJROW JR[R", "JZPXR[TX MURZWU RIRZ", "I\\XRWOVNTMRMONMQLTLWMYNZP[R[UZWXXUYPYKXHWGUFRFPGOHOIPIPH RMPNNQMTMXNZ R[TZVXWUXPXKWHUF", "H\\JFR[ KFRY ZFR[ JFZF KGYG", "AbDMIMRY HNR[ b:R[", "F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` VDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia QKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK", "F_\\S[UYVWVUUTTQPPONNLNJOIQISJULVNVPUQTTPUOWNYN[O\\Q\\S", "F^[FI[ NFPHPJOLMMKMIKIIJGLFNFPGSHVHYG[F WTUUTWTYV[X[ZZ[X[VYTWT", "F_[NZO[P\\O\\N[MZMYNXPVUTXRZP[M[JZIXIUJSPORMSKSIRGPFNGMIMKNNPQUXWZZ[[[\\Z\\Y M[KZJXJUKSMQ MKNMVXXZZ[", "E`WNVLTKQKOLNMMPMSNUPVSVUUVS QKOMNPNSOUPV WKVSVUXVZV\\T]Q]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYZX XKWSWUXV", "H\\PBP_ TBT_ XIWJXKYJYIWGTFPFMGKIKKLMMNOOUQWRYT KKMMONUPWQXRYTYXWZT[P[MZKXKWLVMWLX", "JZUITJUKVJVIUGSFQFOGNINKOMQOVR OMTPVRWTWVVXTZ PNNPMRMTNVPXU[ NVSYU[V]V_UaSbQbOaN_N^O]P^O_", "JZRFQHRJSHRF RFRb RQQTRbSTRQ LMNNPMNLLM LMXM TMVNXMVLTM", "JZRFQHRJSHRF RFRT RPQRSVRXQVSRRP RTRb R^Q`RbS`R^ LMNNPMNLLM LMXM TMVNXMVLTM L[N\\P[NZL[ L[X[ T[V\\X[VZT[", "I\\XFX[ KFXF PPXP K[X[", "E`QFNGKIILHOHRIUKXNZQ[T[WZZX\\U]R]O\\LZIWGTFQF ROQPQQRRSRTQTPSORO RPRQSQSPRP", "J[PFNGOIQJ PFOGOI UFWGVITJ UFVGVI QJOKNLMNMQNSOTQUTUVTWSXQXNWLVKTJQJ RUR[ SUS[ NXWX", "I\\RFOGMILLLMMPORRSSSVRXPYMYLXIVGSFRF RSR[ SSS[ NWWW", "D`PFMGJIHLGOGSHVJYM[P\\T\\W[ZY\\V]S]O\\LZIWGTFPF RFR\\ GQ]Q", "G`PMMNKPJSJTKWMYPZQZTYVWWTWSVPTNQMPM ]GWG[HUN ]G]M\\IVO \\HVN", "F\\IIJGLFOFQGRIRLQOPQNSKU OFPGQIQMPPNS VFT[ WFS[ KUYU", "I\\MFMU NFMQ MQNOONQMTMWNXPXRWTUV TMVNWPWRTXTZU[W[YY KFNF", "I\\RNOOMQLTLUMXOZR[S[VZXXYUYTXQVOSNRN RHNJRFRN SHWJSFSN RSQTQURVSVTUTTSSRS RTRUSUSTRT", "G^QHRFR[ THSFS[ JHKFKMLPNRQSRS MHLFLNMQ [HZFZMYPWRTSSS XHYFYNXQ NWWW", "G]LFL[ MFM[ IFUFXGYHZJZMYOXPUQMQ UFWGXHYJYMXOWPUQ I[Y[YVX[", "H[YGUGQHNJLMKPKSLVNYQ[U\\Y\\ YGVHSJQMPPPSQVSYV[Y\\", "F_OQMQKRJSIUIWJYKZM[O[QZRYSWSURSQROQ SHPQ ZJRR \\QST", "H\\OKUY UKOY KOYU YOKU", "F^NVLUKUIVHXHYI[K\\L\\N[OYOXNVKRJOJMKJMHPGTGWHYJZMZOYRVVUXUYV[X\\Y\\[[\\Y\\X[VYUXUVV JMKKMIPHTHWIYKZM", "F^NMLNKNIMHKHJIHKGLGNHOJOKNMKQJTJVKYM[P\\T\\W[YYZVZTYQVMUKUJVHXGYG[H\\J\\K[MYNXNVM JVKXMZP[T[WZYXZV", "I[KYYK QLULYKXOXS ULXLXO", "I[YKKY LQLUKYOXSX LULXOX", "I[YYKK SLOLKKLOLS OLLLLO", "I[KKYY QXUXYYXUXQ UXXXXU", "F_JMILIJJHLGNGPHQIRKSP IJKHMHOIPJQLRPR[ [M\\L\\J[HYGWGUHTISKRP \\JZHXHVIUJTLSPS[", "F^IGJKKMMOPPTPWOYMZK[G IGJJKLMNPOTOWNYLZJ[G PONPMQLSLVMXOZQ[S[UZWXXVXSWQVPTO PPNQMSMVNY VYWVWSVQTP", "F^MJMV NKNU VKVU WJWV IGKIMJPKTKWJYI[G IYKWMVPUTUWVYW[Y", "F^[ILIJJILINJPLQNQPPQNQLPJ[J IMJOKPMQ QMPKOJMI IXXXZW[U[SZQXPVPTQSSSUTWIW [TZRYQWP STTVUWWX", "F]OUMTLTJUIWIXJZL[M[OZPXPWOUJPINIKJILHOGSGWHYJZLZOYRVUUWUYV[X[YZZX MSKPJNJKKILH SGVHXJYLYOXRVU", "G_HKKHMKMV JILLLV MKPHRKRU OIQLQU RKUHWKW[ TIVLV[ WKZH[J\\M\\P[SZUXWUYP[ YIZJ[M[PZSYUWWTYP[", "F^ISMSLRKOKMLJNHQGSGVHXJYMYOXRWS[S ITOTMRLOLMMJOHQG SGUHWJXMXOWRUT[T KXYX KYYY", "F_GLJIMLMX IJLMLX MLPISLSX OJRMRX SLVIYLYW[Y UJXMXXZZ]W", "G]ZIJY ZIWJQJ XKUKQJ ZIYLYR XKXNYR QRJR PSMSJR QRQY PSPVQY", "F^HOJKOU JMOWRPWPZO[M[KZIXHWHUITKTMUPVRWUWXUZ WHVIUKUMWQXTXWWYUZ", "F^IOLLPN KMOORLUN QMTOWLYN VMXO[L IULRPT KSOURRUT QSTUWRYT VSXU[R", "F^JHNJPLQOQRPUNWJY JHMIOJQLRO RRQUOWMXJY ZHWIUJSLRO RRSUUWWXZY ZHVJTLSOSRTUVWZY IP[P IQ[Q", "NVQQQSSSSQQQ QQSS SQQS", "JZMPQRTTVVWYW[V]U^ MQST MRPSTUVWWY", "JZWKVMTOPQMR SPMS UFVGWIWKVNTPQRMT", "H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM XNSM VMQNLP ONKR LVQW NWSVXT UVYR", "J[SMPNNPMRMTNVPWRWUVWTXRXPWNUMSM OPUM NRVN MTWO NUXP OVWR PWVT", "JZOGO^ UFU] MNWL MOWM MWWU MXWV", "JZNFNX VLV^ NNVL NOVM NWVU NXVV", "JZNBNW NNQLTLVMWOWQVSSUQVNW NNQMTMVN UMVOVQUSSU", "E_HIHL \\I\\L HI\\I HJ\\J HK\\K HL\\L", "JZMNMQ WNWQ MNWN MOWO MPWP MQWQ", "JZMLWX MLONQOTOVNWMWKUKUMTO ONTO QOWM VKVN ULWL WXUVSUPUNVMWMYOYOWPU UVPU SUMW NVNY MXOX", "JZPOOMOKMKMMNNPOSOUNWL NKNN MLOL MMSO POUN WLWY", "A^GfHfIeIdHcGcFdFfGhIiKiNhPfQdR`RUQ;Q4R/S-U,V,X-Y/Y3X6W8U;P?JCHEFHEJDNDREVGYJ[N\\R\\V[XZZW[T[PZMYKWITHPHMIKKJNJRKUMW GdGeHeHdGd U;Q?LCIFGIFKENERFVGXJ[ R\\U[WZYWZTZPYMXKVITH", "EfNSOUQVSVUUVSVQUOSNQNOONPMSMVNYP[S\\V\\Y[[Y\\W]T]P\\MZJXIUHRHOIMJKLIOHSHXI]KaMcPeTfYf]e`cba KLJNIRIXJ\\L`NbQdUeYe]d_cba POTO OPUP NQVQ NRVR NSVS OTUT PUTU aLaNcNcLaL bLbN aMcM aVaXcXcVaV bVbX aWcW", "D`H@Hd M@Md W@Wd \\@\\d MMWK MNWL MOWM MWWU MXWV MYWW", "H\\PMMNLOKQKSLUMVPWTWWVXUYSYQXOWNTMPM MNLPLSMUNVPW WVXTXQWOVNTM", "JZQCVMRTRU ULQS TITKPRRUUY W\\UYSXQXOYN[N]O_Ra W\\UZSYOYO]P_Ra SXPZN]", "JZPOOMOKMKMMNNPOSOUNWL NKNN MLOL MMSO POUN WLSY", "IjNQOOQNSNUOVQVSUUSVQVOUNTMQMNNKPISHWH[I^K`NaRaW`[_]]`ZcVfQiMk WHZI]K_N`R`W_[^]\\`YcTgQi POTO OPUP NQVQ NRVR NSVS OTUT PUTU eLeNgNgLeL fLfN eMgM eVeXgXgVeV fVfX eWgW", "D`H>Hf I>If M>Mf QBSBSDQDQAR?T>W>Y?[A\\D\\I[LYNWOUOSNRLQNOQNROSQVRXSVUUWUYV[X\\[\\`[cYeWfTfReQcQ`S`SbQb RBRD QCSC Y?ZA[D[IZLYN RLRNPQNRPSRVRX YVZX[[[`ZcYe R`Rb QaSa", "AcHBHb IBIb [B[b \\B\\b DB`B DbMb Wb`b", "BaGBQPFb FBPP EBPQ EB\\B^I[B Ga\\a Fb\\b^[[b", "I[X+U1R8P=OANFMNMVN^OcPgRlUsXy U1S6Q<P@OFNNNVO^PdQhSnUs", "I[L+O1R8T=UAVFWNWVV^UcTgRlOsLy O1Q6S<T@UFVNVVU^TdShQnOs", "I[M+MRMy N+NRNy M+X+ MyXy", "I[V+VRVy W+WRWy L+W+ LyWy", "H[V+R1P5O:O>PBTJTLSNROMRRUSVTXTZPbOfOjPoRsVy T.R2Q5P:P>QCRF R^QaPfPjQoRrTv", "I\\N+R1T5U:U>TBPJPLQNROWRRUQVPXPZTbUfUjToRsNy P.R2S5T:T>SCRF R^SaTfTjSoRrPv", "I[V.S1Q4O8N=NCOIPMSXT\\UbUgTlSoQs S1Q5P8O=OBPHQLTWU[VaVgUlSpQsNv", "I[N.Q1S4U8V=VCUITMQXP\\ObOgPlQoSs Q1S5T8U=UBTHSLPWO[NaNgOlQpSsVv", "7Z:RARRo @RQo ?RRr Z\"VJRr", "Ca].\\.[/[0\\1]1^0^.],[+Y+W,U.T0S3R:QJQjPsOv \\/\\0]0]/\\/ R:Rj U.T1S:SZRjQqPtOvMxKyIyGxFvFtGsHsItIuHvGv GtGuHuHtGt", "H\\RFJ[ RIK[J[ RIY[Z[ RFZ[ MUWU LVXV", "H\\LFL[ MGMZ LFTFWGXHYJYMXOWPTQ MGTGWHXJXMWOTP MPTPWQXRYTYWXYWZT[L[ MQTQWRXTXWWYTZMZ", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZV ZKYKXIWHUGQGOHMKLNLSMVOYQZUZWYXXYVZV", "H]LFL[ MGMZ LFSFVGXIYKZNZSYVXXVZS[L[ MGSGVHWIXKYNYSXVWXVYSZMZ", "I\\MFM[ NGNZ MFYF NGYGYF NPTPTQ NQTQ NZYZY[ M[Y[", "I[MFM[ NGN[M[ MFYF NGYGYF NPTPTQ NQTQ", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZVZRUR ZKYKXIWHUGQGOHNIMKLNLSMVNXOYQZUZWYXXYVYSUSUR", "G]KFK[ KFLFL[K[ YFXFX[Y[ YFY[ LPXP LQXQ", "NWRFR[S[ RFSFS[", "J[VFVVUYSZQZOYNVMV VFWFWVVYUZS[Q[OZNYMV", "H]LFL[M[ LFMFM[ ZFYFMR ZFMS POY[Z[ QOZ[", "IZMFM[ MFNFNZ NZYZY[ M[Y[", "F^JFJ[ KKK[J[ KKR[ JFRX ZFRX YKR[ YKY[Z[ ZFZ[", "G]KFK[ LIL[K[ LIY[ KFXX XFXX XFYFY[", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF QGNHLKKNKSLVNYQZSZVYXVYSYNXKVHSGQG", "H\\LFL[ MGM[L[ LFUFWGXHYJYMXOWPUQMQ MGUGWHXJXMWOUPMP", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF QGNHLKKNKSLVNYQZSZVYXVYSYNXKVHSGQG SXX]Y] SXTXY]", "H\\LFL[ MGM[L[ LFTFWGXHYJYMXOWPTQMQ MGTGWHXJXMWOTPMP RQX[Y[ SQY[", "H\\YIWGTFPFMGKIKKLMMNOOTQVRWSXUXXWYTZPZNYMXKX YIWIVHTGPGMHLILKMMONTPVQXSYUYXWZT[P[MZKX", "J[RGR[ SGS[R[ LFYFYG LFLGYG", "G]KFKULXNZQ[S[VZXXYUYF KFLFLUMXNYQZSZVYWXXUXFYF", "H\\JFR[ JFKFRX ZFYFRX ZFR[", "E_GFM[ GFHFMX RFMX RIM[ RIW[ RFWX ]F\\FWX ]FW[", "H\\KFX[Y[ KFLFY[ YFXFK[ YFL[K[", "I\\KFRPR[S[ KFLFSP ZFYFRP ZFSPS[", "H\\XFK[ YFL[ KFYF KFKGXG LZYZY[ K[Y[", "E\\XFVHTKQPOSLWIZG[E[DZDXEWFXEY XFWJUTT[ XFU[ T[TYSVRTPRNQLQKRKTLWOZR[V[XZ", "F^UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWIXHY OLNNMOKOJNJLKJMHOGRFXFZG[I[KZMXNTORO XFYGZIZKYMXN TOWPXQYSYVXYWZU[S[RZRXSU TOVPWQXSXVWYU[", "H]KHJJJLKNNOQOUNWMYKZIZGYFWFTGQJOMMQLULXMZP[R[UZWXXVXTWRURSSRU WFUGRJPMNQMUMXNZP[", "F]UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWJWLXNZP[S[UZWXYTZOZLYIWGUFPFMGKIJKJMKNMNNMOK", "I\\WIVJVLWMYMZKZIYGWFTFRGQHPJPLQNSO TFRHQJQMSO SOQONPLRKTKWLYMZO[R[UZWXXVXTWRURSSRU QOOPMRLTLXMZ", "G\\WHVJTORUQWOZM[ QLPNNOLOKMKKLINGQF[FXGWHVKTSSVRXPZM[K[IZHYHXIWJXIY SFWGXG OSPRRQVQXPZMXT", "G]JIIKIMJOLPOPROTNWKXHXGWFVFTGRIQKPNPQQSSTUTWSYQZO WFUGSIRKQNQRST ZOYSWWUYSZO[L[JZIXIWJVKWJX YSWVUXRZO[", "F^LLKKKILGOFRFOQMWLYKZI[G[FZFXGWHXGY RFOONRLWKYI[ JTKSMRVOXN[L]J^H^G]F\\FZGXJWLURTVTYV[W[YZ[X \\FZHXLVRUVUYV[", "IYWHUKSPQUPWNZL[ YLWNTOQOONNLNJOHQGUFYFWHVJTPRVQXOZL[J[IZIXJWKXJY", "IZYFWHUKSPPYN] YMWOTPQPOONMNKOIQGUFYFWIVKSTQXPZN]M^K_J^J\\KZMXOWRVVU", "F^LLKKKIMGPFRFOQMWLYKZI[G[FZFXGWHXGY RFOONRLWKYI[ ZGWKUMSNPO ]G\\H]I^H^G]F\\FZGWLVMTNPO POSPTRUYV[ PORPSRTYV[W[YZ[X", "I[MILKLMMOOPRPUOWNZK[H[GZFYFWGVHTKPUOWMZK[ VHTLRSQVPXNZK[I[HZHXIWKWMXPZR[U[WZYX", "D`RFNOKUIXGZE[C[BZBXCWDXCY RFPMOQNVNZP[ RFQJPOOVOZP[ [FWORXP[ [FYMXQWVWZY[Z[\\Z^X [FZJYOXVXZY[", "G^RFQJOPMULWJZH[F[EZEXFWGXFY RFRKSVT[ RFSKTVT[ `G_H`IaHaG`F^F\\GZJYLWQUWT[", "H]SFQGOIMLLNKRKVLYMZO[Q[TZVXXUYSZOZKYHXGWGUHSJQNPSPV QGOJMNLRLVMYO[", "F]UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWIXHY OLNNMOKOJNJLKJMHOGRFVFYGZH[J[MZOYPVQTQRP VFXGYHZJZMYOXPVQ", "H]UJULTNSOQPOPNNNLOIQGTFWFYGZIZMYPWSSWPYNZK[I[HZHXIWKWMXPZS[V[XZZX WFXGYIYMXPVSSVOYK[", "F^UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWIXHY OLNNMOKOJNJLKJMHOGRFWFZG[I[KZMYNVORO WFYGZIZKYMXNVO ROUPVRWYX[ ROTPURVYX[Y[[Z]X", "H\\NIMKMMNOPPSPVOXN[K\\H\\G[FZFXGWHVJUMSTRWPZN[ VJUNTUSXQZN[K[IZHXHWIVJWIX", "I[YHXJVOTUSWQZO[ SLRNPONOMMMKNIPGSF\\FZGYHXKVSUVTXRZO[M[KZJYJXKWLXKY UFYGZG", "G]HJJGLFMFOHOKNNKVKYL[ MFNHNKKSJVJYL[N[PZSWUTVR ZFVRUVUYW[X[ZZ\\X [FWRVVVYW[", "G\\HJJGLFMFOHOKNOLVLYM[ MFNHNKLRKVKYM[N[QZTWVTXPYMZIZGYFXFWGVIVLWNYP[Q]Q", "F]ILHLGKGIHGJFNFMHLLKUJ[ LLLUK[ VFTHRLOUMYK[ VFUHTLSUR[ TLTUS[ `F^G\\IZLWUUYS[", "H\\PKOLMLLKLIMGOFQFSGTITLSPQUOXMZJ[H[GZGXHWIXHY QFRGSISLRPPUNXLZJ[ ]G\\H]I^H^G]F[FYGWIULSPRURXSZT[U[WZYX", "G]JJLGNFOFQGQIOOORPT OFPGPINONRPTRTUSWQYNZL \\FZLWTUX ]F[LYQWUUXSZP[L[JZIXIWJVKWJX", "G\\ZHYJWOVRUTSWQYOZL[ SLRNPONOMMMKNIPGSF]F[GZHYKXOVUTXQZL[H[GZGXHWJWLXOZQ[T[WZYX VFZG[G", "H\\WMW[X[ WMXMX[ WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "H\\LFL[M[ LFMFM[ MPONQMTMVNXPYSYUXXVZT[Q[OZMX MPQNTNVOWPXSXUWXVYTZQZMX", "I[XPVNTMQMONMPLSLUMXOZQ[T[VZXX XPWQVOTNQNOONPMSMUNXOYQZTZVYWWXX", "H\\WFW[X[ WFXFX[ WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "I[MTXTXQWOVNTMQMONMPLSLUMXOZQ[T[VZXX MSWSWQVOTNQNOONPMSMUNXOYQZTZVYWWXX", "LZWFUFSGRJR[S[ WFWGUGSH TGSJS[ OMVMVN OMONVN", "H\\XMWMW\\V_U`SaQaO`N_L_ XMX\\W_UaSbPbNaL_ WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "H\\LFL[M[ LFMFM[ MQPNRMUMWNXQX[ MQPORNTNVOWQW[X[", "NWRFQGQHRISITHTGSFRF RGRHSHSGRG RMR[S[ RMSMS[", "NWRFQGQHRISITHTGSFRF RGRHSHSGRG RMRbSb RMSMSb", "H[LFL[M[ LFMFM[ XMWMMW XMMX PTV[X[ QSX[", "CbGMG[H[ GMHMH[ HQKNMMPMRNSQS[ HQKOMNONQORQR[S[ SQVNXM[M]N^Q^[ SQVOXNZN\\O]Q][^[", "H\\LML[M[ LMMMM[ MQPNRMUMWNXQX[ MQPORNTNVOWQW[X[", "I\\QMONMPLSLUMXOZQ[T[VZXXYUYSXPVNTMQM QNOONPMSMUNXOYQZTZVYWXXUXSWPVOTNQN", "H\\LMLbMb LMMMMb MPONQMTMVNXPYSYUXXVZT[Q[OZMX MPQNTNVOWPXSXUWXVYTZQZMX", "H\\WMWbXb WMXMXb WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "KYOMO[P[ OMPMP[ PSQPSNUMXM PSQQSOUNXNXM", "J[XPWNTMQMNNMPNRPSUUWV VUWWWXVZ WYTZQZNY OZNXMX XPWPVN WOTNQNNO ONNPOR NQPRUTWUXWXXWZT[Q[NZMX", "MXRFR[S[ RFSFS[ OMVMVN OMONVN", "H\\LMLWMZO[R[TZWW LMMMMWNYPZRZTYWW WMW[X[ WMXMX[", "JZLMR[ LMMMRY XMWMRY XMR[", "F^IMN[ IMJMNX RMNX RPN[ RPV[ RMVX [MZMVX [MV[", "I[LMW[X[ LMMMX[ XMWML[ XMM[L[", "JZLMR[ LMMMRY XMWMRYNb XMR[ObNb", "I[VNL[ XMNZ LMXM LMLNVN NZXZX[ L[X[", "K[UUTSRRPRNSMTLVLXMZO[Q[SZTX PRNTMVMYO[ VRTXTZV[XZYY[V WRUXUZV[", "LZLVNSPO SFMXMZO[P[RZTXUUURVVWWXWZV TFNXNZO[", "LXTSSTTTTSSRQROSNTMVMXNZP[S[VYXV QROTNVNYP[", "K[UUTSRRPRNSMTLVLXMZO[Q[SZTX PRNTMVMYO[ ZFTXTZV[XZYY[V [FUXUZV[", "LXOYQXRWSUSSRRQROSNTMVMXNZP[S[VYXV QROTNVNYP[", "OXRRUOWLXIXGWFUGTIKdKfLgNfOcPZQ[S[UZVYXV TISNRRO[M`Kd", "K[UUTSRRPRNSMTLVLXMZO[Q[SZTX PRNTMVMYO[ VRPd WRT[R`PdOfMgLfLdMaO_R]V[YY[V", "L[LVNSPO SFL[ TFM[ OUQSSRTRVSVUUXUZV[ TRUSUUTXTZV[XZYY[V", "NVSLRMSNTMSL QROXOZQ[SZTYVV RRPXPZQ[", "NVSLRMSNTMSL QRKd RRO[M`KdJfHgGfGdHaJ_M]Q[TYVV", "LZLVNSPO SFL[ TFM[ URUSVSURTRRTOU OURVSZT[ OUQVRZT[U[XYZV", "NVNVPSRO UFOXOZQ[SZTYVV VFPXPZQ[", "E^EVGSIRKSKUI[ IRJSJUH[ KUMSORPRRSRUP[ PRQSQUO[ RUTSVRWRYSYUXXXZY[ WRXSXUWXWZY[[Z\\Y^V", "I[IVKSMROSOUM[ MRNSNUL[ OUQSSRTRVSVUUXUZV[ TRUSUUTXTZV[XZYY[V", "KYRRPRNSMTLVLXMZO[Q[SZTYUWUUTSRRQSQURWTXVXXWYV PRNTMVMYO[", "L[LVNSPO QLHg RLIg OUQSSRTRVSVUUXUZV[ TRUSUUTXTZV[XZYY[V", "K[UUTSRRPRNSMTLVLXMZO[Q[SZ PRNTMVMYO[ VRPdPfQgSfTcT[V[YY[V WRT[R`Pd", "LZLVNSPRRSRUP[ PRQSQUO[ RUTSVRWRVU VRVUWWXWZV", "NZNVPSQQQSTUUWUYTZR[ QSSUTWTYR[ NZP[U[XYZV", "NVNVPSRO UFOXOZQ[SZTYVV VFPXPZQ[ PNVN", "K[NRLXLZN[O[QZSXUU ORMXMZN[ VRTXTZV[XZYY[V WRUXUZV[", "KZNRMTLWLZN[O[RZTXUUUR ORNTMWMZN[ URVVWWXWZV", "H]LRJTIWIZK[L[NZPX MRKTJWJZK[ RRPXPZR[S[UZWXXUXR SRQXQZR[ XRYVZW[W]V", "JZJVLSNRPRQSQUPXOZM[L[KZKYLYKZ WSVTWTWSVRURSSRUQXQZR[U[XYZV QSRU SSQU PXQZ QXOZ", "K[NRLXLZN[O[QZSXUU ORMXMZN[ VRPd WRT[R`PdOfMgLfLdMaO_R]V[YY[V", "LYLVNSPRRRTSTVSXPZN[ RRSSSVRXPZ N[P\\Q^QaPdNfLgKfKdLaO^R\\VYYV N[O\\P^PaOdNf", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF OGMJLOLRMWOZ NYQZSZVY UZWWXRXOWJUG VHSGQGNH", "H\\NJPISFS[ NJNKPJRHR[S[", "H\\LKLJMHNGPFTFVGWHXJXLWNUQL[ LKMKMJNHPGTGVHWJWLVNTQK[ LZYZY[ K[Y[", "H\\MFXFQO MFMGWG WFPO QNSNVOXQYTYUXXVZS[P[MZLYKWLW POSOVPXS TOWQXTXUWXTZ XVVYSZPZMYLW OZLX", "H\\UIU[V[ VFV[ VFKVZV UILV LUZUZV", "H\\MFLO NGMN MFWFWG NGWG MNPMSMVNXPYSYUXXVZS[P[MZLYKWLW LOMOONSNVOXR TNWPXSXUWXTZ XVVYSZPZMYLW OZLX", "H\\VGWIXIWGTFRFOGMJLOLTMXOZR[S[VZXXYUYTXQVOSNRNOOMQ WHTGRGOH PGNJMOMTNXQZ MVOYRZSZVYXV TZWXXUXTWQTO XSVPSOROOPMS QONQMT", "H\\KFYFO[ KFKGXG XFN[O[", "H\\PFMGLILKMMNNPOTPVQWRXTXWWYTZPZMYLWLTMRNQPPTOVNWMXKXIWGTFPF NGMIMKNMPNTOVPXRYTYWXYWZT[P[MZLYKWKTLRNPPOTNVMWKWIVG WHTGPGMH LXOZ UZXX", "H\\WPURRSQSNRLPKMKLLINGQFRFUGWIXMXRWWUZR[P[MZLXMXNZ WMVPSR WNUQRRQRNQLN PRMPLMLLMIPG LKNHQGRGUHWK SGVIWMWRVWTZ UYRZPZMY", "MXRXQYQZR[S[TZTYSXRX RYRZSZSYRY", "MXTZS[R[QZQYRXSXTYT\\S^Q_ RYRZSZSYRY S[T\\ TZS^", "MXRMQNQORPSPTOTNSMRM RNROSOSNRN RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "MXRMQNQORPSPTOTNSMRM RNROSOSNRN TZS[R[QZQYRXSXTYT\\S^Q_ RYRZSZSYRY S[T\\ TZS^", "MXRFRTST RFSFST RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "I\\LKLJMHNGQFTFWGXHYJYLXNWOUPRQ LKMKMJNHQGTGWHXJXLWNUORP MIPG UGXI XMTP RPRTSTSP RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "MXTFRGQIQLRMSMTLTKSJRJQK RKRLSLSKRK RGQK QIRJ", "MXTHSIRIQHQGRFSFTGTJSLQM RGRHSHSGRG SITJ THSL", "F_\\MZMXNWPUVTXSYQZMZKYJWJUKSLRQOSMTKTISGQFPFNGMIMKNNPQUWXZZ[\\[ \\M\\NZNWP ZMXPVVUXSZQ[M[KZJYIWIUJSLQQNRMSKSIRG SHQGPGNH OGNINKONQQVWXYZZ\\Z\\[", "I\\RBR_S_ RBSBS_ WIYIWGTFQFNGLILKMMNNVRWSXUXWWYTZQZOYNX WIVHTGQGNHMIMKNMVQXSYUYWXYWZT[Q[NZLXNX XXUZ", "G^[BIbJb [B\\BJb", "KYUBSDQGOKNPNTOYQ]S`UbVb UBVBTDRGPKOPOTPYR]T`Vb", "KYNBPDRGTKUPUTTYR]P`NbOb NBOBQDSGUKVPVTUYS]Q`Ob", "JZRFQGSQRR RFRR RFSGQQRR MINIVOWO MIWO MIMJWNWO WIVINOMO WIMO WIWJMNMO", "F_JQ[Q[R JQJR[R", "F_RIRZSZ RISISZ JQ[Q[R JQJR[R", "F_JM[M[N JMJN[N JU[U[V JUJV[V", "NWSFRGRM SGRM SFTGRM", "I[NFMGMM NGMM NFOGMM WFVGVM WGVM WFXGVM", "KYQFOGNINKOMQNSNUMVKVIUGSFQF QFNIOMSNVKUGQF SFOGNKQNUMVISF", "F^ZIJRZ[ ZIZJLRZZZ[", "F^JIZRJ[ JIJJXRJZJ[", "G^OFObPb OFPFPb UFUbVb UFVFVb JP[P[Q JPJQ[Q JW[W[X JWJX[X", "F^[FYGVHSHPGNFLFJGIIIKKMMMOLPJPHNF [FH[I[ [F\\FI[ YTWTUUTWTYV[X[ZZ[X[VYT NFJGIKMMPJNF LFIIKMOLPHLF YTUUTYX[[XYT WTTWV[ZZ[VWT", "E`WMTKQKOLNMMOMRNTOUQVTVWT WMTLQLOMNONROTQUTUWT VKVSWUYVZV\\U]S]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[U[YZ VKWKWSXUZV YV[U\\S\\O[LZJYIWHTGQGNHLIKJJLIOIRJUKWLXNYQZUZYYYZ", "E_JPLONOPPSTTUVVXVZU[S[QZOXNVNTOSPPTNULUJT ZPXOVOTPQTPUNVLVJUISIQJOLNNNPOQPTTVUXUZT KOJQJSKU YUZSZQYO", "H]TFQGOIMLLOKSKVLYMZO[Q[TZVXXUYRZNZKYHXGVFTF TFRGPINLMOLSLVMYO[ Q[SZUXWUXRYNYKXHVF", "H]TJO[ VFP[ VFSIPKNL UIQKNL", "H]OJPKOLNKNJOHPGSFVFYGZIZKYMWOTQPSMUKWI[ VFXGYIYKXMVOPS JYKXMXRZUZWYXW MXR[U[WZXW", "H]OJPKOLNKNJOHPGSFVFYGZIZKYMVOSP VFXGYIYKXMVO QPSPVQWRXTXWWYVZS[O[LZKYJWJVKULVKW SPUQVRWTWWVYUZS[", "H]XGR[ YFS[ YFJUZU", "H]QFLP QF[F QGVG[F LPMOPNSNVOWPXRXUWXUZR[O[LZKYJWJVKULVKW SNUOVPWRWUVXTZR[", "H]YIXJYKZJZIYGWFTFQGOIMLLOKSKWLYMZO[R[UZWXXVXSWQVPTOQOOPMRLT TFRGPINLMOLSLXMZ R[TZVXWVWRVP", "H]NFLL [FZIXLSRQUPWO[ XLRRPUOWN[ MIPFRFWI NHPGRGWIYIZH[F", "H]SFPGOHNJNMOOQPTPXOYNZLZIYGVFSF SFQGPHOJOMPOQP TPWOXNYLYIXGVF QPMQKSJUJXKZN[R[VZWYXWXTWRVQTP QPNQLSKUKXLZN[ R[UZVYWWWSVQ", "H]YMXOVQTRQROQNPMNMKNIPGSFVFXGYHZJZNYRXUVXTZQ[N[LZKXKWLVMWLX OQNONKOIQGSF XGYIYNXRWUUXSZQ[", "MXPYOZP[QZPY", "MXP[OZPYQZQ[P]N_", "MXSMRNSOTNSM PYOZP[QZ", "MXSMRNSOTNSM P[OZPYQZQ[P]N_", "MXUFTGRS UGRS UFVGRS PYOZP[QZPY", "H]OJPKOLNKNJOHPGSFWFZG[I[KZMYNSPQQQSRTTT WFYGZIZKYMXNVO PYOZP[QZPY", "MXVFTHSJSKTLUKTJ", "MXUHTGUFVGVHUJSL", "E_\\N[O\\P]O]N\\M[MYNWPRXPZN[K[HZGXGVHTISKRPPROTMUKUITGRFPGOIOLPRQUSXUZW[Y[ZYZX K[IZHXHVITJSPP OLPQQTSWUYWZYZZY", "H]TBL_ YBQ_ ZJYKZL[K[JZHYGVFRFOGMIMKNMONVRXT MKOMVQWRXTXWWYVZS[O[LZKYJWJVKULVKW", "G]_BEb", "KZZBVESHQKOONTNXO]P`Qb VESIQMPPOUOZP_Qb", "JYSBTDUGVLVPUUSYQ\\N_Jb SBTEUJUOTTSWQ[N_", "J[TFTR OIYO YIOO", "NWUFSM VFSM", "I[PFNM QFNM YFWM ZFWM", "KZSFQGPIPKQMSNUNWMXKXIWGUFSF", "H]SFLb YFRb LQZQ KWYW", "E_^F\\GXHUHQGOFMFKGJIJKLMNMPLQJQHOF ^FF[ XTVTTUSWSYU[W[YZZXZVXT", "G]LFL[ MFM[ IFYFYLXF MPUPXQYRZTZWYYXZU[I[ UPWQXRYTYWXYWZU[", "F^NFNLMTLXKZJ[ XFX[ YFY[ KF\\F G[\\[ G[Gb H[Gb [[\\b \\[\\b", "CbRFR[ SFS[ OFVF GGHHGIFHFGGFHFIGJIKMLONPWPYOZM[I\\G]F^F_G_H^I]H^G NPLQKSJXIZH[ NPMQLSKXJZI[G[FZEX WPYQZS[X\\Z][ WPXQYSZX[Z\\[^[_Z`X O[V[", "H\\LIKFKLLINGPFTFWGXIXLWNTOQO TFVGWIWLVNTO TOVPXRYTYWXYWZT[O[MZLYKWKVLUMVLW WQXTXWWYVZT[", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F XHLY H[O[ U[\\[", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F XHLY H[O[ U[\\[ N@N?M?M@NBPCTCVBW@", "F^KFK[ LFL[ HFOF LPSPUOVMWIXGYFZF[G[HZIYHZG SPUQVSWXXZY[ SPTQUSVXWZX[Z[[Z\\X H[O[", "E^MFMLLTKXJZI[H[GZGYHXIYHZ XFX[ YFY[ JF\\F U[\\[", "H]KFRV LFSV ZFSVQYPZN[M[LZLYMXNYMZ IFOF VF\\F", "F_RFR[ SFS[ OFVF PILJJLIOIRJULWPXUXYW[U\\R\\O[LYJUIPI PIMJKLJOJRKUMWPX UXXWZU[R[OZLXJUI O[V[", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F H[\\[ [[\\b \\[\\b", "F]KFKQLSOTRTUSWQ LFLQMSOT WFW[ XFX[ HFOF TF[F T[[[", "BcGFG[ HFH[ RFR[ SFS[ ]F][ ^F^[ DFKF OFVF ZFaF D[a[", "BcGFG[ HFH[ RFR[ SFS[ ]F][ ^F^[ DFKF OFVF ZFaF D[a[ `[ab a[ab", "F`PFP[ QFQ[ IFHLHFTF QPXP[Q\\R]T]W\\Y[ZX[M[ XPZQ[R\\T\\W[YZZX[", "CaHFH[ IFI[ EFLF IPPPSQTRUTUWTYSZP[E[ PPRQSRTTTWSYRZP[ [F[[ \\F\\[ XF_F X[_[", "H]MFM[ NFN[ JFQF NPUPXQYRZTZWYYXZU[J[ UPWQXRYTYWXYWZU[", "H]LIKFKLLINGQFSFVGXIYKZNZSYVXXVZS[P[MZLYKWKVLUMVLW SFUGWIXKYNYSXVWXUZS[ PPYP", "CbHFH[ IFI[ EFLF E[L[ VFSGQIPKOOORPVQXSZV[X[[Z]X^V_R_O^K]I[GXFVF VFTGRIQKPOPRQVRXTZV[ X[ZZ\\X]V^R^O]K\\IZGXF IPOP", "G]WFW[ XFX[ [FOFLGKHJJJLKNLOOPWP OFMGLHKJKLLNMOOP RPPQORLYKZJZIY PQOSMZL[J[IYIX T[[[", "H\\XFWGQINKLNKQKULXNZQ[S[VZXXYUYSXPVNSMQMNNLPKS XFWHUIQJNLLN QMONMPLSLUMXOZQ[ S[UZWXXUXSWPUNSM", "H\\MMM[ NMN[ JMUMXNYPYQXSUT UMWNXPXQWSUT NTUTXUYWYXXZU[J[ UTWUXWXXWZU[", "HZMMM[ NMN[ JMXMXRWM J[Q[", "F]NMNQMWLZK[ WMW[ XMX[ KM[M I[H`H[[[[`Z[", "E`RMR[ SMS[ OMVM JNIOHNIMJMKNMRNSPTUTWSXRZN[M\\M]N\\O[N PTNUMVKZJ[ PTNVLZK[I[HZGX UTWUXVZZ[[ UTWVYZZ[\\[]Z^X O[V[", "I[MOLMLQMONNPMTMWNXPXQWSTT TMVNWPWQVSTT QTTTWUXWXXWZT[P[MZLXLWMVNWMX TTVUWWWXVZT[", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M I[P[ T[[[ WNMZ", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M I[P[ T[[[ WNMZ OGOFNFNGOIQJSJUIVG", "H\\MMM[ NMN[ JMQM NTPTSSTRVNWMXMYNXOWN PTSUTVVZW[ PTRUSVUZV[X[YZZX J[Q[", "G]NMNQMWLZK[J[IZJYKZ WMW[ XMX[ KM[M T[[[", "G^LML[ LMR[ MMRY XMR[ XMX[ YMY[ IMMM XM\\M I[O[ U[\\[", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M MTWT I[P[ T[[[", "G]LML[ MMM[ WMW[ XMX[ IM[M I[P[ T[[[", "I\\RMR[ SMS[ MMLRLMYMYRXM O[V[", "I[LMR[ MMRY XMR[P_NaLbKbJaK`La JMPM TMZM", "H]RFRb SFSb OFSF RPQNPMNMLNKQKWLZN[P[QZRX NMMNLQLWMZN[ WMXNYQYWXZW[ SPTNUMWMYNZQZWYZW[U[TZSX ObVb", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M I[[[[`Z[", "G]LMLTMVPWRWUVWT MMMTNVPW WMW[ XMX[ IMPM TM[M T[[[", "CbHMH[ IMI[ RMR[ SMS[ \\M\\[ ]M][ EMLM OMVM YM`M E[`[", "CbHMH[ IMI[ RMR[ SMS[ \\M\\[ ]M][ EMLM OMVM YM`M E[`[``_[", "H]QMQ[ RMR[ LMKRKMUM RTVTYUZWZXYZV[N[ VTXUYWYXXZV[", "E_JMJ[ KMK[ GMNM KTOTRUSWSXRZO[G[ OTQURWRXQZO[ YMY[ ZMZ[ VM]M V[][", "J[OMO[ PMP[ LMSM PTTTWUXWXXWZT[L[ TTVUWWWXVZT[", "I\\MOLMLQMONNPMSMVNXPYSYUXXVZS[P[NZLXLWMVNWMX SMUNWPXSXUWXUZS[ RTXT", "DaIMI[ JMJ[ FMMM F[M[ VMSNQPPSPUQXSZV[X[[Z]X^U^S]P[NXMVM VMTNRPQSQURXTZV[ X[ZZ\\X]U]S\\PZNXM JTPT", "G\\VMV[ WMW[ ZMOMLNKPKQLSOTVT OMMNLPLQMSOT TTQUPVNZM[ TTRUQVOZN[L[KZJX S[Z[", "H\\RFKZ QIW[ RIX[ RFY[ MUVU I[O[ T[[[ KZJ[ KZM[ WZU[ WYV[ XYZ[", "G]LFL[ MGMZ NFN[ IFUFXGYHZJZLYNXOUP XHYJYLXN UFWGXIXMWOUP NPUPXQYRZTZWYYXZU[I[ XRYTYWXY UPWQXSXXWZU[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "G\\XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXXYV MILKKNKSLVMX QFOGMJLNLSMWOZQ[", "G]LFL[ MGMZ NFN[ IFSFVGXIYKZNZSYVXXVZS[I[ WIXKYNYSXVWX SFUGWJXNXSWWUZS[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "G\\LFL[ MGMZ NFN[ IFYFYL NPTP TLTT I[Y[YU JFLG KFLH OFNH PFNG TFYG VFYH WFYI XFYL TLSPTT TNRPTR TOPPTQ LZJ[ LYK[ NYO[ NZP[ T[YZ V[YY W[YX X[YU", "G[LFL[ MGMZ NFN[ IFYFYL NPTP TLTT I[Q[ JFLG KFLH OFNH PFNG TFYG VFYH WFYI XFYL TLSPTT TNRPTR TOPPTQ LZJ[ LYK[ NYO[ NZP[", "G^XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXZY[YS MILKKNKSLVMX QFOGMJLNLSMWOZQ[ XTXY WSWYVZ TS\\S USWT VSWU ZSYU [SYT", "F^KFK[ LGLZ MFM[ WFW[ XGXZ YFY[ HFPF TF\\F MPWP H[P[ T[\\[ IFKG JFKH NFMH OFMG UFWG VFWH ZFYH [FYG KZI[ KYJ[ MYN[ MZO[ WZU[ WYV[ YYZ[ YZ[[", "LXQFQ[ RGRZ SFS[ NFVF N[V[ OFQG PFQH TFSH UFSG QZO[ QYP[ SYT[ SZU[", "JZSFSWRZQ[ TGTWSZ UFUWTZQ[O[MZLXLVMUNUOVOWNXMX MVMWNWNVMV PFXF QFSG RFSH VFUH WFUG", "F\\KFK[ LGLZ MFM[ XGMR PPW[ QPX[ QNY[ HFPF UF[F H[P[ T[[[ IFKG JFKH NFMH OFMG WFXG ZFXG KZI[ KYJ[ MYN[ MZO[ WYU[ WYZ[", "I[NFN[ OGOZ PFP[ KFSF K[Z[ZU LFNG MFNH QFPH RFPG NZL[ NYM[ PYQ[ PZR[ U[ZZ W[ZY X[ZX Y[ZU", "E_JFJZ JFQ[ KFQX LFRX XFQ[ XFX[ YGYZ ZFZ[ GFLF XF]F G[M[ U[][ HFJG [FZH \\FZG JZH[ JZL[ XZV[ XYW[ ZY[[ ZZ\\[", "F^KFKZ KFY[ LFXX MFYX YGY[ HFMF VF\\F H[N[ IFKG WFYG [FYG KZI[ KZM[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF MILKKNKSLVMX WXXVYSYNXKWI QFOGMJLNLSMWOZQ[ S[UZWWXSXNWJUGSF", "G]LFL[ MGMZ NFN[ IFUFXGYHZJZMYOXPUQNQ XHYJYMXO UFWGXIXNWPUQ I[Q[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF MILKKNKSLVMX WXXVYSYNXKWI QFOGMJLNLSMWOZQ[ S[UZWWXSXNWJUGSF NXOVQURUTVUXV^W`Y`Z^Z\\ V\\W^X_Y_ UXW]X^Y^Z]", "G]LFL[ MGMZ NFN[ IFUFXGYHZJZLYNXOUPNP XHYJYLXN UFWGXIXMWOUP RPTQUSWYX[Z[[Y[W WWXYYZZZ TQURXXYYZY[X I[Q[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "H\\XIYFYLXIVGSFPFMGKIKLLNOPURWSXUXXWZ LLMNOOUQWRXT MGLILKMMONUPXRYTYWXYWZT[Q[NZLXKUK[LX", "H\\JFJL QFQ[ RGRZ SFS[ ZFZL JFZF N[V[ KFJL LFJI MFJH OFJG UFZG WFZH XFZI YFZL QZO[ QYP[ SYT[ SZU[", "F^KFKULXNZQ[S[VZXXYUYG LGLVMX MFMVNYOZQ[ HFPF VF\\F IFKG JFKH NFMH OFMG WFYG [FYG", "H\\KFR[ LFRXR[ MFSX YGR[ IFPF UF[F JFLH NFMH OFMG WFYG ZFYG", "F^JFN[ KFNVN[ LFOV RFOVN[ RFV[ SFVVV[ TFWV ZGWVV[ GFOF RFTF WF]F HFKG IFKH MFLH NFLG XFZG \\FZG", "H\\KFW[ LFX[ MFY[ XGLZ IFPF UF[F I[O[ T[[[ JFMH NFMH OFMG VFXG ZFXG LZJ[ LZN[ WZU[ WYV[ WYZ[", "G]JFQQQ[ KFRQRZ LFSQS[ YGSQ HFOF VF\\F N[V[ IFKG NFLG WFYG [FYG QZO[ QYP[ SYT[ SZU[", "H\\YFKFKL WFK[ XFL[ YFM[ K[Y[YU LFKL MFKI NFKH PFKG T[YZ V[YY W[YX X[YU", "I[NFN[ OGOZ PFP[ KFZFZL K[S[ LFNG MFNH QFPH RFPG UFZG WFZH XFZI YFZL NYM[ NZL[ PYQ[ PZR[", "H\\RFJ[ QIX[ RIY[ RFZ[ KYXY KZXZ J[Z[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF MILKKNKSLVMX WXXVYSYNXKWI QFOGMJLNLSMWOZQ[ S[UZWWXSXNWJUGSF OMOT UMUT OPUP OQUQ ONPP OOQP UNTP UOSP PQOS QQOR SQUR TQUS", "H\\RFKZ QIW[ RIX[ RFY[ I[O[ T[[[ KZJ[ KZM[ WZU[ WYV[ XYZ[", "G]JEJL ZEZL OMOT UMUT JUJ\\ ZUZ\\ JGZG JHZH JIZI OPUP OQUQ JXZX JYZY JZZZ JFMH ZFWH KIJK LIJJ XIZJ YIZK ONPP OOQP UNTP UOSP PQOS QQOR SQUR TQUS JVKX JWLX ZWXX ZVYX MYJ[ WYZ[", "F^KFK[ LGLZ MFM[ WFW[ XGXZ YFY[ HF\\F H[P[ T[\\[ IFKG JFKH NFMH OFMG UFWG VFWH ZFYH [FYG KZI[ KYJ[ MYN[ MZO[ WZU[ WYV[ YYZ[ YZ[[", "G]IFPPQQ JFQP KFRPI[ IFYFZLYIWF VFYH TFYG KYYY JZYZ I[Y[ZUYXWY", "H\\JMKILGMFOFPGQIRM LHMGOGPH JMKJMHOHPIQMQ[ RMR[ ZMYJWHUHTISMS[ XHWGUGTH ZMYIXGWFUFTGSIRM N[V[ QYP[ QZO[ SZU[ SYT[", "G]QFQ[ RGRZ SFS[ NFVF N[V[ OFQG PFQH TFSH UFSG QZO[ QYP[ SYT[ SZU[ OKLLKMJOJRKTLUOVUVXUYTZRZOYMXLUKOK LMKOKRLT XTYRYOXM OKMLLOLRMUOV UVWUXRXOWLUK", "F^QFQ[ RGRZ SFS[ NFVF N[V[ OFQG PFQH TFSH UFSG QZO[ QYP[ SYT[ SZU[ HMIMJNKQLSMTPUTUWTXSYQZN[M\\M LRKNJLILKN HMIKJKKLLPMSNTPU YN[LZLYNXR TUVTWSXPYLZK[K\\M", "G]NYKYJWK[O[MVKRJOJLKIMGPFTFWGYIZLZOYRWVU[Y[ZWYYVY LSKOKLLI XIYLYOXS O[MULPLKMHNGPF TFVGWHXKXPWUU[ KZNZ VZYZ", "H\\UFIZ SJT[ THUZ UFUHVYV[ LUTU F[L[ Q[X[ IZG[ IZK[ TZR[ TYS[ VYW[", "F^OFI[ PFJ[ QFK[ LFWFZG[I[KZNYOVP YGZIZKYNXO WFXGYIYKXNVP NPVPXQYSYUXXVZR[F[ WQXSXUWXUZ VPWRWUVXTZR[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV QHOJNLMOLSLWMY TFRGPJOLNOMSMXNZP[", "F]OFI[ PFJ[ QFK[ LFUFXGYHZKZOYSWWUYSZO[F[ WGXHYKYOXSVWTY UFWHXKXOWSUWRZO[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "F]OFI[ PFJ[ QFK[ ULST LF[FZL NPTP F[U[WV MFPG NFOH RFPH SFPG WFZG XFZH YFZI ZFZL ULSPST TNRPSR TOQPSQ JZG[ JYH[ KYL[ JZM[ P[UZ R[UY UYWV", "F\\OFI[ PFJ[ QFK[ ULST LF[FZL NPTP F[N[ MFPG NFOH RFPH SFPG WFZG XFZH YFZI ZFZL ULSPST TNRPSR TOQPSQ JZG[ JYH[ KYL[ JZM[", "H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT QHOJNLMOLSLWMY VXWWXT TFRGPJOLNOMSMXNZP[ R[TZVWWT TT\\T UTWU VTWW ZTXV [TXU", "E_NFH[ OFI[ PFJ[ ZFT[ [FU[ \\FV[ KFSF WF_F LPXP E[M[ Q[Y[ LFOG MFNH QFOH RFOG XF[G YFZH ]F[H ^F[G IZF[ IYG[ JYK[ IZL[ UZR[ UYS[ VYW[ UZX[", "KYTFN[ UFO[ VFP[ QFYF K[S[ RFUG SFTH WFUH XFUG OZL[ OYM[ PYQ[ OZR[", "I\\WFRWQYO[ XFTSSVRX YFUSSXQZO[M[KZJXJVKULUMVMWLXKX KVKWLWLVKV TF\\F UFXG VFWH ZFXH [FXG", "F]OFI[ PFJ[ QFK[ \\GMR QOU[ ROV[ SNWZ LFTF YF_F F[N[ R[Y[ MFPG NFOH RFPH SFPG ZF\\G ^F\\G JZG[ JYH[ KYL[ JZM[ UZS[ UYT[ VYX[", "H\\QFK[ RFL[ SFM[ NFVF H[W[YU OFRG PFQH TFRH UFRG LZI[ LYJ[ MYN[ LZO[ R[WZ T[XX V[YU", "D`MFGZ MGNYN[ NFOY OFPX [FPXN[ [FU[ \\FV[ ]FW[ JFOF [F`F D[J[ R[Z[ KFMG LFMH ^F\\H _F\\G GZE[ GZI[ VZS[ VYT[ WYX[ VZY[", "F_OFIZ OFV[ PFVX QFWX \\GWXV[ LFQF YF_F F[L[ MFPG NFPH ZF\\G ^F\\G IZG[ IZK[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF OIMLLOKSKWLY UXWUXRYNYJXH SFQGOJNLMOLSLXMZN[ Q[SZUWVUWRXNXIWGVF", "F]OFI[ PFJ[ QFK[ LFXF[G\\I\\K[NYPUQMQ ZG[I[KZNXP XFYGZIZKYNWPUQ F[N[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF OIMLLOKSKWLY UXWUXRYNYJXH SFQGOJNLMOLSLXMZN[ Q[SZUWVUWRXNXIWGVF LXMVOUPURVSXT]U^V^W] T^U_V_ SXS_T`V`W]W\\", "F^OFI[ PFJ[ QFK[ LFWFZG[I[KZNYOVPNP YGZIZKYNXO WFXGYIYKXNVP RPTQURWXXYYYZX WYXZYZ URVZW[Y[ZXZW F[N[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "G^ZH[H\\F[L[JZHYGVFRFOGMIMLNNPPVSWUWXVZ NLONVRWT OGNINKOMUPWRXTXWWYVZS[O[LZKYJWJUI[JYKY", "G]TFN[ UFO[ VFP[ MFKL ]F\\L MF]F K[S[ NFKL PFLI RFMG YF\\G ZF\\H [F\\I \\F\\L OZL[ OYM[ PYQ[ OZR[", "F_NFKQJUJXKZN[R[UZWXXU\\G OFLQKUKYLZ PFMQLULYN[ KFSF YF_F LFOG MFNH QFOH RFOG ZF\\G ^F\\G", "H\\NFNHOYO[ OGPX PFQW [GO[ LFSF XF^F MFNH QFPH RFOG YF[G ]F[G", "E_MFMHKYK[ NGLX OFMW UFMWK[ UFUHSYS[ VGTX WFUW ]GUWS[ JFRF UFWF ZF`F KFNG LFMH PFNI QFNG [F]G _F]G", "G]NFT[ OFU[ PFV[ [GIZ LFSF XF^F F[L[ Q[X[ MFOH QFPH RFPG YF[G ]F[G IZG[ IZK[ TZR[ TYS[ UYW[", "G]MFQPN[ NFRPO[ OFSPP[ \\GSP KFRF YF_F K[S[ LFNG PFOH QFNG ZF\\G ^F\\G OZL[ OYM[ PYQ[ OZR[", "G]ZFH[ [FI[ \\FJ[ \\FNFLL H[V[XU OFLL PFMI RFNG R[VZ T[WX U[XU", "H\\JFR[ KFRX LFSX JFZFR[ LGYG LHYH", "I]NPNOOOOQMQMONNPMTMVNWOXQXXYZZ[ VOWQWXXZ TMUNVPVXWZZ[[[ VRUSPTMULWLXMZP[S[UZVX NUMWMXNZ USQTOUNWNXOZP[", "G\\LFL[MZOZ MGMY IFNFNZ NPONQMSMVNXPYSYUXXVZS[Q[OZNX WPXRXVWX SMUNVOWRWVVYUZS[ JFLG KFLH", "H[WQWPVPVRXRXPVNTMQMNNLPKSKULXNZQ[S[VZXX MPLRLVMX QMONNOMRMVNYOZQ[", "H]VFV[[[ WGWZ SFXFX[ VPUNSMQMNNLPKSKULXNZQ[S[UZVX MPLRLVMX QMONNOMRMVNYOZQ[ TFVG UFVH XYY[ XZZ[", "H[MSXSXQWOVNSMQMNNLPKSKULXNZQ[S[VZXX WRWQVO MPLRLVMX VSVPUNSM QMONNOMRMVNYOZQ[", "KYWHWGVGVIXIXGWFTFRGQHPKP[ RHQKQZ TFSGRIR[ MMVM M[U[ PZN[ PYO[ RYS[ RZT[", "I\\XNYOZNYMXMVNUO QMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM OONQNSOU UUVSVQUO QMPNOPOTPVQW SWTVUTUPTNSM NUMVLXLYM[N\\Q]U]X^Y_ N[Q\\U\\X] LYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[ ObMaL_L^M\\O[", "G^LFL[ MGMZ IFNFN[ NQOOPNRMUMWNXOYRY[ WOXRXZ UMVNWQW[ I[Q[ T[\\[ JFLG KFLH LZJ[ LYK[ NYO[ NZP[ WZU[ WYV[ YYZ[ YZ[[", "LXQFQHSHSFQF RFRH QGSG QMQ[ RNRZ NMSMS[ N[V[ OMQN PMQO QZO[ QYP[ SYT[ SZU[", "KXRFRHTHTFRF SFSH RGTG RMR^QaPb SNS]R` OMTMT]S`RaPbMbLaL_N_NaMaM` PMRN QMRO", "G]LFL[ MGMZ IFNFN[ WNNW RSY[ RTX[ QTW[ TM[M I[Q[ T[[[ JFLG KFLH UMWN ZMWN LZJ[ LYK[ NYO[ NZP[ WYU[ VYZ[", "LXQFQ[ RGRZ NFSFS[ N[V[ OFQG PFQH QZO[ QYP[ SYT[ SZU[", "AcFMF[ GNGZ CMHMH[ HQIOJNLMOMQNROSRS[ QORRRZ OMPNQQQ[ SQTOUNWMZM\\N]O^R^[ \\O]R]Z ZM[N\\Q\\[ C[K[ N[V[ Y[a[ DMFN EMFO FZD[ FYE[ HYI[ HZJ[ QZO[ QYP[ SYT[ SZU[ \\ZZ[ \\Y[[ ^Y_[ ^Z`[", "G^LML[ MNMZ IMNMN[ NQOOPNRMUMWNXOYRY[ WOXRXZ UMVNWQW[ I[Q[ T[\\[ JMLN KMLO LZJ[ LYK[ NYO[ NZP[ WZU[ WYV[ YYZ[ YZ[[", "H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM MPLRLVMX WXXVXRWP QMONNOMRMVNYOZQ[ S[UZVYWVWRVOUNSM", "G\\LMLb MNMa IMNMNb NPONQMSMVNXPYSYUXXVZS[Q[OZNX WPXRXVWX SMUNVOWRWVVYUZS[ IbQb JMLN KMLO LaJb L`Kb N`Ob NaPb", "H\\VNVb WOWa UNWNXMXb VPUNSMQMNNLPKSKULXNZQ[S[UZVX MPLRLVMX QMONNOMRMVNYOZQ[ Sb[b VaTb V`Ub X`Yb XaZb", "IZNMN[ ONOZ KMPMP[ WOWNVNVPXPXNWMUMSNQPPS K[S[ LMNN MMNO NZL[ NYM[ PYQ[ PZR[", "J[WOXMXQWOVNTMPMNNMOMQNSPTUUWVXY NNMQ NRPSUTWU XVWZ MONQPRUSWTXVXYWZU[Q[OZNYMWM[NY", "KZPHPVQYRZT[V[XZYX QHQWRY PHRFRWSZT[ MMVM", "G^LMLVMYNZP[S[UZVYWW MNMWNY IMNMNWOZP[ WMW[\\[ XNXZ TMYMY[ JMLN KMLO YYZ[ YZ[[", "I[LMR[ MMRY NMSY XNSYR[ JMQM TMZM KMNO PMNN VMXN YMXN", "F^JMN[ KMNX LMOX RMOXN[ RMV[ SMVX RMTMWX ZNWXV[ GMOM WM]M HMKN NMLN XMZN \\MZN", "H\\LMV[ MMW[ NMX[ WNMZ JMQM TMZM J[P[ S[Z[ KMMN PMNN UMWN YMWN MZK[ MZO[ VZT[ WZY[", "H[LMR[ MMRY NMSY XNSYP_NaLbJbIaI_K_KaJaJ` JMQM TMZM KMNO PMNN VMXN YMXN", "I[VML[ WMM[ XMN[ XMLMLQ L[X[XW MMLQ NMLP OMLO QMLN S[XZ U[XY V[XX W[XW", "G^[MZQYTWXUZR[P[MZKXJUJSKPMNPMRMUNVOWQYXZZ[[\\[ ZMYQXTWVUYTZR[ LXKVKRLP P[NZMYLVLRMONNPM RMTNUOVQXXYZ[[", "G\\QFNGMHLJKNKb NHMJLNLa QFOGNIMNMb QFSFVGWHXJXLWNVOSP PPTPWQXRYTYWXYWZT[Q[OZNYMW VHWJWLVN WRXTXWWY SFUGVIVMUOSP TPVQWSWXVZT[ KbMb", "F\\HRINKMMMONPOQRRYSb IOKNMNOOPP HRIPKOMOOPPQQTRYRa XMWPVRTUSWR[Qb YMWQ ZMYOWRTVSXR[ XMZM QbSb", "H\\SMQMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMPLNKMJMHNGPFSFWH MPLSLUMX WXXUXSWP QMONNOMRMVNYOZQ[ S[UZVYWVWRVOUNOKNJNIOHQGTGWH", "I[SMUNVOWOVNSMQMMNLOLQMRQS SSQSMTKVKXMZP[S[VZXXWXVZ NNMOMQNR MULVLXMY QMONNONQORQS QSNTMVMXNZP[", "I[QHRGRFQFPGPIQJTKXKYKYJXJUKSLPNNPMRLULWMYNZP[S\\U]V_VaUbSbRaR`S`Sa POOPNRMUMWNYOZ UKRMQNOQNTNWOYQ[S\\", "G]JMKNLPL[ KMLNMPMZ HPINJMLMMNNPN[ UMVNWQWb WOXRXa NQOOPNRMUMWNXOYRYb L[N[ WbYb", "F]IMJNKPKTLWMYNZQ[S[VZWYXWYRYOXJVGTFRFPGOIOKPMSOVP[Q JMKNLPLTMWNY VYWWXRXOWJVHTG GPHNIMKMLNMPMTNXOZQ[ S[UZVXWSWNVJUHSGQGOI", "KZNMONPPPXQZS[U[WZXX OMPNQPQXRZ LPMNNMPMQNRPRXSZT[", "G]JMKNLPL[ KMLNMPMZ HPINJMLMMNNPN[ SOUNWNXOXPZPZNXMVMTNQQOTNW XNYOYP PSQSWYYYZX TWWZYZ RTUZV[X[YZZX L[N[", "H\\JGKFMFOGQIXXYZZ[ OHPIWXXY MFNGOIVXXZZ[[[ RMJZJ[K[RM", "G]KMKb LNLa MMMb VMVXWZX[Z[[Z\\X WNWXXZY[ XMXXYZZ[ MXNZP[R[TZUYVW KMMM VMXM KbMb", "G]JMKNLPMTN[ KMLNMPNTOZ HPINJMLMMNNPOTPZ VVWTXQXMYMZNYQXSVVTXQZN[ XRYOYM", "JZPGSFRFPGOHOIPJSKVLWKVJSKPLNMMOMQNRPSSTVUWTVSSTOUMVLXLZM[O\\S]U^V_VaTbRbOaPaRb OMNONQOR NVMXMZN[ VKSKQLPMOOOQQSST VTSTPUOVNXNZP\\S]", "G]IQJOKNMM[M KOMNZN IQJPLO[O OONZM[LZMWOO UOVZW[XZWWUO [M[O OOMZ UOWZ", "G\\QMNNLPKTKb MPLTLa QMONNOMSMb MWNYOZQ[S[VZXXYUYSXPVNSMQM WXXVXRWP S[UZVYWVWRVOUNSM KbMb", "G]PMMNKPJSJUKXMZP[R[UZWXXUXSWPUNRM LPKRKVLX VXWVWRVP PMNNMOLRLVMYNZP[ R[TZUYVVVRUOTNRM RMZO[N[MPM RMZN", "H\\JQKOLNNMZM LONNYN JQKPMOZO ROQZR[SZRO ZMZO RORZ", "G\\JMKNLPLUMXOZQ[S[UZWXXVYRYNXMWMXPXSWWUZ KMLNMPMUNX WMXNXO HPINJMLMMNNPNVOYQ[", "G]RQQNPMNMLNKOJRJUKXMZP[T[WZYXZUZRYOXNVMTMSNRQ LOKRKULX XXYUYRXO NMMNLQLVMYNZP[ T[VZWYXVXQWNVM RQQb RQRa RQSb QbSb", "H\\LMMNNPT_VaXbZb[a NOOPU_V` INJMLMNNPPV_WaXb VSXPYMZMYOVSN\\K`JbKbL_N\\", "F]HNINJPJUKXMZP[T[VZXXYVZRZNYMXMYPYSXWVZ JNKPKULX XMYNYO GPHNIMJMKNLPLVMYNZP[ QFSb RGRa SFQb QFSF QbSb", "F^NMLNJPISIWJYKZM[O[QZRYSWSTRSQTQWRYSZU[W[YZZY[W[SZPXNVM KPJSJWKY RTRX YYZWZSYP NMLOKRKWLZM[ W[XZYWYRXOVM", "G]WMUTUXVZW[Y[[Y\\W XMVTVZ WMYMWTVX UTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT NNLQKTKWLY PMNOMQLTLWMZN[", "I\\PFNMMSMWNYOZQ[S[VZXWYTYRXOWNUMSMQNPOOQNT QFOMNQNWOZ VYWWXTXQWO MFRFPMNT S[UYVWWTWQVNUM NFQG OFPH", "I[WQWPVPVRXRXPWNUMRMONMQLTLVMYNZP[R[UZWW OONQMTMWNY RMPOOQNTNWOZP[", "G]YFVQUUUXVZW[Y[[Y\\W ZFWQVUVZ VF[FWTVX UTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT MOLQKTKWLY PMNOMQLTLWMZN[ WFZG XFYH", "I[MVQUTTWRXPWNUMRMONMQLTLVMYNZP[R[UZWX OONQMTMWNY RMPOOQNTNWOZP[", "JZZHZGYGYI[I[GZFXFVGTISKRNQRO[N^M`Kb TJSMRRP[O^ XFVHUJTMSRQZP]O_MaKbIbHaH_J_JaIaI` NMYM", "H]XMT[S^QaOb YMU[S_ XMZMV[T_RaObLbJaI`I^K^K`J`J_ VTVQUNSMQMNNLQKTKVLYMZO[Q[SZTYUWVT NOMQLTLWMY QMOONQMTMWNZO[", "G]OFI[K[ PFJ[ LFQFK[ MTOPQNSMUMWNXPXSVX WNWRVVVZ WPUUUXVZW[Y[[Y\\W MFPG NFOH", "KXTFTHVHVFTF UFUH TGVG LQMOOMQMRNSPSSQX RNRRQVQZ RPPUPXQZR[T[VYWW", "KXUFUHWHWFUF VFVH UGWG MQNOPMRMSNTPTSRZQ]P_NaLbJbIaI_K_KaJaJ` SNSSQZP]O_ SPRTP[O^N`Lb", "G]OFI[K[ PFJ[ LFQFK[ YOYNXNXPZPZNYMWMUNQROS MSOSQTRUTYUZWZ QUSYTZ OSPTRZS[U[WZYW MFPG NFOH", "LXTFQQPUPXQZR[T[VYWW UFRQQUQZ QFVFRTQX RFUG SFTH", "@cAQBODMFMGNHPHSF[ GNGSE[ GPFTD[F[ HSJPLNNMPMRNSPSSQ[ RNRSP[ RPQTO[Q[ SSUPWNYM[M]N^P^S\\X ]N]R\\V\\Z ]P[U[X\\Z][_[aYbW", "F^GQHOJMLMMNNPNSL[ MNMSK[ MPLTJ[L[ NSPPRNTMVMXNYPYSWX XNXRWVWZ XPVUVXWZX[Z[\\Y]W", "H\\QMNNLQKTKVLYMZP[S[VZXWYTYRXOWNTMQM NOMQLTLWMY VYWWXTXQWO QMOONQMTMWNZP[ S[UYVWWTWQVNTM", "G]HQIOKMMMNNOPOSNWKb NNNSMWJb NPMTIb OTPQQORNTMVMXNYOZRZTYWWZT[R[PZOWOT XOYQYTXWWY VMWNXQXTWWVYT[ FbNb JaGb J`Hb K`Lb JaMb", "G\\WMQb XMRb WMYMSb UTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT MOLQKTKWLY PMNOMQLTLWMZN[ NbVb RaOb R`Pb S`Tb RaUb", "I[JQKOMMOMPNQPQTO[ PNPTN[ PPOTM[O[ YOYNXNXPZPZNYMWMUNSPQT", "J[XPXOWOWQYQYOXNUMRMONNONQOSQTTUVVWX ONNQ ORQSTTVU WVVZ NOOQQRTSVTWVWXVZS[P[MZLYLWNWNYMYMX", "KYTFQQPUPXQZR[T[VYWW UFRQQUQZ TFVFRTQX NMXM", "F^GQHOJMLMMNNPNSLX MNMRLVLZ MPKUKXLZN[P[RZTXVU XMVUVXWZX[Z[\\Y]W YMWUWZ XMZMXTWX", "H\\IQJOLMNMONPPPSNX ONORNVNZ OPMUMXNZP[R[TZVXXUYQYMXMXNYP", "CaDQEOGMIMJNKPKSIX JNJRIVIZ JPHUHXIZK[M[OZQXRU TMRURXSZU[W[YZ[X]U^Q^M]M]N^P UMSUSZ TMVMTTSX", "G]JQLNNMPMRNSPSR PMQNQRPVOXMZK[I[HZHXJXJZIZIY RORRQVQY ZOZNYNYP[P[NZMXMVNTPSRRVRZS[ PVPXQZS[U[WZYW", "G]HQIOKMMMNNOPOSMX NNNRMVMZ NPLULXMZO[Q[SZUXWT YMU[T^RaPb ZMV[T_ YM[MW[U_SaPbMbKaJ`J^L^L`K`K_", "H\\YMXOVQNWLYK[ XOOOMPLR VORNONNO VORMOMMOLR LYUYWXXV NYRZUZVY NYR[U[WYXV", "H\\WQVOUNSMQMNNLPKSKULXNZQ[S[VZWYXWYSYNXJWHVGSFQFNGMHNHOGQF MPLRLVMX VYWWXSXNWJVH QMONNOMRMVNYOZQ[ S[UZVXWTWMVIUGSF", "I[UMWNXOYOXNUMRMONMPLSLUMXOZR[U[XZYYXYWZU[ NPMSMUNX RMPNOONRNVOYPZR[ NTTUUTTSNT NTTT", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF NHMJLNLSMWNY VYWWXSXNWJVH QFOGNIMNMSNXOZQ[ S[UZVXWSWNVIUGSF LPXQ LQXP", "G]PMMNKPJSJUKXMZP[T[WZYXZUZSYPWNTMPM LPKSKULX XXYUYSXP PMNNMOLRLVMYNZP[T[VZWYXVXRWOVNTM QFSb RGRa SFQb QFSF QbSb", "H\\TMVNXPYPYOWNTMPMMNLOKQKSLUNWPXRYSZT\\T^S_Q_O^P^Q_ MOLQLSMUOW PMNNMPMSNURY YPXO", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF NHMJLNLSMWNY VYWWXSXNWJVH QFOGNIMNMSNXOZQ[ S[UZVXWSWNVIUGSF", "H\\QHQ[ RHRZ SFS[ SFPINJ M[W[ QZO[ QYP[ SYT[ SZU[", "H\\LJLKMKMJLJ LIMINJNKMLLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ WHXJXLWN TFVGWJWLVNTPPR KYLXNXSYWYYX NXSZWZXY NXS[W[XZYXYV", "H\\LJLKMKMJLJ LIMINJNKMLLLKKKJLHMGPFTFWGXIXLWNTO VGWIWLVN SFUGVIVLUNSO QOTOVPXRYTYWXYWZT[P[MZLYKWKVLUMUNVNWMXLX WRXTXWWY SOUPVQWTWWVZT[ LVLWMWMVLV", "H\\SIS[ THTZ UFU[ UFJUZU P[X[ SZQ[ SYR[ UYV[ UZW[", "H\\MFKPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMUNVNWMXLX WPXRXVWX SMUNVOWRWVVYUZS[ LVLWMWMVLV MFWF MGUG MHQHUGWF", "H\\VIVJWJWIVI WHVHUIUJVKWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNQNOONPMR NIMKLOLUMXNY WXXVXSWQ RFPGOHNJMNMUNXOZQ[ S[UZVYWVWSVPUOSN", "H\\KFKL YFYIXLTQSSRWR[ SRRTQWQ[ XLSQQTPWP[R[ KJLHNFPFUIWIXHYF MHNGPGRH KJLINHPHUI", "H\\PFMGLILLMNPOTOWNXLXIWGTFPF NGMIMLNN VNWLWIVG PFOGNINLONPO TOUNVLVIUGTF POMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO MQLSLWMY WYXWXSWQ PONPMSMWNZP[ T[VZWWWSVPTO", "H\\MWMXNXNWMW WOVQURSSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNVOWOXNYMY MPLNLKMI VHWIXLXRWVVX QSORNQMNMKNHOGQF SFUGVIWLWSVWUYTZR[", "MXRFQGQIRQ RFRTST RFSFST SFTGTISQ RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "I\\MKMJNJNLLLLJMHNGPFTFWGXHYJYLXNWOSQ WHXIXMWN TFVGWIWMVOUP RQRTSTSQRQ RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "E_[O[NZNZP\\P\\N[MZMYNXPVUTXRZP[L[JZIXIUJSPORMSKSIRGPFNGMIMLNOPRTWWZY[[[\\Y\\X KZJXJUKSLR RMSI SKRG NGMK NNPQTVWYYZ N[LZKXKULSPO MINMQQUVXYZZ[Z\\Y", "H\\PBP_ TBT_ XKXJWJWLYLYJXHWGTFPFMGKIKLLNOPURWSXUXXWZ LLMNOOUQWRXT MGLILKMMONUPXRYTYWXYWZT[P[MZLYKWKUMUMWLWLV", "KYUBSDQGOKNPNTOYQ]S`Ub QHPKOOOUPYQ\\ SDRFQIPOPUQ[R^S`", "KYOBQDSGUKVPVTUYS]Q`Ob SHTKUOUUTYS\\ QDRFSITOTUS[R^Q`", "F^[FYGVHSHPGNFLFJGIIIKKMMMOLPJPHNF [FH[ [FI[ [FJ[ YTWTUUTWTYV[X[ZZ[X[VYT OGLFIIJLMMPJOG NFJGIK KMOLPH ZUWTTWUZX[[XZU YTUUTY V[ZZ[V H[J[", "E`VNULSKQKOLNMMOMRNTOUQVSVUUVS OMNONROT QKPLOOORPUQV VKVSWUYVZV\\U]R]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYXYWZ WLWSXU VKXKXSYUZV", "H]TFQGOIMLLOKSKVLYMZO[Q[TZVXXUYRZNZKYHXGVFTF QHOJNLMOLSLWMY TYVWWUXRYNYJXH TFRGPJOLNOMSMXNZO[ Q[SZUWVUWRXNXIWGVF", "H]TJO[Q[ WFUJP[ WFQ[ WFTIQKOL TJRKOL", "H]OKOJPJPLNLNJOHPGSFVFYGZIZKYMWOMUKWI[ XGYIYKXMVOSQ VFWGXIXKWMUOMU JYKXMXRYWYXX MXRZWZ MXR[U[WZXXXW", "H]OKOJPJPLNLNJOHPGSFVFYGZIZKYMXNVOSP XGYIYKXMWN VFWGXIXKWMUOSP QPSPVQWRXTXWWYUZR[O[LZKYJWJULULWKWKV VRWTWWVY SPUQVSVWUYTZR[", "H]WJR[T[ ZFXJS[ ZFT[ ZFJUZU", "H]QFLP QF[F QGYG PHUHYG[F LPMOPNSNVOWPXRXUWXUZQ[N[LZKYJWJULULWKWKV VPWRWUVXTZ SNUOVQVUUXSZQ[", "H]YJYIXIXKZKZIYGWFTFQGOIMLLOKSKVLYMZO[R[UZWXXVXSWQVPTOQOOPNQMS PINLMOLSLWMY VXWVWSVQ TFRGPJOLNOMSMXNZO[ R[TZUYVVVRUPTO", "H]NFLL [FZIXLTQRTQWP[ RSPWO[ XLRRPUOWN[P[ MIPFRFWI OGRGWI MIOHRHWIYIZH[F", "H]SFPGOHNJNMOOQPTPWOYNZLZIYGWFSF UFPG PHOJONPO OORP SPWO XNYLYIXG YGUF SFQHPJPNQP TPVOWNXLXHWF QPMQKSJUJXKZN[R[VZWYXWXTWRVQTP RPMQ NQLSKUKXLZ KZP[VZ VYWWWTVR VQSP QPOQMSLULXMZN[ R[TZUYVWVSUQTP", "H]XNWPVQTRQROQNPMNMKNIPGSFVFXGYHZKZNYRXUVXTZQ[N[LZKXKVMVMXLXLW OPNNNKOI XHYJYNXRWUUX QRPQOOOKPHQGSF VFWGXIXNWRVUUWSZQ[", "MXPXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "MXQ[P[OZOYPXQXRYR[Q]P^N_ PYPZQZQYPY Q[Q\\P^", "MXSMRNROSPTPUOUNTMSM SNSOTOTNSN PXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "MXSMRNROSPTPUOUNTMSM SNSOTOTNSN Q[P[OZOYPXQXRYR[Q]P^N_ PYPZQZQYPY Q[Q\\P^", "MXVFUFTGRT VGUGRT VGVHRT VFWGWHRT PXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "H]OKOJPJPLNLNJOHPGSFWFZG[I[KZMYNWOSPQQQSSTTT UFZG YGZIZKYMXNVO WFXGYIYKXMWNSPRQRSST PXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "MXWFUGTHSJSLTMUMVLVKUJTJ UGTITJ TKTLULUKTK", "MXVIUITHTGUFVFWGWIVKULSM UGUHVHVGUG VIVJUL", "E_\\O\\N[N[P]P]N\\M[MYNWPRXPZN[K[HZGXGVHTISKRPPROTMUKUITGRFPGOIOLPRQURWTZV[X[YYYX L[HZ IZHXHVITJSLR PPQSTYVZ K[JZIXIVJTKSMRRO OLPOQRSVUYWZXZYY", "H]TBL_ YBQ_ ZKZJYJYL[L[JZHYGVFRFOGMIMLNNPPVSWUWXVZ NLONVRWT OGNINKOMUPWRXTXWWYVZS[O[LZKYJWJULULWKWKV", "G^_BEbFb _B`BFb", "JZZBXCUERHPKNOMSMXN\\O_Qb SHQKOONTN\\ ZBWDTGRJQLPOOSN\\ NTO]P`Qb", "JZSBUEVHWLWQVUTYR\\O_LaJb VHVPUUSYQ\\ SBTDUGVP VHUQTUSXRZP]M`Jb", "J[TFSGUQTR TFTR TFUGSQTR OIPIXOYO OIYO OIOJYNYO YIXIPOOO YIOO YIYJONOO", "MWUFTGRM UGRM UFVGRM", "H\\PFOGMM PGMM PFQGMM ZFYGWM ZGWM ZF[GWM", "KZSFQGPIPKQMSNUNWMXKXIWGUFSF SFPIQMUNXKWGSF UFQGPKSNWMXIUF", "G^SFKbLb SFTFLb YFQbRb YFZFRb KP\\P\\Q KPKQ\\Q IWZWZX IWIXZX", "E^^F\\GXHUHQGOFMFKGJIJKLMNMPLQJQHOF ^FE[ ^FF[ ^FG[ XTVTTUSWSYU[W[YZZXZVXT PGMFJIKLNMQJPG OFKGJK LMPLQH YUVTSWTZW[ZXYU XTTUSY U[YZZV E[G[", "E`UQUNTLRKPKNLMMLPLSMUOVQVSUTTUQ OLNMMPMSNU RKPLOMNPNSOUPV VKUQUSVUXVZV\\U]R]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYXYWZ WKVQVSWU VKXKWQWSXUZV", "dst.size == src.size && dst.channels() == cn", "void cv::accumulate(InputArray, InputOutputArray, InputArray)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/accum.cpp", "mask.empty() || (mask.size == src.size && mask.type() == CV_8U)", "void cv::accumulateSquare(InputArray, InputOutputArray, InputArray)", "src2.size && src1.size && src2.type() == src1.type()", "void cv::accumulateProduct(InputArray, InputArray, InputOutputArray, InputArray)", "dst.size == src1.size && dst.channels() == cn", "mask.empty() || (mask.size == src1.size && mask.type() == CV_8U)", "void cv::accumulateWeighted(InputArray, InputOutputArray, double, InputArray)", "CV_IS_SEQ_CHAIN_CONTOUR( chain )", "CvSeq *icvApproximateChainTC89(CvChain *, int, CvMemStorage *, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/approx.cpp", "header_size >= (int)sizeof(CvContour)", "CvSeq *cvApproxChains(CvSeq *, CvMemStorage *, int, double, int, int)", "Unsupported sequence type", "CvSeq *cvApproxPoly(const void *, int, CvMemStorage *, int, double, int)", "NULL storage pointer ", "header_size is negative. Pass 0 to make the destination header_size == input header_size", "Input curves are not polygonal. Use cvApproxChains first", "Input curves have uknown type", "New header size must be non-less than sizeof(CvContour)", "Unknown approximation method", "Accuracy must be non-negative", "Invalid approximation method", "src.depth() == CV_8U", "void cv::Canny(InputArray, OutputArray, double, double, int, bool)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/canny.cpp", "src.size == dst.size && src.depth() == CV_8U && dst.type() == CV_8U", "void cvCanny(const CvArr *, CvArr *, double, double, int)", "virtual void (anonymous namespace)::CLAHE_Impl::apply(cv::InputArray, cv::OutputArray)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/clahe.cpp", "clipLimit", "tilesX", "tilesY", "CLAHE", "depth == CV_8U || depth == CV_16U || depth == CV_32F", "void cv::cvtColor(InputArray, OutputArray, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/color.cpp", "scn == 3 || scn == 4", "(scn == 3 || scn == 4) && depth == CV_8U", "(dcn == 3 || dcn == 4) && scn == 2 && depth == CV_8U", "scn == 2 && depth == CV_8U", "scn == 1 && (dcn == 3 || dcn == 4)", "scn == 1 && depth == CV_8U", "scn == 3 && (dcn == 3 || dcn == 4)", "(scn == 3 || scn == 4) && (depth == CV_8U || depth == CV_32F)", "scn == 3 && (dcn == 3 || dcn == 4) && (depth == CV_8U || depth == CV_32F)", "scn == 1 && dcn == 1", "Bayer->Gray demosaicing only supports 8u and 16u types", "scn == 1 && dcn == 3", "Bayer->RGB demosaicing only supports 8u and 16u types", "depth == CV_8U", "dcn == 3 || dcn == 4", "sz.width % 2 == 0 && sz.height % 3 == 0 && depth == CV_8U", "Unknown/unsupported color conversion code", "sz.width % 2 == 0 && sz.height % 2 == 0", "scn == 4 && dcn == 4", "Unsupported image depth", "src.depth() == dst.depth()", "void cvCvtColor(const CvArr *, CvArr *, int)", "whitept[1] == 1.f", "cv::Luv2RGB_f::Luv2RGB_f(int, int, const float *, const float *, bool)", "coeffs[i*3] >= 0 && coeffs[i*3+1] >= 0 && coeffs[i*3+2] >= 0 && coeffs[i*3] + coeffs[i*3+1] + coeffs[i*3+2] < 1.5f", "cv::RGB2Luv_f::RGB2Luv_f(int, int, const float *, const float *, bool)", "coeffs[j] >= 0 && coeffs[j + 1] >= 0 && coeffs[j + 2] >= 0 && coeffs[j] + coeffs[j + 1] + coeffs[j + 2] < 1.5f*LabCbrtTabScale", "cv::RGB2Lab_f::RGB2Lab_f(int, int, const float *, const float *, bool)", "coeffs[i] >= 0 && coeffs[i*3+1] >= 0 && coeffs[i*3+2] >= 0 && coeffs[i*3] + coeffs[i*3+1] + coeffs[i*3+2] < 2*(1 << lab_shift)", "cv::RGB2Lab_b::RGB2Lab_b(int, int, const float *, const float *, bool)", "hrange == 180 || hrange == 256", "cv::RGB2HSV_b::RGB2HSV_b(int, int, int)", "void cvStartReadChainPoints(CvChain *, CvChainPtReader *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/contours.cpp", "CvPoint cvReadChainPoint(CvChainPtReader *)", "CvContourScanner cvStartFindContours(void *, CvMemStorage *, int, int, int, CvPoint)", "[Start]FindContours support only 8uC1 and 32sC1 images", "void cvSubstituteContour(CvContourScanner, CvSeq *)", "CvSeq *cvFindNextContour(CvContourScanner)", "CvSeq *cvEndFindContours(CvContourScanner *)", "NULL double CvSeq pointer", "int cvFindContours(void *, CvMemStorage *, CvSeq **, int, int, int, CvPoint)", "Nonzero offset is not supported in CV_LINK_RUNS yet", "ci.isContinuous()", "void cv::findContours(InputOutputArray, OutputArrayOfArrays, OutputArray, int, int, Point)", "0 <= contourIdx && contourIdx < (int)last", "void cv::drawContours(InputOutputArray, InputArrayOfArrays, int, const Scalar &, int, int, InputArray, int, Point)", "npoints > 0", "hierarchy.total() == ncontours && hierarchy.type() == CV_32SC4", "npoints >= 0 && (depth == CV_32S || depth == CV_32F)", "void cv::approxPolyDP(InputArray, OutputArray, double, bool)", "curve.checkVector(2) >= 0 && (curve.depth() == CV_32F || curve.depth() == CV_32S)", "double cv::arcLength(InputArray, bool)", "points.checkVector(2) >= 0 && (points.depth() == CV_32F || points.depth() == CV_32S)", "cv::Rect cv::boundingRect(InputArray)", "contour.checkVector(2) >= 0 && (contour.depth() == CV_32F || contour.depth() == CV_32S)", "double cv::contourArea(InputArray, bool)", "cv::RotatedRect cv::minAreaRect(InputArray)", "void cv::minEnclosingCircle(InputArray, Point2f &, float &)", "contour1.checkVector(2) >= 0 && contour2.checkVector(2) >= 0 && (contour1.depth() == CV_32F || contour1.depth() == CV_32S) && contour1.depth() == contour2.depth()", "double cv::matchShapes(InputArray, InputArray, int, double)", "nelems >= 0 && (depth == CV_32F || depth == CV_32S)", "void cv::convexHull(InputArray, OutputArray, bool, bool)", "ptnum > 3", "void cv::convexityDefects(InputArray, InputArray, OutputArray)", "hull.checkVector(1, CV_32S) > 2", "0 <= idx0 && idx0 < ptnum", "0 <= idx1 && idx1 < ptnum", "0 <= idx2 && idx2 < ptnum", "d.depth >= 0", "bool cv::isContourConvex(InputArray)", "cv::RotatedRect cv::fitEllipse(InputArray)", "(is2d || is3d) && (points.depth() == CV_32F || points.depth() == CV_32S)", "void cv::fitLine(InputArray, OutputArray, int, double, double, double)", "l.isContinuous()", "double cv::pointPolygonTest(InputArray, Point2f, bool)", "!_seq || _seq->elem_size == sizeof(_Tp)", "cv::Seq<CvConvexityDefect>::Seq(const CvSeq *) [_Tp = CvConvexityDefect]", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/core/include/opencv2/core/operations.hpp", "cv::Seq<CvSeq *>::Seq(const CvSeq *) [_Tp = CvSeq *]", "int icvFindContoursInInterval(const CvArr *, CvMemStorage *, CvSeq **, int)", "Contour header size must be >= sizeof(CvContour)", "Input array must be 8uC1 or 8sC1", "CvSeq *cvConvexHull2(const CvArr *, void *, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/convhull.cpp", "Destination must be valid memory storage or matrix", "The hull matrix should be continuous and have a single row or a single column", "The hull matrix size might be not enough to fit the hull", "The hull matrix must have the same type as input or 32sC1 (integers)", "Point sequence can not be empty if the output is matrix", "Input sequence is not a sequence of points", "CvSeq *cvConvexityDefects(const CvArr *, const CvArr *, CvMemStorage *)", "Floating-point coordinates are not supported here", "Convex hull must represented as a sequence of indices or sequence of pointers", "Convex hull is neither sequence nor matrix", "The matrix should be 1-dimensional and continuous array of int's", "Convex hull is larger than the point sequence", "Input sequence must be polygon (closed 2d curve)", "int cvCheckContourConvexity(const CvArr *)", "CV_SEQ_ELTYPE(contour) == CV_32FC2", "void icvCalcAndWritePtIndices(CvPoint **, int *, int, int, CvSeq *, CvSeqWriter *)", "src.type() == CV_8UC1 || src.type() == CV_32FC1", "void cv::preCornerDetect(InputArray, OutputArray, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/corner.cpp", "src.size() == dst.size() && dst.type() == CV_32FC1", "void cvCornerMinEigenVal(const CvArr *, CvArr *, int, int)", "void cvCornerHarris(const CvArr *, CvArr *, int, int, double)", "src.rows == dst.rows && src.cols*6 == dst.cols*dst.channels() && dst.depth() == CV_32F", "void cvCornerEigenValsAndVecs(const void *, void *, int, int)", "void cvPreCornerDetect(const void *, void *, int)", "void cv::cornerEigenValsVecs(const cv::Mat &, cv::Mat &, int, int, int, double, int)", "The source image must be 8-bit single-channel (CV_8UC1)", "void cvFindCornerSubPix(const void *, CvPoint2D32f *, int, CvSize, CvSize, CvTermCriteria)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/cornersubpix.cpp", "(icvGetRectSubPix_8u32f_C1R( (uchar*)src->data.ptr, src->step, size, src_buffer, (win_w + 2) * sizeof( src_buffer[0] ), cvSize( win_w + 2, win_h + 2 ), cI )) >= 0", "ncorners >= 0 && corners.depth() == CV_32F", "void cv::cornerSubPix(InputArray, InputOutputArray, Size, Size, cv::TermCriteria)", "src.size() == dst.size() && src.channels() == dst.channels()", "void cvSobel(const void *, void *, int, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/deriv.cpp", "void cvLaplace(const void *, void *, int)", "ktype == CV_32F || ktype == CV_64F", "void cv::getSobelKernels(OutputArray, OutputArray, int, int, int, bool, int)", "The kernel size must be odd and not larger than 31", "dx >= 0 && dy >= 0 && dx+dy > 0", "ksize > order", "void cv::getScharrKernels(OutputArray, OutputArray, int, int, bool, int)", "dx >= 0 && dy >= 0 && dx+dy == 1", "source image must be 8uC1 and the distance map must be 32fC1 (or 8uC1 in case of simple L1 distance transform)", "void cvDistTransform(const void *, void *, int, int, const float *, void *, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/distransform.cpp", "the source and the destination images must be of the same size", "Mask size should be 3 or 5 or 0 (presize)", "the output array of labels must be 32sC1", "the array of labels has a different size", "3x3 mask can not be used for \"labeled\" distance transform. Use 5x5 mask", "CV_IS_MASK_ARR( src ) && CV_MAT_TYPE( dst->type ) == CV_8UC1", "void icvDistanceATS_L1_8u(const CvMat *, CvMat *)", "CV_ARE_SIZES_EQ( src, dst )", "void icvTrueDistTrans(const CvMat *, CvMat *)", "The input image must have 8uC1 type and the output one must have 32fC1 type", "The arrays must have equal number of columns (which is number of dimensions but 1)", "float cvCalcEMD2(const CvArr *, const CvArr *, int, CvDistanceFunction, const CvArr *, CvArr *, float *, void *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/emd.cpp", "The array must have equal types", "The signatures must be 32fC1", "The flow matrix size does not match to the signatures' sizes", "The flow matrix must be 32fC1", "Only one of cost matrix or distance function should be non-NULL in case of user-defined distance", "The lower boundary can not be calculated if the cost matrix is used", "The cost matrix size does not match to the signatures' sizes", "The cost matrix must be 32fC1", "In case of user-defined distance Distance function is undefined", "Number of dimensions can be 0 only if a user-defined metric is used", "Bad or unsupported metric type", "int icvInitEMD(const float *, int, const float *, int, int, CvDistanceFunction, void *, const float *, int, CvEMDState *, float *, cv::AutoBuffer<char> &)", "qualityLevel > 0 && minDistance >= 0 && maxCorners >= 0", "void cv::goodFeaturesToTrack(InputArray, OutputArray, int, double, double, InputArray, int, bool, double)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/featureselect.cpp", "mask.empty() || (mask.type() == CV_8UC1 && mask.size() == image.size())", "_corners && _corner_count", "void cvGoodFeaturesToTrack(const void *, void *, void *, CvPoint2D32f *, int *, double, double, const void *, int, int, double)", "Unknown/unsupported border type", "int cv::borderInterpolate(int, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/filter.cpp", "columnBorderType != BORDER_WRAP", "void cv::FilterEngine::init(const Ptr<cv::BaseFilter> &, const Ptr<cv::BaseRowFilter> &, const Ptr<cv::BaseColumnFilter> &, int, int, int, int, int, const Scalar &)", "!rowFilter.empty() && !columnFilter.empty()", "bufType == srcType", "0 <= anchor.x && anchor.x < ksize.width && 0 <= anchor.y && anchor.y < ksize.height", "roi.x >= 0 && roi.y >= 0 && roi.width >= 0 && roi.height >= 0 && roi.x + roi.width <= wholeSize.width && roi.y + roi.height <= wholeSize.height", "virtual int cv::FilterEngine::start(Size, Rect, int)", "srcRoi.x >= 0 && srcRoi.y >= 0 && srcRoi.width >= 0 && srcRoi.height >= 0 && srcRoi.x + srcRoi.width <= src.cols && srcRoi.y + srcRoi.height <= src.rows", "virtual int cv::FilterEngine::start(const cv::Mat &, const Rect &, bool, int)", "wholeSize.width > 0 && wholeSize.height > 0", "virtual int cv::FilterEngine::proceed(const uchar *, int, int, uchar *, int)", "src && dst && count > 0", "srcY >= startY", "dstY <= roi.height", "src.type() == srcType && dst.type() == dstType", "virtual void cv::FilterEngine::apply(const cv::Mat &, cv::Mat &, const Rect &, Point, bool)", "dstOfs.x >= 0 && dstOfs.y >= 0 && dstOfs.x + srcRoi.width <= dst.cols && dstOfs.y + srcRoi.height <= dst.rows", "_kernel.channels() == 1", "int cv::getKernelType(InputArray, Point)", "cn == CV_MAT_CN(bufType) && ddepth >= std::max(sdepth, CV_32S) && kernel.type() == ddepth", "cv::Ptr<cv::BaseRowFilter> cv::getLinearRowFilter(int, int, InputArray, int, int)", "Unsupported combination of source format (=%d), and buffer format (=%d)", "cn == CV_MAT_CN(bufType) && sdepth >= std::max(ddepth, CV_32S) && kernel.type() == sdepth", "cv::Ptr<cv::BaseColumnFilter> cv::getLinearColumnFilter(int, int, InputArray, int, int, double, int)", "Unsupported combination of buffer format (=%d), and destination format (=%d)", "cn == CV_MAT_CN(_dstType)", "cv::Ptr<cv::FilterEngine> cv::createSeparableLinearFilter(int, int, InputArray, InputArray, Point, double, int, int, const Scalar &)", "ktype == CV_8U || ktype == CV_32S || ktype == CV_32F || ktype == CV_64F", "void cv::preprocess2DKernel(const cv::Mat &, vector<Point> &, vector<uchar> &)", "cn == CV_MAT_CN(dstType) && ddepth >= sdepth", "cv::Ptr<cv::BaseFilter> cv::getLinearFilter(int, int, InputArray, Point, double, int)", "Unsupported combination of source format (=%d), and destination format (=%d)", "cv::Ptr<cv::FilterEngine> cv::createLinearFilter(int, int, InputArray, Point, double, int, int, const Scalar &)", "void cvFilter2D(const CvArr *, CvArr *, const CvMat *, CvPoint)", "_kernel.type() == DataType<KT>::type", "cv::Filter2D<double, cv::Cast<double, double>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = double, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::Filter2D<float, cv::Cast<float, float>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = float, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "cv::Filter2D<short, cv::Cast<double, double>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = short, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::Filter2D<short, cv::Cast<float, float>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = short, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "cv::Filter2D<short, cv::Cast<float, short>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = short, CastOp = cv::Cast<float, short>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned short, cv::Cast<double, double>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned short, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned short, cv::Cast<float, float>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned short, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned short, cv::Cast<float, unsigned short>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned short, CastOp = cv::Cast<float, unsigned short>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned char, cv::Cast<double, double>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned char, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned char, cv::Cast<float, float>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned char, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned char, cv::Cast<float, short>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned char, CastOp = cv::Cast<float, short>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned char, cv::Cast<float, unsigned short>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned char, CastOp = cv::Cast<float, unsigned short>, VecOp = cv::FilterNoVec]", "cv::Filter2D<unsigned char, cv::Cast<float, unsigned char>, cv::FilterNoVec>::Filter2D(const cv::Mat &, Point, double, const CastOp &, const VecOp &) [ST = unsigned char, CastOp = cv::Cast<float, unsigned char>, VecOp = cv::FilterNoVec]", "(symmetryType & (KERNEL_SYMMETRICAL | KERNEL_ASYMMETRICAL)) != 0", "cv::SymmColumnFilter<cv::Cast<double, double>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, double>, VecOp = cv::ColumnNoVec]", "kernel.type() == DataType<ST>::type && (kernel.rows == 1 || kernel.cols == 1)", "cv::ColumnFilter<cv::Cast<double, double>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, double>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<float, float>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, float>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<float, float>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, float>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<double, short>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, short>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<double, short>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, short>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<float, short>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, short>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<float, short>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, short>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<int, short>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<int, short>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<int, short>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<int, short>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<double, unsigned short>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, unsigned short>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<double, unsigned short>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, unsigned short>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<float, unsigned short>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, unsigned short>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<float, unsigned short>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, unsigned short>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<double, unsigned char>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<double, unsigned char>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<double, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::Cast<float, unsigned char>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::Cast<float, unsigned char>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<cv::FixedPtCastEx<int, unsigned char>, cv::ColumnNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<cv::FixedPtCastEx<int, unsigned char>, cv::ColumnNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "this->ksize == 3", "cv::SymmColumnSmallFilter<cv::Cast<float, float>, cv::SymmColumnSmallNoVec>::SymmColumnSmallFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::SymmColumnFilter<cv::Cast<float, float>, cv::SymmColumnSmallNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::ColumnFilter<cv::Cast<float, float>, cv::SymmColumnSmallNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::SymmColumnSmallFilter<cv::Cast<int, short>, cv::SymmColumnSmallNoVec>::SymmColumnSmallFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<int, short>, VecOp = cv::SymmColumnSmallNoVec]", "cv::SymmColumnFilter<cv::Cast<int, short>, cv::SymmColumnSmallNoVec>::SymmColumnFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::Cast<int, short>, VecOp = cv::SymmColumnSmallNoVec]", "cv::ColumnFilter<cv::Cast<int, short>, cv::SymmColumnSmallNoVec>::ColumnFilter(const cv::Mat &, int, double, const CastOp &, const VecOp &) [CastOp = cv::Cast<int, short>, VecOp = cv::SymmColumnSmallNoVec]", "cv::SymmColumnSmallFilter<cv::FixedPtCastEx<int, unsigned char>, cv::ColumnNoVec>::SymmColumnSmallFilter(const cv::Mat &, int, double, int, const CastOp &, const VecOp &) [CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "kernel.type() == DataType<DT>::type && (kernel.rows == 1 || kernel.cols == 1)", "cv::RowFilter<double, double, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = double, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<float, double, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = float, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<float, float, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = float, DT = float, VecOp = cv::RowNoVec]", "cv::RowFilter<short, double, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = short, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<short, float, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = short, DT = float, VecOp = cv::RowNoVec]", "cv::RowFilter<unsigned short, double, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = unsigned short, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<unsigned short, float, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = unsigned short, DT = float, VecOp = cv::RowNoVec]", "cv::RowFilter<unsigned char, double, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = unsigned char, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<unsigned char, float, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = unsigned char, DT = float, VecOp = cv::RowNoVec]", "cv::RowFilter<unsigned char, int, cv::RowNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = unsigned char, DT = int, VecOp = cv::RowNoVec]", "(symmetryType & (KERNEL_SYMMETRICAL | KERNEL_ASYMMETRICAL)) != 0 && this->ksize <= 5", "cv::SymmRowSmallFilter<float, float, cv::SymmRowSmallNoVec>::SymmRowSmallFilter(const cv::Mat &, int, int, const VecOp &) [ST = float, DT = float, VecOp = cv::SymmRowSmallNoVec]", "cv::RowFilter<float, float, cv::SymmRowSmallNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = float, DT = float, VecOp = cv::SymmRowSmallNoVec]", "cv::SymmRowSmallFilter<unsigned char, int, cv::SymmRowSmallNoVec>::SymmRowSmallFilter(const cv::Mat &, int, int, const VecOp &) [ST = unsigned char, DT = int, VecOp = cv::SymmRowSmallNoVec]", "cv::RowFilter<unsigned char, int, cv::SymmRowSmallNoVec>::RowFilter(const cv::Mat &, int, const VecOp &) [ST = unsigned char, DT = int, VecOp = cv::SymmRowSmallNoVec]", "anchor.inside(Rect(0, 0, ksize.width, ksize.height))", "Point cv::normalizeAnchor(Point, Size)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/precomp.hpp", "Number of channels in input image must be 1 or 3", "void cvFloodFill(CvArr *, CvPoint, CvScalar, CvScalar, CvScalar, CvConnectedComp *, int, CvArr *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/floodfill.cpp", "Connectivity must be 4, 0(=4) or 8", "lo_diff and up_diff must be non-negative", "Seed point is outside of image", "mask must be 2 pixel wider and 2 pixel taller than filled image", "cv::Mat cv::getGaborKernel(Size, double, double, double, double, double, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/gabor.cpp", "!GHT_Ballard_Pos_info_auto.name().empty()", "static Ptr<cv::GeneralizedHough> cv::GeneralizedHough::create(int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/generalized_hough.cpp", "!GHT_Ballard_PosScale_info_auto.name().empty()", "!GHT_Ballard_PosRotation_info_auto.name().empty()", "!GHT_Guil_Full_info_auto.name().empty()", "Unsupported method", "templ.type() == CV_8UC1", "void cv::GeneralizedHough::setTemplate(InputArray, int, Point)", "cannyThreshold > 0", "image.type() == CV_8UC1", "void cv::GeneralizedHough::detect(InputArray, OutputArray, OutputArray, int)", "levels > 0", "void (anonymous namespace)::GHT_Guil_Full::calcPosition(double, int, double, int)", "templFeatures.size() == static_cast<size_t>(levels + 1)", "imageFeatures.size() == templFeatures.size()", "posThresh > 0", "void (anonymous namespace)::GHT_Guil_Full::calcScale(double)", "minScale > 0.0 && minScale < maxScale", "scaleStep > 0.0", "scaleThresh > 0", "void (anonymous namespace)::GHT_Guil_Full::calcOrientation()", "minAngle >= 0.0 && minAngle < maxAngle && maxAngle <= 360.0", "angleStep > 0.0 && angleStep < 360.0", "angleThresh > 0", "void (anonymous namespace)::GHT_Guil_Full::buildFeatureList(const cv::Mat &, const cv::Mat &, const cv::Mat &, vector<vector<(anonymous namespace)::GHT_Guil_Full::Feature> > &, Point2d)", "edges.type() == CV_8UC1", "void (anonymous namespace)::GHT_Guil_Full::getContourPoints(const cv::Mat &, const cv::Mat &, const cv::Mat &, vector<(anonymous namespace)::GHT_Guil_Full::ContourPoint> &)", "dx.type() == CV_32FC1 && dx.size == edges.size", "dy.type() == dx.type() && dy.size == edges.size", "!hasVotes || voteOutBuf.size() == posOutBuf.size()", "void (anonymous namespace)::GHT_Pos::convertTo(OutputArray, OutputArray)", "!hasVotes || voteOutBuf.size() == oldSize", "void (anonymous namespace)::GHT_Pos::filterMinDist()", "minDist", "Minimum distance between the centers of the detected objects.", "maxSize", "Maximal size of inner buffers.", "Angle difference in degrees between two points in feature.", "levels", "Feature table levels.", "angleEpsilon", "Maximal difference between angles that treated as equal.", "minAngle", "Minimal rotation angle to detect in degrees.", "maxAngle", "Maximal rotation angle to detect in degrees.", "angleStep", "Angle step in degrees.", "angleThresh", "Angle threshold.", "minScale", "Minimal scale to detect.", "maxScale", "Maximal scale to detect.", "scaleStep", "Scale step.", "scaleThresh", "Scale threshold.", "Inverse ratio of the accumulator resolution to the image resolution.", "posThresh", "Position threshold.", "votesThreshold > 0", "virtual void (anonymous namespace)::GHT_Ballard_PosRotation::findPosInHist()", "imageEdges.type() == CV_8UC1", "virtual void (anonymous namespace)::GHT_Ballard_PosRotation::calcHist()", "imageDx.type() == CV_32FC1 && imageDx.size() == imageSize", "imageDy.type() == imageDx.type() && imageDy.size() == imageSize", "levels > 0 && r_table.size() == static_cast<size_t>(levels + 1)", "templEdges.type() == CV_8UC1", "virtual void (anonymous namespace)::GHT_Ballard_Pos::processTempl()", "templDx.type() == CV_32FC1 && templDx.size() == templSize", "templDy.type() == templDx.type() && templDy.size() == templSize", "R-Table levels.", "votesThreshold", "The accumulator threshold for the template centers at the detection stage. The smaller it is, the more false positions may be detected.", "virtual void (anonymous namespace)::GHT_Ballard_Pos::findPosInHist()", "virtual void (anonymous namespace)::GHT_Ballard_Pos::calcHist()", "virtual void (anonymous namespace)::GHT_Ballard_PosScale::findPosInHist()", "virtual void (anonymous namespace)::GHT_Ballard_PosScale::calcHist()", "GeneralizedHough.POSITION_SCALE_ROTATION", "GeneralizedHough.POSITION_ROTATION", "GeneralizedHough.POSITION_SCALE", "GeneralizedHough.POSITION", "NULL vertex array pointer", "void cvBoxPoints(CvBox2D, CvPoint2D32f *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/geometry.cpp", "Chains are not supported. Convert them to polygonal representation using cvApproxChains()", "double cvPointPolygonTest(const CvArr *, CvPoint2D32f, int)", "Input contour is neither a valid sequence nor a matrix", "p1.depth() == CV_32S || p1.depth() == CV_32F", "float cv::intersectConvexConvex(InputArray, InputArray, OutputArray, bool)", "p2.depth() == CV_32S || p2.depth() == CV_32F", "n >= 0 && m >= 0", "temp.ptr<Point2f>() == dst", "_model must have CV_64FC1 type, rows == 1 and cols == 13*componentsCount", "GMM::GMM(cv::Mat &)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/grabcut.cpp", "covDeterms[ci] > std::numeric_limits<double>::epsilon()", "double GMM::operator()(int, const Vec3d) const", "dtrm > std::numeric_limits<double>::epsilon()", "void GMM::calcInverseCovAndDeterm(int)", "image is empty", "void cv::grabCut(InputArray, InputOutputArray, Rect, InputOutputArray, InputOutputArray, int, int)", "image mush have CV_8UC3 type", "i>=0 && i<(int)vtcs.size()", "bool GCGraph<double>::inSourceSegment(int) [TWeight = double]", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/gcgraph.hpp", "void GCGraph<double>::addEdges(int, int, TWeight, TWeight) [TWeight = double]", "j>=0 && j<(int)vtcs.size()", "w>=0 && revw>=0", "i != j", "void GCGraph<double>::addTermWeights(int, TWeight, TWeight) [TWeight = double]", "!bgdSamples.empty() && !fgdSamples.empty()", "void initGMMs(const cv::Mat &, const cv::Mat &, GMM &, GMM &)", "mask is empty", "void checkMask(const cv::Mat &, const cv::Mat &)", "mask must have CV_8UC1 type", "mask must have as many rows and cols as img", "mask element value must be equelGC_BGD or GC_FGD or GC_PR_BGD or GC_PR_FGD", "dims > 0 && histSize", "void cv::calcHist(const cv::Mat *, int, const int *, InputArray, OutputArray, int, const int *, const float **, bool, bool)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/histogram.cpp", "!mask.data || mask.type() == CV_8UC1", "nimages > 0 && dims > 0", "void cv::calcHist(InputArrayOfArrays, const vector<int> &, InputArray, OutputArray, const vector<int> &, const vector<float> &, bool)", "rsz == dims*2 || (rsz == 0 && images.depth(0) == CV_8U)", "csz == 0 || csz == dims", "dims > 0 && hist.data", "void cv::calcBackProject(const cv::Mat *, int, const int *, InputArray, OutputArray, const float **, double, bool)", "void cv::calcBackProject(const cv::Mat *, int, const int *, const cv::SparseMat &, OutputArray, const float **, double, bool)", "H0.isContinuous()", "void cv::calcBackProject(InputArrayOfArrays, const vector<int> &, InputArray, OutputArray, const vector<float> &, double)", "nimages > 0", "rsz == dims*2 || (rsz == 2 && _1d) || (rsz == 0 && images.depth(0) == CV_8U)", "csz == 0 || csz == dims || (csz == 1 && _1d)", "H1.type() == H2.type() && H1.type() == CV_32F", "double cv::compareHist(InputArray, InputArray, int)", "it.planes[0].isContinuous() && it.planes[1].isContinuous()", "Unknown comparison method", "dims > 0 && dims == H2.dims() && H1.type() == H2.type() && H1.type() == CV_32F", "double cv::compareHist(const cv::SparseMat &, const cv::SparseMat &, int)", "H1.size(i) == H2.size(i)", "Number of dimensions is out of range", "CvHistogram *cvCreateHist(int, int *, CvHistType, float **, int)", "Null <sizes> pointer", "Invalid histogram type", "Null histogram header pointer", "CvHistogram *cvMakeHistHeaderForArray(int, int *, CvHistogram *, float *, float **, int)", "Only uniform bin ranges can be used here (to avoid memory allocation)", "void cvReleaseHist(CvHistogram **)", "Invalid histogram header", "void cvClearHist(CvHistogram *)", "void cvThreshHist(CvHistogram *, double)", "void cvNormalizeHist(CvHistogram *, double)", "void cvGetMinMaxHistValue(const CvHistogram *, float *, float *, int *, int *)", "Invalid histogram header[s]", "double cvCompareHist(const CvHistogram *, const CvHistogram *, int)", "One of histograms is sparse and other is not", "The histograms have different numbers of dimensions", "The histograms have different sizes", "Destination double pointer is NULL", "void cvCopyHist(const CvHistogram *, CvHistogram **)", "NULL ranges pointer", "void cvSetHistBinRanges(CvHistogram *, float **, int)", "One of <ranges> elements is NULL", "Bin ranges should go in ascenting order", "Bad histogram pointer", "void cvCalcArrHist(CvArr **, CvHistogram *, int, const CvArr *)", "Null double array pointer", "void cvCalcArrBackProject(CvArr **, CvArr *, const CvHistogram *)", "_dst.size() == images[0].size() && _dst.depth() == images[0].depth()", "void cvCalcArrBackProjectPatch(CvArr **, CvArr *, CvSize, CvHistogram *, int, double)", "Bad normalization factor (set it to 1.0 if unsure)", "The patch width and height must be positive", "Resultant image must have 32fC1 type", "The output map must be (W-w+1 x H-h+1), where the input images are (W x H) each and the patch is (w x h)", "NULL histogram array pointer", "void cvCalcBayesianProb(CvHistogram **, int, CvHistogram **)", "Too small number of histograms", "The function supports dense histograms only", "scale must be positive", "void cvCalcProbDensity(const CvHistogram *, const CvHistogram *, CvHistogram *, double)", "Invalid histogram pointer[s]", "All histograms must have 32fC1 type", "void cv::equalizeHist(InputArray, OutputArray)", "opencv-hist", "type", "is_uniform", "have_ranges", "bins", "thresh", "Expected CvMatND", "void *icvReadHist(CvFileStorage *, CvFileNode *)", "Unknown Histogram type", "'thresh' node is missing", "void cv::calcHist(const cv::Mat *, int, const int *, const cv::Mat &, cv::SparseMat &, int, const int *, const float **, bool, bool, bool)", "channels != 0 || nimages == dims", "void cv::histPrepareImages(const cv::Mat *, int, const int *, const cv::Mat &, int, const int *, const float **, bool, vector<uchar *> &, vector<int> &, Size &, vector<double> &)", "images[j].channels() == 1", "c >= 0", "j < nimages", "images[j].size() == imsize && images[j].depth() == depth", "mask.size() == imsize && mask.channels() == 1", "ranges[i] && ranges[i][0] < ranges[i][1]", "ranges[i][k] < ranges[i][k+1]", "The source image must be 8-bit, single-channel", "CvSeq *cvHoughLines2(CvArr *, void *, int, double, double, int, double, double)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/hough.cpp", "NULL destination", "rho, theta and threshold must be positive", "The destination matrix should be continuous and have a single row or a single column", "The destination matrix data type is inappropriate, see the manual", "Destination is not CvMemStorage* nor CvMat*", "Unrecognized method id", "CvSeq *cvHoughCircles(CvArr *, void *, int, double, double, double, double, int, int)", "dp, min_dist, canny_threshold and acc_threshold must be all positive numbers", "CV_IS_MAT(image) && CV_MAT_TYPE(image->type) == CV_8UC1", "void icvHoughLinesProbabilistic(CvMat *, float, float, int, int, int, CvSeq *, int)", "CV_IS_MAT(img) && CV_MAT_TYPE(img->type) == CV_8UC1", "void icvHoughLinesSDiv(const CvMat *, float, float, int, int, int, CvSeq *, int)", "linesMax > 0 && rho > 0 && theta > 0", "void icvHoughLinesStandard(const CvMat *, float, float, int, CvSeq *, int)", "ssize.area() > 0", "void cv::resize(InputArray, OutputArray, Size, double, double, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/imgwarp.cpp", "dsize.area() || (inv_scale_x > 0 && inv_scale_y > 0)", "dsize.area()", "func != 0 && cn <= 4", "Unknown interpolation method", "map1.size().area() > 0", "void cv::remap(InputArray, OutputArray, InputArray, InputArray, int, int, const Scalar &)", "!map2.data || (map2.size() == map1.size())", "nnfunc != 0", "ifunc != 0", "((map1.type() == CV_32FC2 || map1.type() == CV_16SC2) && !map2.data) || (map1.type() == CV_32FC1 && map2.type() == CV_32FC1)", "(m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) || (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) || (m1type == CV_32FC1 && m2type == CV_32FC1) || (m1type == CV_32FC2 && !m2->data)", "void cv::convertMaps(InputArray, InputArray, OutputArray, OutputArray, int, bool)", "dstm1type == CV_16SC2 || dstm1type == CV_32FC1 || dstm1type == CV_32FC2", "Unsupported combination of input/output matrices", "src.cols > 0 && src.rows > 0", "void cv::warpAffine(InputArray, OutputArray, InputArray, Size, int, int, const Scalar &)", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 2 && M0.cols == 3", "void cv::warpPerspective(InputArray, OutputArray, InputArray, Size, int, int, const Scalar &)", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 3 && M0.cols == 3", "matM.rows == 2 && matM.cols == 3", "void cv::invertAffineTransform(InputArray, OutputArray)", "src.checkVector(2, CV_32F) == 4 && dst.checkVector(2, CV_32F) == 4", "cv::Mat cv::getPerspectiveTransform(InputArray, InputArray)", "src.checkVector(2, CV_32F) == 3 && dst.checkVector(2, CV_32F) == 3", "cv::Mat cv::getAffineTransform(InputArray, InputArray)", "src.type() == dst.type()", "void cvResize(const CvArr *, CvArr *, int)", "void cvWarpAffine(const CvArr *, CvArr *, const CvMat *, int, CvScalar)", "void cvWarpPerspective(const CvArr *, CvArr *, const CvMat *, int, CvScalar)", "src.type() == dst.type() && dst.size() == mapx.size()", "void cvRemap(const CvArr *, CvArr *, const CvArr *, const CvArr *, int, CvScalar)", "M.size() == M0.size()", "CvMat *cv2DRotationMatrix(CvPoint2D32f, double, double, CvMat *)", "CvMat *cvGetPerspectiveTransform(const CvPoint2D32f *, const CvPoint2D32f *, CvMat *)", "CvMat *cvGetAffineTransform(const CvPoint2D32f *, const CvPoint2D32f *, CvMat *)", "void cvLogPolar(const CvArr *, CvArr *, CvPoint2D32f, double, int)", "M should be >0", "void cvLinearPolar(const CvArr *, CvArr *, CvPoint2D32f, double, int)", "cn <= 4 && ssize.area() > 0", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const Scalar &) [CastOp = cv::Cast<double, double>, VecOp = cv::RemapNoVec, AT = float]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const Scalar &) [CastOp = cv::Cast<float, float>, VecOp = cv::RemapNoVec, AT = float]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const Scalar &) [CastOp = cv::Cast<float, short>, VecOp = cv::RemapNoVec, AT = float]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const Scalar &) [CastOp = cv::Cast<float, unsigned short>, VecOp = cv::RemapNoVec, AT = float]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const Scalar &) [CastOp = cv::FixedPtCast<int, unsigned char, 15>, VecOp = cv::RemapNoVec, AT = short]", "ksize <= MAX_ESIZE", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<double, double, float>, cv::VResizeLanczos4<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLanczos4<double, double, float>, VResize = cv::VResizeLanczos4<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<float, float, float>, cv::VResizeLanczos4<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLanczos4<float, float, float>, VResize = cv::VResizeLanczos4<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<short, float, float>, cv::VResizeLanczos4<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLanczos4<short, float, float>, VResize = cv::VResizeLanczos4<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<unsigned short, float, float>, cv::VResizeLanczos4<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLanczos4<unsigned short, float, float>, VResize = cv::VResizeLanczos4<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<unsigned char, int, short>, cv::VResizeLanczos4<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLanczos4<unsigned char, int, short>, VResize = cv::VResizeLanczos4<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<double, double, float>, cv::VResizeCubic<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeCubic<double, double, float>, VResize = cv::VResizeCubic<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<float, float, float>, cv::VResizeCubic<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeCubic<float, float, float>, VResize = cv::VResizeCubic<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<short, float, float>, cv::VResizeCubic<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeCubic<short, float, float>, VResize = cv::VResizeCubic<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<unsigned short, float, float>, cv::VResizeCubic<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeCubic<unsigned short, float, float>, VResize = cv::VResizeCubic<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<unsigned char, int, short>, cv::VResizeCubic<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeCubic<unsigned char, int, short>, VResize = cv::VResizeCubic<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<double, double, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLinear<double, double, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<float, float, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLinear<float, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<short, float, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLinear<short, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<unsigned short, float, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLinear<unsigned short, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<unsigned char, int, short, 2048, cv::HResizeNoVec>, cv::VResizeLinear<uchar, int, short, FixedPtCast<int, uchar, INTER_RESIZE_COEF_BITS * 2>, VResizeLinearVec_32s8u> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const AT *, const AT *, const Size &, const Size &, int, int, int) [HResize = cv::HResizeLinear<unsigned char, int, short, 2048, cv::HResizeNoVec>, VResize = cv::VResizeLinear<uchar, int, short, FixedPtCast<int, uchar, INTER_RESIZE_COEF_BITS * 2>, VResizeLinearVec_32s8u>]", "Unknown/unsupported interpolation type", "const void *cv::initInterTab2D(int, bool)", "void cv::initInterTab1D(int, float *, int)", "NULL pointer to line parameters", "void cvFitLine(const CvArr *, int, double, double, double, float *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/linefit.cpp", "The sequence has no points", "Input sequence must consist of 2d points or 3d points", "Input array is not a sequence nor matrix", "Input array must be 1d continuous array of 2d or 3d points", "Both reps and aeps must be non-negative", "User-defined distance is not allowed", "(icvFitLine2D( (CvPoint2D32f*)points, ptseq->total, dist, (float)param, (float)reps, (float)aeps, line )) >= 0", "(icvFitLine3D( (CvPoint3D32f*)points, ptseq->total, dist, (float)param, (float)reps, (float)aeps, line )) >= 0", "double cvMatchShapes(const void *, const void *, int, double)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/matchcontours.cpp", "The passed sequence is not a valid contour", "void cvMoments(const void *, CvMoments *, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/moments.cpp", "Invalid image type", "void cvGetHuMoments(CvMoments *, CvHuMoments *)", "double cvGetSpatialMoment(CvMoments *, int, int)", "double cvGetCentralMoment(CvMoments *, int, int)", "hu.isContinuous()", "void cv::HuMoments(const cv::Moments &, OutputArray)", "op == MORPH_ERODE || op == MORPH_DILATE", "cv::Ptr<cv::BaseRowFilter> cv::getMorphologyRowFilter(int, int, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/morph.cpp", "Unsupported data type (=%d)", "cv::Ptr<cv::BaseColumnFilter> cv::getMorphologyColumnFilter(int, int, int, int)", "cv::Ptr<cv::BaseFilter> cv::getMorphologyFilter(int, int, InputArray, Point)", "depth == CV_8U || depth == CV_16U || depth == CV_16S || depth == CV_32F || depth == CV_64F", "cv::Ptr<cv::FilterEngine> cv::createMorphologyFilter(int, int, InputArray, Point, int, int, const Scalar &)", "shape == MORPH_RECT || shape == MORPH_CROSS || shape == MORPH_ELLIPSE", "cv::Mat cv::getStructuringElement(int, Size, Point)", "unknown morphological operation", "void cv::morphologyEx(InputArray, OutputArray, int, InputArray, Point, int, int, const Scalar &)", "cols > 0 && rows > 0 && anchor.inside(cv::Rect(0,0,cols,rows)) && (shape != CV_SHAPE_CUSTOM || values != 0)", "IplConvKernel *cvCreateStructuringElementEx(int, int, int, int, int, int *)", "void cvReleaseStructuringElement(IplConvKernel **)", "void cvErode(const CvArr *, CvArr *, IplConvKernel *, int)", "void cvDilate(const CvArr *, CvArr *, IplConvKernel *, int)", "void cvMorphologyEx(const void *, void *, void *, IplConvKernel *, int, int)", "_kernel.type() == CV_8U", "cv::MorphFilter<cv::MaxOp<double>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MaxOp<double>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MaxOp<float>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MaxOp<float>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MaxOp<short>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MaxOp<short>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MaxOp<unsigned short>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MaxOp<unsigned short>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MaxOp<unsigned char>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MaxOp<unsigned char>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MinOp<double>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MinOp<double>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MinOp<float>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MinOp<float>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MinOp<short>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MinOp<short>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MinOp<unsigned short>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MinOp<unsigned short>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<cv::MinOp<unsigned char>, cv::MorphNoVec>::MorphFilter(const cv::Mat &, Point) [Op = cv::MinOp<unsigned char>, VecOp = cv::MorphNoVec]", "void cv::morphOp(int, InputArray, OutputArray, InputArray, Point, int, int, const Scalar &)", "cv::Point2d cv::phaseCorrelateRes(InputArray, InputArray, InputArray, double *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/phasecorr.cpp", "src1.type() == CV_32FC1 || src1.type() == CV_64FC1", "src1.size == src2.size", "src1.type() == window.type()", "src1.size == window.size", "void cv::createHanningWindow(OutputArray, cv::Size, int)", "Point2d cv::weightedCentroid(InputArray, cv::Point, cv::Size, double *)", "void cv::divSpectrums(InputArray, InputArray, OutputArray, int, bool)", "void cv::magSpectrums(InputArray, OutputArray)", "borderType != BORDER_CONSTANT", "void cv::pyrDown(InputArray, OutputArray, const Size &, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/pyramids.cpp", "borderType == BORDER_DEFAULT", "void cv::pyrUp(InputArray, OutputArray, const Size &, int)", "void cv::buildPyramid(InputArray, OutputArrayOfArrays, int, int)", "_filter == CV_GAUSSIAN_5x5 && src.type() == dst.type()", "void cvPyrDown(const void *, void *, int)", "void cvPyrUp(const void *, void *, int)", "void cvReleasePyramid(CvMat ***, int)", "The number of extra layers must be non negative", "CvMat **cvCreatePyramid(const CvArr *, int, double, const CvSize *, CvArr *, int, int)", "The buffer is too small to fit the pyramid", "std::abs(dsize.width - ssize.width*2) == dsize.width % 2 && std::abs(dsize.height - ssize.height*2) == dsize.height % 2", "void cv::pyrUp_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FltCast<double, 6>, VecOp = cv::NoVec<double, double>]", "void cv::pyrUp_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FltCast<float, 6>, VecOp = cv::NoVec<float, float>]", "void cv::pyrUp_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FixPtCast<unsigned short, 6>, VecOp = cv::NoVec<int, unsigned short>]", "void cv::pyrUp_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FixPtCast<short, 6>, VecOp = cv::NoVec<int, short>]", "void cv::pyrUp_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FixPtCast<unsigned char, 6>, VecOp = cv::NoVec<int, unsigned char>]", "!_src.empty()", "void cv::pyrDown_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FltCast<double, 8>, VecOp = cv::NoVec<double, double>]", "std::abs(dsize.width*2 - ssize.width) <= 2 && std::abs(dsize.height*2 - ssize.height) <= 2", "void cv::pyrDown_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FltCast<float, 8>, VecOp = cv::NoVec<float, float>]", "void cv::pyrDown_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FixPtCast<unsigned short, 8>, VecOp = cv::NoVec<int, unsigned short>]", "void cv::pyrDown_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FixPtCast<short, 8>, VecOp = cv::NoVec<int, short>]", "void cv::pyrDown_(const cv::Mat &, cv::Mat &, int) [CastOp = cv::FixPtCast<unsigned char, 8>, VecOp = cv::NoVec<int, unsigned char>]", "Input sequence must consist of 2d points or pointers to 2d points", "CvBox2D cvMinAreaRect2(const CvArr *, CvMemStorage *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/rotcalipers.cpp", "int cvSampleLine(const void *, CvPoint, CvPoint, void *, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/samplers.cpp", "void cvGetRectSubPix(const void *, void *, CvPoint2D32f)", "(func( src->data.ptr, src_step, src_size, dst->data.ptr, dst_step, dst_size, center )) >= 0", "map matrix is not valid", "void cvGetQuadrangleSubPix(const void *, void *, const CvMat *)", "Transformation matrix must be 2x3", "The transformation matrix should have 32fC1 or 64fC1 type", "(func( src->data.ptr, src->step, src_size, dst->data.ptr, dst->step, dst_size, m )) >= 0", "Only 8-bit, 3-channel input images are supported", "void cvWatershed(const CvArr *, CvArr *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/segmentation.cpp", "Only 32-bit, 1-channel output images are supported", "The input and output images must have the same size", "The number of pyramid levels is too large or negative", "void cvPyrMeanShiftFiltering(const CvArr *, CvArr *, double, double, int, CvTermCriteria)", "Only 8-bit, 3-channel images are supported", "The input and output images must have the same type", "double cvArcLength(const void *, CvSlice, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/shapedescr.cpp", "Null center or radius pointers", "int cvMinEnclosingCircle(const void *, CvPoint2D32f *, float *)", "double cvContourArea(const void *, CvSlice, int)", "Only curves with integer coordinates are supported in case of contour slice", "(icvContourSecArea( contour, slice, &area )) >= 0", "CvBox2D cvFitEllipse2(const CvArr *)", "Number of points should be >= 5", "CvRect cvBoundingRect(CvArr *, int)", "The image/matrix format is not supported by the function", "CV_MAT_CN(sumType) == CV_MAT_CN(srcType)", "cv::Ptr<cv::BaseRowFilter> cv::getRowSumFilter(int, int, int, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/smooth.cpp", "CV_MAT_CN(sumType) == CV_MAT_CN(dstType)", "cv::Ptr<cv::BaseColumnFilter> cv::getColumnSumFilter(int, int, int, int, double)", "Unsupported combination of sum format (=%d), and destination format (=%d)", "cv::Mat cv::getGaussianKernel(int, double, int)", "ksize.width > 0 && ksize.width % 2 == 1 && ksize.height > 0 && ksize.height % 2 == 1", "cv::Ptr<cv::FilterEngine> cv::createGaussianFilter(int, Size, double, double, int)", "ksize % 2 == 1", "void cv::medianBlur(InputArray, OutputArray, int)", "src.depth() == CV_8U && (cn == 1 || cn == 3 || cn == 4)", "Bilateral filtering is only implemented for 8u and 32f images", "void cv::bilateralFilter(InputArray, OutputArray, int, double, double, int)", "src.type() == CV_8UC1 || src.type() == CV_8UC3", "void cv::adaptiveBilateralFilter(InputArray, OutputArray, Size, double, double, Point, int)", "Adaptive Bilateral filtering is only implemented for 8u images", "dst.size() == src.size() && (smooth_type == CV_BLUR_NO_SCALE || dst.type() == src.type())", "void cvSmooth(const void *, void *, int, int, int, double, double)", "The destination image does not have the proper type", "sumCount == ksize-1", "virtual void cv::ColumnSum<double, double>::operator()(const uchar **, uchar *, int, int, int) [ST = double, T = double]", "virtual void cv::ColumnSum<int, double>::operator()(const uchar **, uchar *, int, int, int) [ST = int, T = double]", "virtual void cv::ColumnSum<double, float>::operator()(const uchar **, uchar *, int, int, int) [ST = double, T = float]", "virtual void cv::ColumnSum<int, float>::operator()(const uchar **, uchar *, int, int, int) [ST = int, T = float]", "virtual void cv::ColumnSum<int, int>::operator()(const uchar **, uchar *, int, int, int) [ST = int, T = int]", "virtual void cv::ColumnSum<double, short>::operator()(const uchar **, uchar *, int, int, int) [ST = double, T = short]", "virtual void cv::ColumnSum<double, unsigned short>::operator()(const uchar **, uchar *, int, int, int) [ST = double, T = unsigned short]", "virtual void cv::ColumnSum<double, unsigned char>::operator()(const uchar **, uchar *, int, int, int) [ST = double, T = unsigned char]", "(src.type() == CV_8UC1 || src.type() == CV_8UC3) && src.type() == dst.type() && src.size() == dst.size() && src.data != dst.data", "void cv::adaptiveBilateralFilter_8u(const cv::Mat &, cv::Mat &, Size, double, double, Point, int)", "(ksize.width & 1) && (ksize.height & 1)", "cv::adaptiveBilateralFilter_8u_Invoker::adaptiveBilateralFilter_8u_Invoker(cv::Mat &, const cv::Mat &, Size, double, double, Point)", "(src.type() == CV_32FC1 || src.type() == CV_32FC3) && src.type() == dst.type() && src.size() == dst.size() && src.data != dst.data", "void cv::bilateralFilter_32f(const cv::Mat &, cv::Mat &, int, double, double, int)", "void cv::bilateralFilter_8u(const cv::Mat &, cv::Mat &, int, double, double, int)", "virtual void cv::ColumnSum<int, short>::operator()(const uchar **, uchar *, int, int, int)", "virtual void cv::ColumnSum<int, unsigned short>::operator()(const uchar **, uchar *, int, int, int)", "virtual void cv::ColumnSum<int, unsigned char>::operator()(const uchar **, uchar *, int, int, int)", "Subdivision is empty", "int cv::Subdiv2D::locate(Point2f, int &, int &)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/subdivision2d.cpp", "int cv::Subdiv2D::insert(Point2f)", "Subdiv2D::locate returned invalid location = %d", "edgeDst(edge, &t) > 0", "int cv::Subdiv2D::findNearest(Point2f, Point2f *)", "edgeOrg( edge, &t ) > 0", "edgeOrg(e) == edgeOrg(o_next)", "void cv::Subdiv2D::checkSubdiv() const", "edgeOrg(e) == edgeOrg(o_prev)", "edgeDst(e) == edgeDst(d_next)", "edgeDst(e) == edgeDst(d_prev)", "edgeDst(o_next) == edgeOrg(d_prev)", "edgeDst(o_prev) == edgeOrg(d_next)", "getEdge(getEdge(getEdge(e,NEXT_AROUND_LEFT),NEXT_AROUND_LEFT),NEXT_AROUND_LEFT) == e", "getEdge(getEdge(getEdge(e,NEXT_AROUND_RIGHT),NEXT_AROUND_RIGHT),NEXT_AROUND_RIGHT) == e", "void cv::integral(InputArray, OutputArray, OutputArray, OutputArray, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/sumpixels.cpp", "sum.data == sum0.data && sqsum.data == sqsum0.data && tilted.data == tilted0.data", "void cvIntegral(const CvArr *, CvArr *, CvArr *, CvArr *)", "img.dims <= 2 && templ.dims <= 2 && corr.dims <= 2", "void cv::crossCorr(const cv::Mat &, const cv::Mat &, cv::Mat &, Size, int, Point, double, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/templmatch.cpp", "depth == tdepth || tdepth == CV_32F", "corrsize.height <= img.rows + templ.rows - 1 && corrsize.width <= img.cols + templ.cols - 1", "ccn == 1 || delta == 0", "the input arrays are too big", "CV_TM_SQDIFF <= method && method <= CV_TM_CCOEFF_NORMED", "void cv::matchTemplate(InputArray, InputArray, OutputArray, int)", "(img.depth() == CV_8U || img.depth() == CV_32F) && img.type() == templ.type()", "img.rows >= templ.rows && img.cols >= templ.cols", "result.size() == cv::Size(std::abs(img.cols - templ.cols) + 1, std::abs(img.rows - templ.rows) + 1) && result.type() == CV_32F", "void cvMatchTemplate(const CvArr *, const CvArr *, CvArr *, int)", "double cv::threshold(InputArray, OutputArray, double, double, int)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/thresh.cpp", "void cv::adaptiveThreshold(InputArray, OutputArray, double, int, int, int, double)", "blockSize % 2 == 1 && blockSize > 1", "Unknown/unsupported adaptive threshold method", "Unknown/unsupported threshold type", "src.size == dst.size && src.channels() == dst.channels() && (src.depth() == dst.depth() || dst.depth() == CV_8U)", "double cvThreshold(const void *, void *, double, double, int)", "void cvAdaptiveThreshold(const void *, void *, double, int, int, int, double)", "void cv::thresh_32f(const cv::Mat &, cv::Mat &, float, float, int)", "void cv::thresh_16s(const cv::Mat &, cv::Mat &, short, short, int)", "Unknown threshold type", "void cv::thresh_8u(const cv::Mat &, cv::Mat &, uchar, uchar, int)", "m1type == CV_16SC2 || m1type == CV_32FC1 || m1type == CV_32FC2", "void cv::initUndistortRectifyMap(InputArray, InputArray, InputArray, InputArray, Size, int, OutputArray, OutputArray)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/undistort.cpp", "A.size() == Size(3,3) && A.size() == R.size()", "Ar.size() == Size(3,3) || Ar.size() == Size(4, 3)", "distCoeffs.size() == Size(1, 4) || distCoeffs.size() == Size(4, 1) || distCoeffs.size() == Size(1, 5) || distCoeffs.size() == Size(5, 1) || distCoeffs.size() == Size(1, 8) || distCoeffs.size() == Size(8, 1)", "dst.data != src.data", "void cv::undistort(InputArray, OutputArray, InputArray, InputArray, InputArray)", "void cvUndistort2(const CvArr *, CvArr *, const CvMat *, const CvMat *, const CvMat *)", "mapx0.data == mapx.data && mapy0.data == mapy.data", "void cvInitUndistortMap(const CvMat *, const CvMat *, CvArr *, CvArr *)", "void cvInitUndistortRectifyMap(const CvMat *, const CvMat *, const CvMat *, const CvMat *, CvArr *, CvArr *)", "CV_IS_MAT(_src) && CV_IS_MAT(_dst) && (_src->rows == 1 || _src->cols == 1) && (_dst->rows == 1 || _dst->cols == 1) && _src->cols + _src->rows - 1 == _dst->rows + _dst->cols - 1 && (CV_MAT_TYPE(_src->type) == CV_32FC2 || CV_MAT_TYPE(_src->type) == CV_64FC2) && (CV_MAT_TYPE(_dst->type) == CV_32FC2 || CV_MAT_TYPE(_dst->type) == CV_64FC2)", "void cvUndistortPoints(const CvMat *, CvMat *, const CvMat *, const CvMat *, const CvMat *, const CvMat *)", "CV_IS_MAT(_cameraMatrix) && _cameraMatrix->rows == 3 && _cameraMatrix->cols == 3", "CV_IS_MAT(_distCoeffs) && (_distCoeffs->rows == 1 || _distCoeffs->cols == 1) && (_distCoeffs->rows*_distCoeffs->cols == 4 || _distCoeffs->rows*_distCoeffs->cols == 5 || _distCoeffs->rows*_distCoeffs->cols == 8)", "CV_IS_MAT(matR) && matR->rows == 3 && matR->cols == 3", "CV_IS_MAT(matP) && matP->rows == 3 && (matP->cols == 3 || matP->cols == 4)", "src.isContinuous() && (src.depth() == CV_32F || src.depth() == CV_64F) && ((src.rows == 1 && src.channels() == 2) || src.cols*src.channels() == 2)", "void cv::undistortPoints(InputArray, OutputArray, InputArray, InputArray, InputArray, InputArray)", "(distCoeffs0.cols == 1 || distCoeffs0.rows == 1) && (ndcoeffs == 4 || ndcoeffs == 5 || ndcoeffs == 8)", "float cv::initWideAngleProjMap(InputArray, InputArray, Size, int, int, OutputArray, OutputArray, int, double)", "cameraMatrix0.size() == Size(3,3)", "avg iters = %g\n", "Unknown projection type", "Point2f cv::mapPointSpherical(const Point2f &, float, Vec4d *, int)", "arr != 0 && contour_header != 0 && block != 0", "CvSeq *cvPointSeqFromMat(int, const CvArr *, CvContour *, CvSeqBlock *)", "/Users/fedir.poliakov/Development/opencv-2.4.11/modules/imgproc/src/utils.cpp", "Input array is not a valid matrix", "The matrix can not be converted to point sequence because of inappropriate element type", "The matrix converted to point sequence must be 1-dimensional and continuous", "top >= 0 && bottom >= 0 && left >= 0 && right >= 0", "void cv::copyMakeBorder(InputArray, OutputArray, int, int, int, int, int, const Scalar &)", "value[0] == value[1] && value[0] == value[2] && value[0] == value[3]", "src1.depth() == CV_8U", "double cv::PSNR(InputArray, InputArray)", "dst.type() == src.type()", "void cvCopyMakeBorder(const CvArr *, CvArr *, CvPoint, int, CvScalar)", "N2cv9AlgorithmE", "NSt3__114basic_iostreamIcNS_11char_traitsIcEEEE", "NSt3__113basic_istreamIcNS_11char_traitsIcEEEE", "NSt3__19basic_iosIcNS_11char_traitsIcEEEE", "NSt3__113basic_ostreamIcNS_11char_traitsIcEEEE", "NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE", "NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE", "NSt3__115basic_streambufIcNS_11char_traitsIcEEEE", "0Y\r@:i\r", "PF SdF", " [@W:[", "14EmptyFuncTable", "12GpuFuncTable", "24EmptyDeviceInfoFuncTable", "19DeviceInfoFuncTable", "The library is compiled without CUDA support", "N2cv5MatOpE", "N2cv14MatOp_IdentityE", "N2cv11MatOp_AddExE", "N2cv9MatOp_BinE", "N2cv9MatOp_CmpE", "N2cv10MatOp_GEMME", "N2cv12MatOp_InvertE", "N2cv7MatOp_TE", "N2cv11MatOp_SolveE", "N2cv17MatOp_InitializerE", "N2cv12_OutputArrayE", "N2cv11_InputArrayE", "N2cv22KMeansDistanceComputerE", "N2cv24KMeansPPDistanceComputerE", "15CvOpenGlFuncTab", "N2cv10CFormatterE", "N2cv9FormatterE", "N2cv12CSVFormatterE", "N2cv14NumpyFormatterE", "N2cv15PythonFormatterE", "N2cv15MatlabFormatterE", "N2cv16ParallelLoopBodyE", "N2cv11FileStorageE", "ucwsifdr", "N2cv16BatchDistInvokerE", "N2cv9ExceptionE", "N2cv16TLSDataContainerE", "N12_GLOBAL__N_110CLAHE_ImplE", "N2cv5CLAHEE", "N12_GLOBAL__N_118CLAHE_CalcLut_BodyE", "N12_GLOBAL__N_124CLAHE_Interpolation_BodyE", "N2cv20CvtColorLoop_InvokerINS_10mRGBA2RGBAIhEEEE", "N2cv20CvtColorLoop_InvokerINS_10RGBA2mRGBAIhEEEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi1EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi0EEE", "N2cv22RGB888toYUV420pInvokerILi2EEE", "N2cv22RGB888toYUV420pInvokerILi0EEE", "N2cv23YUV420p2RGBA8888InvokerILi2EEE", "N2cv23YUV420p2RGBA8888InvokerILi0EEE", "N2cv21YUV420p2RGB888InvokerILi2EEE", "N2cv21YUV420p2RGB888InvokerILi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi1EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi1EEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi0EEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_bEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11Gray2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB5x52GrayEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIfEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayItEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIhEEEE", "N2cv20CvtColorLoop_InvokerINS_10RGB5x52RGBEEE", "N2cv20CvtColorLoop_InvokerINS_10RGB2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBIhEEEE", "N2cv12DTRowInvokerE", "N2cv15DTColumnInvokerE", "N2cv13BaseRowFilterE", "N2cv16BaseColumnFilterE", "N2cv10BaseFilterE", "N2cv12FilterEngineE", "N2cv8Filter2DIdNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIfNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfhEENS_11FilterNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv9RowFilterIddNS_8RowNoVecEEE", "N2cv9RowFilterIfdNS_8RowNoVecEEE", "N2cv9RowFilterIffNS_8RowNoVecEEE", "N2cv9RowFilterIsdNS_8RowNoVecEEE", "N2cv9RowFilterIsfNS_8RowNoVecEEE", "N2cv9RowFilterItdNS_8RowNoVecEEE", "N2cv9RowFilterItfNS_8RowNoVecEEE", "N2cv9RowFilterIhdNS_8RowNoVecEEE", "N2cv9RowFilterIhfNS_8RowNoVecEEE", "N2cv9RowFilterIhiNS_8RowNoVecEEE", "N2cv18SymmRowSmallFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv16GeneralizedHoughE", "N12_GLOBAL__N_113GHT_Guil_FullE", "N12_GLOBAL__N_17GHT_PosE", "N12_GLOBAL__N_123GHT_Ballard_PosRotationE", "N12_GLOBAL__N_115GHT_Ballard_PosE", "N12_GLOBAL__N_123GHT_Ballard_PosRotation6WorkerE", "N12_GLOBAL__N_120GHT_Ballard_PosScaleE", "N12_GLOBAL__N_120GHT_Ballard_PosScale6WorkerE", "23EqualizeHistLut_Invoker", "28EqualizeHistCalcHist_Invoker", "N2cv18ResizeArea_InvokerIddEE", "N2cv18ResizeArea_InvokerIffEE", "N2cv18ResizeArea_InvokerIsfEE", "N2cv18ResizeArea_InvokerItfEE", "N2cv18ResizeArea_InvokerIhfEE", "N2cv22resizeAreaFast_InvokerIddNS_19ResizeAreaFastNoVecIddEEEE", "N2cv22resizeAreaFast_InvokerIffNS_19ResizeAreaFastNoVecIffEEEE", "N2cv22resizeAreaFast_InvokerIsfNS_17ResizeAreaFastVecIsEEEE", "N2cv22resizeAreaFast_InvokerItfNS_17ResizeAreaFastVecItEEEE", "N2cv22resizeAreaFast_InvokerIhiNS_17ResizeAreaFastVecIhEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IddfEENS_15VResizeLanczos4IddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IfffEENS_15VResizeLanczos4IfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IsffEENS_15VResizeLanczos4IsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4ItffEENS_15VResizeLanczos4ItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IhisEENS_15VResizeLanczos4IhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIddfEENS_12VResizeCubicIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIfffEENS_12VResizeCubicIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIsffEENS_12VResizeCubicIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicItffEENS_12VResizeCubicItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIhisEENS_12VResizeCubicIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIddfLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIfffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIsffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearItffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIhisLi2048ENS_12HResizeNoVecEEENS_13VResizeLinearIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv22warpPerspectiveInvokerE", "N2cv17warpAffineInvokerE", "N2cv12RemapInvokerE", "N2cv15resizeNNInvokerE", "N2cv11MorphFilterINS_5MaxOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIhEENS_10MorphNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIhEENS_16MorphColumnNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIhEENS_13MorphRowNoVecEEE", "N2cv16MorphologyRunnerE", "N2cv9ColumnSumIddEE", "N2cv9ColumnSumIidEE", "N2cv9ColumnSumIdfEE", "N2cv9ColumnSumIifEE", "N2cv9ColumnSumIiiEE", "N2cv9ColumnSumIdsEE", "N2cv9ColumnSumIdtEE", "N2cv9ColumnSumIdhEE", "N2cv6RowSumIddEE", "N2cv6RowSumIfdEE", "N2cv6RowSumIsdEE", "N2cv6RowSumIiiEE", "N2cv6RowSumIsiEE", "N2cv6RowSumItdEE", "N2cv6RowSumItiEE", "N2cv6RowSumIhdEE", "N2cv6RowSumIhiEE", "N2cv34adaptiveBilateralFilter_8u_InvokerE", "N2cv27BilateralFilter_32f_InvokerE", "N2cv26BilateralFilter_8u_InvokerE", "N2cv9ColumnSumIisEE", "N2cv9ColumnSumIitEE", "N2cv9ColumnSumIihEE", "N2cv15ThresholdRunnerE"], "stringidentifiers": ["name", "vector", "basic_string", "integer", "short", "boolean", "double", "string", "cv::Mat", "algorithm", "float", "GRAY", "BGRA", "false", "true", "ranges", "MATLAB", "PYTHON", "NUMPY", "uint8", "int8", "uint16", "int16", "int32", "float32", "float64", "uint64", "sizes", "data", "rows", "cols", "width", "height", "origin", "layout", "planar", "interleaved", "flags", "oriented", "vertex_count", "vertex_dt", "edge_count", "edge_dt", "vertices", "edges", "header_dt", "rect", "color", "header_user_data", "sequences", "level", "recursive", "False", "FALSE", "count", "curve", "closed", "hole", "untyped", "opencv_storage", "type_id", "apos", "quot", "OPENCV_TEMP_PATH", "Backtrace", "status", "error", "cxcore", "MXVNTMRMPNOPOSPURVTVVU", "PTRMRV", "NUSMSTRVPVOTOS", "MXRMPNOPOSPURVSVUUVSVPUNSMRM", "MWUNSMQMONOOPPTRUSUUSVQVOU", "MXOMOSPURVSVUUVSVM", "MXOVQVOROPPNRMSMUNVPVRTVVV", "LXVPUNTMRMPNOONQNSOUPVRVTUUT", "LXVPUNTMRMPNOONQNSOUPVRVTUUSRS", "PUTMQV", "OVUMSSRUQVPVOUOT", "LXRMPNOONQNSOUPVRVTUUTVRVPUNTMRM", "MWVNTMRMPNPPQQTRUSUUSVPVNU", "LXPMNSNUOVRVTUUSWM", "MWQMWMNVTV", "MWNLVX", "MWNVVV", "PVRMUQ", "MWMMOKQKTMVMWK", "MWUQSPRPPQOSPURVSVUU", "MWOSUSTQRPPQOSPURVTV", "MWRPPQOSPURVTUUSTQRP", "NWUQTPQPPQPRQSTSUTUUTVQVPU", "MWOPUPOVUV", "MXVPUSTURVPUOSPQRPTQUUVV", "MWOTQVSVTUTSSRPQRQTPUOUNTMRMQNPPOTNY", "MWTNSMRMQNQORPTQUSTURVPUOSPQRP", "LXNQOPPPQQQURVSVTUUSVPVNUMTMSNSPTRUSWT", "OVRPQSQURVSVTU", "MWOSPURVTUUSTQRPPQOSNY", "MXVPRPPQOSPURVTUUSTQRP", "KXMQNPOPPQPUQVSVTUUSVP", "MXPPOQOSPURVSVUUVSVQUPTPSQRSQY", "MWQMOSPURVTUUSTQRPPQOS", "MWUQSPRPPQOSPURVTV", "MWOSTSURUQSPRPPQOSPURVTV", "OTSMQSQURVSV", "NVTQSPQPPQPRQSRSSTSURVPVOU", "MWNPOPPQPROTOUPVRVTUURUP", "MWUSTQRPPQOSPURVTUUSUPTNRMQM", "MWUQSPQPOQOSPTRUSVSWRXQX", "MWUNORUV", "MWONUROV", "OUTKQKQYTY", "OUPKSKSYPY", "OUTKSLRNROSQQRSSRURVSXTY", "OUPKQLRNROQQSRQSRURVQXPY", "MWRMPNOPOSPURVTUUSUPTNRM", "MWPORMRV", "MWONQMSMUNUPTROVUV", "MWTMRMPNOPOSPURVTUUSTQRPPQOS", "MWUPTRRSPROPPNRMTNUPUSTURVPV", "PURURVSVSURU", "PUSVRVRUSUSWRY", "PTRMRQ", "NVQMPNPPQQSQTPTNSMQM", "MWVLNX", "OUTKRNQQQSRVTY", "OUPKRNSQSSRVPY", "PTRKRY", "LXNRVR", "PURQRRSRSQRQ", "PUSMRORQSQSPRP", "PUSNRNRMSMSORQ", "LXVRURTSSURVOVNUNSORRQSPSNRMPMONOPQSSUUVVV", "LYRQQPOPNQNSOTQTRSSQTPVPWQWSVTTTSSRQ", "NVRFRM", "KYQFOGNINKOMQNSNUMVKVIUGSFQF", "NVRBRb", "MWRQQRRSSRRQ", "MWSFRGQIQKRLSKRJ", "MWRHQGRFSGSIRKQL", "MWWRWQVOUNSMQMONNOMQMR", "MWMRMSNUOVQWSWUVVUWSWR", "LXLPNRQSSSVRXP", "RURUTTURTPRO", "RVRRUPVNVLUKTK", "NRRROPNNNLOKPK", "KYKRYR", "MWMWWM", "MWMMWW", "KYRJYNKVRZ", "JZJRNKVYZR", "KYKVKNYVYN", "JZLXJPZTXL", "KYQKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK", "LXLLLXXXXLLL", "KYRJKVYVRJ", "JZRIPOJOOSMYRUWYUSZOTORI", "LXPLPPLPLTPTPXTXTTXTXPTPTLPL", "QSRQQRRSSRRQ", "PTQPPQPSQTSTTSTQSPQP", "NVQNOONQNSOUQVSVUUVSVQUOSNQN", "MWQMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM", "NVRVQWRXSWRV", "MWQKPLPNQOSOTNTLSKQK", "NVRQQRRSSRRQ", "JZWLMRWX", "JZMLWRMX", "NVSLRMQLRKSLSNQP", "NVSKQMQORPSORNQO", "NVQLRMSLRKQLQNSP", "NVQKSMSORPQORNSO", "JZWMQMONNOMQMSNUOVQWWW", "JZMMMSNUOVQWSWUVVUWSWM", "JZMMSMUNVOWQWSVUUVSWMW", "JZMWMQNOONQMSMUNVOWQWW", "KYUBNRUb", "KYOBVROb", "MWRHSGRFQGQIRKSL", "MWQFRGSISKRLQKRJ", "MXVFTHSJSKTLUKTJ", "MXUHTGUFVGVHUJSL", "KZSFQGPIPKQMSNUNWMXKXIWGUFSF", "clipLimit", "tilesX", "tilesY", "CLAHE", "minDist", "maxSize", "levels", "angleEpsilon", "minAngle", "maxAngle", "angleStep", "angleThresh", "minScale", "maxScale", "scaleStep", "scaleThresh", "posThresh", "votesThreshold", "type", "is_uniform", "have_ranges", "bins", "thresh", "N2cv9AlgorithmE", "NSt3__114basic_iostreamIcNS_11char_traitsIcEEEE", "NSt3__113basic_istreamIcNS_11char_traitsIcEEEE", "NSt3__19basic_iosIcNS_11char_traitsIcEEEE", "NSt3__113basic_ostreamIcNS_11char_traitsIcEEEE", "NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE", "NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE", "NSt3__115basic_streambufIcNS_11char_traitsIcEEEE", "N2cv5MatOpE", "N2cv14MatOp_IdentityE", "N2cv11MatOp_AddExE", "N2cv9MatOp_BinE", "N2cv9MatOp_CmpE", "N2cv10MatOp_GEMME", "N2cv12MatOp_InvertE", "N2cv7MatOp_TE", "N2cv11MatOp_SolveE", "N2cv17MatOp_InitializerE", "N2cv12_OutputArrayE", "N2cv11_InputArrayE", "N2cv22KMeansDistanceComputerE", "N2cv24KMeansPPDistanceComputerE", "N2cv10CFormatterE", "N2cv9FormatterE", "N2cv12CSVFormatterE", "N2cv14NumpyFormatterE", "N2cv15PythonFormatterE", "N2cv15MatlabFormatterE", "N2cv16ParallelLoopBodyE", "N2cv11FileStorageE", "ucwsifdr", "N2cv16BatchDistInvokerE", "N2cv9ExceptionE", "N2cv16TLSDataContainerE", "N12_GLOBAL__N_110CLAHE_ImplE", "N2cv5CLAHEE", "N12_GLOBAL__N_118CLAHE_CalcLut_BodyE", "N12_GLOBAL__N_124CLAHE_Interpolation_BodyE", "N2cv20CvtColorLoop_InvokerINS_10mRGBA2RGBAIhEEEE", "N2cv20CvtColorLoop_InvokerINS_10RGBA2mRGBAIhEEEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi1EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi0EEE", "N2cv22RGB888toYUV420pInvokerILi2EEE", "N2cv22RGB888toYUV420pInvokerILi0EEE", "N2cv23YUV420p2RGBA8888InvokerILi2EEE", "N2cv23YUV420p2RGBA8888InvokerILi0EEE", "N2cv21YUV420p2RGB888InvokerILi2EEE", "N2cv21YUV420p2RGB888InvokerILi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi1EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi1EEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi0EEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_bEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11Gray2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB5x52GrayEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIfEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayItEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIhEEEE", "N2cv20CvtColorLoop_InvokerINS_10RGB5x52RGBEEE", "N2cv20CvtColorLoop_InvokerINS_10RGB2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBIhEEEE", "N2cv12DTRowInvokerE", "N2cv15DTColumnInvokerE", "N2cv13BaseRowFilterE", "N2cv16BaseColumnFilterE", "N2cv10BaseFilterE", "N2cv12FilterEngineE", "N2cv8Filter2DIdNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIfNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfhEENS_11FilterNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv9RowFilterIddNS_8RowNoVecEEE", "N2cv9RowFilterIfdNS_8RowNoVecEEE", "N2cv9RowFilterIffNS_8RowNoVecEEE", "N2cv9RowFilterIsdNS_8RowNoVecEEE", "N2cv9RowFilterIsfNS_8RowNoVecEEE", "N2cv9RowFilterItdNS_8RowNoVecEEE", "N2cv9RowFilterItfNS_8RowNoVecEEE", "N2cv9RowFilterIhdNS_8RowNoVecEEE", "N2cv9RowFilterIhfNS_8RowNoVecEEE", "N2cv9RowFilterIhiNS_8RowNoVecEEE", "N2cv18SymmRowSmallFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv16GeneralizedHoughE", "N12_GLOBAL__N_113GHT_Guil_FullE", "N12_GLOBAL__N_17GHT_PosE", "N12_GLOBAL__N_123GHT_Ballard_PosRotationE", "N12_GLOBAL__N_115GHT_Ballard_PosE", "N12_GLOBAL__N_123GHT_Ballard_PosRotation6WorkerE", "N12_GLOBAL__N_120GHT_Ballard_PosScaleE", "N12_GLOBAL__N_120GHT_Ballard_PosScale6WorkerE", "N2cv18ResizeArea_InvokerIddEE", "N2cv18ResizeArea_InvokerIffEE", "N2cv18ResizeArea_InvokerIsfEE", "N2cv18ResizeArea_InvokerItfEE", "N2cv18ResizeArea_InvokerIhfEE", "N2cv22resizeAreaFast_InvokerIddNS_19ResizeAreaFastNoVecIddEEEE", "N2cv22resizeAreaFast_InvokerIffNS_19ResizeAreaFastNoVecIffEEEE", "N2cv22resizeAreaFast_InvokerIsfNS_17ResizeAreaFastVecIsEEEE", "N2cv22resizeAreaFast_InvokerItfNS_17ResizeAreaFastVecItEEEE", "N2cv22resizeAreaFast_InvokerIhiNS_17ResizeAreaFastVecIhEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IddfEENS_15VResizeLanczos4IddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IfffEENS_15VResizeLanczos4IfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IsffEENS_15VResizeLanczos4IsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4ItffEENS_15VResizeLanczos4ItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IhisEENS_15VResizeLanczos4IhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIddfEENS_12VResizeCubicIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIfffEENS_12VResizeCubicIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIsffEENS_12VResizeCubicIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicItffEENS_12VResizeCubicItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIhisEENS_12VResizeCubicIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIddfLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIfffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIsffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearItffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIhisLi2048ENS_12HResizeNoVecEEENS_13VResizeLinearIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv22warpPerspectiveInvokerE", "N2cv17warpAffineInvokerE", "N2cv12RemapInvokerE", "N2cv15resizeNNInvokerE", "N2cv11MorphFilterINS_5MaxOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIhEENS_10MorphNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIhEENS_16MorphColumnNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIhEENS_13MorphRowNoVecEEE", "N2cv16MorphologyRunnerE", "N2cv9ColumnSumIddEE", "N2cv9ColumnSumIidEE", "N2cv9ColumnSumIdfEE", "N2cv9ColumnSumIifEE", "N2cv9ColumnSumIiiEE", "N2cv9ColumnSumIdsEE", "N2cv9ColumnSumIdtEE", "N2cv9ColumnSumIdhEE", "N2cv6RowSumIddEE", "N2cv6RowSumIfdEE", "N2cv6RowSumIsdEE", "N2cv6RowSumIiiEE", "N2cv6RowSumIsiEE", "N2cv6RowSumItdEE", "N2cv6RowSumItiEE", "N2cv6RowSumIhdEE", "N2cv6RowSumIhiEE", "N2cv34adaptiveBilateralFilter_8u_InvokerE", "N2cv27BilateralFilter_32f_InvokerE", "N2cv26BilateralFilter_8u_InvokerE", "N2cv9ColumnSumIisEE", "N2cv9ColumnSumIitEE", "N2cv9ColumnSumIihEE", "N2cv15ThresholdRunnerE"], "debugstrings": ["virtual int EmptyDeviceInfoFuncTable::minorVersion(int) const", "virtual int EmptyDeviceInfoFuncTable::majorVersion(int) const", "<?xml version=\"1.0\" encoding=\"%s\"?>\n", "<?xml version=\"1.0\"?>\n", "Unsupported YAML version (it must be 1.x)", "module != 0 && module->name != 0 && module->version != 0", "Unknown/unsupported color conversion code", "GCC: (GNU) 4.6 20120106 (prerelease)", "GCC: (GNU) 4.8", "clang version 3.5 "], "localsymbols": [""], "dependencies": ["libstdc++.so", "libz.so", "libm.so", "libc.so", "libdl.so", "libc++_shared.so", "liblog.so"], "elfname": "libopencv.so"}