{"globalvars": ["__start_pre_merge_jni_libraries", "__stop_pre_merge_jni_libraries"], "importedglobals": ["__stack_chk_guard", "_ZTVN10__cxxabiv117__class_type_infoE", "_ctype_", "_ZTVN10__cxxabiv120__si_class_type_infoE", "__sF", "_ZTISt9exception"], "importedfunctions": ["free", "__gnu_ldivmod_helper", "sprintf", "open", "_ZSt20__throw_length_errorPKc", "__gxx_personality_v0", "sqrt", "pthread_mutexattr_settype", "read", "fflush", "pthread_mutexattr_init", "_ZNSt8ios_base4InitC1Ev", "strlen", "abort", "__wrap_malloc", "pthread_mutex_unlock", "_Unwind_Resume", "pthread_mutex_lock", "cos", "sin", "__stack_chk_fail", "_ZNSt8ios_base4InitD1Ev", "vsnprintf", "calloc", "pthread_mutexattr_destroy", "_ZSt9terminatev", "strdup", "pthread_mutex_destroy", "_ZSt17__throw_bad_allocv", "fprintf", "_ZdlPv", "__android_log_print", "_ZNSt9exceptionD2Ev", "close", "pthread_mutex_init", "_ZdaPv", "__wrap__Znwj", "__wrap__Znaj"], "exportedfunctions": ["_ZN2cv4flipERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv9transposeERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv3dftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZNK2cv3Mat9convertToERKNS_12_OutputArrayEidd", "_ZN2cv3Mat10deallocateEv", "_ZN2cv8fastFreeEPv", "_ZN2cv12mulSpectrumsERKNS_11_InputArrayES2_RKNS_12_OutputArrayEib", "_ZN2cv3MatC1ERKS0_RKNS_5RangeES5_", "_ZN2cv7noArrayEv", "_ZN2cv3Mat6createEiPKii", "_ZN2cv9minMaxLocERKNS_11_InputArrayEPdS3_PNS_6Point_IiEES6_S2_", "_ZN2cv10meanStdDevERKNS_11_InputArrayERKNS_12_OutputArrayES5_S2_", "_ZN2cvmlEdRKNS_7MatExprE", "_ZN2cv7absdiffERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZNK2cv3Mat6copyToERKNS_12_OutputArrayE", "_ZN2cv6String10deallocateEv", "_ZNK2cv3Mat9locateROIERNS_5Size_IiEERNS_6Point_IiEE", "_ZN2cv14copyMakeBorderERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiiRKNS_7Scalar_IdEE", "_ZN2cv6String8allocateEj", "_ZN2cv3sumERKNS_11_InputArrayE", "_ZN2cv13parallel_for_ERKNS_5RangeERKNS_16ParallelLoopBodyEd", "_ZN2cv5errorEiRKNS_6StringEPKcS4_i", "_ZNK2cv3Mat1tEv", "_ZN2cv3addERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "_ZN2cv11addWeightedERKNS_11_InputArrayEdS2_ddRKNS_12_OutputArrayEi", "_ZN2cv17borderInterpolateEiii", "JNI_OnLoad_Weak", "_ZN2cv3MatC1ERKS0_RKNS_5Rect_IiEE", "_ZN2cv3Mat9adjustROIEiiii", "_ZN2cv11mixChannelsEPKNS_3MatEjPS0_jPKij", "_ZN2cv3MataSERKNS_7Scalar_IdEE", "_ZN2cvmiERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv16ParallelLoopBodyD2Ev", "_ZN2cv17getOptimalDFTSizeEi", "_ZN2cv3Mat8copySizeERKS0_"], "allstrings": ["jni_lib_merge-stub", "void cv::convertAndUnrollScalar(const cv::Mat &, int, uchar *, size_t)", "third-party/opencv/src/modules/core/src/arithm.cpp", "op == CMP_LT || op == CMP_LE || op == CMP_EQ || op == CMP_NE || op == CMP_GE || op == CMP_GT", "void cv::compare(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "The operation is neither 'array op array' (where arrays have the same size and the same type), nor 'array op scalar', nor 'scalar op array'", "The lower bounary is neither an array of the same size and same type as src, nor a scalar", "void cv::inRange(cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray)", "The upper bounary is neither an array of the same size and same type as src, nor a scalar", "src.size == dst.size && src.type() == dst.type()", "src1.size == dst.size && src1.type() == dst.type()", "void cvAnd(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvXor(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "src1.size == dst.size && src1.channels() == dst.channels()", "void cvAdd(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvSub(const CvArr *, const CvArr *, CvArr *, const CvArr *)", "void cvAddWeighted(const CvArr *, double, const CvArr *, double, double, CvArr *)", "src1.size == dst.size && dst.type() == CV_8U", "void cvInRange(const void *, const void *, const void *, void *)", "The operation is neither 'array op array' (where arrays have the same size and type), nor 'array op scalar', nor 'scalar op array'", "void cv::binary_op(cv::InputArray, cv::InputArray, cv::OutputArray, cv::InputArray, const cv::BinaryFuncC *, bool, int)", "The operation is neither 'array op array' (where arrays have the same size and the same number of channels), nor 'array op scalar', nor 'scalar op array'", "void cv::arithm_op(cv::InputArray, cv::InputArray, cv::OutputArray, cv::InputArray, int, cv::BinaryFuncC *, bool, void *, int)", "When the input arrays in add/subtract/multiply/divide functions have different types, the output array type must be explicitly specified", "(mtype == CV_8UC1 || mtype == CV_8SC1) && _mask.sameSize(*psrc1)", "/mnt/btrfs/trunk-hg-fb4a-fbsource-22445371-1534090287/xplat/third-party/opencv/src/modules/core/include/opencv2/core/mat.inl.hpp", "func != 0", "third-party/opencv/src/modules/core/src/convert.cpp", "mv[i].size == mv[0].size && mv[i].depth() == depth", "void cv::mixChannels(const cv::Mat *, size_t, cv::Mat *, size_t, const int *, size_t)", "i1 >= 0 && j < ndsts && dst[j].depth() == depth", "void cv::mixChannels(cv::InputArrayOfArrays, cv::InputOutputArrayOfArrays, const int *, size_t)", "void cv::mixChannels(cv::InputArrayOfArrays, cv::InputOutputArrayOfArrays, const std::vector<int> &)", "void cv::insertChannel(cv::InputArray, cv::InputOutputArray, int)", "void cv::convertScaleAbs(cv::InputArray, cv::OutputArray, double, double)", "void cv::Mat::convertTo(cv::OutputArray, int, double, double) const", "(lutcn == cn || lutcn == 1) && _lut.total() == 256 && _lut.isContinuous() && (depth == CV_8U || depth == CV_8S)", "void cv::normalize(cv::InputArray, cv::InputOutputArray, double, double, int, int, cv::InputArray)", "nz > 0", "dvec[j].channels() == 1", "i < src.channels()", "void cvMerge(const void *, const void *, const void *, const void *, void *)", "svec[j].size == dst.size && svec[j].depth() == dst.depth() && svec[j].channels() == 1 && i < dst.channels()", "dst.size() == src.size() && dst.type() == CV_MAKETYPE(lut.depth(), src.channels())", "void cvNormalize(const CvArr *, CvArr *, double, double, int, const CvArr *)", "third-party/opencv/src/modules/core/src/copy.cpp", "mask.empty() || (mask.type() == CV_8U && size == mask.size)", "_src.dims() <= 2", "void cv::copyMakeBorder(cv::InputArray, cv::OutputArray, int, int, int, int, int, const cv::Scalar &)", "value[0] == value[1] && value[0] == value[2] && value[0] == value[3]", "maskarr == 0", "(coi1 != 0 || src.channels() == 1) && (coi2 != 0 || dst.channels() == 1)", "src.type() == dst.type() && dst.rows % src.rows == 0 && dst.cols % src.cols == 0", "0 <= rowRange_.start && rowRange_.start <= rowRange_.end && rowRange_.end <= m.rows", "cv::cuda::GpuMat::GpuMat(const cv::cuda::GpuMat &, cv::Range, cv::Range)", "third-party/opencv/src/modules/core/src/cuda_gpu_mat.cpp", "0 <= colRange_.start && colRange_.start <= colRange_.end && colRange_.end <= m.cols", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows", "The matrix is not continuous, thus its number of rows can not be changed", "The total number of matrix elements is not divisible by the new number of rows", "The total width is not divisible by the new number of channels", "/mnt/btrfs/trunk-hg-fb4a-fbsource-22445371-1534090287/xplat/third-party/opencv/src/modules/core/include/opencv2/core/private.cuda.hpp", "Bad new number of rows", "type == CV_32FC1 || type == CV_32FC2 || type == CV_64FC1 || type == CV_64FC2", "third-party/opencv/src/modules/core/src/dxt.cpp", "This mode (using nonzero_rows with a single-column matrix) breaks the function's logic, so it is prohibited.\nFor fast convolution/correlation use 2-column matrix or single-row matrix instead", "void cv::mulSpectrums(cv::InputArray, cv::InputArray, cv::OutputArray, int, bool)", "factors[0] == factors[nf-1]", "void cv::DFT(const Complex<T> *, Complex<T> *, int, int, const int *, const int *, const Complex<T> *, int, const void *, Complex<T> *, int, double) [T = float]", "void cv::DFT(const Complex<T> *, Complex<T> *, int, int, const int *, const int *, const Complex<T> *, int, const void *, Complex<T> *, int, double) [T = double]", "third-party/opencv/src/modules/core/src/lapack.cpp", "type == CV_32F || type == CV_64F", "bool cv::solve(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "(method != DECOMP_LU && method != DECOMP_CHOLESKY) || is_normal || src.rows == src.cols", "bool cv::eigen(cv::InputArray, cv::OutputArray, cv::OutputArray)", "w.type() == u.type() && u.type() == vt.type() && u.data && vt.data && w.data", "static void cv::SVD::backSubst(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray)", "u.cols >= nm && vt.rows >= nm && (w.size() == Size(nm, 1) || w.size() == Size(1, nm) || w.size() == Size(vt.rows, u.cols))", "src.type() == dst.type() && src.rows == dst.cols && src.cols == dst.rows", "w.type() == type && (w.size() == cv::Size(nm,1) || w.size() == cv::Size(1, nm) || w.size() == cv::Size(nm, nm) || w.size() == cv::Size(n, m))", "v.size() == svd.vt.size()", "void cvSVBkSb(const CvArr *, const CvArr *, const CvArr *, const CvArr *, CvArr *, int)", "void cv::_SVDcompute(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int)", "Func.type()==CV_64FC1 || Func.type()==CV_32FC1", "Constr.type()==CV_64FC1 || Constr.type()==CV_32FC1", "(Func.rows==1 && (Constr.cols-Func.cols==1))|| (Func.cols==1 && (Constr.cols-Func.rows==1))", "vector::_M_default_append", "src1.size() == src2.size() && type == src2.type() && (depth == CV_32F || depth == CV_64F)", "void cv::magnitude(cv::InputArray, cv::InputArray, cv::OutputArray)", "third-party/opencv/src/modules/core/src/mathfuncs.cpp", "void cv::phase(cv::InputArray, cv::InputArray, cv::OutputArray, bool)", "X.size == Y.size && type == Y.type() && (depth == CV_32F || depth == CV_64F)", "void cv::cartToPolar(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool)", "(depth == CV_32F || depth == CV_64F) && (src1.empty() || src1.type() == type)", "void cv::polarToCart(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool)", "depth == CV_32F || depth == CV_64F", "bool cv::checkRange(cv::InputArray, bool, cv::Point *, double, double)", "void cvCartToPolar(const CvArr *, const CvArr *, CvArr *, CvArr *, int)", "void cvPolarToCart(const CvArr *, const CvArr *, CvArr *, CvArr *, int)", "Y.size() == Angle.size() && Y.type() == Angle.type()", "src.type() == dst.type() && src.size == dst.size", "(coeffs.size() == Size(n0, 1) || coeffs.size() == Size(n0+1, 1) || coeffs.size() == Size(1, n0) || coeffs.size() == Size(1, n0+1))", "coeffs0.rows == 1 || coeffs0.cols == 1", "type == B.type() && (type == CV_32FC1 || type == CV_64FC1 || type == CV_32FC2 || type == CV_64FC2)", "void cv::gemm(cv::InputArray, cv::InputArray, double, cv::InputArray, double, cv::OutputArray, int)", "third-party/opencv/src/modules/core/src/matmul.cpp", "C.type() == type && (((flags&GEMM_3_T) == 0 && C.rows == d_size.height && C.cols == d_size.width) || ((flags&GEMM_3_T) != 0 && C.rows == d_size.width && C.cols == d_size.height))", "void cv::transform(cv::InputArray, cv::OutputArray, cv::InputArray)", "void cv::perspectiveTransform(cv::InputArray, cv::OutputArray, cv::InputArray)", "void cv::scaleAdd(cv::InputArray, double, cv::InputArray, cv::OutputArray)", "void cv::calcCovarMatrix(const cv::Mat *, int, cv::Mat &, cv::Mat &, int, int)", "_mean.size() == size", "void cv::calcCovarMatrix(cv::InputArray, cv::OutputArray, cv::InputOutputArray, int, int)", "(*each).size() == size && (*each).type() == type", "type == v2.type() && type == icovar.type() && sz == v2.size() && len == icovar.rows && len == icovar.cols", "double cv::Mahalanobis(cv::InputArray, cv::InputArray, cv::InputArray)", "void cv::mulTransposed(cv::InputArray, cv::OutputArray, bool, cv::InputArray, double, int)", "delta.channels() == 1 && (delta.rows == src.rows || delta.rows == 1) && (delta.cols == src.cols || delta.cols == 1)", "(D.rows == ((flags & CV_GEMM_A_T) == 0 ? A.rows : A.cols)) && (D.cols == ((flags & CV_GEMM_B_T) == 0 ? B.cols : B.rows)) && D.type() == A.type()", "void cvGEMM(const CvArr *, const CvArr *, double, const CvArr *, double, CvArr *, int)", "void cvTransform(const CvArr *, CvArr *, const CvMat *, const CvMat *)", "void cvPerspectiveTransform(const CvArr *, CvArr *, const CvMat *)", "void cvScaleAdd(const CvArr *, CvScalar, const CvArr *, CvArr *)", "void cvCalcCovarMatrix(const CvArr **, int, CvArr *, CvArr *, int)", "(evals0.cols == 1 || evals0.rows == 1) && ecount0 <= ecount && evects0.cols == evects.cols && evects0.rows == ecount0", "void cvProjectPCA(const CvArr *, const CvArr *, const CvArr *, CvArr *)", "dst0.data == dst.data", "void cvBackProjectPCA(const CvArr *, const CvArr *, const CvArr *, CvArr *)", "virtual void cv::MatOp_Identity::assign(const cv::MatExpr &, cv::Mat &, int) const", "third-party/opencv/src/modules/core/src/matop.cpp", "virtual void cv::MatOp_Bin::assign(const cv::MatExpr &, cv::Mat &, int) const", "virtual void cv::MatOp_Initializer::assign(const cv::MatExpr &, cv::Mat &, int) const", "sz[i] <= (size_t)INT_MAX", "virtual void cv::MatAllocator::download(cv::UMatData *, void *, int, const size_t *, const size_t *, const size_t *, const size_t *) const", "third-party/opencv/src/modules/core/src/matrix.cpp", "virtual void cv::MatAllocator::upload(cv::UMatData *, const void *, int, const size_t *, const size_t *, const size_t *, const size_t *) const", "virtual void cv::MatAllocator::copy(cv::UMatData *, cv::UMatData *, int, const size_t *, const size_t *, const size_t *, const size_t *, const size_t *, bool) const", "cv::Mat::Mat(const cv::Mat &, const cv::Range &, const cv::Range &)", "0 <= _rowRange.start && _rowRange.start <= _rowRange.end && _rowRange.end <= m.rows", "0 <= _colRange.start && _colRange.start <= _colRange.end && _colRange.end <= m.cols", "m.dims <= 2", "r == Range::all() || (0 <= r.start && r.start < r.end && r.end <= m.size[i])", "dims <= 2", "(int)nelems >= 0", "cv::Mat cv::cvarrToMat(const CvArr *, bool, bool, int, AutoBuffer<double> *)", "total > 0 && CV_ELEM_SIZE(seq->flags) == esz", "dims <= 2 && step[0] > 0", "CV_IS_IMAGE(arr)", "ch.size == mat.size && ch.depth() == mat.depth() && 0 <= coi && coi < mat.channels()", "i < 0", "0 <= i && i < (int)v.size()", "You should explicitly call mapHost/unmapHost methods for ogl::Buffer object", "You should explicitly call download method for cuda::GpuMat object", "Unknown/unsupported array type", "You should explicitly call mapDevice/unmapDevice methods for ogl::Buffer object", "k == OPENGL_BUFFER", "i < (int)vv.size()", "(size_t)i < vv.size()", "void cv::_InputArray::copyTo(const cv::_OutputArray &, const cv::_InputArray &) const", "!fixedSize() || ((Mat*)obj)->size.operator()() == _sz", "void cv::_OutputArray::create(cv::Size, int, int, bool, int) const", "!fixedType() || ((Mat*)obj)->type() == mtype", "!fixedSize() || ((UMat*)obj)->size.operator()() == _sz", "!fixedType() || ((UMat*)obj)->type() == mtype", "!fixedSize() || ((cuda::GpuMat*)obj)->size() == _sz", "!fixedType() || ((cuda::GpuMat*)obj)->type() == mtype", "!fixedType() || ((ogl::Buffer*)obj)->type() == mtype", "!fixedType() || ((cuda::HostMem*)obj)->type() == mtype", "!fixedSize() || ((Mat*)obj)->size.operator()() == Size(_cols, _rows)", "void cv::_OutputArray::create(int, int, int, int, bool, int) const", "!fixedSize() || ((UMat*)obj)->size.operator()() == Size(_cols, _rows)", "!fixedSize() || ((cuda::GpuMat*)obj)->size() == Size(_cols, _rows)", "!fixedSize() || ((ogl::Buffer*)obj)->size() == Size(_cols, _rows)", "!fixedSize() || ((cuda::HostMem*)obj)->size() == Size(_cols, _rows)", "void cv::_OutputArray::create(int, const int *, int, int, bool, int) const", "mtype == type0 || (CV_MAT_CN(mtype) == 1 && ((1 << type0) & fixedDepthMask) != 0)", "d == 2 && ((sizes[0] == sz.height && sizes[1] == sz.width) || (allowTransposed && sizes[0] == sz.width && sizes[1] == sz.height))", "d == 2 && (sizes[0] == 1 || sizes[1] == 1 || sizes[0]*sizes[1] == 0)", "!fixedSize() || len == vv.size()", "mtype == type0 || (CV_MAT_CN(mtype) == CV_MAT_CN(type0) && ((1 << type0) & fixedDepthMask) != 0)", "!fixedSize() || len == ((std::vector<uchar>*)v)->size() / esz", "Vectors with element size %d are not supported. Please, modify OutputArray::create()\n", "create() called for the missing output array", "i < (int)v.size()", "!fixedSize()", "std::vector<cuda::GpuMat> &cv::_OutputArray::getGpuMatVecRef() const", "checkScalar(value, type(), arr.kind(), _InputArray::CUDA_GPU_MAT)", "void cv::_OutputArray::setTo(const cv::_InputArray &, const cv::_InputArray &) const", "src[i].dims <= 2 && src[i].rows == src[0].rows && src[i].type() == src[0].type()", "src[i].dims <= 2 && src[i].cols == src[0].cols && src[i].type() == src[0].type()", "src.size() == dst.size() && (src.cols == 1 || src.rows == 1)", "dims <= 2 && m.dims <= 2 && size() == m.size() && tp == m.type() && ((rows == 3 && cols == 1) || (cols*channels() == 3 && rows == 1))", "op == CV_REDUCE_SUM || op == CV_REDUCE_MAX || op == CV_REDUCE_MIN || op == CV_REDUCE_AVG", "Unsupported combination of input and output array formats", "src.dims <= 2 && src.channels() == 1 && func != 0", "src.rows == dst.cols && src.cols == dst.rows && src.type() == dst.type()", "Input and output arrays must have the same number of channels", "src.size() == idx.size() && idx.type() == CV_32S && src.data != idx.data", "int cvKMeans2(const CvArr *, int, CvArr *, CvTermCriteria, int, CvRNG *, int, CvArr *, double *)", "labels.isContinuous() && labels.type() == CV_32S && (labels.cols == 1 || labels.rows == 1) && labels.cols + labels.rows - 1 == data.rows", "_cn <= CV_CN_MAX", "Copy dimension (which has zero size) is not present in source matrix", "Requested and source matrices have different count of elements", "Reshaping of n-dimensional non-continuous matrices is not supported yet", "void cv::NAryMatIterator::init(const cv::Mat **, cv::Mat *, uchar **, int)", "void cv::SparseMat::convertTo(cv::SparseMat &, int, double) const", "void cv::SparseMat::convertTo(cv::Mat &, int, double, double) const", "hdr && hdr->dims == 2", "hdr && hdr->dims == 3", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2", "Only 32f and 64f are supported", "void cv::minMaxLoc(const cv::SparseMat &, double *, double *, int *, int *)", "void cv::normalize(const cv::SparseMat &, cv::SparseMat &, double, int)", "abs(vecs[0].dot(vecs[1])) / (norm(vecs[0]) * norm(vecs[1])) <= FLT_EPSILON", "cv::RotatedRect::RotatedRect(const cv::Point2f &, const cv::Point2f &, const cv::Point2f &)", "virtual cv::UMatData *cv::StdMatAllocator::allocate(int, const int *, int, void *, size_t *, int, cv::UMatUsageFlags) const", "virtual void cv::StdMatAllocator::deallocate(cv::UMatData *) const", "void cv::setSize(cv::Mat &, int, const int *, const size_t *, bool)", "Step must be a multiple of esz1", "img->dataOrder == IPL_DATA_ORDER_PIXEL", "cv::Mat cv::iplImageToMat(const IplImage *, bool)", "total() == 0 || data != NULL", "src.data != dst.data", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = unsigned char]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = signed char]", "void cv::sortIdx_(const cv::Mat &, cv::Mat &, int) [T = unsigned short]", "third-party/opencv/src/modules/core/src/opengl.cpp", "depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "depth == CV_8S || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "OpenCV was build without OpenGL support", "void cv::ogl::convertToGLTexture2D(cv::InputArray, cv::ogl::Texture2D &)", "void cv::ogl::convertFromGLTexture2D(const cv::ogl::Texture2D &, cv::OutputArray)", "cn <= 4 && func != 0", "third-party/opencv/src/modules/core/src/stat.cpp", "mask.empty() || mask.type() == CV_8U", "void cv::meanStdDev(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::InputArray)", "dst.type() == CV_64F && dst.isContinuous() && (dst.cols == 1 || dst.rows == 1) && dcn >= cn", "(cn == 1 && (_mask.empty() || _mask.type() == CV_8U)) || (cn > 1 && _mask.empty() && !minIdx && !maxIdx)", "void cv::minMaxIdx(cv::InputArray, double *, double *, int *, int *, cv::InputArray)", "void cv::minMaxLoc(cv::InputArray, double *, double *, cv::Point *, cv::Point *, cv::InputArray)", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && _src.type() == CV_8U)", "double cv::norm(cv::InputArray, cv::InputArray, int, cv::InputArray)", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && src1.type() == CV_8U)", "type == src2.type() && src1.cols == src2.cols && (type == CV_32F || type == CV_8U)", "void cv::batchDistance(cv::InputArray, cv::InputArray, cv::OutputArray, int, cv::OutputArray, int, int, cv::InputArray, int, bool)", "The combination of type=%d, dtype=%d and normType=%d is not supported", "0 < coi && coi <= 4", "void cvAvgSdv(const CvArr *, CvScalar *, CvScalar *, const void *)", "\nGeneral configuration for OpenCV 3.1.0 =====================================\n  Version control:               unknown\n\n  Platform:\n    Host:                        Darwin 15.6.0 x86_64\n    CMake:                       3.6.1\n    CMake generator:             Unix Makefiles\n    CMake build tool:            /usr/bin/make\n    Configuration:               RELEASE\n\n  C/C++:\n    Built as dynamic libs?:      YES\n    C++ Compiler:                /Applications/Xcode7.3.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++  (ver 7.3.0.7030031)\n    C++ flags (Release):         -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG  -DNDEBUG\n    C++ flags (Debug):           -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -g  -O0 -DDEBUG -D_DEBUG\n    C Compiler:                  /Applications/Xcode7.3.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc\n    C flags (Release):           -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG  -DNDEBUG\n    C flags (Debug):             -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -g  -O0 -DDEBUG -D_DEBUG\n    Linker flags (Release):\n    Linker flags (Debug):\n    Precompiled headers:         NO\n    Extra dependencies:          -framework OpenCL -framework Cocoa avcodec avformat avutil swscale avresample /usr/lib/libbz2.dylib -framework VideoDecodeAcceleration bz2 -framework QTKit -framework QuartzCore -framework AppKit\n    3rdparty dependencies:       libjpeg libwebp libpng libtiff libjasper IlmImf zlib libprotobuf\n\n  OpenCV modules:\n    To be built:                 core flann imgproc ml photo reg surface_matching video dnn fuzzy imgcodecs shape videoio highgui objdetect plot superres ts xobjdetect xphoto bgsegm bioinspired dpm face features2d line_descriptor saliency text calib3d ccalib datasets rgbd stereo structured_light tracking videostab xfeatures2d ximgproc aruco optflow stitching\n    Disabled:                    world contrib_world\n    Disabled by dependency:      -\n    Unavailable:                 cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev java python2 python3 viz cvv hdf matlab sfm\n\n  GUI: \n    QT:                          NO\n    Cocoa:                       YES\n    OpenGL support:              NO\n    VTK support:                 NO\n\n  Media I/O: \n    ZLib:                        build (ver 1.2.8)\n    JPEG:                        build (ver 90)\n    WEBP:                        build (ver 0.3.1)\n    PNG:                         build (ver 1.6.19)\n    TIFF:                        build (ver 42 - 4.0.2)\n    JPEG 2000:                   build (ver 1.900.1)\n    OpenEXR:                     build (ver 1.7.1)\n    GDAL:                        NO\n\n  Video I/O:\n    DC1394 1.x:                  NO\n    DC1394 2.x:                  NO\n    FFMPEG:                      YES\n      codec:                     YES (ver 57.48.101)\n      format:                    YES (ver 57.41.100)\n      util:                      YES (ver 55.28.100)\n      swscale:                   YES (ver 4.1.100)\n      resample:                  YES (ver 3.0.0)\n      gentoo-style:              YES\n    GStreamer:                   NO\n    OpenNI:                      NO\n    OpenNI PrimeSensor Modules:  NO\n    OpenNI2:                     NO\n    PvAPI:                       NO\n    GigEVisionSDK:               NO\n    QuickTime:                   NO\n    QTKit:                       YES\n    V4L/V4L2:                    NO/NO\n    XIMEA:                       NO\n    gPhoto2:                     NO\n\n  Parallel framework:            GCD\n\n  Other third-party libraries:\n    Use IPP:                     9.0.1 [9.0.1]\n         at:                     /Users/kri/workspace/third_party/opencv3.1/opencv-3.1.0/3rdparty/ippicv/unpack/ippicv_osx\n    Use IPP Async:               NO\n    Use VA:                      NO\n    Use Intel VA-API/OpenCL:     NO\n    Use Eigen:                   YES (ver 3.2.9)\n    Use Cuda:                    NO\n    Use OpenCL:                  YES\n    Use custom HAL:              NO\n\n  OpenCL:\n    Version:                     static\n    libraries:                   -framework OpenCL\n    Use AMDFFT:                  NO\n    Use AMDBLAS:                 NO\n\n  Python 2:\n    Interpreter:                 /usr/local/bin/python2.7 (ver 2.7.12)\n\n  Python 3:\n    Interpreter:                 /usr/local/bin/python3 (ver 3.5.2)\n\n  Python (for build):            /usr/local/bin/python2.7\n\n  Java:\n    ant:                         NO\n    JNI:                         /System/Library/Frameworks/JavaVM.framework/Headers /System/Library/Frameworks/JavaVM.framework/Headers /System/Library/Frameworks/JavaVM.framework/Headers\n    Java wrappers:               NO\n    Java tests:                  NO\n\n  Matlab:                        Matlab not found or implicitly disabled\n\n  Documentation:\n    Doxygen:                     NO\n    PlantUML:                    NO\n\n  Tests and samples:\n    Tests:                       YES\n    Performance tests:           YES\n    C/C++ Examples:              NO\n\n  Install path:                  /Users/kri/workspace/third_party/opencv3.1/opencv-3.1.0/build\n\n  cvconfig.h is in:              /Users/kri/workspace/third_party/opencv3.1/opencv-3.1.0/build\n-----------------------------------------------------------------\n\n", "Unspecified error", "Internal error", "Insufficient memory", "Bad argument", "Iterations do not converge", "Autotrace call", "Incorrect size of input array", "Null pointer", "Division by zero occured", "Image step is wrong", "Inplace operation is not supported", "Requested object was not found", "Input image depth is not supported by function", "Formats of input arguments do not match", "Sizes of input arguments do not match", "One of arguments' values is out of range", "Unsupported format or combination of formats", "Input COI is not supported", "Bad number of channels", "Bad flag (parameter or structure field)", "Bad parameter of type CvPoint", "Bad type of mask argument", "The function/feature is not implemented", "Unknown %s code %d", "status", "error", "third-party/opencv/src/modules/core/src/system.cpp", "vector::reserve", "vector::_M_emplace_back_aux", "tlsSlots.size() > slotIdx", "third-party/opencv/src/modules/core/src/umatrix.cpp", "void cv::setSize(cv::UMat &, int, const int *, const size_t *, bool)", "void cv::UMat::create(int, const int *, int, cv::UMatUsageFlags)", "cv::UMat::UMat(const cv::UMat &, const cv::Range &, const cv::Range &)", "ssize.area() > 0", "void cv::resize(cv::InputArray, cv::OutputArray, cv::Size, double, double, int)", "third-party/opencv/src/modules/imgproc/src/imgwarp.cpp", "Unknown interpolation method", "void cv::remap(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, int, int, const cv::Scalar &)", "((map1.type() == CV_32FC2 || map1.type() == CV_16SC2) && map2.empty()) || (map1.type() == CV_32FC1 && map2.type() == CV_32FC1)", "(m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) || (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) || (m1type == CV_32FC1 && m2type == CV_32FC1) || (m1type == CV_32FC2 && m2->empty())", "void cv::convertMaps(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, int, bool)", "dstm1type == CV_16SC2 || dstm1type == CV_32FC1 || dstm1type == CV_32FC2", "void cv::warpAffine(cv::InputArray, cv::OutputArray, cv::InputArray, cv::Size, int, int, const cv::Scalar &)", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 2 && M0.cols == 3", "void cv::warpPerspective(cv::InputArray, cv::OutputArray, cv::InputArray, cv::Size, int, int, const cv::Scalar &)", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 3 && M0.cols == 3", "src.checkVector(2, CV_32F) == 4 && dst.checkVector(2, CV_32F) == 4", "cv::Mat cv::getPerspectiveTransform(cv::InputArray, cv::InputArray)", "src.checkVector(2, CV_32F) == 3 && dst.checkVector(2, CV_32F) == 3", "src.type() == dst.type()", "void cvWarpAffine(const CvArr *, CvArr *, const CvMat *, int, CvScalar)", "void cvWarpPerspective(const CvArr *, CvArr *, const CvMat *, int, CvScalar)", "void cvRemap(const CvArr *, CvArr *, const CvArr *, const CvArr *, int, CvScalar)", "M.size() == M0.size()", "CvMat *cv2DRotationMatrix(CvPoint2D32f, double, double, CvMat *)", "CvMat *cvGetPerspectiveTransform(const CvPoint2D32f *, const CvPoint2D32f *, CvMat *)", "CvMat *cvGetAffineTransform(const CvPoint2D32f *, const CvPoint2D32f *, CvMat *)", "void cvLogPolar(const CvArr *, CvArr *, CvPoint2D32f, double, int)", "void cvLinearPolar(const CvArr *, CvArr *, CvPoint2D32f, double, int)", "ksize <= MAX_ESIZE", "cv::resizeGeneric_Invoker<cv::HResizeLinear<unsigned char, int, short, 2048, cv::HResizeNoVec>, cv::VResizeLinear<uchar, int, short, FixedPtCast<int, uchar, INTER_RESIZE_COEF_BITS * 2>, cv::VResizeLinearVec_32s8u> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLinear<unsigned char, int, short, 2048, cv::HResizeNoVec>, VResize = cv::VResizeLinear<uchar, int, short, FixedPtCast<int, uchar, INTER_RESIZE_COEF_BITS * 2>, cv::VResizeLinearVec_32s8u>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<unsigned short, float, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLinear<unsigned short, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<short, float, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLinear<short, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<float, float, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLinear<float, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLinear<double, double, float, 1, cv::HResizeNoVec>, cv::VResizeLinear<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLinear<double, double, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<unsigned char, int, short>, cv::VResizeCubic<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeCubic<unsigned char, int, short>, VResize = cv::VResizeCubic<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<unsigned short, float, float>, cv::VResizeCubic<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeCubic<unsigned short, float, float>, VResize = cv::VResizeCubic<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<short, float, float>, cv::VResizeCubic<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeCubic<short, float, float>, VResize = cv::VResizeCubic<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<float, float, float>, cv::VResizeCubic<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeCubic<float, float, float>, VResize = cv::VResizeCubic<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeCubic<double, double, float>, cv::VResizeCubic<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeCubic<double, double, float>, VResize = cv::VResizeCubic<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<unsigned char, int, short>, cv::VResizeLanczos4<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLanczos4<unsigned char, int, short>, VResize = cv::VResizeLanczos4<unsigned char, int, short, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<unsigned short, float, float>, cv::VResizeLanczos4<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLanczos4<unsigned short, float, float>, VResize = cv::VResizeLanczos4<unsigned short, float, float, cv::Cast<float, unsigned short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<short, float, float>, cv::VResizeLanczos4<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLanczos4<short, float, float>, VResize = cv::VResizeLanczos4<short, float, float, cv::Cast<float, short>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<float, float, float>, cv::VResizeLanczos4<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLanczos4<float, float, float>, VResize = cv::VResizeLanczos4<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>]", "cv::resizeGeneric_Invoker<cv::HResizeLanczos4<double, double, float>, cv::VResizeLanczos4<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec> >::resizeGeneric_Invoker(const cv::Mat &, cv::Mat &, const int *, const int *, const cv::resizeGeneric_Invoker::AT *, const cv::resizeGeneric_Invoker::AT *, const cv::Size &, const cv::Size &, int, int, int) [HResize = cv::HResizeLanczos4<double, double, float>, VResize = cv::VResizeLanczos4<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>]", "cn == 4", "int cv::ResizeAreaFastVec<unsigned char, cv::ResizeAreaFastNoVec<unsigned char, unsigned char> >::operator()(const T *, T *, int) const [T = unsigned char, SIMDVecOp = cv::ResizeAreaFastNoVec<unsigned char, unsigned char>]", "int cv::ResizeAreaFastVec<unsigned short, cv::ResizeAreaFastNoVec<unsigned short, unsigned short> >::operator()(const T *, T *, int) const [T = unsigned short, SIMDVecOp = cv::ResizeAreaFastNoVec<unsigned short, unsigned short>]", "int cv::ResizeAreaFastVec<short, cv::ResizeAreaFastNoVec<short, short> >::operator()(const T *, T *, int) const [T = short, SIMDVecOp = cv::ResizeAreaFastNoVec<short, short>]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const cv::Scalar &) [CastOp = cv::FixedPtCast<int, unsigned char, 15>, VecOp = cv::RemapNoVec, AT = short]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const cv::Scalar &) [CastOp = cv::Cast<float, unsigned short>, VecOp = cv::RemapNoVec, AT = float]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const cv::Scalar &) [CastOp = cv::Cast<float, short>, VecOp = cv::RemapNoVec, AT = float]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const cv::Scalar &) [CastOp = cv::Cast<float, float>, VecOp = cv::RemapNoVec, AT = float]", "void cv::remapBilinear(const cv::Mat &, cv::Mat &, const cv::Mat &, const cv::Mat &, const void *, int, const cv::Scalar &) [CastOp = cv::Cast<double, double>, VecOp = cv::RemapNoVec, AT = float]", "0Y\r@:i\r", "PF SdF", " [@W:[", "N2cv14MatOp_IdentityE", "N2cv5MatOpE", "N2cv11MatOp_AddExE", "N2cv9MatOp_BinE", "N2cv9MatOp_CmpE", "N2cv10MatOp_GEMME", "N2cv12MatOp_InvertE", "N2cv7MatOp_TE", "N2cv11MatOp_SolveE", "N2cv17MatOp_InitializerE", "N2cv12MatAllocatorE", "N2cv25DummyBufferPoolControllerE", "N2cv20BufferPoolControllerE", "N2cv15StdMatAllocatorE", "N2cv9ExceptionE"], "stringidentifiers": ["vector::_M_default_append", "status", "error", "vector::reserve", "vector::_M_emplace_back_aux", "N2cv14MatOp_IdentityE", "N2cv5MatOpE", "N2cv11MatOp_AddExE", "N2cv9MatOp_BinE", "N2cv9MatOp_CmpE", "N2cv10MatOp_GEMME", "N2cv12MatOp_InvertE", "N2cv7MatOp_TE", "N2cv11MatOp_SolveE", "N2cv17MatOp_InitializerE", "N2cv12MatAllocatorE", "N2cv25DummyBufferPoolControllerE", "N2cv20BufferPoolControllerE", "N2cv15StdMatAllocatorE", "N2cv9ExceptionE"], "debugstrings": ["GCC: (GNU) 4.9.x 20150123 (prerelease)", "Android clang version 5.0.300080  (based on LLVM 5.0.300080)"], "localsymbols": [""], "dependencies": ["liblog.so", "libmemalign16.so", "libdl.so", "libc.so", "libstdc++.so", "libgnustl_shared.so", "libm.so"], "elfname": "libopencv.so"}