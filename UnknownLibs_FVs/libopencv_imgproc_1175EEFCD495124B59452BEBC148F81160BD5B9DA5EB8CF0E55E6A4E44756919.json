{"globalvars": ["_ZTSN2cv13BaseRowFilterE", "__FINI_ARRAY__", "hist_type", "_ZTIN2cv12FilterEngineE", "icv8x32fTab_cv", "_ZTSN2cv16BaseColumnFilterE", "_ZTVN2cv12FilterEngineE", "_ZTIN2cv13BaseRowFilterE", "__dso_handle", "__INIT_ARRAY__", "_ZTIN2cv10BaseFilterE", "_ZTVN2cv16BaseColumnFilterE", "_ZTSN2cv10BaseFilterE", "_ZTVN2cv10BaseFilterE", "_ZTSN2cv12FilterEngineE", "icv8x32fSqrTab", "_ZTVN2cv13BaseRowFilterE", "icvSaturate8u_cv", "__data_start", "_ZTIN2cv16BaseColumnFilterE"], "importedglobals": ["_ZTIPv", "_ctype_", "_ZTVSt13bad_exception", "_ZTIN10__cxxabiv119__foreign_exceptionE", "_ZTISt8bad_cast", "_ZTVN10__cxxabiv121__vmi_class_type_infoE", "_ZTVN2cv12_OutputArrayE", "_ZTVN2cv11_InputArrayE", "__sF", "_ZTISt13bad_exception", "_ZTVN10__cxxabiv117__class_type_infoE", "_ZTIN10__cxxabiv115__forced_unwindE", "_ZTVN10__cxxabiv120__si_class_type_infoE", "_ZTIv", "_ZTVSt9bad_alloc", "_ZTISt9bad_alloc", "_ZTISt9exception", "_ZTVSt8bad_cast"], "importedfunctions": ["exp", "_Znwj", "cvDrawContours", "pow", "wcslen", "_ZNK2cv3Mat1tEv", "cvSolve", "btowc", "_Unwind_VRS_Get", "setlocale", "cvSum", "cvReleaseMat", "_ZN2cv6kmeansERKNS_11_InputArrayEiRKNS_12_OutputArrayENS_12TermCriteriaEiiS5_", "cvCreateChildMemStorage", "memmove", "memset", "wcscoll", "strcmp", "strcoll", "cvChangeSeqBlock", "_Unwind_GetTextRelBase", "strftime", "_ZN2cv8subtractERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "cvClearSeq", "wcrtomb", "cvCartToPolar", "cvCreateSparseMat", "cvRead", "cvScalarToRawData", "_ZN2cv3MataSERKNS_7Scalar_IdEE", "_ZN2cv5solveERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "cvEndWriteSeq", "_ZN2cv4flipERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvCreateSeq", "_ZN2cv10meanStdDevERKNS_11_InputArrayERKNS_12_OutputArrayES5_S2_", "ungetwc", "cvWriteInt", "fseek", "_ZNK2cv3Mat7reshapeEiiPKi", "_Znaj", "_Unwind_Resume", "cvInitSparseMatIterator", "_ZN2cv17getOptimalDFTSizeEi", "cvSeqPush", "cvInsertNodeIntoTree", "_Unwind_GetDataRelBase", "cvCbrt", "cvGetDims", "_ZN2cv22SparseMatConstIteratorC1EPKNS_9SparseMatE", "cvStartReadRawData", "cvReleaseData", "cvFastArctan", "cvEndWriteStruct", "cvGetImage", "_ZNK2cv3Mat9locateROIERNS_5Size_IiEERNS_6Point_IiEE", "_Unwind_GetLanguageSpecificData", "_ZN2cv3Mat5setToERKNS_11_InputArrayES3_", "towlower", "cvSeqPushMulti", "cvSaveMemStoragePos", "cvCmpS", "abort", "cvFlushSeqWriter", "_ZN2cv9patchNaNsERKNS_12_OutputArrayEd", "cvAlloc", "cvStartReadSeq", "cvStartWriteSeq", "_ZN6CvTypeC1EPKcPFiPKvEPFvPPvEPFS6_P13CvFileStorageP10CvFileNodeEPFvSB_S1_S3_10CvAttrListEPFS6_S3_E", "cvSeqPopMulti", "cvSetSeqReaderPos", "_ZNK2cv7MatExpr3invEi", "strtod", "_ZN2cv12_OutputArrayC1ERNS_3MatE", "cvWriteRawData", "cvTreeToNodeSeq", "_ZN10__cxxabiv112__unexpectedEPFvvE", "cvWrite", "atan2", "getwc", "_Unwind_GetRegionStart", "cvInvert", "cvGetFileNodeByName", "fread", "_ZN2cv3PtrI5CvMatE10delete_objEv", "cvReleaseSparseMat", "iswctype", "_ZN2cvmlERKNS_3MatES2_", "_ZN2cv9ExceptionC1EiRKSsS2_S2_i", "_ZN2cv22SparseMatConstIteratorppEv", "_ZN2cv9SparseMatC1EPK11CvSparseMat", "_ZN2cv5mergeEPKNS_3MatEjRKNS_12_OutputArrayE", "cvStartAppendToSeq", "_ZN2cv3MatC1EPK7CvMatNDb", "towupper", "acos", "log", "cvGEMM", "printf", "_ZN2cv15NAryMatIteratorppEv", "_Unwind_VRS_Set", "wmemchr", "_ZdaPv", "cvSetZero", "_ZN2cv3Mat6createEiPKii", "__dynamic_cast", "_ZNK2cv3Mat11checkVectorEiib", "cvInitMatHeader", "_ZN2cv5splitERKNS_3MatERSt6vectorIS0_SaIS0_EE", "_ZN2cv3Mat3eyeEiii", "cvCreateSeqBlock", "_ZN2cv5splitERKNS_3MatEPS0_", "memcmp", "_ZN2cv14extractChannelERKNS_11_InputArrayERKNS_12_OutputArrayEi", "log10", "cvGetSeqElem", "cvPtrND", "_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPS1_i", "_ZN2cv3dftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "getc", "_ZN2cv3MatC1EiPKiiPvPKj", "_ZN2cv12countNonZeroERKNS_11_InputArrayE", "_ZN2cv3Mat10deallocateEv", "putwc", "strxfrm", "cvCopy", "cvCreateData", "cvDiv", "cvAdd", "_ZN10__cxxabiv111__terminateEPFvvE", "_ZN2cv6formatEPKcz", "_ZN2cv7compareERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "_ZNK2cv3Mat6copyToERKNS_12_OutputArrayE", "__gnu_unwind_frame", "sin", "cvMakeSeqHeaderForArray", "_ZNSt13bad_exceptionD1Ev", "_ZN2cv9SparseMat6createEiPKii", "_ZNK2cv3Mat9convertToERKNS_12_OutputArrayEidd", "sscanf", "_ZN2cv5errorERKNS_9ExceptionE", "_ZN2cv4meanERKNS_11_InputArrayES2_", "pthread_mutex_lock", "cvSeqElemIdx", "wmemcpy", "fwrite", "_ZdlPv", "pthread_once", "cvMinMaxLoc", "_ZN2cv8fastFreeEPv", "cvSetData", "_ZN2cv3Mat9adjustROIEiiii", "putc", "cvReleaseMemStorage", "cvFree_", "_ZN2cv4idftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "wctob", "cos", "_ZN2cv5mergeERKSt6vectorINS_3MatESaIS1_EERKNS_12_OutputArrayE", "cvGetCols", "cvGetMat", "_ZN2cv11mixChannelsEPKNS_3MatEjPS0_jPKij", "_ZN6CvTypeD1Ev", "_ZNK2cv11RotatedRect6pointsEPNS_6Point_IfEE", "_ZN2cv3addERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "memchr", "cvReadRawDataSlice", "_ZN2cv3MatC1ERKS0_RKNS_5Rect_IiEE", "cvCreateSet", "strlen", "wctype", "_ZN2cv8multiplyERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi", "lrint", "cvSeqPop", "_ZN2cvmiERKNS_3MatES2_", "_ZN2cv10cvarrToMatEPKvbbi", "vsprintf", "_ZN2cv9SparseMat3ptrEPKibPj", "_ZN2cv11_InputArrayC1ERKNS_3MatE", "wmemset", "_ZN2cv15scalarToRawDataERKNS_7Scalar_IdEEPvii", "cvSliceLength", "_ZN2cv12mulSpectrumsERKNS_11_InputArrayES2_RKNS_12_OutputArrayEib", "cvCreateMat", "cvCvtSeqToArray", "_ZN2cv9minMaxLocERKNS_11_InputArrayEPdS3_PNS_6Point_IiEES6_S2_", "_ZN2cv22SparseMatConstIteratorC2EPKNS_9SparseMatE", "sqrt", "cvConvertScale", "_ZSt9terminatev", "cvCreateMemStorage", "pthread_mutex_unlock", "cvMemStorageAlloc", "asin", "_ZN2cv12_OutputArrayC1Ev", "cvSetIdentity", "_ZN2cv20checkHardwareSupportEi", "_ZN2cv9ExceptionD1Ev", "cvClearMemStorage", "cvPow", "_ZN2cv3Mat8copySizeERKS0_", "ungetc", "cvInitLineIterator", "_ZN2cv4normERKNS_11_InputArrayES2_iS2_", "mbrtowc", "_ZNK2cv3Mat7reshapeEii", "_ZN2cv3PtrI12CvMemStorageE10delete_objEv", "_ZN2cv11_InputArrayC1ERKd", "_ZN2cv10fastMallocEj", "cvInitNArrayIterator", "_ZN2cv3MatC1ERKS0_RKNS_5RangeES5_", "_ZN2cv6invertERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv3MatC1EPK5CvMatb", "fflush", "_ZN2cv7noArrayEv", "cvLog", "_ZNSt9bad_allocD1Ev", "_ZNSt8bad_castD1Ev", "cvGetSeqReaderPos", "sqrtf", "cvRestoreMemStoragePos", "cvStartWriteStruct", "cvMul", "cvSetAdd", "ftell", "cvNextNArraySlice", "strerror", "wcsxfrm", "cvInitMatNDHeader", "_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPPhi", "_ZSt10unexpectedv", "wcsftime", "cvEigenVV", "cvCreateMatHeader", "wmemmove", "_ZNSt9exceptionD2Ev", "_ZN2cv4sqrtERKNS_11_InputArrayERKNS_12_OutputArrayE", "memcpy"], "exportedfunctions": ["_ZN2cv9boxFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiNS_5Size_IiEENS_6Point_IiEEbi", "_Z23icvApproximateChainTC89P7CvChainiP12CvMemStoragei", "_ZN2cv15warpPerspectiveERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv22cornerEigenValsAndVecsERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "_ZpLRN2cv3VecIiLi3EEERKNS0_IhLi3EEE", "_ZN2cv9thresholdERKNS_11_InputArrayERKNS_12_OutputArrayEddi", "_ZN2cv17adaptiveThresholdERKNS_11_InputArrayERKNS_12_OutputArrayEdiiid", "cvReleasePyramid", "_ZN2cv18getColumnSumFilterEiiiid", "_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEPPKfdb", "cvThreshHist", "_ZN2cv7MomentsC1Ev", "_ZN2cv8Subdiv2D12clearVoronoiEv", "_ZN2cv22createMorphologyFilterEiiRKNS_11_InputArrayENS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv10fitEllipseERKNS_11_InputArrayE", "_ZN2cv5pyrUpERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi", "cvIntegral", "_ZN2cv12FilterEngine4initERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "_ZN2cv9crossCorrERKNS_3MatES2_RS0_NS_5Size_IiEEiNS_6Point_IiEEdi", "_ZN2cv21intersectConvexConvexERKNS_11_InputArrayES2_RKNS_12_OutputArrayEb", "_ZN3GMMC2ERN2cv3MatE", "_Z8initGMMsRKN2cv3MatES2_R3GMMS4_", "cvCornerHarris", "_ZN2cv8Subdiv2DC1Ev", "cvInitUndistortRectifyMap", "cvAcc", "cvConvexityDefects", "cvSubstituteContour", "cvCalcArrBackProject", "_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_9SparseMatERKNS_12_OutputArrayEPPKfdb", "cvCalcEMD2", "_ZN2cv19getRotationMatrix2DENS_6Point_IfEEdd", "_ZN2cv7grabCutERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Rect_IiEES5_S5_ii", "cvSetHistBinRanges", "_Z16initMaskWithRectRN2cv3MatENS_5Size_IiEENS_5Rect_IiEE", "cvApproxPoly", "cvGetHuMoments", "_ZN2cv16weightedCentroidERKNS_11_InputArrayENS_6Point_IiEENS_5Size_IiEE", "_ZNK2cv8Subdiv2D11checkSubdivEv", "_ZN2cv7pyrDownERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi", "_Z29icvGetQuadrangleSubPix_8u_C1RPKhi6CvSizePhiS1_PKf", "cvGetRectSubPix", "cvLogPolar", "_ZN2cv15createBoxFilterEiiNS_5Size_IiEENS_6Point_IiEEbi", "_ZN2cv21invertAffineTransformERKNS_11_InputArrayERKNS_12_OutputArrayE", "_Z8calcBetaRKN2cv3MatE", "_ZN2cv12morphologyExERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "cvDistTransform", "_ZSt14__convert_to_vIfEvPKcRT_RSt12_Ios_IostateRKPi", "cv2DRotationMatrix", "cvMultiplyAcc", "_ZN2cv11minAreaRectERKNS_11_InputArrayE", "_ZN2cv13getKernelTypeERKNS_11_InputArrayENS_6Point_IiEE", "_ZN2cv10medianBlurERKNS_11_InputArrayERKNS_12_OutputArrayEi", "cvFindContours", "cvGetSpatialMoment", "cvConvertMaps", "_ZN2cv16accumulateSquareERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_i", "_ZN2cv8Subdiv2D8QuadEdgeC2Ei", "_ZN2cv11contourAreaERKNS_11_InputArrayEb", "_ZN2cv8Subdiv2D11deletePointEi", "cvThreshold", "cvGetQuadrangleSubPix", "_ZN2cv10BaseFilterC2Ev", "cvMinEnclosingCircle", "_Z18icvIntersectLines3PdS_S_S_S_S_P12CvPoint2D32f", "_ZN2cv12FilterEngineD0Ev", "_ZN2cv22getMorphologyRowFilterEiiii", "_ZN3GMM11endLearningEv", "_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayES5_iii", "_ZN2cv10BaseFilterC1Ev", "_ZN2cv14phaseCorrelateERKNS_11_InputArrayES2_S2_", "cvBoundingRect", "cvPyrMeanShiftFiltering", "cvHoughCircles", "_ZN2cv8Subdiv2D9swapEdgesEi", "_ZN2cv21pyrMeanShiftFilteringERKNS_11_InputArrayERKNS_12_OutputArrayEddiNS_12TermCriteriaE", "cvCalcArrBackProjectPatch", "_ZN2cv5remapERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_iiRKNS_7Scalar_IdEE", "cvMoments", "_ZN2cv12FilterEngineD2Ev", "cvCalcArrHist", "_ZN2cv21getLinearColumnFilterEiiRKNS_11_InputArrayEiidi", "cvMakeHistHeaderForArray", "_Z24icvGetRectSubPix_32f_C1RPKfi6CvSizePfiS1_12CvPoint2D32f", "cvReleaseStructuringElement", "_ZN2cv6ScharrERKNS_11_InputArrayERKNS_12_OutputArrayEiiiddi", "_ZN2cv19createHanningWindowERKNS_12_OutputArrayENS_5Size_IiEEi", "_ZN2cv8calcHistERKNS_11_InputArrayERKSt6vectorIiSaIiEES2_RKNS_12_OutputArrayES7_RKS3_IfSaIfEEb", "_ZN2cv10BaseFilterD1Ev", "cvWatershed", "_ZNK3GMM14whichComponentEN2cv3VecIdLi3EEE", "_ZN2cv8Subdiv2D8QuadEdgeC1Ev", "_ZN2cv16BaseColumnFilterD2Ev", "_Z15h_is_pos__index4_pos", "_ZN2cv8Subdiv2DC2Ev", "cvPointSeqFromMat", "_ZN2cv10warpAffineERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv5erodeERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv12findContoursERKNS_12_OutputArrayES2_iiNS_6Point_IiEE", "cvGetNormalizedCentralMoment", "cvCornerMinEigenVal", "cvClearHist", "_ZN2cv18accumulateWeightedERKNS_11_InputArrayERKNS_12_OutputArrayEdS2_", "_Z16constructGCGraphRKN2cv3MatES2_RK3GMMS5_dS2_S2_S2_S2_R7GCGraphIdE", "_ZN2cv3EMDERKNS_11_InputArrayES2_iS2_PfRKNS_12_OutputArrayE", "cvArcLength", "_ZN2cv12buildPyramidERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv15bilateralFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiddi", "cvSmooth", "_ZN3GMM9addSampleEiN2cv3VecIdLi3EEE", "cvRunningAvg", "cvBoxPoints", "_ZN2cv8Subdiv2D8newPointENS_6Point_IfEEbi", "_ZN2cv11matchShapesERKNS_11_InputArrayES2_id", "cvCalcProbDensity", "cvEndFindContours", "_ZN2cv16convexityDefectsERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "cvCanny", "_ZN2cv12integral_64fEPdjS0_jS0_jS0_jNS_5Size_IiEEi", "_ZN2cv8Subdiv2D6VertexC1ENS_6Point_IfEEbi", "_ZN2cv16BaseColumnFilterC1Ev", "_ZN2cv10BaseFilterD2Ev", "_ZN2cv3PtrI14_IplConvKernelE10delete_objEv", "_Z17icvIntersectLinesddddddddPd", "_ZN2cv7MomentsC1Edddddddddd", "_ZN2cv13BaseRowFilterC2Ev", "_ZN2cv3PtrI11CvHistogramE10delete_objEv", "_ZN2cv8Subdiv2D6insertENS_6Point_IfEE", "_ZN2cv13BaseRowFilterC1Ev", "_ZN2cv17borderInterpolateEiii", "_Z12calcNWeightsRKN2cv3MatERS0_S3_S3_S3_dd", "_Z30icvGetQuadrangleSubPix_32f_C1RPKfi6CvSizePfiS1_S0_", "_ZN2cv12GaussianBlurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi", "_ZN2cv18createLinearFilterEiiRKNS_11_InputArrayENS_6Point_IiEEdiiRKNS_7Scalar_IdEE", "_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayEii", "cvCheckContourConvexity", "_ZN2cv8Subdiv2D10deleteEdgeEi", "_ZNK2cv7Momentscv9CvMomentsEv", "_ZN2cv7MomentsC2Ev", "_Z20assignGMMsComponentsRKN2cv3MatES2_RK3GMMS5_RS0_", "cvResize", "_ZNK2cv8Subdiv2D7getEdgeEii", "_ZN2cv10convexHullERKNS_11_InputArrayERKNS_12_OutputArrayEbb", "_ZN2cv14integral_8u32fEPhjPfjPdjS1_jNS_5Size_IiEEi", "cvFilter2D", "cvFitEllipse2", "_ZN2cv8Subdiv2DC2ENS_5Rect_IiEE", "_ZN2cv13matchTemplateERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "_ZN2cv8Subdiv2D6locateENS_6Point_IfEERiS3_", "cvInitUndistortMap", "_ZN2cv13BaseRowFilterD0Ev", "_Z20icvSepConvSmall3_32fPfiS_i6CvSizePKfS2_S_", "cvDilate", "_ZNK2cv8Subdiv2D7edgeOrgEiPNS_6Point_IfEE", "cvGetAffineTransform", "_ZN2cv12integral_32fEPfjS0_jPdjS0_jNS_5Size_IiEEi", "_ZN2cv16BaseColumnFilterC2Ev", "_ZN2cv4PSNRERKNS_11_InputArrayES2_", "cvCreateStructuringElementEx", "cvMatchTemplate", "cvCvtColor", "_ZN2cv8Subdiv2D6VertexC2ENS_6Point_IfEEbi", "cvCalcBayesianProb", "_ZN2cv20createGaussianFilterEiNS_5Size_IiEEddi", "cvSampleLine", "_ZN2cv15calcBackProjectERKNS_11_InputArrayERKSt6vectorIiSaIiEES2_RKNS_12_OutputArrayERKS3_IfSaIfEEd", "_ZNK2cv8Subdiv2D11getEdgeListERSt6vectorINS_3VecIfLi4EEESaIS3_EE", "_ZN2cv10HoughLinesERKNS_11_InputArrayERKNS_12_OutputArrayEddidd", "_ZN2cv9HuMomentsERKNS_7MomentsERKNS_12_OutputArrayE", "_ZN2cv25getDefaultNewCameraMatrixERKNS_11_InputArrayENS_5Size_IiEEb", "_ZNK2cv8Subdiv2D7edgeDstEiPNS_6Point_IfEE", "_ZN3GMM12initLearningEv", "_ZNK2cv12FilterEngine18remainingInputRowsEv", "cvContourArea", "_ZNK2cv12FilterEngine19remainingOutputRowsEv", "cvHoughLines2", "_ZN2cv23initUndistortRectifyMapERKNS_11_InputArrayES2_S2_S2_NS_5Size_IiEEiRKNS_12_OutputArrayES7_", "_ZN2cv6resizeERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi", "_ZNK2cv8Subdiv2D9getVertexEiPi", "_ZN2cv15getLinearFilterEiiRKNS_11_InputArrayENS_6Point_IiEEdi", "_ZN2cv8eigen2x2EPKfPfi", "cvUndistortPoints", "_ZNK2cv8Subdiv2D9isRightOfENS_6Point_IfEEi", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv16BaseColumnFilterD0Ev", "cvLaplace", "_ZN2cv16BaseColumnFilter5resetEv", "_ZN2cv8Subdiv2D19getVoronoiFacetListERKSt6vectorIiSaIiEERS1_IS1_INS_6Point_IfEESaIS7_EESaIS9_EERS9_", "_ZN2cv12FilterEngineC1Ev", "_ZN2cv7MomentsC2Edddddddddd", "_ZNK2cv8Subdiv2D6Vertex6isfreeEv", "_ZN2cv5SobelERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiddi", "_ZN2cv16BaseColumnFilterD1Ev", "cvRemap", "_Z20estimateSegmentationR7GCGraphIdERN2cv3MatE", "cvLinearPolar", "_ZN2cv17getGaussianKernelEidi", "_ZNK2cv8Subdiv2D8nextEdgeEi", "_ZN2cv12FilterEngineC2ERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "_ZN2cv15getDerivKernelsERKNS_12_OutputArrayES2_iiibi", "_ZN2cv12FilterEngine5startERKNS_3MatERKNS_5Rect_IiEEbi", "_ZN2cv23getPerspectiveTransformEPKNS_6Point_IfEES3_", "cvCreateHist", "_ZN2cv10BaseFilterD0Ev", "_ZNK2cv8Subdiv2D8QuadEdge6isfreeEv", "_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKPi", "cvCopyMakeBorder", "_ZN2cv13BaseRowFilterD1Ev", "_ZN2cv20initWideAngleProjMapERKNS_11_InputArrayES2_NS_5Size_IiEEiiRKNS_12_OutputArrayES7_id", "_ZN2cv16pointPolygonTestERKNS_11_InputArrayENS_6Point_IfEEb", "_ZN2cv13BaseRowFilterD2Ev", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_i", "cvConvexHull2", "_ZN2cv9watershedERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKPi", "_ZNK3GMMclEiN2cv3VecIdLi3EEE", "cvUndistort2", "_ZN2cv8Subdiv2DC1ENS_5Rect_IiEE", "_ZN2cv11HoughLinesPERKNS_11_InputArrayERKNS_12_OutputArrayEddidd", "_ZN2cv8Subdiv2D6insertERKSt6vectorINS_6Point_IfEESaIS3_EE", "cvFindNextContour", "_ZN2cv14integral_8u32sEPhjPijPdjS1_jNS_5Size_IiEEi", "cvPyrDown", "_ZN2cv8Subdiv2D13setEdgePointsEiii", "_Z26icvGetRectSubPix_8u32f_C1RPKhi6CvSizePfiS1_12CvPoint2D32f", "_ZN2cv15preCornerDetectERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv8Subdiv2D6spliceEii", "_ZN2cv15integral_32f64fEPfjPdjS1_jS1_jNS_5Size_IiEEi", "_ZN2cv7fitLineERKNS_11_InputArrayERKNS_12_OutputArrayEiddd", "cvFitLine", "cvPointPolygonTest", "_ZN2cv8Subdiv2D12initDelaunayENS_5Rect_IiEE", "_ZN2cv14getGaborKernelENS_5Size_IiEEdddddi", "_ZN2cv12cornerHarrisERKNS_11_InputArrayERKNS_12_OutputArrayEiidi", "_ZN2cv15undistortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_S2_", "cvMatchShapes", "_ZN2cv27createSeparableLinearFilterEiiRKNS_11_InputArrayES2_NS_6Point_IiEEdiiRKNS_7Scalar_IdEE", "_ZN2cv11compareHistERKNS_9SparseMatES2_i", "cvStartReadChainPoints", "_ZN2cv17cornerMinEigenValERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "_ZN2cv10accumulateERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "cvSquareAcc", "_ZN2cv7MomentsC2ERK9CvMoments", "_ZN2cv9floodFillERKNS_12_OutputArrayENS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i", "_ZN2cv8Subdiv2D8QuadEdgeC2Ev", "_ZN2cv12HoughCirclesERKNS_11_InputArrayERKNS_12_OutputArrayEiddddii", "_ZN2cv12cornerSubPixERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEES7_NS_12TermCriteriaE", "_ZN2cv11compareHistERKNS_11_InputArrayES2_i", "_ZN2cv12FilterEngine5applyERKNS_3MatERS1_RKNS_5Rect_IiEENS_6Point_IiEEb", "cvSobel", "_ZN2cv25getMorphologyColumnFilterEiiii", "_ZN2cv6dilateERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv9floodFillERKNS_12_OutputArrayES2_NS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i", "_ZN2cv18minEnclosingCircleERKNS_11_InputArrayERNS_6Point_IfEERf", "cvWarpAffine", "_ZN2cv18getLinearRowFilterEiiRKNS_11_InputArrayEii", "_ZN2cv8Subdiv2D11findNearestENS_6Point_IfEEPS2_", "_ZN2cv7MomentsC1ERK9CvMoments", "cvStartFindContours", "_ZN2cv12approxPolyDPERKNS_11_InputArrayERKNS_12_OutputArrayEdb", "_ZN2cv8Subdiv2D7newEdgeEv", "_ZN2cv12FilterEngine7proceedEPKhiiPhi", "_ZN2cv11convertMapsERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_ib", "_ZNK2cv8Subdiv2D10rotateEdgeEii", "_ZN2cv8Subdiv2D12connectEdgesEii", "_ZN3GMM23calcInverseCovAndDetermEi", "_ZN2cv19goodFeaturesToTrackERKNS_11_InputArrayERKNS_12_OutputArrayEiddS2_ibd", "_ZN2cv18preprocess2DKernelERKNS_3MatERSt6vectorINS_6Point_IiEESaIS5_EERS3_IhSaIhEE", "cvCompareHist", "_ZN2cv11sepFilter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_S2_NS_6Point_IiEEdi", "_ZN2cv12boundingRectERKNS_11_InputArrayE", "_ZN2cv14integral_8u64fEPhjPdjS1_jS1_jNS_5Size_IiEEi", "cvCornerEigenValsAndVecs", "_ZN2cv8Subdiv2D6VertexC1Ev", "_ZN2cv12drawContoursERKNS_12_OutputArrayERKNS_11_InputArrayEiRKNS_7Scalar_IdEEiiS5_iNS_6Point_IiEE", "_ZNK2cv8Subdiv2D15getTriangleListERSt6vectorINS_3VecIfLi6EEESaIS3_EE", "cvGetPerspectiveTransform", "cvPyrUp", "_ZN2cv9arcLengthERKNS_11_InputArrayEb", "_ZN2cv12equalizeHistERKNS_11_InputArrayERKNS_12_OutputArrayE", "_Z9checkMaskRKN2cv3MatES2_", "cvReadChainPoint", "_Z9learnGMMsRKN2cv3MatES2_S2_R3GMMS4_", "_ZN2cv18getAffineTransformERKNS_11_InputArrayES2_", "_Z32icvGetQuadrangleSubPix_8u32f_C1RPKhi6CvSizePfiS1_PKf", "_ZNK2cv8Subdiv2D6Vertex9isvirtualEv", "_ZN2cv18getAffineTransformEPKNS_6Point_IfEES3_", "cvCreatePyramid", "cvFindCornerSubPix", "cvFloodFill", "_ZN2cv15getRowSumFilterEiiii", "_ZN2cv9LaplacianERKNS_11_InputArrayERKNS_12_OutputArrayEiiddi", "_Z23icvGetRectSubPix_8u_C1RPKhi6CvSizePhiS1_12CvPoint2D32f", "cvNormalizeHist", "_ZN2cv12FilterEngineC1ERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERNS_9SparseMatEiS4_PPKfbb", "cvGetMinMaxHistValue", "_ZN2cv12FilterEngineD1Ev", "_ZN2cv23getPerspectiveTransformERKNS_11_InputArrayES2_", "_ZN2cv5CannyERKNS_11_InputArrayERKNS_12_OutputArrayEddib", "cvAdaptiveThreshold", "_ZN2cv9undistortERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_", "cvErode", "_ZN2cv4blurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEENS_6Point_IiEEi", "_ZN2cv15isContourConvexERKNS_11_InputArrayE", "_ZN2cv10BaseFilter5resetEv", "_ZN2cv8Subdiv2D8QuadEdgeC1Ei", "_ZN2cv9HuMomentsERKNS_7MomentsEPd", "_ZN2cv12FilterEngineC2Ev", "cvEqualizeHist", "_ZN2cv13getRectSubPixERKNS_11_InputArrayENS_5Size_IiEENS_6Point_IfEERKNS_12_OutputArrayEi", "_ZN2cv12FilterEngine5startENS_5Size_IiEENS_5Rect_IiEEi", "_ZN2cv14copyMakeBorderERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiiRKNS_7Scalar_IdEE", "cvMaxRect", "_ZN2cv12findContoursERKNS_12_OutputArrayES2_S2_iiNS_6Point_IiEE", "_ZN2cv17createDerivFilterEiiiiii", "cvMinAreaRect2", "cvWarpPerspective", "_ZN2cv17accumulateProductERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "cvGoodFeaturesToTrack", "_ZNK3GMMclEN2cv3VecIdLi3EEE", "_ZN2cv19getMorphologyFilterEiiRKNS_11_InputArrayENS_6Point_IiEE", "_ZN2cv8Subdiv2D11calcVoronoiEv", "_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEiS4_PPKfbb", "_ZN2cv8filter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEdi", "cvPreCornerDetect", "_ZN2cv21getStructuringElementEiNS_5Size_IiEENS_6Point_IiEE", "cvMorphologyEx", "_ZNK2cv8Subdiv2D7symEdgeEi", "_ZN2cv8cvtColorERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv8Subdiv2D6VertexC2Ev", "cvReleaseHist", "cvGetCentralMoment", "_ZN3GMMC1ERN2cv3MatE", "_ZN2cv7momentsERKNS_11_InputArrayEb", "cvApproxChains", "cvCopyHist"], "allstrings": ["void cv::accumulateProduct(const cv::_InputArray&, const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&)", "void cv::accumulateSquare(const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&)", "void cv::accumulate(const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&)", "dst.size == src.size && dst.channels() == cn", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/accum.cpp", "mask.empty() || (mask.size == src.size && mask.type() == CV_8U)", "func != 0", "src2.size && src1.size && src2.type() == src1.type()", "dst.size == src1.size && dst.channels() == cn", "mask.empty() || (mask.size == src1.size && mask.type() == CV_8U)", "void cv::accumulateWeighted(const cv::_InputArray&, const cv::_OutputArray&, double, const cv::_InputArray&)", "CvSeq* cvApproxChains(CvSeq*, CvMemStorage*, int, double, int, int)", "CvSeq* icvApproximateChainTC89(CvChain*, int, CvMemStorage*, int)", "CV_IS_SEQ_CHAIN_CONTOUR( chain )", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/approx.cpp", "header_size >= (int)sizeof(CvContour)", "Unsupported sequence type", "NULL storage pointer ", "header_size is negative. Pass 0 to make the destination header_size == input header_size", "Input curves are not polygonal. Use cvApproxChains first", "Input curves have uknown type", "New header size must be non-less than sizeof(CvContour)", "Unknown approximation method", "Accuracy must be non-negative", "Invalid approximation method", "CvSeq* cvApproxPoly(const void*, int, CvMemStorage*, int, double, int)", "src.depth() == CV_8U", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/canny.cpp", "vector::_M_fill_insert", "src.size == dst.size && src.depth() == CV_8U && dst.type() == CV_8U", "void cvCanny(const CvArr*, CvArr*, double, double, int)", "void cv::Canny(const cv::_InputArray&, const cv::_OutputArray&, double, double, int, bool)", "cv::RGB2Lab_b::RGB2Lab_b(int, int, const float*, const float*, bool)", "void cvCvtColor(const CvArr*, CvArr*, int)", "cv::RGB2Luv_f::RGB2Luv_f(int, int, const float*, const float*, bool)", "coeffs[i*3] >= 0 && coeffs[i*3+1] >= 0 && coeffs[i*3+2] >= 0 && coeffs[i*3] + coeffs[i*3+1] + coeffs[i*3+2] < 1.5f", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/color.cpp", "depth == CV_8U || depth == CV_16U || depth == CV_32F", "scn == 3 || scn == 4", "(scn == 3 || scn == 4) && depth == CV_8U", "(dcn == 3 || dcn == 4) && scn == 2 && depth == CV_8U", "scn == 2 && depth == CV_8U", "scn == 1 && (dcn == 3 || dcn == 4)", "scn == 1 && depth == CV_8U", "scn == 3 && (dcn == 3 || dcn == 4)", "(scn == 3 || scn == 4) && (depth == CV_8U || depth == CV_32F)", "hrange == 180 || hrange == 256", "scn == 3 && (dcn == 3 || dcn == 4) && (depth == CV_8U || depth == CV_32F)", "coeffs[i] >= 0 && coeffs[i*3+1] >= 0 && coeffs[i*3+2] >= 0 && coeffs[i*3] + coeffs[i*3+1] + coeffs[i*3+2] < 2*(1 << lab_shift)", "coeffs[i*3] >= 0 && coeffs[i*3+1] >= 0 && coeffs[i*3+2] >= 0 && coeffs[i*3] + coeffs[i*3+1] + coeffs[i*3+2] < 1.5f*LabCbrtTabScale", "scn == 1 && dcn == 1", "Bayer->Gray demosaicing only supports 8u and 16u types", "scn == 1 && dcn == 3", "Bayer->RGB demosaicing only supports 8u and 16u types", "dcn == 3 || dcn == 4", "sz.width % 2 == 0 && sz.height % 3 == 0 && depth == CV_8U", "Unknown/unsupported color conversion code", "src.depth() == dst.depth()", "dst.data == dst0.data", "cv::RGB2HSV_b::RGB2HSV_b(int, int, int)", "double cv::contourArea(const cv::_InputArray&, bool)", "cv::Seq<_Tp>::Seq(const CvSeq*) [with _Tp = CvConvexityDefect]", "void cv::minEnclosingCircle(const cv::_InputArray&, cv::Point2f&, float&)", "double cv::pointPolygonTest(const cv::_InputArray&, cv::Point2f, bool)", "cv::Seq<_Tp>::Seq(const CvSeq*) [with _Tp = CvSeq*]", "void cv::convexityDefects(const cv::_InputArray&, const cv::_InputArray&, const cv::_OutputArray&)", "_CvContourScanner* cvStartFindContours(void*, CvMemStorage*, int, int, int, CvPoint)", "void cv::approxPolyDP(const cv::_InputArray&, const cv::_OutputArray&, double, bool)", "void cv::findContours(const cv::_OutputArray&, const cv::_OutputArray&, const cv::_OutputArray&, int, int, cv::Point)", "CvSeq* cvFindNextContour(_CvContourScanner*)", "void cvStartReadChainPoints(CvChain*, CvChainPtReader*)", "CvPoint cvReadChainPoint(CvChainPtReader*)", "int icvFindContoursInInterval(const CvArr*, CvMemStorage*, CvSeq**, int)", "CvSeq* cvEndFindContours(_CvContourScanner**)", "cv::Rect cv::boundingRect(const cv::_InputArray&)", "void cv::fitLine(const cv::_InputArray&, const cv::_OutputArray&, int, double, double, double)", "cv::RotatedRect cv::fitEllipse(const cv::_InputArray&)", "double cv::arcLength(const cv::_InputArray&, bool)", "void cv::convexHull(const cv::_InputArray&, const cv::_OutputArray&, bool, bool)", "bool cv::isContourConvex(const cv::_InputArray&)", "double cv::matchShapes(const cv::_InputArray&, const cv::_InputArray&, int, double)", "void cv::drawContours(const cv::_OutputArray&, const cv::_InputArray&, int, const cv::Scalar&, int, int, const cv::_InputArray&, int, cv::Point)", "void cvSubstituteContour(_CvContourScanner*, CvSeq*)", "int cvFindContours(void*, CvMemStorage*, CvSeq**, int, int, int, CvPoint)", "cv::RotatedRect cv::minAreaRect(const cv::_InputArray&)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/contours.cpp", "npoints >= 0 && (depth == CV_32S || depth == CV_32F)", "points.checkVector(2) >= 0 && (points.depth() == CV_32F || points.depth() == CV_32S)", "contour.checkVector(2) >= 0 && (contour.depth() == CV_32F || contour.depth() == CV_32S)", "contour1.checkVector(2) >= 0 && contour2.checkVector(2) >= 0 && (contour1.depth() == CV_32F || contour1.depth() == CV_32S) && contour1.depth() == contour2.depth()", "(is2d || is3d) && (points.depth() == CV_32F || points.depth() == CV_32S)", "l.isContinuous()", "curve.checkVector(2) >= 0 && (curve.depth() == CV_32F || curve.depth() == CV_32S)", "nelems >= 0 && (depth == CV_32F || depth == CV_32S)", "0 <= contourIdx && contourIdx < (int)last", "npoints > 0", "hierarchy.total() == ncontours && hierarchy.type() == CV_32SC4", "ptnum > 3", "hull.checkVector(1, CV_32S) > 2", "!_seq || _seq->elem_size == sizeof(_Tp)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/core/include/opencv2/core/operations.hpp", "0 <= idx0 && idx0 < ptnum", "0 <= idx1 && idx1 < ptnum", "0 <= idx2 && idx2 < ptnum", "d.depth >= 0", "[Start]FindContours support only 8uC1 and 32sC1 images", "NULL double CvSeq pointer", "Nonzero offset is not supported in CV_LINK_RUNS yet", "NULL storage pointer", "Contour header size must be >= sizeof(CvContour)", "Input array must be 8uC1 or 8sC1", "ci.isContinuous()", "void icvCalcAndWritePtIndices(CvPoint**, int*, int, int, CvSeq*, CvSeqWriter*)", "CvSeq* cvConvexHull2(const CvArr*, void*, int, int)", "int cvCheckContourConvexity(const CvArr*)", "Internal error", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/convhull.cpp", "Destination must be valid memory storage or matrix", "The hull matrix should be continuous and have a single row or a single column", "The hull matrix size might be not enough to fit the hull", "The hull matrix must have the same type as input or 32sC1 (integers)", "Point sequence can not be empty if the output is matrix", "Input sequence must be polygon (closed 2d curve)", "CV_SEQ_ELTYPE(contour) == CV_32FC2", "Input sequence is not a sequence of points", "Floating-point coordinates are not supported here", "Convex hull must represented as a sequence of indices or sequence of pointers", "Convex hull is neither sequence nor matrix", "The matrix should be 1-dimensional and continuous array of int's", "Convex hull is larger than the point sequence", "CvSeq* cvConvexityDefects(const CvArr*, const CvArr*, CvMemStorage*)", "void cv::preCornerDetect(const cv::_InputArray&, const cv::_OutputArray&, int, int)", "void cvCornerHarris(const CvArr*, CvArr*, int, int, double)", "void cv::cornerEigenValsVecs(const cv::Mat&, cv::Mat&, int, int, int, double, int)", "void cvCornerEigenValsAndVecs(const void*, void*, int, int)", "void cvPreCornerDetect(const void*, void*, int)", "src.type() == CV_8UC1 || src.type() == CV_32FC1", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/corner.cpp", "src.rows == dst.rows && src.cols*6 == dst.cols*dst.channels() && dst.depth() == CV_32F", "src.size() == dst.size() && dst.type() == CV_32FC1", "void cvCornerMinEigenVal(const CvArr*, CvArr*, int, int)", "void cvFindCornerSubPix(const void*, CvPoint2D32f*, int, CvSize, CvSize, CvTermCriteria)", "The source image must be 8-bit single-channel (CV_8UC1)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/cornersubpix.cpp", "(icvGetRectSubPix_8u32f_C1R( (uchar*)src->data.ptr, src->step, size, src_buffer, (win_w + 2) * sizeof( src_buffer[0] ), cvSize( win_w + 2, win_h + 2 ), cI )) >= 0", "ncorners >= 0 && corners.depth() == CV_32F", "void cv::cornerSubPix(const cv::_InputArray&, const cv::_OutputArray&, cv::Size, cv::Size, cv::TermCriteria)", "void cvLaplace(const void*, void*, int)", "ktype == CV_32F || ktype == CV_64F", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/deriv.cpp", "dx >= 0 && dy >= 0 && dx+dy == 1", "The kernel size must be odd and not larger than 31", "dx >= 0 && dy >= 0 && dx+dy > 0", "ksize > order", "src.size() == dst.size() && src.channels() == dst.channels()", "void cv::getSobelKernels(const cv::_OutputArray&, const cv::_OutputArray&, int, int, int, bool, int)", "void cvSobel(const void*, void*, int, int, int)", "@void icvTrueDistTrans(const CvMat*, CvMat*)", "void icvDistanceATS_L1_8u(const CvMat*, CvMat*)", "source image must be 8uC1 and the distance map must be 32fC1 (or 8uC1 in case of simple L1 distance transform)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/distransform.cpp", "the source and the destination images must be of the same size", "Mask size should be 3 or 5 or 0 (presize)", "The input image must have 8uC1 type and the output one must have 32fC1 type", "the output array of labels must be 32sC1", "the array of labels has a different size", "3x3 mask can not be used for \"labeled\" distance transform. Use 5x5 mask", "CV_IS_MASK_ARR( src ) && CV_MAT_TYPE( dst->type ) == CV_8UC1", "CV_ARE_SIZES_EQ( src, dst )", "void cvDistTransform(const void*, void*, int, int, const float*, void*, int)", "float cvCalcEMD2(const CvArr*, const CvArr*, int, float (*)(const float*, const float*, void*), const CvArr*, CvArr*, float*, void*)", "int icvInitEMD(const float*, int, const float*, int, int, float (*)(const float*, const float*, void*), void*, const float*, int, CvEMDState*, float*, cv::AutoBuffer<char>&)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/emd.cpp", "The arrays must have equal number of columns (which is number of dimensions but 1)", "The array must have equal types", "The signatures must be 32fC1", "The flow matrix size does not match to the signatures' sizes", "The flow matrix must be 32fC1", "Only one of cost matrix or distance function should be non-NULL in case of user-defined distance", "The lower boundary can not be calculated if the cost matrix is used", "The cost matrix size does not match to the signatures' sizes", "The cost matrix must be 32fC1", "In case of user-defined distance Distance function is undefined", "Number of dimensions can be 0 only if a user-defined metric is used", "Bad or unsupported metric type", "void cvGoodFeaturesToTrack(const void*, void*, void*, CvPoint2D32f*, int*, double, double, const void*, int, int, double)", "qualityLevel > 0 && minDistance >= 0 && maxCorners >= 0", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/featureselect.cpp", "mask.empty() || (mask.type() == CV_8UC1 && mask.size() == image.size())", "vector::_M_insert_aux", "_corners && _corner_count", "void cv::goodFeaturesToTrack(const cv::_InputArray&, const cv::_OutputArray&, int, double, double, const cv::_InputArray&, int, bool, double)", "N2cv8Filter2DIhNS_4CastIfhEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIfNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIdNS_4CastIddEENS_11FilterNoVecEEE", "N2cv12ColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv18SymmRowSmallFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_8RowNoVecEEE", "N2cv9RowFilterIhfNS_8RowNoVecEEE", "N2cv9RowFilterIhdNS_8RowNoVecEEE", "N2cv9RowFilterItfNS_8RowNoVecEEE", "N2cv9RowFilterItdNS_8RowNoVecEEE", "N2cv9RowFilterIsfNS_8RowNoVecEEE", "N2cv9RowFilterIsdNS_8RowNoVecEEE", "N2cv9RowFilterIffNS_8RowNoVecEEE", "N2cv9RowFilterIfdNS_8RowNoVecEEE", "N2cv9RowFilterIddNS_8RowNoVecEEE", "cv::Ptr<cv::BaseRowFilter> cv::getLinearRowFilter(int, int, const cv::_InputArray&, int, int)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, double>, VecOp = cv::ColumnNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = float, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = double, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::Point cv::normalizeAnchor(cv::Point, cv::Size)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::FilterNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, unsigned char>, VecOp = cv::FilterNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short unsigned int, CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::FilterNoVec]", "cv::Ptr<cv::FilterEngine> cv::createLinearFilter(int, int, const cv::_InputArray&, cv::Point, double, int, int, const cv::Scalar&)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, short int>, VecOp = cv::ColumnNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short unsigned int, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "virtual void cv::FilterEngine::apply(const cv::Mat&, cv::Mat&, const cv::Rect&, cv::Point, bool)", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short unsigned int, DT = double, VecOp = cv::RowNoVec]", "cv::SymmColumnSmallFilter<CastOp, VecOp>::SymmColumnSmallFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short int, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec]", "N2cv16BaseColumnFilterE", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = float, DT = float, VecOp = cv::RowNoVec]", "cv::SymmColumnSmallFilter<CastOp, VecOp>::SymmColumnSmallFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::SymmColumnSmallNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short unsigned int, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = int, VecOp = cv::SymmRowSmallNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short int, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = float, VecOp = cv::RowNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short int, CastOp = cv::Cast<float, short int>, VecOp = cv::FilterNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::Ptr<cv::BaseFilter> cv::getLinearFilter(int, int, const cv::_InputArray&, cv::Point, double, int)", "Unknown/unsupported border type", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/filter.cpp", "srcRoi.x >= 0 && srcRoi.y >= 0 && srcRoi.width >= 0 && srcRoi.height >= 0 && srcRoi.x + srcRoi.width <= src.cols && srcRoi.y + srcRoi.height <= src.rows", "roi.x >= 0 && roi.y >= 0 && roi.width >= 0 && roi.height >= 0 && roi.x + roi.width <= wholeSize.width && roi.y + roi.height <= wholeSize.height", "_kernel.channels() == 1", "wholeSize.width > 0 && wholeSize.height > 0", "src && dst && count > 0", "srcY >= startY", "dstY <= roi.height", "src.type() == srcType && dst.type() == dstType", "dstOfs.x >= 0 && dstOfs.y >= 0 && dstOfs.x + srcRoi.width <= dst.cols && dstOfs.y + srcRoi.height <= dst.rows", "kernel.type() == DataType<ST>::type && (kernel.rows == 1 || kernel.cols == 1)", "(symmetryType & (KERNEL_SYMMETRICAL | KERNEL_ASYMMETRICAL)) != 0", "cn == CV_MAT_CN(bufType) && sdepth >= std::max(ddepth, CV_32S) && kernel.type() == sdepth", "this->ksize == 3", "Unsupported combination of buffer format (=%d), and destination format (=%d)", "ktype == CV_8U || ktype == CV_32S || ktype == CV_32F || ktype == CV_64F", "cn == CV_MAT_CN(dstType) && ddepth >= sdepth", "anchor.inside(Rect(0, 0, ksize.width, ksize.height))", "/Users/tw/Documents/lumber/buffalo/opencv/build-2.4.1/modules/imgproc/precomp.hpp", "_kernel.type() == DataType<KT>::type", "Unsupported combination of source format (=%d), and destination format (=%d)", "columnBorderType != BORDER_WRAP", "!rowFilter.empty() && !columnFilter.empty()", "bufType == srcType", "0 <= anchor.x && anchor.x < ksize.width && 0 <= anchor.y && anchor.y < ksize.height", "cn == CV_MAT_CN(_dstType)", "cn == CV_MAT_CN(bufType) && ddepth >= std::max(sdepth, CV_32S) && kernel.type() == ddepth", "kernel.type() == DataType<DT>::type && (kernel.rows == 1 || kernel.cols == 1)", "(symmetryType & (KERNEL_SYMMETRICAL | KERNEL_ASYMMETRICAL)) != 0 && this->ksize <= 5", "Unsupported combination of source format (=%d), and buffer format (=%d)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short int, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short unsigned int, DT = float, VecOp = cv::RowNoVec]", "cv::SymmRowSmallFilter<ST, DT, VecOp>::SymmRowSmallFilter(const cv::Mat&, int, int, const VecOp&) [with ST = unsigned char, DT = int, VecOp = cv::SymmRowSmallNoVec]", "cv::SymmRowSmallFilter<ST, DT, VecOp>::SymmRowSmallFilter(const cv::Mat&, int, int, const VecOp&) [with ST = float, DT = float, VecOp = cv::SymmRowSmallNoVec]", "cv::Ptr<cv::BaseColumnFilter> cv::getLinearColumnFilter(int, int, const cv::_InputArray&, int, int, double, int)", "int cv::borderInterpolate(int, int, int)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, short int>, VecOp = cv::FilterNoVec]", "virtual int cv::FilterEngine::proceed(const uchar*, int, int, uchar*, int)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, short int>, VecOp = cv::ColumnNoVec]", "virtual int cv::FilterEngine::start(const cv::Mat&, const cv::Rect&, bool, int)", "int cv::getKernelType(const cv::_InputArray&, cv::Point)", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = double, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = float, DT = double, VecOp = cv::RowNoVec]", "cv::Ptr<cv::FilterEngine> cv::createSeparableLinearFilter(int, int, const cv::_InputArray&, const cv::_InputArray&, cv::Point, double, int, int, const cv::Scalar&)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::SymmColumnSmallNoVec]", "N2cv10BaseFilterE", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = int, VecOp = cv::RowNoVec]", "void cv::preprocess2DKernel(const cv::Mat&, std::vector<cv::Point_<int> >&, std::vector<unsigned char>&)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "void cvFilter2D(const CvArr*, CvArr*, const CvMat*, CvPoint)", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, unsigned char>, VecOp = cv::ColumnNoVec]", "N2cv13BaseRowFilterE", "cv::SymmColumnSmallFilter<CastOp, VecOp>::SymmColumnSmallFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short int, DT = float, VecOp = cv::RowNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::ColumnNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = float, DT = float, VecOp = cv::SymmRowSmallNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, short unsigned int>, VecOp = cv::ColumnNoVec]", "void cv::FilterEngine::init(const cv::Ptr<cv::BaseFilter>&, const cv::Ptr<cv::BaseRowFilter>&, const cv::Ptr<cv::BaseColumnFilter>&, int, int, int, int, int, const cv::Scalar&)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, unsigned char>, VecOp = cv::ColumnNoVec]", "virtual int cv::FilterEngine::start(cv::Size, cv::Rect, int)", "N2cv12FilterEngineE", "Connectivity must be 4, 0(=4) or 8", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/floodfill.cpp", "lo_diff and up_diff must be non-negative", "Seed point is outside of image", "mask must be 2 pixel wider and 2 pixel taller than filled image", "void cvFloodFill(CvArr*, CvPoint, CvScalar, CvScalar, CvScalar, CvConnectedComp*, int, CvArr*)", "cv::Mat cv::getGaborKernel(cv::Size, double, double, double, double, double, int)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/gabor.cpp", "float cv::intersectConvexConvex(const cv::_InputArray&, const cv::_InputArray&, const cv::_OutputArray&, bool)", "double cvPointPolygonTest(const CvArr*, CvPoint2D32f, int)", "NULL vertex array pointer", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/geometry.cpp", "p1.depth() == CV_32S || p1.depth() == CV_32F", "p2.depth() == CV_32S || p2.depth() == CV_32F", "n >= 0 && m >= 0", "temp.ptr<Point2f>() == dst", "Chains are not supported. Convert them to polygonal representation using cvApproxChains()", "Input contour is neither a valid sequence nor a matrix", "void cvBoxPoints(CvBox2D, CvPoint2D32f*)", "void initGMMs(const cv::Mat&, const cv::Mat&, GMM&, GMM&)", "void GMM::calcInverseCovAndDeterm(int)", "void GCGraph<TWeight>::addTermWeights(int, TWeight, TWeight) [with TWeight = double]", "double GMM::operator()(int, cv::Vec3d) const", "GMM::GMM(cv::Mat&)", "void checkMask(const cv::Mat&, const cv::Mat&)", "i>=0 && i<(int)vtcs.size()", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/gcgraph.hpp", "mask is empty", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/grabcut.cpp", "mask must have CV_8UC1 type", "mask must have as many rows and cols as img", "mask element value must be equelGC_BGD or GC_FGD or GC_PR_BGD or GC_PR_FGD", "covDeterms[ci] > std::numeric_limits<double>::epsilon()", "dtrm > std::numeric_limits<double>::epsilon()", "!bgdSamples.empty() && !fgdSamples.empty()", "_model must have CV_64FC1 type, rows == 1 and cols == 13*componentsCount", "j>=0 && j<(int)vtcs.size()", "w>=0 && revw>=0", "i != j", "vector::reserve", "image is empty", "image mush have CV_8UC3 type", "void GCGraph<TWeight>::addEdges(int, int, TWeight, TWeight) [with TWeight = double]", "bool GCGraph<TWeight>::inSourceSegment(int) [with TWeight = double]", "void cv::grabCut(const cv::_InputArray&, const cv::_OutputArray&, cv::Rect, const cv::_OutputArray&, const cv::_OutputArray&, int, int)", "void cvClearHist(CvHistogram*)", "CvHistogram* cvCreateHist(int, int*, CvHistType, float**, int)", "void cvReleaseHist(CvHistogram**)", "double cvCompareHist(const CvHistogram*, const CvHistogram*, int)", "void cv::calcHist(const cv::Mat*, int, const int*, const cv::_InputArray&, const cv::_OutputArray&, int, const int*, const float**, bool, bool)", "double cv::compareHist(const cv::_InputArray&, const cv::_InputArray&, int)", "void cv::calcBackProject(const cv::_InputArray&, const std::vector<int>&, const cv::_InputArray&, const cv::_OutputArray&, const std::vector<float>&, double)", "void* icvReadHist(CvFileStorage*, CvFileNode*)", "void cvSetHistBinRanges(CvHistogram*, float**, int)", "double cv::compareHist(const cv::SparseMat&, const cv::SparseMat&, int)", "void cvThreshHist(CvHistogram*, double)", "void cv::calcHist(const cv::Mat*, int, const int*, const cv::Mat&, cv::SparseMat&, int, const int*, const float**, bool, bool, bool)", "void cvCalcArrHist(CvArr**, CvHistogram*, int, const CvArr*)", "void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)", "void cvEqualizeHist(const CvArr*, CvArr*)", "void cvCopyHist(const CvHistogram*, CvHistogram**)", "void cvCalcProbDensity(const CvHistogram*, const CvHistogram*, CvHistogram*, double)", "void cv::histPrepareImages(const cv::Mat*, int, const int*, const cv::Mat&, int, const int*, const float**, bool, std::vector<uchar*>&, std::vector<int>&, cv::Size&, std::vector<double>&)", "void cvCalcBayesianProb(CvHistogram**, int, CvHistogram**)", "void cvNormalizeHist(CvHistogram*, double)", "void cv::calcHist(const cv::_InputArray&, const std::vector<int>&, const cv::_InputArray&, const cv::_OutputArray&, const std::vector<int>&, const std::vector<float>&, bool)", "void cv::calcBackProject(const cv::Mat*, int, const int*, const cv::SparseMat&, const cv::_OutputArray&, const float**, double, bool)", "void cv::calcBackProject(const cv::Mat*, int, const int*, const cv::_InputArray&, const cv::_OutputArray&, const float**, double, bool)", "void cvCalcArrBackProjectPatch(CvArr**, CvArr*, CvSize, CvHistogram*, int, double)", "void cvCalcArrBackProject(CvArr**, CvArr*, const CvHistogram*)", "CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)", "opencv-hist", "is_uniform", "have_ranges", "bins", "thresh", "NULL histogram array pointer", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/histogram.cpp", "Too small number of histograms", "Invalid histogram header", "The function supports dense histograms only", "dims > 0 && dims == H2.dims() && H1.type() == H2.type() && H1.type() == CV_32F", "H1.size(i) == H2.size(i)", "Unknown comparison method", "H1.type() == H2.type() && H1.type() == CV_32F", "it.planes[0].isContinuous() && it.planes[1].isContinuous()", "CV_ARE_SIZES_EQ(src, dst) && CV_ARE_TYPES_EQ(src, dst) && CV_MAT_TYPE(src->type) == CV_8UC1", "NULL ranges pointer", "One of <ranges> elements is NULL", "Bin ranges should go in ascenting order", "scale must be positive", "Invalid histogram pointer[s]", "All histograms must have 32fC1 type", "Number of dimensions is out of range", "Null <sizes> pointer", "Invalid histogram type", "Destination double pointer is NULL", "Invalid histogram header[s]", "One of histograms is sparse and other is not", "The histograms have different numbers of dimensions", "The histograms have different sizes", "Null histogram header pointer", "Null data pointer", "Only uniform bin ranges can be used here (to avoid memory allocation)", "channels != 0 || nimages == dims", "images[j].channels() == 1", "c >= 0", "j < nimages", "images[j].size() == imsize && images[j].depth() == depth", "mask.size() == imsize && mask.channels() == 1", "ranges[i] && ranges[i][0] < ranges[i][1]", "ranges[i][j] < ranges[i][j+1]", "dims > 0 && hist.data", "dims > 0", "Bad histogram pointer", "Null double array pointer", "_dst.size() == images[0].size() && _dst.depth() == images[0].depth()", "dims > 0 && histSize", "!mask.data || mask.type() == CV_8UC1", "Expected CvMatND", "Unknown Histogram type", "'thresh' node is missing", "H0.isContinuous()", "nimages > 0", "rsz == dims*2 || (rsz == 2 && _1d) || (rsz == 0 && images.depth(0) == CV_8U)", "csz == 0 || csz == dims || (csz == 1 && _1d)", "nimages > 0 && dims > 0", "rsz == dims*2 || (rsz == 0 && images.depth(0) == CV_8U)", "csz == 0 || csz == dims", "Bad normalization factor (set it to 1.0 if unsure)", "The patch width and height must be positive", "Resultant image must have 32fC1 type", "The output map must be (W-w+1 x H-h+1), where the input images are (W x H) each and the patch is (w x h)", "void icvHoughLinesProbabilistic(CvMat*, float, float, int, int, int, CvSeq*, int)", "void icvHoughLinesStandard(const CvMat*, float, float, int, CvSeq*, int)", "CV_IS_MAT(img) && CV_MAT_TYPE(img->type) == CV_8UC1", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/hough.cpp", "linesMax > 0 && rho > 0 && theta > 0", "The source image must be 8-bit, single-channel", "NULL destination", "rho, theta and threshold must be positive", "The destination matrix should be continuous and have a single row or a single column", "The destination matrix data type is inappropriate, see the manual", "Destination is not CvMemStorage* nor CvMat*", "CV_IS_MAT(image) && CV_MAT_TYPE(image->type) == CV_8UC1", "Unrecognized method id", "dp, min_dist, canny_threshold and acc_threshold must be all positive numbers", "CvSeq* cvHoughLines2(CvArr*, void*, int, double, double, int, double, double)", "void icvHoughLinesSDiv(const CvMat*, float, float, int, int, int, CvSeq*, int)", "CvSeq* cvHoughCircles(CvArr*, void*, int, double, double, double, double, int, int)", "void cv::warpPerspective(const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&, cv::Size, int, int, const cv::Scalar&)", "void cv::remap(const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&, const cv::_InputArray&, int, int, const cv::Scalar&)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const cv::Scalar&) [with CastOp = cv::FixedPtCast<int, unsigned char, 15>, VecOp = cv::RemapNoVec, AT = short int]", "void cv::warpAffine(const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&, cv::Size, int, int, const cv::Scalar&)", "void cvWarpAffine(const CvArr*, CvArr*, const CvMat*, int, CvScalar)", "void cvLinearPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const cv::Scalar&) [with CastOp = cv::Cast<float, float>, VecOp = cv::RemapNoVec, AT = float]", "void cv::resizeArea_(const cv::Mat&, cv::Mat&, const cv::DecimateAlpha*, int) [with T = short unsigned int, WT = float]", "const void* cv::initInterTab2D(int, bool)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const cv::Scalar&) [with CastOp = cv::Cast<float, short int>, VecOp = cv::RemapNoVec, AT = float]", "void cvResize(const CvArr*, CvArr*, int)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const cv::Scalar&) [with CastOp = cv::Cast<double, double>, VecOp = cv::RemapNoVec, AT = float]", "cv::Mat cv::getAffineTransform(const cv::_InputArray&, const cv::_InputArray&)", "void cv::resizeArea_(const cv::Mat&, cv::Mat&, const cv::DecimateAlpha*, int) [with T = float, WT = float]", "void cv::resizeArea_(const cv::Mat&, cv::Mat&, const cv::DecimateAlpha*, int) [with T = double, WT = double]", "cv::Mat cv::getPerspectiveTransform(const cv::_InputArray&, const cv::_InputArray&)", "void cv::convertMaps(const cv::_InputArray&, const cv::_InputArray&, const cv::_OutputArray&, const cv::_OutputArray&, int, bool)", "CvMat* cvGetAffineTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)", "void cv::resizeArea_(const cv::Mat&, cv::Mat&, const cv::DecimateAlpha*, int) [with T = short int, WT = float]", "void cv::invertAffineTransform(const cv::_InputArray&, const cv::_OutputArray&)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const cv::Scalar&) [with CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::RemapNoVec, AT = float]", "void cvLogPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)", "void cvRemap(const CvArr*, CvArr*, const CvArr*, const CvArr*, int, CvScalar)", "void cv::resizeArea_(const cv::Mat&, cv::Mat&, const cv::DecimateAlpha*, int) [with T = unsigned char, WT = float]", "void cvWarpPerspective(const CvArr*, CvArr*, const CvMat*, int, CvScalar)", "void cv::resize(const cv::_InputArray&, const cv::_OutputArray&, cv::Size, double, double, int)", "cn <= 4 && ssize.area() > 0", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/imgwarp.cpp", "cn <= 4", "(!map2.data || map2.size() == map1.size())", "nnfunc != 0", "Unknown interpolation method", "ifunc != 0", "Unknown/unsupported interpolation type", "(map1.type() == CV_32FC2 && !map2.data) || (map1.type() == CV_32FC1 && map2.type() == CV_32FC1)", "src.type() == dst.type() && dst.size() == mapx.size()", "dst0.data == dst.data", "M should be >0", "src.checkVector(2, CV_32F) == 4 && dst.checkVector(2, CV_32F) == 4", "M.size() == M0.size()", "src.checkVector(2, CV_32F) == 3 && dst.checkVector(2, CV_32F) == 3", "src.cols > 0 && src.rows > 0", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 3 && M0.cols == 3", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 2 && M0.cols == 3", "ssize.area() > 0", "!(dsize == Size()) || (inv_scale_x > 0 && inv_scale_y > 0)", "func != 0 && cn <= 4", "(m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) || (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) || (m1type == CV_32FC1 && m2type == CV_32FC1) || (m1type == CV_32FC2 && !m2->data)", "dstm1type == CV_16SC2 || dstm1type == CV_32FC1 || dstm1type == CV_32FC2", "Unsupported combination of input/output matrices", "matM.rows == 2 && matM.cols == 3", "void cv::initInterTab1D(int, float*, int)", "NULL pointer to line parameters", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/linefit.cpp", "The sequence has no points", "Input sequence must consist of 2d points or 3d points", "Input array is not a sequence nor matrix", "Input array must be 1d continuous array of 2d or 3d points", "Both reps and aeps must be non-negative", "User-defined distance is not allowed", "(icvFitLine2D( (CvPoint2D32f*)points, ptseq->total, dist, (float)param, (float)reps, (float)aeps, line )) >= 0", "(icvFitLine3D( (CvPoint3D32f*)points, ptseq->total, dist, (float)param, (float)reps, (float)aeps, line )) >= 0", "void cvFitLine(const CvArr*, int, double, double, double, float*)", "double cvMatchShapes(const void*, const void*, int, double)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/matchcontours.cpp", "void cv::HuMoments(const cv::Moments&, const cv::_OutputArray&)", "double cvGetSpatialMoment(CvMoments*, int, int)", "hu.isContinuous()", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/moments.cpp", "The passed sequence is not a valid contour", "Invalid image type", "void cvMoments(const void*, CvMoments*, int)", "double cvGetCentralMoment(CvMoments*, int, int)", "void cvGetHuMoments(CvMoments*, CvHuMoments*)", "N2cv11MorphFilterINS_5MinOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIdEENS_10MorphNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIdEENS_16MorphColumnNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIdEENS_13MorphRowNoVecEEE", "void cv::morphologyEx(const cv::_InputArray&, const cv::_OutputArray&, int, const cv::_InputArray&, cv::Point, int, int, const cv::Scalar&)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<float>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<float>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<short unsigned int>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<short int>, VecOp = cv::MorphNoVec]", "void cvErode(const CvArr*, CvArr*, IplConvKernel*, int)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<short int>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<unsigned char>, VecOp = cv::MorphNoVec]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<double>, VecOp = cv::MorphNoVec]", "cv::Point cv::normalizeAnchor(cv::Point, cv::Size)", "IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)", "void cvReleaseStructuringElement(IplConvKernel**)", "cv::Ptr<cv::FilterEngine> cv::createMorphologyFilter(int, int, const cv::_InputArray&, cv::Point, int, int, const cv::Scalar&)", "void cvMorphologyEx(const void*, void*, void*, IplConvKernel*, int, int)", "op == MORPH_ERODE || op == MORPH_DILATE", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/morph.cpp", "Unsupported data type (=%d)", "shape == MORPH_RECT || shape == MORPH_CROSS || shape == MORPH_ELLIPSE", "cols > 0 && rows > 0 && anchor.inside(cv::Rect(0,0,cols,rows)) && (shape != CV_SHAPE_CUSTOM || values != 0)", "_kernel.type() == CV_8U", "depth == CV_8U || depth == CV_16U || depth == CV_16S || depth == CV_32F || depth == CV_64F", "src.size() == dst.size() && src.type() == dst.type()", "unknown morphological operation", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<double>, VecOp = cv::MorphNoVec]", "cv::Ptr<cv::BaseRowFilter> cv::getMorphologyRowFilter(int, int, int, int)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<short unsigned int>, VecOp = cv::MorphNoVec]", "void cv::morphOp(int, const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&, cv::Point, int, int, const cv::Scalar&)", "void cvDilate(const CvArr*, CvArr*, IplConvKernel*, int)", "cv::Mat cv::getStructuringElement(int, cv::Size, cv::Point)", "cv::Ptr<cv::BaseFilter> cv::getMorphologyFilter(int, int, const cv::_InputArray&, cv::Point)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<unsigned char>, VecOp = cv::MorphNoVec]", "cv::Ptr<cv::BaseColumnFilter> cv::getMorphologyColumnFilter(int, int, int, int)", "void cv::magSpectrums(const cv::_InputArray&, const cv::_OutputArray&)", "cv::Point2d cv::weightedCentroid(const cv::_InputArray&, cv::Point, cv::Size)", "void cv::divSpectrums(const cv::_InputArray&, const cv::_InputArray&, const cv::_OutputArray&, int, bool)", "type == srcB.type() && srcA.size() == srcB.size()", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/phasecorr.cpp", "type == CV_32FC1 || type == CV_32FC2 || type == CV_64FC1 || type == CV_64FC2", "type == CV_32FC1 || type == CV_64FC1", "src1.type() == src2.type()", "src1.type() == CV_32FC1 || src1.type() == CV_64FC1", "src1.size == src2.size", "src1.type() == window.type()", "src1.size == window.size", "void cv::createHanningWindow(const cv::_OutputArray&, cv::Size, int)", "cv::Point2d cv::phaseCorrelate(const cv::_InputArray&, const cv::_InputArray&, const cv::_InputArray&)", "void cvReleasePyramid(CvMat***, int)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<double, 6>, VecOp = cv::NoVec<double, double>]", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short int, 8>, VecOp = cv::NoVec<int, short int>]", "CvMat** cvCreatePyramid(const CvArr*, int, double, const CvSize*, CvArr*, int, int)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short unsigned int, 6>, VecOp = cv::NoVec<int, short unsigned int>]", "void cvPyrUp(const void*, void*, int)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short int, 6>, VecOp = cv::NoVec<int, short int>]", "void cvPyrDown(const void*, void*, int)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/pyramids.cpp", "std::abs(dsize.width*2 - ssize.width) <= 2 && std::abs(dsize.height*2 - ssize.height) <= 2", "std::abs(dsize.width - ssize.width*2) == dsize.width % 2 && std::abs(dsize.height - ssize.height*2) == dsize.height % 2", "_filter == CV_GAUSSIAN_5x5 && src.type() == dst.type()", "The number of extra layers must be non negative", "The buffer is too small to fit the pyramid", "void cv::pyrDown(const cv::_InputArray&, const cv::_OutputArray&, const cv::Size&, int)", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<float, 8>, VecOp = cv::NoVec<float, float>]", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short unsigned int, 8>, VecOp = cv::NoVec<int, short unsigned int>]", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<double, 8>, VecOp = cv::NoVec<double, double>]", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<unsigned char, 8>, VecOp = cv::NoVec<int, unsigned char>]", "void cv::pyrUp(const cv::_InputArray&, const cv::_OutputArray&, const cv::Size&, int)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<float, 6>, VecOp = cv::NoVec<float, float>]", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<unsigned char, 6>, VecOp = cv::NoVec<int, unsigned char>]", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/rotcalipers.cpp", "CvBox2D cvMinAreaRect2(const CvArr*, CvMemStorage*)", "void cvGetQuadrangleSubPix(const void*, void*, const CvMat*)", "int cvSampleLine(const void*, CvPoint, CvPoint, void*, int)", "void cvGetRectSubPix(const void*, void*, CvPoint2D32f)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/samplers.cpp", "(func( src->data.ptr, src_step, src_size, dst->data.ptr, dst_step, dst_size, center )) >= 0", "map matrix is not valid", "Transformation matrix must be 2x3", "The transformation matrix should have 32fC1 or 64fC1 type", "(func( src->data.ptr, src->step, src_size, dst->data.ptr, dst->step, dst_size, m )) >= 0", "void cvPyrMeanShiftFiltering(const CvArr*, CvArr*, double, double, int, CvTermCriteria)", "void cvWatershed(const CvArr*, CvArr*)", "The number of pyramid levels is too large or negative", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/segmentation.cpp", "Only 8-bit, 3-channel images are supported", "The input and output images must have the same type", "The input and output images must have the same size", "Only 8-bit, 3-channel input images are supported", "Only 32-bit, 1-channel output images are supported", "double cvArcLength(const void*, CvSlice, int)", "double cvContourArea(const void*, CvSlice, int)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/shapedescr.cpp", "Only curves with integer coordinates are supported in case of contour slice", "(icvContourSecArea( contour, slice, &area )) >= 0", "Null center or radius pointers", "Number of points should be >= 5", "The image/matrix format is not supported by the function", "CvRect cvBoundingRect(CvArr*, int)", "CvBox2D cvFitEllipse2(const CvArr*)", "int cvMinEnclosingCircle(const void*, CvPoint2D32f*, float*)", "N2cv9ColumnSumIihEE", "N2cv9ColumnSumIdhEE", "N2cv9ColumnSumIitEE", "N2cv9ColumnSumIdtEE", "N2cv9ColumnSumIisEE", "N2cv9ColumnSumIdsEE", "N2cv9ColumnSumIiiEE", "N2cv9ColumnSumIifEE", "N2cv9ColumnSumIdfEE", "N2cv9ColumnSumIidEE", "N2cv9ColumnSumIddEE", "N2cv6RowSumIhiEE", "N2cv6RowSumIhdEE", "N2cv6RowSumItiEE", "N2cv6RowSumItdEE", "N2cv6RowSumIsiEE", "N2cv6RowSumIiiEE", "N2cv6RowSumIsdEE", "N2cv6RowSumIfdEE", "N2cv6RowSumIddEE", "void cv::bilateralFilter_32f(const cv::Mat&, cv::Mat&, int, double, double, int)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = unsigned char]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = double]", "cv::Ptr<cv::BaseColumnFilter> cv::getColumnSumFilter(int, int, int, int, double)", "void cv::bilateralFilter_8u(const cv::Mat&, cv::Mat&, int, double, double, int)", "void cv::medianBlur(const cv::_InputArray&, const cv::_OutputArray&, int)", "void cv::bilateralFilter(const cv::_InputArray&, const cv::_OutputArray&, int, double, double, int)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = double]", "cv::Ptr<cv::BaseRowFilter> cv::getRowSumFilter(int, int, int, int)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = float]", "cv::Mat cv::getGaussianKernel(int, double, int)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = int]", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/smooth.cpp", "ksize % 2 == 1", "src.depth() == CV_8U && (cn == 1 || cn == 3 || cn == 4)", "ksize.width > 0 && ksize.width % 2 == 1 && ksize.height > 0 && ksize.height % 2 == 1", "CV_MAT_CN(sumType) == CV_MAT_CN(srcType)", "CV_MAT_CN(sumType) == CV_MAT_CN(dstType)", "Unsupported combination of sum format (=%d), and destination format (=%d)", "(src.type() == CV_8UC1 || src.type() == CV_8UC3) && src.type() == dst.type() && src.size() == dst.size() && src.data != dst.data", "(src.type() == CV_32FC1 || src.type() == CV_32FC3) && src.type() == dst.type() && src.size() == dst.size() && src.data != dst.data", "Bilateral filtering is only implemented for 8u and 32f images", "dst.size() == src.size() && (smooth_type == CV_BLUR_NO_SCALE || dst.type() == src.type())", "The destination image does not have the proper type", "sumCount == ksize-1", "=void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = unsigned char]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = short unsigned int]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = short int]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = float]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = short int]", "void cvSmooth(const void*, void*, int, int, int, double, double)", "cv::Ptr<cv::FilterEngine> cv::createGaussianFilter(int, cv::Size, double, double, int)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = short unsigned int]", "int cv::Subdiv2D::findNearest(cv::Point2f, cv::Point2f*)", "int cv::Subdiv2D::insert(cv::Point2f)", "edgeOrg(e) == edgeOrg(o_next)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/subdivision2d.cpp", "edgeOrg(e) == edgeOrg(o_prev)", "edgeDst(e) == edgeDst(d_next)", "edgeDst(e) == edgeDst(d_prev)", "edgeDst(o_next) == edgeOrg(d_prev)", "edgeDst(o_prev) == edgeOrg(d_next)", "getEdge(getEdge(getEdge(e,NEXT_AROUND_LEFT),NEXT_AROUND_LEFT),NEXT_AROUND_LEFT) == e", "getEdge(getEdge(getEdge(e,NEXT_AROUND_RIGHT),NEXT_AROUND_RIGHT),NEXT_AROUND_RIGHT) == e", "Subdivision is empty", "edge > 0", "edgeDst(edge, &t) > 0", "edgeOrg( edge, &t ) > 0", "Subdiv2D::locate returned invalid location = %d", "int cv::Subdiv2D::locate(cv::Point2f, int&, int&)", "void cv::Subdiv2D::checkSubdiv() const", "void cvIntegral(const CvArr*, CvArr*, CvArr*, CvArr*)", "void cv::integral(const cv::_InputArray&, const cv::_OutputArray&, const cv::_OutputArray&, const cv::_OutputArray&, int)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/sumpixels.cpp", "sum.data == sum0.data && sqsum.data == sqsum0.data && tilted.data == tilted0.data", "void cvMatchTemplate(const CvArr*, const CvArr*, CvArr*, int)", "void cv::matchTemplate(const cv::_InputArray&, const cv::_InputArray&, const cv::_OutputArray&, int)", "img.dims <= 2 && templ.dims <= 2 && corr.dims <= 2", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/templmatch.cpp", "depth == tdepth || tdepth == CV_32F", "corrsize.height <= img.rows + templ.rows - 1 && corrsize.width <= img.cols + templ.cols - 1", "ccn == 1 || delta == 0", "the input arrays are too big", "CV_TM_SQDIFF <= method && method <= CV_TM_CCOEFF_NORMED", "(img.depth() == CV_8U || img.depth() == CV_32F) && img.type() == templ.type()", "result.size() == cv::Size(std::abs(img.cols - templ.cols) + 1, std::abs(img.rows - templ.rows) + 1) && result.type() == CV_32F", "double cv::threshold(const cv::_InputArray&, const cv::_OutputArray&, double, double, int)", "void cvAdaptiveThreshold(const void*, void*, double, int, int, int, double)", "void cv::thresh_32f(const cv::Mat&, cv::Mat&, float, float, int)", "void cv::adaptiveThreshold(const cv::_InputArray&, const cv::_OutputArray&, double, int, int, int, double)", "Unknown threshold type", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/thresh.cpp", "src.type() == CV_8UC1", "blockSize % 2 == 1 && blockSize > 1", "Unknown/unsupported adaptive threshold method", "Unknown/unsupported threshold type", "src.size == dst.size && src.type() == dst.type()", "src.size == dst.size && src.channels() == dst.channels() && (src.depth() == dst.depth() || dst.depth() == CV_8U)", "double cvThreshold(const void*, void*, double, double, int)", "void cv::thresh_16s(const cv::Mat&, cv::Mat&, short int, short int, int)", "void cv::thresh_8u(const cv::Mat&, cv::Mat&, uchar, uchar, int)", "void cv::undistort(const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&, const cv::_InputArray&, const cv::_InputArray&)", "float cv::initWideAngleProjMap(const cv::_InputArray&, const cv::_InputArray&, cv::Size, int, int, const cv::_OutputArray&, const cv::_OutputArray&, int, double)", "void cvUndistortPoints(const CvMat*, CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*)", "CV_IS_MAT(_src) && CV_IS_MAT(_dst) && (_src->rows == 1 || _src->cols == 1) && (_dst->rows == 1 || _dst->cols == 1) && _src->cols + _src->rows - 1 == _dst->rows + _dst->cols - 1 && (CV_MAT_TYPE(_src->type) == CV_32FC2 || CV_MAT_TYPE(_src->type) == CV_64FC2) && (CV_MAT_TYPE(_dst->type) == CV_32FC2 || CV_MAT_TYPE(_dst->type) == CV_64FC2)", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/undistort.cpp", "CV_IS_MAT(_cameraMatrix) && _cameraMatrix->rows == 3 && _cameraMatrix->cols == 3", "CV_IS_MAT(_distCoeffs) && (_distCoeffs->rows == 1 || _distCoeffs->cols == 1) && (_distCoeffs->rows*_distCoeffs->cols == 4 || _distCoeffs->rows*_distCoeffs->cols == 5 || _distCoeffs->rows*_distCoeffs->cols == 8)", "CV_IS_MAT(matR) && matR->rows == 3 && matR->cols == 3", "CV_IS_MAT(matP) && matP->rows == 3 && (matP->cols == 3 || matP->cols == 4)", "src.isContinuous() && (src.depth() == CV_32F || src.depth() == CV_64F) && ((src.rows == 1 && src.channels() == 2) || src.cols*src.channels() == 2)", "(distCoeffs0.cols == 1 || distCoeffs0.rows == 1) && (ndcoeffs == 4 || ndcoeffs == 5 || ndcoeffs == 8)", "cameraMatrix0.size() == Size(3,3)", "Unknown projection type", "avg iters = %g\n", "m1type == CV_16SC2 || m1type == CV_32FC1 || m1type == CV_32FC2", "A.size() == Size(3,3) && A.size() == R.size()", "Ar.size() == Size(3,3) || Ar.size() == Size(4, 3)", "distCoeffs.size() == Size(1, 4) || distCoeffs.size() == Size(4, 1) || distCoeffs.size() == Size(1, 5) || distCoeffs.size() == Size(5, 1) || distCoeffs.size() == Size(1, 8) || distCoeffs.size() == Size(8, 1)", "mapx0.data == mapx.data && mapy0.data == mapy.data", "dst.data != src.data", "cv::Point2f cv::mapPointSpherical(const cv::Point2f&, float, cv::Vec4d*, int)", "void cv::initUndistortRectifyMap(const cv::_InputArray&, const cv::_InputArray&, const cv::_InputArray&, const cv::_InputArray&, cv::Size, int, const cv::_OutputArray&, const cv::_OutputArray&)", "void cv::undistortPoints(const cv::_InputArray&, const cv::_OutputArray&, const cv::_InputArray&, const cv::_InputArray&, const cv::_InputArray&, const cv::_InputArray&)", "void cvInitUndistortMap(const CvMat*, const CvMat*, CvArr*, CvArr*)", "void cvUndistort2(const CvArr*, CvArr*, const CvMat*, const CvMat*, const CvMat*)", "void cvInitUndistortRectifyMap(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvArr*, CvArr*)", "void cvCopyMakeBorder(const CvArr*, CvArr*, CvPoint, int, CvScalar)", "CvSeq* cvPointSeqFromMat(int, const CvArr*, CvContour*, CvSeqBlock*)", "double cv::PSNR(const cv::_InputArray&, const cv::_InputArray&)", "void cv::copyMakeBorder(const cv::_InputArray&, const cv::_OutputArray&, int, int, int, int, int, const cv::Scalar&)", "src1.depth() == CV_8U", "/Users/tw/Documents/lumber/buffalo/opencv/OpenCV-2.4.1/modules/imgproc/src/utils.cpp", "arr != 0 && contour_header != 0 && block != 0", "Input array is not a valid matrix", "The matrix can not be converted to point sequence because of inappropriate element type", "The matrix converted to point sequence must be 1-dimensional and continuous", "top >= 0 && bottom >= 0 && left >= 0 && right >= 0", "value[0] == value[1] && value[0] == value[2] && value[0] == value[3]", "dst.type() == src.type()", "St12out_of_range", "St12length_error", "NSt8ios_base7failureE", "N9__gnu_cxx24__concurrence_lock_errorE", "N9__gnu_cxx26__concurrence_unlock_errorE", "NSt6locale5facetE", "__gnu_cxx::__concurrence_lock_error", "__gnu_cxx::__concurrence_unlock_error", "locale::_S_normalize_category category not found", "locale::_Impl::_M_replace_facet", "St13runtime_error", "St11logic_error", "N12_GLOBAL__N_121system_error_categoryE", "N12_GLOBAL__N_122generic_error_categoryE", "St14error_category", "generic", "system", "St9basic_iosIwSt11char_traitsIwEE", "St9basic_iosIcSt11char_traitsIcEE", "basic_ios::clear", "St13basic_istreamIwSt11char_traitsIwEE", "St10ctype_base", "St9time_base", "St12codecvt_base", "St13messages_base", "St10money_base", "St7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St9money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St16__numpunct_cacheIcE", "St11__timepunctIcE", "St9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St18__moneypunct_cacheIcLb1EE", "St7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St8messagesIcE", "St8numpunctIcE", "St10moneypunctIcLb0EE", "St8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St7collateIcE", "St10moneypunctIcLb1EE", "St18__moneypunct_cacheIcLb0EE", "St17__timepunct_cacheIcE", "POSIX", "%m/%d/%y", "%H:%M", "%H:%M:%S", "%.*Lf", "St23__codecvt_abstract_baseIcc9mbstate_tE", "N9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE", "N9__gnu_cxx18stdio_sync_filebufIcSt11char_traitsIcEEE", "St13basic_ostreamIwSt11char_traitsIwEE", "St15basic_streambufIwSt11char_traitsIwEE", "St15basic_streambufIcSt11char_traitsIcEE", "basic_string::_S_create", "basic_string::at", "basic_string::compare", "basic_string::_S_construct NULL not valid", "basic_string::basic_string", "basic_string::substr", "basic_string::copy", "basic_string::append", "basic_string::_M_replace_aux", "basic_string::replace", "basic_string::insert", "basic_string::erase", "basic_string::assign", "basic_string::resize", "St10moneypunctIwLb0EE", "St10moneypunctIwLb1EE", "St18__moneypunct_cacheIwLb0EE", "St9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7collateIwE", "St17__timepunct_cacheIwE", "St7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St18__moneypunct_cacheIwLb1EE", "St23__codecvt_abstract_baseIwc9mbstate_tE", "St8messagesIwE", "St16__numpunct_cacheIwE", "St21__ctype_abstract_baseIwE", "St11__timepunctIwE", "St8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St8numpunctIwE", "St8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "true", "false", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "January", "February", "March", "April", "June", "July", "August", "September", "October", "November", "December", "locale::facet::_S_create_c_locale name not valid", "LC_CTYPE", "LC_NUMERIC", "LC_TIME", "LC_COLLATE", "LC_MONETARY", "LC_MESSAGES", "St7codecvtIwc9mbstate_tE", "St7codecvtIcc9mbstate_tE", "St5ctypeIcE", "St5ctypeIwE", "St8ios_base", "AKST", "-0123456789", "-+xX0123456789abcdefABCDEF", "-+xX0123456789abcdef0123456789ABCDEF", "space", "print", "cntrl", "upper", "lower", "alpha", "digit", "punct", "xdigit", "alnum", "graph"], "stringidentifiers": ["vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv8Filter2DIhNS_4CastIfhEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIfNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIdNS_4CastIddEENS_11FilterNoVecEEE", "N2cv12ColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv18SymmRowSmallFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_8RowNoVecEEE", "N2cv9RowFilterIhfNS_8RowNoVecEEE", "N2cv9RowFilterIhdNS_8RowNoVecEEE", "N2cv9RowFilterItfNS_8RowNoVecEEE", "N2cv9RowFilterItdNS_8RowNoVecEEE", "N2cv9RowFilterIsfNS_8RowNoVecEEE", "N2cv9RowFilterIsdNS_8RowNoVecEEE", "N2cv9RowFilterIffNS_8RowNoVecEEE", "N2cv9RowFilterIfdNS_8RowNoVecEEE", "N2cv9RowFilterIddNS_8RowNoVecEEE", "N2cv16BaseColumnFilterE", "N2cv10BaseFilterE", "N2cv13BaseRowFilterE", "N2cv12FilterEngineE", "vector::reserve", "is_uniform", "have_ranges", "bins", "thresh", "N2cv11MorphFilterINS_5MinOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIdEENS_10MorphNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIdEENS_16MorphColumnNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIdEENS_13MorphRowNoVecEEE", "N2cv9ColumnSumIihEE", "N2cv9ColumnSumIdhEE", "N2cv9ColumnSumIitEE", "N2cv9ColumnSumIdtEE", "N2cv9ColumnSumIisEE", "N2cv9ColumnSumIdsEE", "N2cv9ColumnSumIiiEE", "N2cv9ColumnSumIifEE", "N2cv9ColumnSumIdfEE", "N2cv9ColumnSumIidEE", "N2cv9ColumnSumIddEE", "N2cv6RowSumIhiEE", "N2cv6RowSumIhdEE", "N2cv6RowSumItiEE", "N2cv6RowSumItdEE", "N2cv6RowSumIsiEE", "N2cv6RowSumIiiEE", "N2cv6RowSumIsdEE", "N2cv6RowSumIfdEE", "N2cv6RowSumIddEE", "St12out_of_range", "St12length_error", "NSt8ios_base7failureE", "N9__gnu_cxx24__concurrence_lock_errorE", "N9__gnu_cxx26__concurrence_unlock_errorE", "NSt6locale5facetE", "__gnu_cxx::__concurrence_lock_error", "__gnu_cxx::__concurrence_unlock_error", "St13runtime_error", "St11logic_error", "N12_GLOBAL__N_121system_error_categoryE", "N12_GLOBAL__N_122generic_error_categoryE", "St14error_category", "generic", "system", "St9basic_iosIwSt11char_traitsIwEE", "St9basic_iosIcSt11char_traitsIcEE", "basic_ios::clear", "St13basic_istreamIwSt11char_traitsIwEE", "St10ctype_base", "St9time_base", "St12codecvt_base", "St13messages_base", "St10money_base", "St7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St9money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St16__numpunct_cacheIcE", "St11__timepunctIcE", "St9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St18__moneypunct_cacheIcLb1EE", "St7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St8messagesIcE", "St8numpunctIcE", "St10moneypunctIcLb0EE", "St8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St7collateIcE", "St10moneypunctIcLb1EE", "St18__moneypunct_cacheIcLb0EE", "St17__timepunct_cacheIcE", "POSIX", "St23__codecvt_abstract_baseIcc9mbstate_tE", "N9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE", "N9__gnu_cxx18stdio_sync_filebufIcSt11char_traitsIcEEE", "St13basic_ostreamIwSt11char_traitsIwEE", "St15basic_streambufIwSt11char_traitsIwEE", "St15basic_streambufIcSt11char_traitsIcEE", "basic_string::_S_create", "basic_string::at", "basic_string::compare", "basic_string::basic_string", "basic_string::substr", "basic_string::copy", "basic_string::append", "basic_string::_M_replace_aux", "basic_string::replace", "basic_string::insert", "basic_string::erase", "basic_string::assign", "basic_string::resize", "St10moneypunctIwLb0EE", "St10moneypunctIwLb1EE", "St18__moneypunct_cacheIwLb0EE", "St9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7collateIwE", "St17__timepunct_cacheIwE", "St7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St18__moneypunct_cacheIwLb1EE", "St23__codecvt_abstract_baseIwc9mbstate_tE", "St8messagesIwE", "St16__numpunct_cacheIwE", "St21__ctype_abstract_baseIwE", "St11__timepunctIwE", "St8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St8numpunctIwE", "St8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "true", "false", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "January", "February", "March", "April", "June", "July", "August", "September", "October", "November", "December", "LC_CTYPE", "LC_NUMERIC", "LC_TIME", "LC_COLLATE", "LC_MONETARY", "LC_MESSAGES", "St7codecvtIwc9mbstate_tE", "St7codecvtIcc9mbstate_tE", "St5ctypeIcE", "St5ctypeIwE", "St8ios_base", "AKST", "space", "print", "cntrl", "upper", "lower", "alpha", "digit", "punct", "xdigit", "alnum", "graph"], "debugstrings": ["Unknown/unsupported color conversion code", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3"], "localsymbols": [""], "dependencies": ["libm.so", "libz.so", "libdl.so", "libc.so", "libopencv_core.so", "liblog.so"], "elfname": "libopencv_imgproc.so"}