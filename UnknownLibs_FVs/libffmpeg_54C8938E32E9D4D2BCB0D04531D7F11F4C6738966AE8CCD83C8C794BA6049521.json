{"globalvars": ["ff_vc1_imode_vlc", "ff_h263_intra_MCBPC_code", "ff_mkv_image_mime_tags", "ff_vorbis_parser", "ff_avsrc_movie", "x264_log2_lz_lut", "invCount", "x264_levels", "ff_cos_16384_fixed", "ff_mpa_synth_window_fixed", "ff_vf_scale2ref", "ff_image_bmp_pipe_demuxer", "ff_sine_64_fixed", "ff_wav_muxer", "ff_af_ebur128", "ff_vf_paletteuse", "FDKaacEnc_huff_ctab1", "x264_cache_mv_func_table", "rgb24tobgr16", "ff_ac3_fast_decay_tab", "rgb16to15", "x264_lambda_tab", "ff_vf_hqx", "RotVectorImag240", "rgb32tobgr24", "ff_h263_inter_MCBPC_bits", "ff_af_join", "ff_pcm_s24le_demuxer", "ff_vc1_parser", "ff_vsink_nullsink", "ff_id3v2_3_tags", "ff_ac3_parser", "FDKaacEnc_huff_ltabscf", "ff_vorbis_codec", "ff_vf_fifo", "ff_avcodec_locked", "ff_fc_2pulses_9bits_track1", "ff_aac_psy_model", "ff_pcm_mulaw_demuxer", "ff_mpeg4_rl_intra", "ff_vc1_2mv_block_pattern_vlc", "ff_codec_movsubtitle_tags", "ff_ogm_video_codec", "ff_vsrc_buffer", "avpriv_mjpeg_bits_ac_chrominance", "bookSbrEnvBalanceC11T", "p_FDKaacEnc_11025_long_1024", "ff_af_adelay", "ff_msmpeg4v3_encoder", "ff_avf_concat", "ff_pcm_u32le_muxer", "ff_pcm_f64be_demuxer", "ff_image_dpx_pipe_demuxer", "ff_rv40_parser", "ff_flac_codec", "ff_aac_eld_window_512_fixed", "ff_vf_elbg", "ff_vf_fieldmatch", "ff_hevc_mp4toannexb_bsf", "qmf_phaseshift_sin32_cldfb", "ff_pcm_u16be_muxer", "ff_mp3_decoder", "ff_vc1_adv_progressive_8x4_zz", "ff_asink_anullsink", "ff_cos_1024", "ff_vf_spp", "ff_pcm_u16be_demuxer", "ff_sipr_subpk_size", "av_twofish_size", "ff_asf_extended_content_header", "ff_mpegtsraw_demuxer", "ff_dnxhd_parser", "p_FDKaacEnc_96000_short_128", "ff_bmp_parser", "ff_ogm_old_codec", "ff_sine_512", "ff_table0_dc_lum", "ff_cavsvideo_parser", "x264_exp2_lut", "ff_pcm_s32be_demuxer", "av_codec_ffversion", "ff_id3v2_tags", "ff_vorbis_vwin", "ff_h263_pixel_aspect", "ff_mpeg1_default_non_intra_matrix", "SineWindow64", "ff_ac3_floor_tab", "x264_last_coeff_flag_offset_8x8", "p_FDKaacEnc_22050_long_1024", "ff_ac3_db_per_bit_tab", "ff_concat_demuxer", "ff_vf_find_rect", "qmf_phaseshift_sin64_cldfb", "yv12toyuy2", "avpriv_pix_fmt_bps_mov", "ff_dither_8x8_220", "ff_af_flanger", "ff_vf_null", "ff_hls_demuxer", "ff_mjpeg_decoder", "ff_interleaved_se_golomb_vlc_code", "ff_image_jpeg_pipe_demuxer", "ff_dirac_codec", "ff_pcm_s16be_demuxer", "ff_mb_btype_vlc", "ff_vc1_field_mvpred_scales", "qmf_phaseshift_cos32_cldfb", "ff_aac_num_swb_1024", "ff_mpeg4audio_channels", "ff_h263_rl_inter", "ff_h263i_decoder", "ff_table1_dc_lum", "ff_image_exr_pipe_demuxer", "ff_vf_field", "yvu9_to_yuy2", "ff_vf_crop", "ff_vc1_intfr_4mv_mbmode_codes", "ff_eac3_default_cpl_band_struct", "ff_vf_separatefields", "ff_vf_colormatrix", "ff_wav_demuxer", "ff_dvd_nav_parser", "FDKaacEnc_huff_ltab11", "ff_cos_tabs_fixed", "ff_ue_golomb_vlc_code", "ff_asrc_sine", "ff_h263_loop_filter_strength", "FDKaacEnc_specExpMantTableCombElc", "ff_sine_windows_fixed", "ff_png_encoder", "ff_sine_4096", "ff_vc1_ttblk_codes", "p_FDKaacEnc_88200_long_1024", "ff_avf_showwavespic", "ff_hevc_pel_weight", "ff_mjpeg_demuxer", "FDKaacEnc_huff_ctab5", "FDKaacEnc_mTab_3_4", "FDKaacEnc_huff_ctab8", "ff_cos_32768_fixed", "ff_aac_pow2sf_tab", "ff_cos_8192_fixed", "yv12touyvy", "ff_image_sgi_pipe_demuxer", "ff_vf_drawbox", "ff_mpeg4_unpack_bframes_bsf", "ff_image_jpegls_pipe_demuxer", "ff_dither_8x8_128", "ff_old_flac_codec", "rgb24to15", "rgb32tobgr15", "v_Huff_envelopeLevelC11T", "FDKaacEnc_tnsEncCoeff3", "ff_ac3_hearing_threshold_tab", "ff_sine_128", "ff_vc1_bfraction_bits", "ff_vf_drawgrid", "x264_dct4_weight_tab", "ff_sine_64", "avpriv_vga16_font", "ff_asink_abuffer", "ff_af_aphaser", "ff_vf_ssim", "ff_reverse", "ff_avf_showwaves", "ff_hevc_parser", "ff_image2_demuxer", "ff_vc1_intfr_4mv_mbmode_vlc", "ff_af_asetnsamples", "x264_cabac_size_unary", "ff_mkv_metadata_conv", "ff_mlp_huffman_tables", "ff_vsrc_rgbtestsrc", "ff_dither_8x8_73", "ff_af_astats", "p_FDKaacEnc_64000_long_1024", "ff_vf_framerate", "ff_alternate_vertical_scan", "ff_webm_dash_manifest_demuxer", "ff_aac_pow34sf_tab", "ff_vf_swapuv", "ff_dca_parser", "ff_vc1_if_1mv_mbmode_codes", "ff_vc1_ttmb_codes", "ff_modified_quant_tab", "ff_hevc_decoder", "ff_vorbis_channel_layouts", "ff_vorbiscomment_metadata_conv", "x264_cabac_transition_unary", "ff_sine_256", "ff_id3v2_4_metadata_conv", "ff_mpegts_demuxer", "ff_image_j2k_pipe_demuxer", "ff_gif_demuxer", "FDKSEEK_CUR", "ff_mpeg12_vlc_dc_chroma_bits", "ff_aac_codebook_vector_idx", "av_pix_fmt_descriptors", "ff_vc1_bfraction_codes", "ff_sine_windows", "ff_vc1_ac_coeff_table", "ff_vc1_norm2_vlc", "ff_asf_video_stream", "ff_h263_parser", "ff_vf_rotate", "ff_cos_8192", "x264_significant_coeff_flag_offset_8x8", "ff_af_areverse", "windowSlopes", "p_FDKaacEnc_16000_short_128", "ff_pow_0_7", "ff_vc1_mbmode_intfrp", "ff_vc1_2mv_block_pattern_codes", "ff_af_treble", "swri_resampler", "ff_sine_8192_fixed", "ff_mp4_muxer", "ff_vc1_if_1mv_mbmode_vlc", "ff_sin_64", "ff_asrc_abuffer", "ff_ac3_log_add_tab", "ff_rawvideo_options", "ff_vsrc_haldclutsrc", "ff_mjpeg2jpeg_bsf", "ff_af_silencedetect", "ff_hevc_epel_filters", "ff_vsrc_mptestsrc", "SineWindow32", "ff_vc1_demuxer", "ff_vf_signalstats", "ff_vsrc_nullsrc", "ff_sine_32_fixed", "p_FDKaacEnc_24000_long_1024", "ff_vc1_2ref_mvdata_vlc", "x264_log2_lut", "ff_pcm_alaw_muxer", "x264_decimate_table8", "ff_fft_offsets_lut", "ff_vc1_1ref_mvdata_codes", "ff_vsrc_allrgb", "x264_total_zeros_2x2_dc", "x264_count_cat_m1", "ff_vf_lutyuv", "ff_vf_scale", "ff_pcm_u32be_muxer", "ff_apng_encoder", "ff_id3v2_mime_tags", "ff_opus_codec", "FDKaacEnc_tnsCoeff4Borders", "psTuningTable", "qmf_phaseshift_cos64", "p_FDKaacEnc_44100_long_1024", "ff_live_flv_demuxer", "ff_vf_showinfo", "ff_dirac_parser", "ff_fc_2pulses_9bits_track1_gray", "ff_png_decoder", "ff_mpeg4_y_dc_scale_table", "ff_cos_512", "ff_mpeg4_DCtab_chrom", "ff_asf_ext_stream_header", "ff_wmv1_scantable", "qmf_phaseshift_sin_downsamp32", "ff_adts_muxer", "ff_mdct_win_fixed", "SineWindow512", "ff_vc1_intfr_non4mv_mbmode_bits", "ff_file_protocol", "ff_golomb_vlc_len", "ff_dpx_parser", "ff_af_asendcmd", "rgb24to16", "ff_ac3_bitrate_tab", "avpriv_cga_font", "ff_vc1_2ref_mvdata_bits", "SineWindow960", "x264_total_zeros_2x4_dc", "ff_async_protocol", "ff_h261_parser", "ff_vc1_icbpcy_p_codes", "ff_wmv1_y_dc_scale_table", "ff_mpeg4_default_intra_matrix", "qmf_phaseshift_sin32", "ff_pcm_u24le_muxer", "ff_gif_muxer", "ff_gsm_parser", "ff_asf_stream_header", "x264_iter_kludge", "ff_mb_ptype_vlc", "vu9_to_vu12", "ff_swf_codec_tags", "ff_vc1_icbpcy_p_bits", "ff_vf_setsar", "ff_mlp_parser", "ff_pcm_s16le_decoder", "ff_mpeg2_aspect", "p_FDKaacEnc_48000_long_1024", "ff_vc1_bfraction_vlc", "ff_mjpeg_parser", "ff_msmpeg4v2_encoder", "ff_vf_blend", "ff_vc1_mv_diff_bits", "ff_vf_fspp", "ff_vf_vstack", "ff_adx_parser", "ff_vf_colorkey", "ff_aac_latm_decoder", "ff_af_amerge", "ff_mpeg4_intra_vlc", "ff_vf_trim", "ff_vf_pixdesctest", "ff_libwebp_encoder", "x264_run_before", "ff_xmv_demuxer", "ff_af_sidechaincompress", "ff_mpa_sblimit_table", "ff_vf_colorlevels", "ff_rm_codec_tags", "ff_tns_max_bands_1024", "ff_asf_metadata_conv", "ff_asf_simple_index_header", "qmf_phaseshift_sin64", "ff_v2_dc_lum_table", "ff_se_golomb_vlc_code", "ff_h263_intra_MCBPC_bits", "ff_vf_extractplanes", "ff_aac_swb_size_128_len", "ff_swb_offset_128", "ff_image_qdraw_pipe_demuxer", "ff_asf_command_stream", "ff_amrnb_decoder", "ff_vf_decimate", "ff_pcm_f64le_demuxer", "av_ripemd_size", "ff_sin_8192", "ff_aac_spectral_bits", "ff_image2_muxer", "av_cast5_size", "v_Huff_envelopeLevelL11F", "ff_af_amix", "p_FDKaacEnc_11025_short_128", "ff_pcm_u32be_demuxer", "ff_h264_muxer", "ff_aac_parser", "ff_mpeg4_default_non_intra_matrix", "ff_vc1_adv_interlaced_4x4_zz", "ff_hevc_diag_scan8x8_x", "ff_vc1t_demuxer", "ff_sin_512", "avpriv_mjpeg_val_ac_chrominance", "ff_aac_spectral_sizes", "ff_fc_2pulses_9bits_track2_gray", "ff_inter_vlc", "ff_vc1_ttblk_to_tt", "ff_vf_geq", "ff_pcm_u32le_demuxer", "ff_mjpeg_encoder", "FDKaacEnc_tnsCoeff3Borders", "ff_vf_codecview", "ff_vf_pullup", "ff_vf_hstack", "ff_dump_extradata_bsf", "ff_sin_256", "ff_vc1_imode_bits", "v_Huff_envelopeLevelC10F", "qmf_phaseshift_cos_downsamp32", "ff_vc1_adv_interlaced_4x8_zz", "ff_vc1_2mv_block_pattern_bits", "FDKaacEnc_tnsEncCoeff4", "ff_image_webp_pipe_demuxer", "ff_libfdk_aac_encoder", "ff_mpeg12_vlc_dc_lum_code", "ff_vf_unsharp", "ff_sprite_trajectory_tab", "ff_asf_ext_stream_audio_stream", "ff_msmp4_dc_luma_vlc", "bookSbrNoiseBalanceC11T", "ff_vf_eq", "ff_af_atrim", "ff_aac_eld_window_512", "ff_vf_colorbalance", "ff_mkv_mime_tags", "ff_sin_32", "ff_wmv1_c_dc_scale_table", "ff_vf_dilation", "SineTable512", "ff_vc1_4mv_block_pattern_vlc", "p_FDKaacEnc_32000_short_128", "ff_af_pan", "ff_vsrc_cellauto", "ff_af_aresample", "av_tea_size", "BitMask", "rgb16to32", "ff_old_dirac_codec", "ff_h264_chroma_qp", "ff_aanscales", "ELDAnalysis512", "ff_aac_demuxer", "ff_vf_mcdeint", "ff_vf_idet", "ff_mkv_codec_tags", "ff_vf_pp7", "ff_mpeg12_mbAddrIncrTable", "ff_af_asplit", "ff_vf_xbr", "ff_aac_kbd_long_1024", "v_Huff_envelopeLevelC11F", "ff_ipod_muxer", "ff_vf_framepack", "ff_vf_bbox", "ff_vsrc_color", "ff_vc1_fps_dr", "VP8GetCPUInfo", "ff_table0_dc_chroma", "KBDWindow1024", "FDKaacEnc_huff_ltab9_10", "ff_vf_lut", "ff_vf_zoompan", "ff_aac_swb_size_1024", "ELDAnalysis480", "ff_dither_2x2_4", "ff_sine_4096_fixed", "ff_vc1_if_mmv_mbmode_vlc", "ff_sln_demuxer", "ff_vf_interlace", "ff_asf_codec_comment1_header", "ff_vc1_bfraction_lut", "ff_img_options", "ff_af_aperms", "ff_vp3_parser", "ff_h263_static_rl_table_store", "ff_vf_vflip", "ff_zigzag_direct", "ff_id3v2_4_tags", "ff_h263_chroma_qscale_table", "ff_mpv_generic_options", "ff_mpeg1_default_intra_matrix", "p_FDKaacEnc_12000_short_128", "ff_af_acrossfade", "ff_vc1_4mv_block_pattern_codes", "ff_ac3_enc_channel_map", "ff_pcm_u8_muxer", "ff_vf_mpdecimate", "ff_vf_psnr", "ff_data_demuxer", "ff_af_bandreject", "ff_tns_max_bands_128", "ff_vf_random", "sbrTuningTableSize", "ff_cos_65536_fixed", "ff_mpeg12_vlc_dc_lum_bits", "ff_avio_class", "ff_asrc_aevalsrc", "avpriv_ac3_channel_layout_tab", "ff_sine_32", "ff_mpeg2_dc_scale_table", "ff_sbr_noise_table", "ff_vc1_intfr_4mv_mbmode_bits", "ff_asf_jfif_media", "ff_codec_bmp_tags", "ff_mp3_demuxer", "ff_subfile_protocol", "ff_avf_showspectrum", "ff_vf_atadenoise", "planar2x", "ff_vsrc_smptebars", "bookSbrEnvBalanceC10T", "yuy2toyv12", "ff_sqrt_tab", "ff_vc1_ttmb_vlc", "ff_mpeg4_DCtab_lum", "ff_vc1_norm6_bits", "ff_vf_perspective", "x264_cpu_names", "ff_vc1_if_mmv_mbmode_codes", "ff_pcm_u16le_muxer", "ff_pcm_f64le_muxer", "ff_af_channelsplit", "ff_avf_showfreqs", "ff_asf_my_guid", "ff_h263_inter_MCBPC_vlc", "FDKaacEnc_huff_ctab11", "FDKaacEnc_huff_ltab7_8", "FDKaacEnc_huff_ctabscf", "p_FDKaacEnc_64000_short_128", "ff_vf_vectorscope", "ff_aac_kbd_short_128", "ff_pnm_parser", "ff_cos_16_fixed", "ff_vf_fade", "FDKaacEnc_sideInfoTabShort", "ff_vf_settb", "ff_wmv2_scantableA", "ff_vf_fftfilt", "avpriv_mpeg4audio_sample_rates", "ff_af_bass", "ff_af_aformat", "av_format_ffversion", "v_Huff_envelopeLevelL10T", "ff_vc1_pquant_table", "ff_lzw_encode_state_size", "av_util_ffversion", "ff_vf_setdar", "ff_log2_tab", "x264_decimate_table4", "ff_dvdsub_parser", "ff_pcm_f32be_muxer", "ff_vc1_ttblk_bits", "ff_vc1_intfr_non4mv_mbmode_vlc", "ff_flac_parser", "rgb24tobgr32", "ff_vf_hflip", "ff_mp3_header_decompress_bsf", "FDKaacEnc_sideInfoTabLong", "ff_vc1_ttmb_bits", "ff_vf_boxblur", "ff_crop_tab", "ff_sin_4096", "ff_pcm_f64be_muxer", "ff_vc1_norm2_bits", "avpriv_pix_fmt_bps_avi", "ff_data_protocol", "ff_ogm_audio_codec", "ff_vc1_b_field_mvpred_scales", "p_FDKaacEnc_88200_short_128", "ff_vf_noise", "ff_asf_head1_guid", "FDKaacEnc_huff_ctab2", "x264_coeff_token", "ff_pcm_s24be_muxer", "ff_vf_sab", "ff_mpeg4video_parser", "ff_aac_swb_size_1024_len", "ff_png_pass_ymask", "SineWindow128", "ff_aac_adtstoasc_bsf", "SineTable480", "ff_pcm_s32le_muxer", "ff_ac3_slow_gain_tab", "ff_flac_blocksize_table", "ff_vf_hqdn3d", "ff_vf_smartblur", "x264_lambda2_tab", "ff_cos_512_fixed", "ff_sin_2048", "v_Huff_NoiseLevelL11T", "ff_vf_dejudder", "ff_vc1_mv_diff_vlc", "ff_af_earwax", "ff_cos_2048_fixed", "FDKaacEnc_huff_ctab9", "ff_cos_tabs", "ff_af_biquad", "ff_h264_parser", "ff_vf_perms", "SineWindow1024", "rgb16tobgr24", "ff_mb_non_intra_vlc", "ff_aac_swb_size_128", "ff_flac_sample_rate_table", "x264_dct8_weight_tab", "ff_asink_ffabuffersink", "ff_aac_num_swb_512", "bookSbrEnvBalanceL11T", "ff_log2_run", "p_FDKaacEnc_96000_long_1024", "ff_asf_content_encryption", "ff_loas_demuxer", "ff_old_ff_y_dc_scale_table", "ff_vf_interleave", "ff_mpegps_demuxer", "qmf_cldfb_320", "shuffle_bytes_2103", "ff_vf_delogo", "bookSbrEnvBalanceC11F", "ff_af_channelmap", "ff_af_silenceremove", "ff_aac_encoder", "ff_sine_1024_fixed", "avfilter_all_channel_layouts", "avpriv_dca_sample_rates", "ff_vf_hue", "ff_pcm_s16be_muxer", "ff_vf_setfield", "x264_last_coeff_flag_offset", "ff_msmpeg4v1_decoder", "ff_vf_phase", "uyvytoyuv422", "x264_dct8_weight2_tab", "ff_vc1_adv_interlaced_8x4_zz", "ff_asf_header", "ff_vf_transpose", "x264_cabac_range_lps", "bookSbrEnvBalanceL11F", "ff_cos_4096_fixed", "ff_sin_1024", "ff_avf_aphasemeter", "ff_vf_il", "rgb32tobgr16", "sws_context_class", "ff_mv_vlc", "ff_mpeg2_frame_rate_tab", "FDKaacEnc_huff_ltab1_2", "ff_noise_bsf", "ff_sin_65536", "ff_pcm_u8_demuxer", "ff_interleaved_dirac_golomb_vlc_code", "ff_rm_metadata", "ff_af_aeval", "ff_vf_select", "KBDWindow120", "ff_mov_demuxer", "ff_sine_512_fixed", "ff_msmp4_mb_i_table", "ff_mpeg12_frame_rate_tab", "ff_dvbsub_parser", "ff_msmpeg4v2_decoder", "shuffle_bytes_0321", "ff_codec_wav_tags", "ff_af_equalizer", "ff_ac3_sample_rate_tab", "ff_mbincr_vlc", "rgb24tobgr24", "FDKaacEnc_specExpTableComb", "p_FDKaacEnc_16000_long_1024", "ff_mpeg4_intra_level", "ff_hevc_diag_scan4x4_y", "ff_dither_8x8_32", "bookSbrEnvBalanceL10T", "ff_af_chorus", "ff_aac_decoder", "ff_af_aecho", "ff_vf_lutrgb", "ff_vp8_parser", "ff_sine_2048", "ff_asf_file_header", "ff_vf_tinterlace", "ff_remove_extradata_bsf", "ff_pcm_u16le_demuxer", "ff_af_asetpts", "ff_vf_telecine", "ff_vf_fieldorder", "ff_asf_reserved_4", "ff_vf_yadif", "ff_vf_deband", "ff_vp9_parser", "KBDWindow128", "ff_af_anull", "ff_ac3_fast_gain_tab", "ff_interleaved_ue_golomb_vlc_code", "ff_eac3_default_chmap", "ff_cos_2048", "ff_celt_codec", "ff_vc1_1ref_mvdata_vlc", "ff_pcm_s24be_demuxer", "ff_vf_removegrain", "ff_af_bandpass", "ff_square_tab", "ff_matroska_video_stereo_mode", "ff_raw_pix_fmt_tags", "ff_table_mb_non_intra", "swr_ffversion", "x264_cabac_transition", "SineWindow120", "ff_vf_mergeplanes", "p_FDKaacEnc_8000_short_128", "ff_rvlc_rl_inter", "RotVectorReal480", "x264_hpel_ref1", "ff_libx264_encoder", "ff_mp2_encoder", "ff_sine_256_fixed", "ff_b60_sinc", "ff_codec_wav_guids", "ff_vc1_if_1mv_mbmode_bits", "ff_yuv2rgb_coeffs", "ff_riff_info_conv", "ff_vc1_ac_sizes", "ff_id3v2_picture_types", "ff_vf_blackframe", "ff_vf_detelecine", "ff_asf_comment_header", "ff_vsrc_life", "ff_dc_chroma_vlc", "ff_ac3_bap_tab", "ff_vf_gradfun", "ff_h263p_decoder", "ff_vf_uspp", "ff_sine_1024", "ff_ac3_slow_decay_tab", "avpriv_mpa_bitrate_tab", "FDKaacEnc_huff_ltab3_4", "ff_vf_deflate", "FDKSEEK_SET", "ff_pcm_mulaw_muxer", "ff_aac_num_swb_480", "ff_aac_pred_sfb_max", "ff_gif_encoder", "RotVectorReal240", "ff_vf_split", "ff_ue_golomb_len", "ff_cos_256", "ff_vc1_cbpcy_p_bits", "ff_ac3_window", "ff_inv_aanscales", "ff_inter_level", "ff_codec_movvideo_tags", "ff_h263_inter_MCBPC_code", "av_filter_ffversion", "ff_swb_offset_480", "ff_vf_fps", "ff_asf_codec_comment_header", "yuyvtoyuv422", "ff_imx_dump_header_bsf", "ff_mpa_enwindow", "av_sha512_size", "ff_vsrc_testsrc", "ff_vc1_norm6_vlc", "ff_af_asettb", "ff_vc1_1ref_mvdata_bits", "ff_vf_curves", "ff_vf_edgedetect", "ff_vc1_imode_codes", "ff_png_parser", "ff_latm_demuxer", "ff_inter_run", "ff_sin_16", "ff_msmp4_mb_i_vlc", "ff_mpa_synth_window_float", "FDKaacEnc_huff_ctab6", "ff_cos_128", "ff_static_rl_table_store", "ff_vf_lut3d", "ff_h261_demuxer", "ff_pcm_f32le_demuxer", "ff_vc1_4mv_block_pattern_bits", "ff_vc1_decoder", "ff_v2_intra_cbpc", "v_Huff_envelopeLevelC10T", "bookSbrEnvBalanceC10F", "ff_mpeg4_dc_threshold", "ff_vc1_cbpcy_p_codes", "ff_dither_4x4_16", "p_FDKaacEnc_8000_long_1024", "ff_codec_movaudio_tags", "FDKaacEnc_mTab_4_3Elc", "ff_vf_cropdetect", "ff_tak_parser", "x264_weight_none", "ff_webp_muxer", "FDKaacEnc_huff_ltab5_6", "ff_pcm_s8_demuxer", "ff_cos_16", "ff_sine_128_fixed", "ff_mpa_quant_steps", "ff_mba_length", "ff_asf_ext_content_encryption", "ff_tta_demuxer", "ff_mlp_layout", "ff_v2_mb_type", "ff_aac_spectral_codes", "ff_vf_repeatfields", "ff_vf_palettegen", "ff_vc1_norm2_codes", "ff_ac3_channels_tab", "avpriv_mpa_freq_tab", "ff_flv_demuxer", "ff_h263_demuxer", "ff_hevc_diag_scan4x4_x", "ff_mjpeg_muxer", "ff_vf_inflate", "deinterleaveBytes", "ff_af_replaygain", "ff_avf_adrawgraph", "ff_vf_thumbnail", "ff_cbpc_b_tab", "ff_mpeg12_mbMotionVectorTable", "x264_dct4_weight2_tab", "ff_asf_audio_conceal_spread", "KBDWindow960", "p_FDKaacEnc_22050_short_128", "ff_vf_tile", "ff_aac_coders", "rgb15tobgr24", "x264_cabac_renorm_shift", "ff_pcm_s32le_demuxer", "ff_af_volume", "ff_skeleton_codec", "ff_asf_data_header", "ff_rgb24toyv12", "ff_af_afifo", "ff_af_atempo", "ff_mpeg12_vlc_dc_chroma_code", "ff_gif_decoder", "ff_sin_32768", "ff_ac3_rematrix_band_tab", "ff_vf_stereo3d", "ff_vf_histeq", "bookSbrEnvBalanceL10F", "ff_vc1_mv_pmode_table2", "FDKaacEnc_huff_ctab10", "ff_mpeg4_resync_prefix", "ff_vf_erosion", "ff_flv_decoder", "ff_mpegaudio_parser", "avpriv_mjpeg_bits_dc_luminance", "ff_ogg_demuxer", "ff_avf_avectorscope", "ff_aac_codebook_vectors", "ff_swb_offset_512", "ff_af_dynaudnorm", "ff_af_aselect", "x264_significant_coeff_flag_offset", "ff_wmv1_decoder", "ff_rl_mpeg2", "ff_sin_16384", "ff_cos_65536", "ff_ac3_dec_channel_map", "ff_vc1_subblkpat_bits", "x264_bit_depth", "ff_v2_dc_chroma_table", "ff_af_ashowinfo", "ff_cos_4096", "ff_vf_pad", "sqrt_tab", "FDKaacEnc_huff_ctab3", "ff_af_allpass", "ff_vf_tblend", "v_Huff_envelopeLevelL11T", "ff_amrwb_decoder", "ff_mjpega_dump_header_bsf", "ff_inter_intra_vlc", "ff_wmv2_inter_table", "avpriv_mjpeg_val_ac_luminance", "ff_vc1_norm6_codes", "FDKaacEnc_quantTableQ", "ff_pcm_u24be_demuxer", "ff_vf_drawgraph", "ff_asf_marker_header", "ff_add_pixels_clamped", "ff_mpegvideo_demuxer", "ff_cos_64", "ff_wmv3_dc_scale_table", "ff_vc1_pixel_aspect", "ff_pcm_s32be_muxer", "ff_vf_copy", "ff_asf_head2_guid", "ff_pcm_u24be_muxer", "ff_opus_parser", "ff_vc1_cbpcy_p_vlc", "ff_vc1_adv_progressive_4x8_zz", "ff_mpeg4_static_rl_table_store", "ff_swb_offset_1024", "ff_vc1_adv_interlaced_8x8_zz", "ff_vorbis_encoding_channel_layout_offsets", "bookSbrNoiseBalanceL11T", "ff_ogm_text_codec", "ff_asf_video_conceal_none", "ff_pcm_s16le_muxer", "ff_rvlc_rl_intra", "ff_af_volumedetect", "ff_pow_0_75", "ff_rl_mpeg1", "ff_libx264rgb_encoder", "ff_sine_8192", "ff_image_sunrast_pipe_demuxer", "ff_dc_lum_vlc", "rgb24tobgr15", "ff_put_pixels_clamped", "ff_vc1_subblkpat_codes", "ff_tns_max_bands_512", "ff_sine_2048_fixed", "ff_aic_dc_scale_table", "ff_w_tab_sr", "avpriv_mjpeg_bits_dc_chrominance", "ff_matroska_video_stereo_plane", "x264_chroma_format", "ff_speex_codec", "ff_vf_dctdnoiz", "ff_h264_decoder", "ff_vf_cover_rect", "ff_cos_256_fixed", "ff_pcm_s16le_demuxer", "av_tree_node_size", "ff_pcm_alaw_demuxer", "rgb32to15", "ff_vc1_if_mmv_mbmode_bits", "ff_rv30_parser", "ff_id3v1_genre_str", "FDKaacEnc_huff_ctab4", "ff_mv_tables", "ff_vc1_mv_pmode_table", "interleaveBytes", "ff_vf_alphaextract", "ff_mba_max", "ff_vf_blackdetect", "ff_vf_sendcmd", "ff_wmv1_encoder", "ff_af_highpass", "ff_sin_128", "sbrTuningTable", "ff_vc1_subblkpat_vlc", "ff_vf_removelogo", "ff_af_ainterleave", "sin_twiddle_L64", "x264_coeff_flag_offset_chroma_422_dc", "ff_pow_0_55", "ff_matroska_demuxer", "v_Huff_envelopeLevelL10F", "ff_asf_language_guid", "ff_h264_mb_sizes", "ff_vf_deshake", "ff_vf_format", "ff_h263p_encoder", "ff_vf_w3fdif", "ff_msmpeg4v3_decoder", "ff_msmp4_dc_chroma_vlc", "ff_interleaved_golomb_vlc_len", "ff_h264_mp4toannexb_bsf", "ff_mb_type_b_tab", "p_FDKaacEnc_24000_short_128", "ff_rdt_demuxer", "ff_mov_muxer", "ff_vc1_2ref_mvdata_codes", "ff_vc1_simple_progressive_4x4_zz", "ff_mpa_alloc_tables", "ff_cos_32_fixed", "ff_pcm_f32be_demuxer", "ff_hevc_demuxer", "ff_h263_cbpy_tab", "ff_vf_framestep", "ff_aac_kbd_short_128_fixed", "ff_cos_128_fixed", "ff_fc_4pulses_8bits_tracks_13", "ff_mdct_win_float", "x264_coeff_abs_level_m1_offset", "ff_image_dds_pipe_demuxer", "ff_vf_negate", "ff_af_asetrate", "ff_rl_intra_aic", "ff_vf_owdenoise", "ff_h263_intra_MCBPC_vlc", "ff_aac_eld_window_480", "rgb15to32", "qmf_phaseshift_cos64_cldfb", "ff_g729_parser", "qmf_cldfb_640", "ff_vf_reverse", "ff_h263_encoder", "ff_vsrc_mandelbrot", "ff_rl_table", "ff_theora_codec", "ff_mpa_quant_bits", "p_FDKaacEnc_44100_short_128", "ff_avf_showcqt", "uyvytoyuv420", "ff_avf_showvolume", "ff_asf_audio_conceal_none", "ff_pcm_u24le_demuxer", "ff_fc_4pulses_8bits_track_4", "p_FDKaacEnc_12000_long_1024", "ff_h264_demuxer", "RotVectorReal60", "ff_hevc_qpel_filters", "ff_vf_kerndeint", "ff_cos_64_fixed", "ff_aac_scalefactor_bits", "ff_vp8_codec", "ff_af_lowpass", "ff_image_png_pipe_demuxer", "ff_table_inter_intra", "ff_af_apad", "ff_vf_showpalette", "ff_cos_32768", "ff_vf_alphamerge", "av_camellia_size", "ff_vf_setpts", "ff_cos_32", "ff_vf_histogram", "ff_swf_demuxer", "ff_h263_decoder", "ff_aac_num_swb_128", "qmf_phaseshift_cos32", "ff_m4v_demuxer", "FDKaacEnc_huff_ctab7", "ff_wmv2_scantableB", "ff_vorbis_floor1_inverse_db_table", "ff_asf_digital_signature", "RotVectorImag480", "ff_pcm_f32le_muxer", "yuyvtoyuv420", "ff_chomp_bsf", "ff_vorbis_channel_layout_offsets", "ff_default_chroma_qscale_table", "ff_vc1_ttfrm_to_tt", "av_aes_size", "ff_asf_metadata_header", "avpriv_mjpeg_bits_ac_luminance", "v_Huff_NoiseLevelC11T", "av_sha_size", "yuv422ptoyuy2", "ff_vc1_mv_diff_codes", "ff_asrc_anullsrc", "ff_vsink_buffer", "ff_cook_parser", "ff_flac_demuxer", "ff_mb_pat_vlc", "x264_hpel_ref0", "av_md5_size", "__popcount_tab", "ff_ac3_frame_size_tab", "ff_mvtab", "yuv422ptouyvy", "ff_vc1_fps_nr", "ff_mpeg12_static_rl_table_store", "ff_vc1_dqscale", "ff_aac_kbd_long_1024_fixed", "avpriv_mjpeg_val_dc", "ff_alternate_horizontal_scan", "ff_pcm_s8_muxer", "ff_tns_max_bands_480", "ff_mpeg4_intra_run", "ff_vc1_intfr_non4mv_mbmode_codes", "ff_vsink_ffbuffersink", "ff_vf_vignette", "x264_level_token", "x264_cabac_entropy", "ff_vf_overlay", "ff_h263_hwaccel_pixfmt_list_420", "ff_aac_scalefactor_code", "ff_mpeg1_dc_scale_table", "ff_aac_latm_parser", "av_reverse", "ff_mpeg12_mbPatTable", "x264_cache_ref_func_table", "ff_af_dcshift", "ff_af_astreamsync", "ff_cos_16384", "ff_vc1_icbpcy_vlc", "ff_avsrc_amovie", "ff_image_tiff_pipe_demuxer", "x264_total_zeros", "ff_mp4_obj_type", "ff_id3v2_34_metadata_conv", "rgb15to16", "ff_vc1_ttblk_vlc", "ff_vsrc_allyuv", "ff_asf_ext_stream_embed_stream_header", "ff_vf_colorchannelmixer", "x264_coeff0_token", "ff_vf_lenscorrection", "ff_aac_eld_window_480_fixed", "ff_mpeg4_decoder", "ff_vf_noformat", "ff_vf_shuffleplanes", "ff_af_afade", "ff_h263_format", "qmf_64", "ff_h264_cabac_tables", "ff_dither_2x2_8", "ff_pcm_s24le_muxer", "ff_vf_haldclut", "SineWindow480", "rgb32to16", "ff_hevc_diag_scan8x8_y", "ff_aac_codebook_vector_vals", "ff_table1_dc_chroma", "ff_inverse", "p_FDKaacEnc_48000_short_128", "ff_mpeg1_aspect", "ff_mpeg4_c_dc_scale_table", "p_FDKaacEnc_32000_long_1024", "ff_vf_qp", "ff_vsrc_smptehdbars", "ff_ape_demuxer", "ff_text2movsub_bsf", "ff_pcm_s16le_encoder", "x264_cache_mvd_func_table", "ff_asf_audio_stream", "ff_vf_super2xsai", "ff_af_compand", "ff_asf_metadata_library_header", "RotVectorImag60", "ffurl_context_class", "ff_h263_cbpy_vlc", "ff_mov2textsub_bsf", "ff_h263_mbtype_b_tab", "ff_asf_demuxer", "FDKSEEK_END", "x264_cabac_contexts", "ff_mpegvideo_parser", "FDKaacEnc_quantTableE", "ff_image_pictor_pipe_demuxer", "ff_rm_demuxer", "ff_vf_waveform", "ff_acelp_interp_filter", "ff_cos_1024_fixed"], "importedglobals": ["__stack_chk_guard", "__sF"], "importedfunctions": ["deflate", "strcpy", "vfprintf", "erf", "log10f", "time", "pthread_cond_broadcast", "strspn", "read", "ftello", "mkstemp", "cosh", "strcat", "strtod", "sscanf", "lrintf", "memalign", "clock_gettime", "ldexp", "fputs", "raise", "sin", "memcpy", "__errno", "strcmp", "powf", "inflate", "pthread_mutex_destroy", "fabs", "expf", "strtok_r", "strstr", "memchr", "snprintf", "log", "fseeko", "strcspn", "fflush", "strdup", "cbrt", "rename", "sinh", "strtoll", "deflateEnd", "realloc", "memmem", "pthread_cond_init", "exp2", "strftime", "atan2f", "llrint", "access", "cos", "__isinff", "gettimeofday", "readdir", "pthread_cond_wait", "asin", "pthread_cond_destroy", "__assert2", "strtoul", "stat", "mmap", "mktime", "pow", "strncasecmp", "fprintf", "__stack_chk_fail", "fstat", "deflateInit2_", "atol", "fgets", "exp2f", "pthread_mutex_unlock", "deflateBound", "strcasecmp", "getenv", "munmap", "fcntl", "atan", "ftell", "uncompress", "vsprintf", "dlerror", "lseek64", "vprintf", "nanosleep", "malloc", "modf", "trunc", "strtok", "atoi", "pthread_cond_signal", "strncpy", "rmdir", "localtime_r", "clock", "logf", "fdopen", "gmtime_r", "cosf", "pthread_mutex_lock", "cbrtf", "closedir", "deflateReset", "isatty", "strlen", "floor", "free", "lrint", "frexp", "memcmp", "fopen", "memset", "strerror_r", "rewind", "fclose", "sprintf", "inflateEnd", "fwrite", "rint", "tan", "hypot", "ceil", "sysconf", "atan2", "isnanf", "memmove", "fputc", "llrintf", "dlsym", "round", "opendir", "exp", "vsnprintf", "strncmp", "strrchr", "floorf", "pthread_mutex_init", "strchr", "log10", "pthread_join", "sqrt", "acos", "atanf", "dlopen", "pthread_once", "strtol", "open", "__isfinite", "qsort", "ceilf", "write", "calloc", "fread", "getc", "truncf", "abort", "lstat", "inflateInit_", "nice", "unlink", "tanh", "strpbrk", "close", "bsearch", "__isinf", "sinf", "fseek", "dlclose", "pthread_create"], "exportedfunctions": ["ff_put_h264_chroma_mc8_neon", "rgb16tobgr15", "ff_avg_qpel8_mc13_old_c", "avfilter_transform", "ff_raw_audio_read_header", "ff_aac_ac3_parse", "ff_generate_avci_extradata", "avpriv_request_sample", "x264_sps_init", "ff_h264_decode_mb_cabac", "_Z21GetRam_Sbr_envRBufferiPh", "ff_parse_key_value", "_Z36GetRequiredMemRam_aacEnc_PsyInternalv", "_Z30FDKaacEnc_CheckBandEnergyOptimPKlPiPKiiPlS4_i", "ff_codec_get_tag", "ff_mdct_calc_neon", "x264_predict_8x8_v_c", "ff_hevc_put_qpel_uw_pixels_w48_neon_8", "avpriv_vorbis_parse_extradata", "av_small_strptime", "x264_quant_8x8_trellis", "x264_opencl_slicetype_prep", "__cmpsf2", "ff_framesync_filter_frame", "ff_hevc_ref_idx_lx_decode", "x264_malloc", "_Z36FreeRam_Sbr_prevEnvelopeCompensationPPh", "ff_dct_quantize_c", "av_write_image_line", "x264_expand_border_mbpair", "x264_predict_8x8_init", "ff_put_vc1_chroma_mc8_neon", "FDKfabs", "ff_pred8x8_top_dc_neon", "ff_lpc_init", "ff_mdct_calc_c", "ff_hevc_compute_poc", "ff_put_v", "_Z28FDKsbrEnc_initPsBandNrgScaleP11T_PS_ENCODE", "x264_opencl_flush", "av_get_string", "avio_rb16", "avpriv_lock_avformat", "avio_wb64", "ff_imdct36_blocks_fixed", "ff_draw_horiz_band", "av_opt_child_class_next", "ff_raw_data_read_header", "av_find_info_tag", "ff_intrax8dsp_init", "ff_read_packet", "ff_h264_luma_dc_dequant_idct_9_c", "av_fifo_drain", "ff_seek_frame_binary", "x264_macroblock_cache_allocate", "_Z31FDKaacEnc_CalculateFullTonalityPlPiS_PsiPKii", "av_codec_set_seek_preroll", "x264_sei_dec_ref_pic_marking_write", "x264_intra_sad_x3_8x8_neon", "ff_mpv_common_init_arm", "av_copy_packet", "ff_avfilter_graph_update_heap", "av_dup_packet", "av_hmac_init", "avpriv_do_elbg", "av_get_pix_fmt", "ff_put_h264_qpel8_mc10_neon", "ff_ps_ctx_init", "av_packet_rescale_ts", "av_xtea_alloc", "sws_alloc_context", "ff_aac_apply_tns", "ff_put_h264_chroma_mc2_neon", "ff_simple_idct_10", "av_frame_side_data_name", "av_pkt_dump_log2", "ff_h263_update_motion_val", "av_tempfile", "_Z21FDKaacEnc_AdjThrClosePP13ADJ_THR_STATE", "av_camellia_init", "ff_add_index_entry", "ff_simple_idct_armv6", "x264_intra_satd_x3_8x8c", "ff_h263_decode_end", "x264_threadslice_cond_broadcast", "ff_avg_h264_qpel16_mc02_neon", "ff_pix_sum_armv6", "av_bprint_finalize", "avcodec_decode_audio3", "ff_replaygain_export", "ff_merge_channel_layouts", "x264_mb_mc_8x8", "ff_af_queue_init", "ff_amr_set_fixed_gain", "ff_h264_pred_init", "ff_decode_10_pulses_35bits", "av_format_set_metadata_header_padding", "ff_h264_idct8_add4_9_c", "ff_decode_pitch_lag", "_Z42transportEnc_LatmCountTotalBitDemandHeaderP11LATM_STREAMj", "av_format_set_open_cb", "ff_sbr_hf_g_filt_neon", "ff_rate_control_init", "ffurl_write", "x264_encoder_close", "_Z23FDKaacEnc_AdjustBitrateP8QC_STATEP15CHANNEL_MAPPINGPiiii", "ff_print_debug_info", "ff_libwebp_get_frame", "avcodec_get_frame_defaults", "___Unwind_Resume_or_Rethrow", "ff_h264_decode_slice_header", "_Unwind_VRS_Get", "ff_mov_add_hinted_packet", "swr_convert_frame", "x264_frame_expand_border_chroma", "x264_frame_copy_picture", "ff_simple_idct_add_12", "_Z21FDKaacEnc_GetPnsParamP11NOISEPARAMSiiiPKiPiii", "_Z22FDKaacEnc_reduceMinSnrP15CHANNEL_MAPPINGPP14QC_OUT_ELEMENTPP15PSY_OUT_ELEMENTPA2_A60_hiPiii", "avfilter_graph_get_filter", "av_rdft_calc", "_Unwind_GetLanguageSpecificData", "ff_thread_await_progress", "avpriv_mpegts_parse_open", "av_new_program", "ff_hevc_merge_idx_decode", "ff_psy_preprocess_end", "avfilter_register", "ff_fill_rectangle", "av_frame_move_ref", "_Z8sqrtFixpl", "_Z25qmfSynthesisFilteringSlotP15QMF_FILTER_BANKPKlS2_iiPsiPl", "__addsf3", "x264_macroblock_encode_p4x4", "avformat_close_input", "aacEncOpen", "av_opt_set_dict_val", "ff_put_qpel8_mc12_old_c", "ff_h264_fill_mbaff_ref_list", "x264_predict_8x8c_p_c", "FDKfeof", "av_basename", "_Z27FDKaacEnc_GetMonoStereoMode12CHANNEL_MODE", "ff_codec_open2_recursive", "_Z24qmfAnalysisFilteringSlotP15QMF_FILTER_BANKPlS1_PKsiS1_", "ff_init_ff_cos_tabs_fixed", "av_convert_lang_to", "av_color_range_name", "ff_put_qpel8_mc32_old_c", "avio_size", "av_codec_set_pkt_timebase", "FDKrewind", "ff_j_rev_dct1", "ff_amrwb_lsp2lpc", "sbrEncoder_GetInBufferSize", "_Z35FDKaacEnc_IntensityStereoProcessingPlS_S_S_S_S_S_S_S_S_S_PiS0_iiiPKiiS0_S0_PP8PNS_DATA", "ff_mjpeg_encode_close", "ff_avg_pixels16x16_c", "av_abuffersink_params_alloc", "ff_hevc_transform_add_4x4_neon_8", "avcodec_is_open", "av_find_input_format", "ff_tlog_link", "ff_metadata_conv_ctx", "av_timegm", "av_opt_get_q", "ff_simple_idct_put_10", "___Unwind_Resume", "ff_avg_h264_qpel16_mc12_neon", "avfilter_get_video_buffer_ref_from_frame", "ff_acelp_filter_init", "x264_macroblock_encode", "_Z19FreeRam_ParamStereoPP19T_PARAMETRIC_STEREO", "ff_hevc_put_qpel_uw_h3v3_neon_8", "av_cpu_count", "ff_videodsp_init", "ff_flac_parse_picture", "av_pix_fmt_desc_get", "ff_hevc_hls_filter", "__ltsf2", "ff_avg_h264_qpel8_mc30_neon", "ff_avg_h264_qpel8_mc13_neon", "av_hash_init", "x264_cabac_encode_ue_bypass", "x264_encoder_open_148", "av_codec_get_pkt_timebase", "_Z23adifWrite_GetHeaderBitsP9ADIF_INFO", "ff_fetch_timestamp", "av_packet_new_side_data", "_Z16FDKaacEnc_PsyNewPP12PSY_INTERNALiiPh", "ff_pix_norm1_armv6", "av_buffersink_get_buffer_ref", "x264_encoder_maximum_delayed_frames", "x264_threads_merge_ratecontrol", "ff_get_pcm_codec_id", "av_copy_packet_side_data", "_Z28FreeRam_PsQmfStatesSynthesisPPl", "avio_rl64", "avfilter_link_get_channels", "_Z7fPowIntliiPi", "FDKafree", "x264_intra_sa8d_x3_8x8", "av_fft_calc", "av_frame_set_best_effort_timestamp", "x264_quant_4x4_trellis", "ff_put_vc1_mspel_mc02_neon", "_Z46GetRequiredMemRam_Sbr_prevEnvelopeCompensationv", "__fixdfdi", "avfilter_get_class", "ff_avg_pixels16_x2_neon", "x264_frame_expand_border", "av_stream_get_side_data", "av_opt_serialize", "x264_intra_satd_x3_16x16_neon", "ff_vector_fmul_vfp", "ff_id3v2_write_metadata", "_Z29GetRam_aacEnc_MergeGainLookUpiPh", "ff_sbr_hf_apply_noise_1_neon", "av_parse_video_rate", "rgb64tobgr48_bswap", "avio_rl24", "_Z15GetRam_PsEncodei", "swresample_configuration", "ff_draw_color", "ff_sbr_qmf_post_shuffle_neon", "x264_analyse_init_costs", "ff_hevc_idct_4x4_dc_neon_8", "avcodec_find_encoder_by_name", "x264_pixel_ssim_wxh", "av_format_set_opaque", "ff_put_h264_qpel8_mc32_neon", "ff_put_pixels16_armv6", "x264_lookahead_put_frame", "ff_all_channel_counts", "ff_set_common_samplerates", "ff_h264dsp_init_arm", "avpriv_scalarproduct_float_c", "_Z24FDK_MetadataEnc_GetDelayP20FDK_METADATA_ENCODER", "ff_get_channel_layout", "x264_macroblock_thread_free", "ff_hevc_put_qpel_uni_neon_wrapper", "ff_tdecode_header", "av_blowfish_crypt_ecb", "_Z15mul_dbl_sgl_rndls", "avio_read", "ff_put_pixels8x8_c", "ff_rfps_calculate", "FDKstrcpy", "av_codec_get_lowres", "ff_hevc_idct_16x16_dc_neon_8", "ff_put_pixels8_x2_no_rnd_armv6", "av_codec_is_encoder", "_Z26GetRam_Sbr_guideVectorOrigi", "_Z22adifWrite_EncodeHeaderP9ADIF_INFOP13FDK_BITSTREAMi", "_Z31FDKaacEnc_CalculateChaosMeasurePliS_", "av_set_options_string", "_Z24FDKaacEnc_DistributeBitsP13ADJ_THR_STATEP11ATS_ELEMENTPP15PSY_OUT_CHANNELP7PE_DATAPiS8_iiiiili", "avcodec_encode_audio", "x264_predict_lossless_16x16", "__fixdfsi", "ff_mpeg_er_init", "avcodec_descriptor_next", "_Z21FDKaacEnc_countValuesPsii", "sws_getGaussianVec", "ff_mpeg4_workaround_bugs", "ff_prefetch_arm", "_Z23FDK_MetadataEnc_ProcessP20FDK_METADATA_ENCODERPsiPK15AACENC_MetaDataPP18AACENC_EXT_PAYLOADPjPi", "ff_fft_init_arm", "av_bprint_init_for_buffer", "av_twofish_alloc", "av_resample", "swr_get_out_samples", "av_file_map", "av_set_int", "ff_stream_new_side_data", "ff_put_pixels8_y2_neon", "av_div_q", "ff_init_desc_chscale", "ff_h263_pred_dc", "x264_frame_pop_unused", "x264_cabac_block_residual_rd_c", "__gnu_Unwind_Restore_WMMXC", "__gnu_Unwind_Resume", "ff_mov_init_hinting", "av_vlog", "ff_framesync_drop", "_Z37GetRequiredMemRam_Sbr_freqBandTableHIv", "av_codec_get_codec_descriptor", "ff_put_h264_qpel16_mc30_neon", "x264_cavlc_init", "ff_dualinput_request_frame", "x264_frame_expand_border_filtered", "FDKfread_EL", "ff_tadd_doubles_metadata", "ff_dct_init", "ff_mpeg_flush", "avpriv_report_missing_feature", "avfilter_process_command", "ff_float_dsp_init_arm", "ff_convert_matrix", "FDKaacEnc_LimitBitrate", "av_log_missing_feature", "av_vorbis_parse_init", "av_opt_flag_is_set", "av_format_get_open_cb", "x264_macroblock_probe_skip", "ff_idctdsp_init_armv5te", "ff_put_pixels16_y2_armv6", "__nedf2", "x264_param_apply_fastfirstpass", "x264_predict_8x8c_dc_c", "av_buffer_make_writable", "av_timecode_make_mpeg_tc_string", "av_hex_dump", "ff_get_v_length", "avfilter_pad_get_name", "ff_h264_idct_dc_add_neon", "av_frame_get_buffer", "ff_mpadsp_apply_window_float", "_Z32FDKaacEnc_FreqToBandWithRoundingiiiPKi", "ff_init_ff_cos_tabs_fixed_32", "_Z9fMultNormllPi", "ff_hevc_put_qpel_v1_neon_8", "_Z36FDKsbrEnc_resetSbrNoiseFloorEstimateP24SBR_NOISE_FLOOR_ESTIMATEPKhi", "x264_opencl_close_library", "__subdf3", "ff_acelp_decode_4bit_to_2nd_delay3", "ff_hevc_put_qpel_uw_h1_neon_8", "ff_set_dimensions", "ff_put_no_rnd_qpel8_mc32_old_c", "rgb15tobgr32", "FDKfread", "ff_put_vc1_mspel_mc23_neon", "av_mul_q", "_Z17FDKgetWindowSlopeii", "ff_simple_idct_12", "x264_slicetype_decide", "FDKabs", "ff_emulated_edge_mc_16", "ff_add_pixels_clamped_neon", "_Unwind_DeleteException", "ff_hevc_put_qpel_uw_h3v2_neon_8", "_Z30FDKaacEnc_EstimateScaleFactorsPP15PSY_OUT_CHANNELPP14QC_OUT_CHANNELii", "ff_mp4_read_descr_len", "ff_put_no_rnd_pixels8_x2_arm", "ff_acelp_fc_pulse_per_track", "_Z22FDKhybridAnalysisApplyP18FDK_ANA_HYB_FILTERPKlS2_PlS3_", "_Z21adtsWrite_CrcStartRegP11STRUCT_ADTSP13FDK_BITSTREAMi", "ff_acelp_lsf2lsp", "_Z22FDKhybridSynthesisInitP18FDK_SYN_HYB_FILTER15FDK_HYBRID_MODEii", "av_malloc", "FDKmalloc", "ff_thread_init", "ffio_open_dyn_packet_buf", "ff_filter_graph_remove_filter", "avfilter_license", "av_pixelutils_get_sad_fn", "av_adler32_update", "_Z23FreeRam_Sbr_quotaMatrixPPl", "avio_feof", "_Z20FDK_MetadataEnc_InitP20FDK_METADATA_ENCODERiiijjj12CHANNEL_MODE13CHANNEL_ORDER", "ff_acelp_lsp2lpc", "av_des_crypt", "av_realloc", "ff_sws_init_range_convert", "av_codec_get_tag", "ff_h264_idct8_add_9_c", "ff_hevc_mpm_idx_decode", "av_rescale_delta", "av_sha_update", "av_pkt_dump2", "ff_af_queue_close", "ff_hpeldsp_init_arm", "ff_imdct_calc_c_fixed_32", "_Z17transportEnc_InitP12TRANSPORTENCPhi14TRANSPORT_TYPEP12CODER_CONFIGj", "ff_vector_fmul_scalar_neon", "sbrEncoder_Open", "ff_epzs_motion_search", "av_frame_set_sample_rate", "av_opt_get_dict_val", "av_cast5_crypt", "av_get_channel_layout", "_Z24FDKaacEnc_updateFillBitsP15CHANNEL_MAPPINGP8QC_STATEPP12ELEMENT_BITSPP6QC_OUT", "ff_hevc_v_loop_filter_luma_neon", "ff_mdct_init", "avio_skip", "ff_af_queue_remove", "ff_h264_chroma422_dc_dequant_idct_10_c", "ff_rl_free", "av_format_get_probe_score", "_Z28GetRam_aacEnc_PsyOutElementsi", "av_opt_eval_int", "___Unwind_ForcedUnwind", "av_bprint_strftime", "av_audio_convert_free", "FDKmemcpy", "ff_init_ff_cos_tabs", "ff_hevc_put_pixels_w6_neon_8", "ff_h263_find_frame_end", "ff_frame_thread_encoder_free", "aacEncoder_GetParam", "FDKstrncmp", "av_read_play", "ff_h264_idct_add_9_c", "ff_truehd_layout", "av_sha512_init", "FDK_get", "av_fft_end", "_Z40FDKsbrEnc_SbrMissingHarmonicsDetectorQmfP30SBR_MISSING_HARMONICS_DETECTORPPlPPiPaPK14SBR_FRAME_INFOPKhS3_PhSA_iSB_S1_", "ff_slice_thread_free", "__gnu_Unwind_Backtrace", "_Z23GetRam_TransportEncoderi", "av_thread_message_queue_set_err_recv", "av_dct_calc", "_Unwind_GetCFA", "avio_seek_time", "av_codec_get_max_lowres", "_Z24FDKaacEnc_groupShortDataPlP13SFB_THRESHOLDP10SFB_ENERGYS3_S3_iiPKiPKlPiS8_S_iS5_i", "ff_idet_filter_line_c_16bit", "avpicture_deinterlace", "avcodec_flush_buffers", "ff_h264_idct8_dc_add_10_c", "swscale_version", "ff_mpeg4_pred_ac", "ff_h264_idct_add8_8_c", "avpriv_vorbis_parse_frame_flags", "_Z18FDKsbrEnc_PSEncodeP11T_PS_ENCODEP8T_PS_OUTPhjPA2_A2_Plii", "__subsf3", "av_mdct_calc", "ff_h264_check_intra4x4_pred_mode", "x264_sync_frame_list_push", "ff_ape_parse_tag", "ff_celp_convolve_circ", "_Z38GetRequiredMemRam_Sbr_detectionVectorsv", "av_isgraph", "ff_check_interrupt", "av_buffersrc_add_frame", "av_get_profile_name", "ff_side_data_set_encoder_stats", "_Z29GetRequiredMemRam_ParamStereov", "ff_make_absolute_url", "av_demuxer_open", "x264_rd_cost_part", "av_twofish_init", "ff_h264_free_tables", "ff_h264chroma_init_arm", "ff_pred16x16_vert_neon", "sws_getDefaultFilter", "av_memcpy_backptr", "av_parse_video_size", "_Z26FDKsbrEnc_TonCorrParamExtrP16SBR_TON_CORR_ESTP9INVF_MODEPlPiPhS5_PK14SBR_FRAME_INFOS5_S5_i9XPOS_MODEj", "ff_hevc_slice_rpl", "ff_side_data_update_matrix_encoding", "WebPPictureSmartARGBToYUVA", "av_buffer_realloc", "av_opt_get_pixel_fmt", "ff_h263_decode_mba", "av_get_frame_filename", "av_append_path_component", "ff_h264chroma_init", "x264_opencl_lookahead_init", "_Z30FDKsbrEnc_FindStartAndStopBandiiiiiPiS_", "avfilter_graph_free", "_Z31FDKsbrEnc_ResetTonCorrParamExtrP16SBR_TON_CORR_ESTiiPhiiPS1_Pii", "FDK_Fetch", "ff_scale_image", "av_buffersink_read_samples", "ff_dct_unquantize_h263_intra_neon", "rgb64tobgr48_nobswap", "ff_mpeg1_find_frame_end", "avio_printf", "ff_init_scantable", "ff_put_no_rnd_qpel8_mc13_old_c", "av_hash_freep", "av_frame_set_color_range", "x264_frame_expand_border_mod16", "ff_pnm_decode_header", "av_probe_input_format3", "av_opt_next", "sws_init_context", "ff_gen_search", "x264_frame_pop_blank_unused", "x264_macroblock_thread_init", "avfilter_init_filter", "ff_aac_search_for_is", "_Z16FDKaacEnc_QCInitP8QC_STATEP7QC_INIT", "av_codec_get_id", "FDK_putBwd", "ff_put_h264_qpel16_mc11_neon", "_Z28FDKaacEnc_AdaptThresholdsVBRPP14QC_OUT_CHANNELPP15PSY_OUT_CHANNELP11ATS_ELEMENTP9TOOLSINFOP7PE_DATAi", "ff_h264_decode_ref_pic_list_reordering", "ff_vc1_inv_trans_8x8_neon", "av_nearer_q", "ff_rdft_init_arm", "ffurl_protocol_next", "ff_interleave_add_packet", "ff_channel_layouts_ref", "ff_hevc_put_qpel_uw_pixels_w32_neon_8", "av_fifo_free", "ff_hevc_put_qpel_h1v2_neon_8", "ff_h263_resync", "_Z23GetRam_aacEnc_BitLookUpiPh", "ff_h264_idct_add16intra_neon", "av_display_rotation_set", "_Z16autoCorr2nd_cplxP11ACORR_COEFSPKlS2_i", "ff_tadd_bytes_metadata", "ff_vc1_pred_b_mv_intfi", "ff_slice_thread_init", "x264_field_vsad", "ff_avg_qpel8_mc33_old_c", "_Z16FDKaacEnc_QCMainP8QC_STATEPP7PSY_OUTPP6QC_OUTiP15CHANNEL_MAPPING17AUDIO_OBJECT_TYPEja", "av_blowfish_alloc", "ff_sbr_sum64x5_neon", "__gesf2", "ff_mpv_frame_start", "x264_mb_predict_mv_ref16x16", "av_probe_input_buffer", "WebPEncodeLosslessBGRA", "ff_crc04C11DB7_update", "x264_mc_init_arm", "avpriv_set_systematic_pal2", "av_memdup", "ff_pred16x16_hor_neon", "ff_init_mpadsp_tabs_fixed", "ff_dct_unquantize_h263_armv5te", "_Z24GetRam_aacEnc_AacEncoderi", "avpriv_flac_parse_streaminfo", "ff_hcscale_fast_c", "ff_psy_preprocess", "avpriv_vorbis_parse_reset", "WebPPictureImportBGR", "ff_avfilter_default_free_buffer", "av_buffer_ref", "av_fast_realloc", "FDKfseek", "__udivsi3", "_Z22FDK_DRC_Generator_OpenPP8DRC_COMP", "av_opt_set_dict", "_Z24FDKaacEnc_BlockSwitchingP23BLOCK_SWITCHING_CONTROLiiPKs", "av_crc", "ff_iir_filter_flt", "avpriv_ac3_parse_header", "ff_rtp_enc_name", "ff_pred_weight_table", "ff_weighted_vector_sumf", "ff_hevc_put_qpel_uw_pixels_w64_neon_8", "avpriv_find_start_code", "x264_picture_clean", "FDKatan2", "avfilter_add_matrix", "ffio_open2_wrapper", "ff_sdp_write_media", "ff_h264_decode_sei", "x264_frame_pop", "avfilter_configuration", "ff_ps_hybrid_synthesis_deint_neon", "swri_rematrix_free", "av_dict_set_int", "ff_jpeg_fdct_islow_8", "FDKfprintf", "_Z22FreeRam_SbrDynamic_RAMPPl", "av_d2q", "ff_simple_idct84_add", "_Z27FDKsbrEnc_getSbrStopFreqRAWii", "ff_sws_init_input_funcs", "ff_avg_h264_qpel8_mc22_neon", "ff_update_duplicate_context", "avformat_match_stream_specifier", "ff_avc_parse_nal_units_buf", "ff_tget_double", "avfilter_get_video_buffer_ref_from_arrays", "ff_put_h264_qpel16_mc20_neon", "av_interleaved_write_frame", "avfilter_init_dict", "ff_aac_sbr_ctx_init", "av_opt_free", "av_opt_find2", "av_init_packet", "ff_rm_parse_packet", "_Z30FDKaacEnc_codeScalefactorDeltaiP13FDK_BITSTREAM", "ff_h264_idct8_add_8_c", "avfilter_register_all", "WebPPictureImportRGBX", "avfilter_init_str", "av_mallocz", "ff_h264_luma_dc_dequant_idct_14_c", "ff_put_qpel8_mc11_old_c", "ff_h264_idct_add_10_c", "av_filename_number_test", "av_register_output_format", "avio_rb64", "__gnu_Unwind_Restore_VFP_D", "ff_emulated_edge_mc_8", "x264_analyse_free_costs", "av_packet_split_side_data", "ff_avg_pixels8_xy2_neon", "av_rc4_crypt", "swri_oldapi_conv_fltp_to_s16_2ch_neon", "FDKceil", "_Z8fixp_sinli", "avio_alloc_context", "_Z31GetRequiredMemRam_aacEnc_PsyOutv", "ff_h264_v_loop_filter_chroma_neon", "sws_addVec", "WebPPictureFree", "ff_avg_pixels8_y2_neon", "av_get_audio_frame_duration", "x264_me_search_ref", "av_write_frame", "ff_vc1_mc_4mv_chroma4", "ff_put_vc1_mspel_mc13_neon", "ff_tis_ifd", "ff_simple_idct_add_neon", "av_match_list", "_Z28GetRequiredMemRam_SbrElementv", "av_strtod", "av_des_alloc", "av_vorbis_parse_reset", "ff_h264_chroma_dc_dequant_idct_10_c", "x264_ratecontrol_set_weights", "av_rdft_init", "av_hash_final_hex", "ff_acelp_decode_gain_code", "restore_core_regs", "av_add_q", "x264_log", "ff_avg_h264_qpel16_mc13_neon", "ff_get_cpu_flags_arm", "ff_hevc_hls_mvd_coding", "WebPPictureImportBGRA", "avpriv_color_frame", "ff_init_cabac_states", "sws_allocVec", "_Z6fLdPowliliPi", "ff_load_image", "av_buffersrc_write_frame", "ff_put_pixels8_xy2_arm", "ff_adx_decode_header", "ff_sbr_qmf_pre_shuffle_neon", "FDKsprintf", "av_gettime_relative", "x264_sei_avcintra_umid_write", "_Z12invSqrtNorm2lPi", "av_tree_node_alloc", "_Z12FDKcrcGetCRCP11FDK_CRCINFO", "FDKprintDisclaimer", "_Z26FreeRam_aacEnc_ElementBitsPP12ELEMENT_BITS", "rgb24to32", "ff_avg_pixels16_y2_neon", "avfilter_ref_buffer", "ff_rate_control_uninit", "ff_thread_get_format", "_Z20qmfAnalysisFilteringP15QMF_FILTER_BANKPPlS2_P16QMF_SCALE_FACTORPKsiS1_", "ff_thread_get_buffer", "FDK_pushBack", "av_get_channel_description", "ff_af_queue_add", "avpriv_set_pts_info", "av_audio_fifo_reset", "ff_h264_get_slice_type", "av_get_q", "av_parser_next", "ff_mp4_parse_es_descr", "ff_hevc_put_qpel_uw_pixels_w16_neon_8", "av_parse_time", "x264_threadpool_run", "_Z23qmfSynPrototypeFirSlot2P15QMF_FILTER_BANKPlS1_Psi", "av_write_uncoded_frame_query", "av_format_get_video_codec", "ff_insert_pad", "ff_vc1_pred_b_mv", "x264_param_default_preset", "ff_tak_decode_frame_header", "_Z38GetRequiredMemRam_PsQmfStatesSynthesisv", "ff_hevc_put_qpel_uw_h2v3_neon_8", "av_parser_change", "avpriv_bprint_to_extradata", "ff_id3v1_read", "ffurl_size", "av_add_stable", "FDKaacEnc_Initialize", "avformat_alloc_context", "_Z19FDKaacEnc_TnsDetectP8TNS_DATAPK10TNS_CONFIGP8TNS_INFOiPlii", "_Z23FDK_DRC_Generator_ClosePP8DRC_COMP", "x264_predict_lossless_chroma", "ff_mpadsp_init", "ff_put_pixels8_y2_no_rnd_armv6", "ff_vc1_inv_trans_4x4_dc_neon", "ffio_rewind_with_probe_data", "ff_mpeg_ref_picture", "x264_predict_8x16c_init_arm", "_Z36FDKsbrEnc_CountSbrChannelPairElementP15SBR_HEADER_DATAP19T_PARAMETRIC_STEREOP18SBR_BITSTREAM_DATAP12SBR_ENV_DATAS6_P11COMMON_DATAj", "ff_mlp_checksum16", "x264_opencl_load_library", "avfilter_inout_free", "ff_avg_h264_qpel8_mc31_neon", "av_md5_final", "ff_hevc_put_qpel_h3v1_neon_8", "x264_threadslice_cond_wait", "av_buffersrc_buffer", "av_oformat_next", "ff_hevc_idct_8x8_dc_neon_8", "swr_close", "ff_put_no_rnd_pixels8_xy2_arm", "FDKfgets", "sws_normalizeVec", "ffurl_connect", "avio_enum_protocols", "_Z21FreeRam_Sbr_guideScfbPPh", "av_fmt_ctx_get_duration_estimation_method", "ff_hevc_decode_nal_sei", "ff_init_ff_sine_windows_fixed", "ff_hevc_transform_4x4_neon_8", "ff_hevc_unref_frame", "ff_h264_sei_stereo_mode", "ff_flac_decode_frame_header", "x264_frame_cond_wait", "ff_aac_sbr_ctx_close", "swri_oldapi_conv_fltp_to_s16_nch_neon", "ff_vector_fmul_reverse_vfp", "avfilter_graph_send_command", "_Z27FreeRam_aacEnc_BitCntrStatePP13BITCNTR_STATE", "ff_check_pixfmt_descriptors", "avfilter_get_by_name", "ff_get_buffer", "rgb12to15", "sws_getCoefficients", "ff_intrax8_decode_picture", "ff_psy_init", "ff_draw_supported_pixel_formats", "_Z28GetRam_Sbr_QmfStatesAnalysisi", "_Z26transportEnc_EndAccessUnitP12TRANSPORTENCPi", "ff_init_cabac_encoder", "x264_macroblock_thread_allocate", "_Z24FDKsbrEnc_EnvEncodeFrameP11SBR_ENCODERiPsjPjPhi", "ff_graph_thread_init", "ff_get_pixels_armv6", "av_strtok", "x264_picture_init", "av_hex_dump_log", "av_timecode_make_smpte_tc_string", "rgb64to48_bswap", "x264_cqm_delete", "ff_hevc_cabac_init", "ff_j_rev_dct2", "ff_h264_free_context", "x264_frame_filter", "x264_macroblock_cache_save", "sbrEncoder_GetEstimateBitrate", "av_buffer_get_ref_count", "av_probe_input_format", "ff_avg_h264_qpel16_mc33_neon", "ff_imdct_half_neon", "FDKsbrEnc_WritePSBitstream", "ff_default_get_video_buffer", "ff_shrink44", "_Z22FreeRam_Sbr_v_k_masterPPh", "av_opt_get_double", "av_find_best_stream", "ff_h264_luma_dc_dequant_idct_8_c", "ff_acelp_decode_9bit_to_1st_delay6", "ff_dct_encode_init", "avcodec_copy_context", "ff_mdct_fixed_calcw_neon", "ff_vc1_mc_4mv_chroma", "ff_ape_write_tag", "ff_draw_rectangle", "ff_add_pixels_clamped_arm", "x264_picture_alloc", "av_audio_fifo_peek", "ff_pred8x8_left_dc_neon", "av_get_pix_fmt_name", "ff_mpeg4_frame_end", "ff_parse_close", "ff_hevc_pred_mode_decode", "_Z26GetRam_Sbr_freqBandTableHIi", "ff_hevc_part_mode_decode", "avformat_free_context", "ff_h264_init_dequant_tables", "ff_hevc_cu_qp_delta_abs", "av_opt_is_set_to_default", "ff_mjpeg_decode_sof", "ff_hevc_decode_nal_sps", "_Z28FDKaacEnc_InitBlockSwitchingP23BLOCK_SWITCHING_CONTROLi", "_Unwind_GetTextRelBase", "ffio_init_checksum", "avfilter_link_free", "avpicture_free", "av_opt_eval_int64", "ff_avg_pixels16_y2_no_rnd_neon", "ff_combine_frame", "_Z21FreeRam_aacEnc_PsyOutPP7PSY_OUT", "_Z21FDK_MetadataEnc_ClosePP20FDK_METADATA_ENCODER", "ff_j_rev_dct", "ff_id3v2_start", "ff_er_frame_end", "ffio_fdopen", "ff_psdsp_init", "x264_intra_satd_x3_8x16c_neon", "ff_copy_whitelists", "__lshrdi3", "ff_h264_set_erpic", "_Z19FDKaacEnc_PsyOutNewPP7PSY_OUTiiiPh", "av_buffersrc_get_nb_failed_requests", "av_free", "FDKstrncpy", "FDKacos", "sws_scale", "ff_simple_idct_put_armv5te", "ff_rotate_slice", "FDK_getValidBits", "av_strstart", "ff_h264_idct_add8_9_c", "av_stristr", "ff_vector_fmul_add_neon", "_Z22transportEnc_LatmWriteP11LATM_STREAMP13FDK_BITSTREAMiiP13CSTpCallBacks", "av_md5_init", "x264_intra_sad_x3_4x4_neon", "ff_h264_idct_add8_neon", "ff_h264_direct_ref_list_init", "x264_plane_copy_swap_c", "_Z32GetRequiredMemRam_Sbr_v_k_masterv", "av_timecode_init", "ff_sse16_armv6", "ff_check_alignment", "_Z22GetRam_Sbr_quotaMatrixi", "avio_wl32", "_Z8fDivNormll", "ff_put_vc1_mspel_mc11_neon", "ff_vc1_inv_trans_4x8_neon", "ff_h264_slice_context_init", "ff_h264_idct_dc_add_8_c", "av_md5_update", "__gnu_Unwind_Save_VFP_D", "av_d2str", "av_dct_init", "ff_hevc_v_loop_filter_chroma_neon", "ff_framesync_init", "ff_reset_entries", "av_bmg_get", "ff_hevc_put_qpel_uw_h2_neon_8", "av_asprintf", "_Z10CalcLdDatal", "av_buffer_alloc", "av_chroma_location_name", "av_format_set_subtitle_codec", "ff_avc_mp4_find_startcode", "ff_hevc_get_ref_list", "avpriv_mpeg4audio_get_config", "_Z28FDKaacEnc_DetermineBandWidthPiii19AACENC_BITRATE_MODEiiP15CHANNEL_MAPPING12CHANNEL_MODE", "av_picture_crop", "ff_shrink22", "ff_tlog_ref", "sws_isSupportedInput", "ff_mdct_end", "rgb15tobgr16", "av_stream_set_recommended_encoder_configuration", "ff_put_h264_qpel16_mc31_neon", "x264_frame_unshift", "av_frame_make_writable", "av_fast_padded_mallocz", "av_audio_fifo_size", "FDKaacEnc_AacInitDefaultConfig", "avpriv_align_put_bits", "ff_hevc_put_pixels_w24_neon_8", "x264_me_refine_bidir_rd", "ff_opus_parse_packet", "ff_h264_draw_horiz_band", "ff_h264_decode_extradata", "av_cast5_alloc", "__gnu_uldivmod_helper", "x264_intra_satd_x3_16x16", "av_expr_eval", "ff_pred8x8_l00_dc_neon", "avio_wl24", "sws_convertPalette8ToPacked24", "av_imdct_half", "ff_init_me", "x264_macroblock_slice_init", "avcodec_default_get_buffer2", "ff_graph_thread_free", "avcodec_alloc_frame", "_Z25FDKsbrEnc_transientDetectP22SBR_TRANSIENT_DETECTORPPlPiPhiiii", "ff_vc1_decode_blocks", "av_get_codec_tag_string", "av_guess_codec", "ff_init_slice_from_src", "_Z26GetRam_Sbr_guideVectorDiffi", "avformat_get_riff_video_tags", "ff_jpeg_fdct_islow_10", "avfilter_inout_alloc", "__gnu_Unwind_Restore_VFP_D_16_to_31", "ff_avg_pixels16_neon", "ff_mpv_reallocate_putbitbuffer", "_Z37FDKsbrEnc_qmfInverseFilteringDetectorP16SBR_INV_FILT_ESTPPlS1_PaiiiP9INVF_MODE", "ff_h264_idct_add_12_c", "ff_mjpeg_decode_frame", "av_get_sample_fmt_string", "av_file_unmap", "ff_framesync_request_frame", "_Z37GetRequiredMemRam_Sbr_freqBandTableLOv", "ff_put_no_rnd_pixels8_y2_arm", "_Z34FDKsbrEnc_sbrNoiseFloorEstimateQmfP24SBR_NOISE_FLOOR_ESTIMATEPK14SBR_FRAME_INFOPlPS4_PaiiiiP9INVF_MODEj", "ff_mpeg_unref_picture", "swscale_configuration", "swr_config_frame", "FDKfwrite_EL", "av_murmur3_alloc", "av_pix_fmt_desc_get_id", "ff_h264_remove_all_refs", "ff_avg_h264_chroma_mc4_neon", "rgb15to24", "ff_add_param_change", "av_get_token", "av_get_standard_channel_layout", "av_buffer_create", "ff_h264_idct_add16intra_8_c", "avfilter_copy_buffer_ref_props", "_Z20FDKaacEnc_AdjThrInitP13ADJ_THR_STATEiPP12ELEMENT_BITSiiiiil", "WebPPictureImportRGBA", "ff_frame_thread_init", "ff_biweight_h264_pixels_4_neon", "av_expr_parse", "_Z19GetRam_aacEnc_QCouti", "_Z22FDK_DRC_Generator_CalcP8DRC_COMPPKsiiillPiS3_", "_Z23FDKhybridSynthesisApplyP18FDK_SYN_HYB_FILTERPKlS2_PlS3_", "av_frame_is_writable", "av_packet_free_side_data", "FDKprintf", "av_opt_set_from_string", "av_log", "_Z23FDKaacEnc_peCalculationP7PE_DATAPP15PSY_OUT_CHANNELPP14QC_OUT_CHANNELP9TOOLSINFOP11ATS_ELEMENTi", "ff_avg_pixels8_neon", "ffio_free_dyn_buf", "ff_put_pixels16_x2_neon", "ff_codec_guid_get_id", "av_opt_set_pixel_fmt", "WebPEncodeBGRA", "ff_crcA001_update", "ff_formats_unref", "ff_lzw_decode_open", "x264_macroblock_write_cabac", "ff_avg_h264_qpel16_mc21_neon", "ff_hevc_h_loop_filter_luma_neon", "av_image_copy_to_buffer", "ff_mpv_decode_init", "_Z14Get_AacEncoderi", "av_frame_set_pkt_pos", "ff_faandct", "av_strlcatf", "ff_h264_ref_picture", "av_opt_get_image_size", "_Z27GetRam_Sbr_detectionVectorsi", "x264_threadpool_init", "_Z30FDKsbrEnc_resetInvFiltDetectorP16SBR_INV_FILT_ESTPii", "ff_mpeg4_set_direct_mv", "sws_cloneVec", "av_hmac_final", "ff_filter_frame", "swri_rematrix", "ff_mpeg_draw_horiz_band", "ff_raw_video_read_header", "x264_ratecontrol_slice_type", "_Z17transportEnc_OpenPP12TRANSPORTENC", "_Z19FDKaacEnc_calcSfbPeP15PE_CHANNEL_DATAPKlS2_iiiPKiS4_", "x264_cabac_encode_terminal_c", "x264_cpu_num_processors", "ff_start_tag", "ff_mjpeg_encode_picture_header", "ff_float_dsp_init_vfp", "_Z28GetRam_aacEnc_PsyInputBufferi", "av_realloc_array", "x264_frame_push_unused", "av_bprint_get_buffer", "ff_put_no_rnd_qpel16_mc33_old_c", "ff_mpeg_update_thread_context", "ffio_ensure_seekback", "ff_rm_alloc_rmstream", "avformat_find_stream_info", "ff_mdct_calcw_c", "ff_lzw_encode_init", "av_qsv_alloc_context", "swresample_version", "av_image_fill_pointers", "ff_put_no_rnd_qpel16_mc31_old_c", "ff_simple_idct48_add", "sws_get_class", "ff_acelp_interpolate", "ff_vc1_inv_trans_4x8_dc_neon", "av_buffersrc_add_ref", "ff_intel_h263_decode_picture_header", "x264_sei_buffering_period_write", "_Z16FreeRam_PsEncodePP11T_PS_ENCODE", "av_packet_unpack_dictionary", "ffio_read_varlen", "ff_simple_idct_put_armv6", "ff_get_audio_buffer", "avcodec_configuration", "ff_tget", "_Z29FreeRam_Sbr_QmfStatesAnalysisPPs", "av_packet_unref", "av_frame_unref", "avio_accept", "avfilter_graph_queue_command", "av_opt_query_ranges", "android_getCpuCount", "ff_jref_idct_put", "av_buffer_unref", "ff_pixblockdsp_init_arm", "av_samples_fill_arrays", "x264_sei_frame_packing_write", "x264_me_refine_qpel_refdupe", "av_sha_final", "av_ripemd_update", "ff_adaptive_gain_control", "ff_mpeg4_get_video_packet_prefix_length", "ff_msmpeg4_decode_picture_header", "FDKaalloc", "_Z32FDKsbrEnc_initFrameInfoGeneratorP18SBR_ENVELOPE_FRAMEiiiiii", "av_ripemd_alloc", "ff_h264_decode_nal", "ff_pix_abs16_armv6", "ff_msmpeg4_common_init", "ff_mpv_encode_picture", "ff_avg_pixels16_x2_no_rnd_neon", "av_guess_frame_rate", "FDKatoi", "ff_h264_idct_add16_12_c", "avcodec_get_subtitle_rect_class", "android_setCpuArm", "av_opt_freep_ranges", "ff_mpa_synth_init_fixed", "ff_lpc_calc_ref_coefs_f", "swr_set_matrix", "x264_frame_deblock_row", "av_rc4_alloc", "_Z32GetRequiredMemRam_Sbr_envYBufferv", "ff_h263_decode_picture_header", "ff_get_guid", "aacEncInfo", "x264_threadpool_wait", "_Z40GetRequiredMemRam_aacEnc_AdjustThresholdv", "ff_parse_sample_format", "WebPMemoryWriterInit", "ff_rl_init_vlc", "ff_riff_write_info", "ff_lzw_decode_init", "_Z30FDKaacEnc_InitPnsConfigurationP10PNS_CONFIGiiiiPKiii", "ff_put_h264_qpel8_mc21_neon", "av_set_q", "av_find_default_stream_index", "x264_mb_predict_mv_16x16", "_Z32FDKaacEnc_FinalizeBitConsumptionP15CHANNEL_MAPPINGP8QC_STATEP6QC_OUTPP14QC_OUT_ELEMENTP12TRANSPORTENC17AUDIO_OBJECT_TYPEja", "_Z24FreeRam_aacEnc_QCelementPP14QC_OUT_ELEMENT", "_Z33GetRequiredMemRam_Sbr_quotaMatrixv", "ff_mpv_common_init_neon", "ff_fft_permute_neon", "ff_hevc_put_pixels_w48_neon_8", "ff_simple_idct_put_neon", "ff_fix_long_p_mvs", "ff_hevc_put_qpel_neon_wrapper", "ff_er_add_slice", "ff_match_2uint16", "_Z21FDKhybridAnalysisOpenP18FDK_ANA_HYB_FILTERPljS1_j", "FDKftell", "ff_reget_buffer", "ff_put_h264_qpel16_mc21_neon", "ff_hevc_put_qpel_h2v1_neon_8", "ff_print_debug_info2", "ff_sws_alphablendaway", "_Z30FDKaacEnc_DetermineEncoderModeP12CHANNEL_MODEi", "_Z11FDKcrcResetP11FDK_CRCINFO", "_Z34GetRequiredMemRam_aacEnc_PsyStaticv", "av_frame_get_decode_error_flags", "av_pix_fmt_desc_next", "ff_avc_write_annexb_extradata", "_Z22FDKaacEnc_SpreadingMaxiPKlS0_Pl", "FDKaacEnc_EncodeFrame", "av_get_channel_layout_channel_index", "ff_hevc_rem_intra_luma_pred_mode_decode", "_Z43FDKsbrEnc_DeleteSbrMissingHarmonicsDetectorP30SBR_MISSING_HARMONICS_DETECTOR", "av_frame_get_colorspace", "_Z27FreeRam_Sbr_guideVectorDiffPPl", "ff_read_riff_info", "ff_h264_idct_dc_add_12_c", "avio_wb32", "avpriv_copy_pce_data", "ff_riff_write_info_tag", "ff_aac_encode_main_pred", "ff_dct32_float", "av_frame_copy_props", "ff_hevc_put_qpel_h1_neon_8", "_Z6dct_IIPlS_iPi", "av_frame_set_colorspace", "av_dict_set", "ff_mpv_decode_defaults", "ff_copy_rectangle", "ff_avg_h264_qpel8_mc03_neon", "ff_clean_intra_table_entries", "av_opt_show2", "x264_encoder_reconfig_apply", "WebPMemoryWriterClear", "ff_mpegvideodsp_init", "avformat_get_class", "ff_put_vc1_mspel_mc33_neon", "ff_hevc_merge_flag_decode", "ff_get_best_fcode", "_Z32GetRequiredMemRam_Sbr_signMatrixv", "ff_hevc_frame_nb_refs", "ff_rm_retrieve_cache", "ff_celp_lp_zero_synthesis_filterf", "x264_cabac_encode_init", "ff_add_pixels_clamped_armv6", "ff_avg_qpel16_mc32_old_c", "_Z24FreeRam_TransportEncoderPP12TRANSPORTENC", "_Unwind_Resume_or_Rethrow", "ff_free_filters", "ff_avg_h264_qpel8_mc12_neon", "ff_avg_h264_qpel16_mc00_neon", "ff_dct32_fixed", "ff_hevcdsp_init_neon", "_Z19FDKaacEnc_PnsDetectP10PNS_CONFIGP8PNS_DATAiiiPlPKiS3_PiPsiiiS3_S6_", "av_audio_convert", "FDK_setBitCnt", "ff_avg_qpel16_mc33_old_c", "WebPEncodeBGR", "_Z31FreeRam_Sbr_guideVectorDetectedPPh", "_Z39GetRequiredMemRam_aacEnc_PsyInputBufferv", "_Unwind_ForcedUnwind", "ff_avg_h264_qpel8_mc20_neon", "ff_tget_long", "ff_hevc_deblocking_boundary_strengths", "ff_put_vc1_mspel_mc32_neon", "rgb15tobgr15", "ff_hevc_save_states", "av_hash_get_name", "ff_asfcrypt_dec", "av_get_media_type_string", "ff_acelp_decode_6bit_to_2nd_delay6", "avcodec_default_get_format", "ff_fft_fixed_init_arm", "ff_unlock_avcodec", "ffio_read_partial", "_Z23adtsWrite_GetHeaderBitsP11STRUCT_ADTS", "ff_h264_filter_mb", "av_get_alt_sample_fmt", "avpriv_mpa_decode_header2", "x264_weights_analyse", "_Z23getBitstreamElementList17AUDIO_OBJECT_TYPEahh", "avcodec_default_release_buffer", "ff_generate_wave_table", "_Z25FDKsbrEnc_Shellsort_fractPli", "av_get_channel_layout_string", "ff_imdct36_blocks_float", "av_dct_end", "ff_hevc_cbf_cb_cr_decode", "android_getCpuFamily", "ff_mjpeg_encode_dc", "ff_hevc_sao_band_position_decode", "ff_gmc_c", "av_audio_fifo_alloc", "ff_mpeg4_decode_video_packet_header", "avfilter_make_format64_list", "x264_plane_copy_c", "x264_intra_sad_x3_16x16_neon", "x264_opencl_slicetype_end", "ff_hevc_put_qpel_uw_pixels_w12_neon_8", "avpriv_dirac_parse_sequence_header", "x264_cabac_context_init", "ff_hevc_luma_mv_merge_mode", "av_frame_set_decode_error_flags", "ffurl_shutdown", "_Z21FDKaacEnc_calcSfbDistPlPsii", "avio_r8", "ff_scalarproduct_float_neon", "x264_encoder_parameters", "avio_get_str", "ff_psy_end", "ffio_open_null_buf", "av_downmix_info_update_side_data", "av_packet_side_data_name", "ff_h264_idct8_add_neon", "ff_acelp_high_pass_filter", "avformat_write_header", "ff_hevc_log2_res_scale_abs", "ff_get_unscaled_swscale", "__gnu_Unwind_Save_VFP_D_16_to_31", "ff_avg_h264_qpel8_mc01_neon", "WebPConfigLosslessPreset", "avformat_seek_file", "avcodec_dct_alloc", "avcodec_get_pix_fmt_loss", "_Z16qmfChangeOutGainP15QMF_FILTER_BANKl", "ff_blend_rectangle", "FDK_Copy", "ff_lpc_end", "av_hmac_update", "av_sample_fmt_is_planar", "x264_intra_sad_x3_4x4", "ff_imdct15_init", "avcodec_find_best_pix_fmt_of_2", "ff_pre_estimate_p_frame_motion", "avio_rl32", "av_buffersink_poll_frame", "av_image_alloc", "_Z18GetRam_ParamStereoi", "ff_init_mpadsp_tabs_float", "ff_formats_ref", "ff_png_get_nb_channels", "_Z24FDKaacEnc_PreEchoControlPliiisS_iPi", "ff_set_common_formats", "ff_hevc_decode_short_term_rps", "ff_avg_h264_qpel8_mc32_neon", "ff_h264_idct_add16intra_14_c", "ff_vc1_init_transposed_scantables", "x264_sync_frame_list_init", "rgb48tobgr48_bswap", "_Z34FDKsbrEnc_deleteExtractSbrEnvelopeP20SBR_EXTRACT_ENVELOPE", "FDKtan", "ff_h264_idct8_add_14_c", "ff_h264_luma_dc_dequant_idct_10_c", "av_tea_crypt", "_Z21FDKsbrEnc_UpdateHiResPhPiS_iS0_", "x264_sps_write", "ff_rl_init", "av_filter_next", "_Unwind_GetRegionStart", "ff_compute_frame_duration", "av_interleaved_write_uncoded_frame", "ff_opencl_register_filter_kernel_code_all", "ff_h264_idct8_add_12_c", "av_get_planar_sample_fmt", "x264_param_default", "_Z22FreeRam_Sbr_envYBufferPPl", "ff_avg_qpel8_mc32_old_c", "_Z17FDKaacEnc_QCClosePP8QC_STATEPP6QC_OUT", "av_frame_clone", "__cmpdf2", "_Z36FDKsbrEnc_WriteEnvChannelPairElementP15SBR_HEADER_DATAP19T_PARAMETRIC_STEREOP18SBR_BITSTREAM_DATAP12SBR_ENV_DATAS6_P11COMMON_DATAj", "ff_put_no_rnd_qpel8_mc31_old_c", "ff_put_no_rnd_qpel8_mc33_old_c", "ff_hevc_sao_merge_flag_decode", "av_format_get_control_message_cb", "ff_add_png_paeth_prediction", "x264_predict_4x4_h_c", "av_get_pix_fmt_loss", "x264_cabac_encode_init_core", "__ledf2", "ff_put_h264_qpel8_mc23_neon", "av_samples_copy", "av_packet_pack_dictionary", "_Z5fLog2li", "x264_deblock_init", "ff_mov_get_lpcm_codec_id", "ff_pred8x8_0lt_dc_neon", "ff_h264_unref_picture", "FDK_Feed", "WebPPictureImportRGB", "av_format_set_video_codec", "swr_is_initialized", "ff_h263_decode_init", "avio_seek", "_Z28FreeRam_Sbr_detectionVectorsPPh", "_Z32FDKsbrEnc_InitExtractSbrEnvelopeP20SBR_EXTRACT_ENVELOPEiiiiiimiPhj", "ff_write_quant_matrix", "x264_me_refine_qpel", "ff_xvid_idct_init", "avcodec_find_decoder_by_name", "x264_predict_4x4_init", "ff_pred8x8_l0t_dc_neon", "_Z6dst_IVPliPi", "ff_mpv_frame_end", "av_frame_get_pkt_size", "ff_put_h264_qpel8_mc02_neon", "ff_pix_abs16_y2_armv6", "swri_noise_shaping_double", "ff_get_wav_header", "ff_vorbis_stream_comment", "sws_scaleVec", "ff_init_poc", "av_buffer_allocz", "_Z21transportEnc_writeASCP13FDK_BITSTREAMP12CODER_CONFIGP13CSTpCallBacks", "ff_brktimegm", "ff_idctdsp_init_armv6", "android_getCpuFeatures", "rgb12tobgr12", "ff_copy_rectangle2", "x264_me_refine_qpel_rd", "avcodec_descriptor_get_by_name", "x264_predict_8x16c_init", "x264_ratecontrol_mb", "x264_rc_analyse_slice", "ff_avg_h264_qpel16_mc23_neon", "ffio_init_context", "av_display_rotation_get", "x264_predict_lossless_4x4", "av_opt_set", "x264_sei_pic_timing_write", "sws_rgb2rgb_init", "ff_set_cmp", "ff_fft_end", "ff_hevc_inter_pred_idc_decode", "ff_init_qscale_tab", "x264_cabac_block_residual_c", "ff_hevc_cu_qp_delta_sign_flag", "ff_er_frame_start", "ff_set_min_dist_lsf", "av_log2", "ff_imdct_half_c_fixed_32", "x264_rdo_init", "av_stream_get_recommended_encoder_configuration", "ff_mp4_read_dec_config_descr", "x264_ratecontrol_delete", "ff_hevc_put_qpel_h2v3_neon_8", "ff_put_h264_qpel16_mc32_neon", "ff_line_noise_avg_c", "av_realloc_f", "avformat_new_stream", "_Z16fDivNormHighPrecllPi", "ff_aac_encode_tns_info", "av_codec_get_codec_properties", "_Z27FDKsbrEnc_PSEnc_WritePSDataP19T_PARAMETRIC_STEREOP13FDK_BITSTREAM", "_Z28FDK_DRC_Generator_InitializeP8DRC_COMP11DRC_PROFILES1_ij12CHANNEL_MODE13CHANNEL_ORDERh", "swri_audio_convert_alloc", "x264_macroblock_cache_free", "ff_thread_report_progress2", "ff_mov_write_chan", "ff_float_dsp_init_neon", "x264_ratecontrol_zone_init", "av_image_copy", "sbrEncoder_GetLibInfo", "ff_hevc_annexb2mp4_buf", "swri_rematrix_init", "_Z13CalcInvLdDatal", "ff_fft_init_fixed_32", "ff_interleave_packet_per_dts", "ff_hevc_h_loop_filter_chroma_neon", "ff_rtp_get_payload_type", "av_register_codec_parser", "x264_predict_8x8c_h_c", "__truncdfsf2", "ff_put_h264_qpel8_mc01_neon", "av_frame_set_qp_table", "_Z22adtsWrite_EncodeHeaderP11STRUCT_ADTSP13FDK_BITSTREAMii", "_Z24FDKaacEnc_WriteBitstreamP12TRANSPORTENCP15CHANNEL_MAPPINGP6QC_OUTP7PSY_OUTP8QC_STATE17AUDIO_OBJECT_TYPEja", "ff_parse_specific_params", "av_buffer_is_writable", "avcodec_get_name", "av_isxdigit", "av_get_cpu_flags", "avcodec_get_frame_class", "ff_ps_apply", "av_ripemd_init", "av_dict_get", "ff_aac_search_for_tns", "av_match_name", "ff_hevc_sao_eo_class_decode", "ff_h264_idct_add_8_c", "av_pix_fmt_count_planes", "ff_init_desc_hscale", "ff_avg_h264_qpel8_mc00_neon", "ff_fill_line_with_color", "ffurl_close", "avio_put_str16le", "avpriv_dv_frame_profile2", "av_log_format_line", "x264_ratecontrol_mb_qp", "FDKaacEnc_GetVBRBitrate", "_Z43FDKsbrEnc_CreateSbrMissingHarmonicsDetectorP30SBR_MISSING_HARMONICS_DETECTORi", "_Z17GetRam_SbrEncoderi", "av_stream_set_r_frame_rate", "ff_hevc_put_pixels_w4_neon_8", "ff_h264_idct_add8_10_c", "av_format_inject_global_side_data", "x264_slicetype_analyse", "WebPSafeFree", "ff_fdct248_islow_10", "av_parse_color", "av_get_default_channel_layout", "av_audio_fifo_drain", "av_picture_copy", "ff_hevc_transform_add_8x8_neon_8", "ff_rtp_codec_id", "ff_biweight_h264_pixels_16_neon", "_Z17FDKaacEnc_psyInitP12PSY_INTERNALPP7PSY_OUTii17AUDIO_OBJECT_TYPEP15CHANNEL_MAPPING", "ffio_close_null_buf", "av_append_packet", "ff_init_gamma_convert", "ff_avg_h264_qpel8_mc23_neon", "ff_put_qpel16_mc31_old_c", "_Z32GetRequiredMemRam_aacEnc_QCstatev", "ff_hevc_put_qpel_h1v3_neon_8", "av_log_set_level", "_Z35FDKsbrEnc_InitSbrNoiseFloorEstimateP24SBR_NOISE_FLOOR_ESTIMATEiPKhiiiij", "ff_vc1dsp_init_arm", "av_frame_get_channel_layout", "ff_sbr_hf_apply_noise_0_neon", "av_tree_find", "ff_free_picture_tables", "_Z24transportEnc_CrcStartRegP12TRANSPORTENCi", "ff_hevc_put_pixels_w64_neon_8", "av_register_bitstream_filter", "ff_h264_chroma_dc_dequant_idct_12_c", "_Z38FDKsbrEnc_WriteEnvSingleChannelElementP15SBR_HEADER_DATAP19T_PARAMETRIC_STEREOP18SBR_BITSTREAM_DATAP12SBR_ENV_DATAP11COMMON_DATAj", "ff_mpeg4video_split", "ff_vector_fmul_window_vfp", "FDK_pushForward", "WebPPictureARGBToYUVA", "av_display_matrix_flip", "_Z29GetRam_aacEnc_AdjustThresholdi", "ff_rdft_calc_neon", "ff_vc1dsp_init", "av_fifo_alloc_array", "av_bprint_channel_layout", "ff_free_vlc", "av_lfg_init", "_Z29FDKsbrEnc_extractSbrEnvelope2P15SBR_CONFIG_DATAP15SBR_HEADER_DATAP19T_PARAMETRIC_STEREOP18SBR_BITSTREAM_DATAP11ENV_CHANNELS8_P11COMMON_DATAP17SBR_ENV_TEMP_DATAP19SBR_FRAME_TEMP_DATAi", "av_get_time_base_q", "av_rescale_q_rnd", "ff_psdsp_init_arm", "ff_hevc_put_pixels_w12_neon_8", "av_next_option", "ff_mpv_export_qp_table", "ff_blockdsp_init_arm", "av_isspace", "_Z34FDKaacEnc_PreProcessPnsChannelPairiPlS_S_S_S_P10PNS_CONFIGP8PNS_DATAS3_", "ff_avg_pixels8x8_c", "ff_mpv_common_frame_size_change", "ff_fft_calc_neon", "_Z28GetRequiredMemRam_SbrChannelv", "swr_alloc_set_opts", "ff_hevc_idct_32x32_dc_neon_8", "FDK_CreateBitBuffer", "x264_opencl_frame_delete", "ff_put_vc1_mspel_mc31_neon", "ff_dualinput_uninit", "ff_thread_finish_setup", "ff_mjpeg_encode_mb", "avfilter_version", "ff_h264_idct_add16_8_c", "x264_frame_new_slice", "ff_rdft_init", "avpriv_h264_has_num_reorder_frames", "x264_pps_write", "ff_avg_h264_qpel16_mc20_neon", "ff_put_signed_pixels_clamped_neon", "ff_iir_filter_init_state", "_Z21GetRam_Sbr_envYBufferiPh", "ff_hevc_parse_sps", "ff_fix_long_mvs", "av_buffersink_get_frame_flags", "av_base64_encode", "__gedf2", "ff_hevc_cu_transquant_bypass_flag_decode", "x264_encoder_delayed_frames", "_Z18FDKaacEnc_bitCountPKsiiPi", "ff_hevc_hls_filters", "avpriv_flac_is_extradata_valid", "swri_resample_dsp_init", "ff_faandct248", "ff_imdct_calc_c_fixed", "av_default_get_category", "ff_mlp_restart_checksum", "ff_put_qpel16_mc11_old_c", "ff_jref_idct_add", "_Z28GetRequiredMemRam_SbrEncoderv", "ff_avg_h264_qpel8_mc33_neon", "ff_h264_idct_add8_12_c", "ff_imdct15_uninit", "ff_mjpeg_decode_init", "_Z24FDKsbrEnc_CreatePSEncodePP11T_PS_ENCODE", "av_freep", "ff_h264_chroma422_dc_dequant_idct_8_c", "av_camellia_crypt", "avcodec_decode_video2", "__gnu_ldivmod_helper", "_Z35GetRequiredMemRam_aacEnc_AacEncoderv", "avio_wl16", "x264_macroblock_bipred_init", "ff_lzw_decode_close", "av_calloc", "ff_put_pixels16_x2_no_rnd_neon", "avfilter_graph_parse2", "_Z30FDKsbrEnc_InitTonCorrParamExtriP16SBR_TON_CORR_ESTP15SBR_CONFIG_DATAiiiiij", "ff_png_zalloc", "ff_put_pixels8x8_neon", "_Z32FDKsbrEnc_LSI_divide_scale_fractlll", "av_buffersink_params_alloc", "ff_poll_frame", "_Z37GetRequiredMemRam_Sbr_guideVectorOrigv", "ff_h264dsp_init", "_Z26FDKsbrEnc_InitSbrBitstreamP11COMMON_DATAPhiP11FDK_CRCINFOj", "_Unwind_Complete", "ff_put_wav_header", "ff_hevc_bump_frame", "_Z33FDKsbrEnc_CalculateTonalityQuotasP16SBR_TON_CORR_ESTPPlS2_ii", "ff_put_vc1_mspel_mc01_neon", "ff_lzw_encode", "ff_alloc_entries", "avfilter_copy_frame_props", "av_opt_set_defaults", "av_cast5_crypt2", "ff_avg_pixels16_xy2_no_rnd_neon", "x264_predict_4x4_v_c", "x264_predict_16x16_dc_c", "_Z17FDKaacEnc_BCClosePP13BITCNTR_STATE", "_Z17GetRam_SbrElementi", "_Z25qmfInitAnalysisFilterBankP15QMF_FILTER_BANKPsiiiii", "ff_write_chained", "ff_draw_init", "avpriv_get_raw_pix_fmt_tags", "x264_nal_encode", "av_fifo_space", "_Z29FreeRam_aacEnc_PsyInputBufferPPs", "WebPSafeCalloc", "swri_audio_convert_free", "avpriv_alloc_fixed_dsp", "x264_mb_predict_mv_direct16x16", "ff_put_pixels16_xy2_no_rnd_neon", "ff_hevc_flush_dpb", "ff_update_cur_dts", "ff_put_pixels8_x2_armv6", "avio_free_directory_entry", "FDKfclose", "ff_put_pixels8_arm", "ff_mpv_common_init_armv5te", "_Z22transportEnc_CrcEndRegP12TRANSPORTENCi", "ff_h264_idct_add8_14_c", "_Z21FDKaacEnc_psyMainInitP12PSY_INTERNAL17AUDIO_OBJECT_TYPEP15CHANNEL_MAPPINGiiiiiiijm", "ff_put_pixels16_x2_no_rnd_armv6", "av_opt_eval_flags", "x264_quant_luma_dc_trellis", "ff_ps_stereo_interpolate_neon", "ff_h264_execute_decode_slices", "ff_avc_find_startcode", "sws_subVec", "x264_frame_push", "av_read_pause", "avpriv_unlock_avformat", "avpriv_init_lls", "av_opt_set_int", "ffurl_closep", "_Z21GetRam_aacEnc_QCstatei", "ff_avg_h264_qpel8_mc02_neon", "ff_getSwsFunc", "avfilter_free", "avcodec_string", "_Z25transportEnc_GetBitstreamP12TRANSPORTENC", "ff_acelp_apply_order_2_transfer_function", "ff_ps_read_data", "x264_dct_init", "_Z4ifftiPlPi", "avpriv_mpegts_parse_packet", "ff_celp_lp_synthesis_filterf", "av_opt_get_key_value", "x264_predict_8x8c_init", "ff_h264_decode_ref_pic_marking", "ff_vector_fmul_window_neon", "_Z10PSEnc_InitP19T_PARAMETRIC_STEREOP14T_PSENC_CONFIGiiPh", "ff_h264_reset_sei", "_Z14InitInvSqrtTabv", "ff_h264_chroma422_dc_dequant_idct_9_c", "ff_h264_decode_init", "ff_request_frame", "ff_mjpeg_escape_FF", "_Z6fLdPowlili", "ff_simple_idct_add_10", "_Z5f2PowliPi", "av_vorbis_parse_free", "ff_h264_chroma_dc_dequant_idct_8_c", "ff_rm_reorder_sipr_data", "ff_imdct_half_vfp", "ff_mpeg4_init_direct_mv", "x264_mc_init", "avpriv_copy_bits", "x264_opencl_lookahead_delete", "av_opt_set_channel_layout", "x264_mb_mc", "av_vbprintf", "WebPEncodeLosslessRGBA", "av_timecode_get_smpte_from_framenum", "ff_acelp_lp_decode", "WebPEncodeRGB", "ff_hpeldsp_init", "av_hmac_free", "avfilter_graph_alloc", "_Z17FDKsbrEnc_AddLeftPiS_i", "avformat_alloc_output_context2", "FDKcalloc_L", "_Z3fftiPlPi", "ff_ps_hybrid_analysis_neon", "ff_pred16x16_plane_neon", "ff_hevc_intra_chroma_pred_mode_decode", "av_ctz", "__fixunssfdi", "ff_put_h264_qpel8_mc31_neon", "_Z29GetRequiredMemRam_bsOutbufferv", "_Z31FDK_DRC_Generator_getDrcProfileP8DRC_COMP", "ff_mpegvideoencdsp_init", "ff_alloc_packet", "ff_acelp_decode_5_6_bit_to_2nd_delay3", "_Z22FDKsbrEnc_codeEnvelopePaPK8FREQ_RESP17SBR_CODE_ENVELOPEPiiiii", "ff_rfps_add_frame", "x264_mb_predict_mv", "ff_startcode_find_candidate_c", "ff_put_qpel8_mc33_old_c", "avfilter_get_audio_buffer_ref_from_arrays", "av_mdct_end", "sbrEncoder_Close", "x264_reduce_fraction64", "ff_mpeg12_common_init", "ff_put_pixels16_neon", "ff_configure_buffers_for_index", "ff_mlp_calculate_parity", "av_image_get_linesize", "ff_vc1_apply_p_loop_filter", "_Z35transportEnc_LatmAdjustSubframeBitsP11LATM_STREAMPi", "WebPEncodeRGBA", "ff_blockdsp_init_neon", "_Z16CopyAlignedBlockP10FDK_BITBUFPhj", "av_read_image_line", "_Z21transportEnc_GetFrameP12TRANSPORTENCPi", "ff_put_h264_qpel16_mc01_neon", "_Z25GetRam_aacEnc_PsyInternali", "ff_vc1_parse_frame_header", "WebPGetWorkerInterface", "_Z22transportEnc_Latm_InitP11LATM_STREAMP13FDK_BITSTREAMP12CODER_CONFIGj14TRANSPORT_TYPEP13CSTpCallBacks", "WebPPictureYUVAToARGB", "__gnu_Unwind_Restore_WMMXD", "av_frame_free", "ff_h264_update_thread_context", "ff_hevc_put_pixels_w2_neon_8", "ff_put_no_rnd_qpel16_mc32_old_c", "av_parse_ratio", "avcodec_encode_audio2", "__ltdf2", "avpriv_dca_convert_bitstream", "_Z26FDKaacEnc_AdjustThresholdsPP11ATS_ELEMENTPP14QC_OUT_ELEMENTP6QC_OUTPP15PSY_OUT_ELEMENTiP15CHANNEL_MAPPING", "av_reallocp_array", "ff_put_qpel8_mc13_old_c", "_Unwind_VRS_Set", "ff_mpv_decode_mb", "ff_avg_vc1_chroma_mc8_neon", "x264_param_parse", "av_shrink_packet", "ff_formats_changeref", "ff_sbrdsp_init_arm", "ff_vc1_inv_trans_8x8_dc_neon", "ff_set_common_channel_layouts", "av_md5_sum", "x264_macroblock_write_cavlc", "ff_libwebp_encode_init_common", "av_sub_q", "avformat_get_mov_audio_tags", "ff_put_pixels_clamped_neon", "avcodec_default_get_buffer", "_Z25FDKaacEnc_InitDownsamplerP11DOWNSAMPLERii", "av_rescale_rnd", "ff_put_pixels8_xy2_no_rnd_neon", "av_guess_format", "ff_iir_filter_init", "ff_lpc_calc_ref_coefs", "av_dv_codec_profile2", "__fixunsdfdi", "av_audio_resample_init", "avio_close", "ff_tadd_string_metadata", "_Z24FDKaacEnc_Transform_RealPKsPliiPiiS2_iS1_", "ff_metadata_conv", "_Unwind_VRS_Pop", "ff_sbr_autocorrelate_neon", "ff_get_bmp_header", "ff_kbd_window_init_fixed", "ff_h264_chroma_dc_dequant_idct_9_c", "av_timecode_adjust_ntsc_framenum2", "__muldf3", "avcodec_find_best_pix_fmt_of_list", "ff_rtp_get_codec_info", "av_tea_init", "ff_pred8x8_dc_neon", "ff_blockdsp_init", "_Z30GetRam_Sbr_guideVectorDetectedi", "ff_mpeg4_find_frame_end", "ff_ps_add_squares_neon", "_Z4fPowliliPi", "av_hash_update", "av_strcasecmp", "WebPValidateConfig", "ff_program_add_stream_index", "avpicture_fill", "ff_thread_release_buffer", "ff_fdct248_islow_8", "av_mdct_init", "av_pix_fmt_get_chroma_sub_sample", "ff_thread_await_progress2", "ff_init_buffer_info", "ff_avg_qpel8_mc12_old_c", "ff_id3v2_parse_apic", "avfilter_get_matrix", "ff_hyscale_fast_c", "_Z20transportEnc_GetConfP12TRANSPORTENCP12CODER_CONFIGP13FDK_BITSTREAMPj", "FDKatan", "FDKfree", "ff_hevc_set_qPy", "av_sha_init", "av_opt_set_dict2", "_Z19aacEncDefaultConfigP13AACENC_CONFIGP10USER_PARAM", "ff_h264_pred_init_arm", "ff_add_format", "av_grow_packet", "ff_vc1_decode_sequence_header", "avpriv_mpa_decode_header", "ff_put_pixels16_y2_no_rnd_neon", "av_hash_final", "sws_freeFilter", "_Z27transportEnc_GetChannelModei", "x264_opencl_lowres_init", "av_buffer_default_free", "_Z34GetRequiredMemRam_TransportEncoderv", "ff_butterflies_float_vfp", "ff_estimate_p_frame_motion", "sws_alloc_set_opts", "x264_free", "av_set_cpu_flags_mask", "ff_hevc_dsp_init", "_Z8dit_ifftPliPK8FIXP_SPKi", "ff_acelp_interpolatef", "ff_tadd_rational_metadata", "ff_mjpeg_encode_stuffing", "_Z24FDKsbrEnc_GetEnvEstDelayP20SBR_EXTRACT_ENVELOPE", "av_opt_get_sample_fmt", "ffurl_seek", "avfilter_graph_request_oldest", "av_samples_alloc_array_and_samples", "_Z29FDKsbrEnc_extractSbrEnvelope1P15SBR_CONFIG_DATAP15SBR_HEADER_DATAP18SBR_BITSTREAM_DATAP11ENV_CHANNELP11COMMON_DATAP17SBR_ENV_TEMP_DATAP19SBR_FRAME_TEMP_DATA", "ff_end_tag", "ff_hevc_put_qpel_h3_neon_8", "_Z32GetRam_aacEnc_AdjThrStateElementi", "av_bprintf", "ff_h264_direct_dist_scale_factor", "ff_put_qpel8_mc31_old_c", "x264_sync_frame_list_delete", "WebPEncodeLosslessBGR", "ff_put_pixels8_x2_neon", "_Z28transportEnc_WriteAccessUnitP12TRANSPORTENCiii", "ff_aac_search_for_pred", "__gnu_Unwind_Restore_VFP", "ff_put_h264_qpel16_mc13_neon", "__fixsfsi", "ff_h264qpel_init_arm", "_Z16getChannelConfig12CHANNEL_MODE", "ff_flac_parse_streaminfo", "_Z33FreeRam_aacEnc_AdjThrStateElementPP11ATS_ELEMENT", "ff_hevc_cu_chroma_qp_offset_idx", "x264_sei_write", "x264_quant_init", "sws_setColorspaceDetails", "x264_weight_scale_plane", "sbrEncoder_Init", "_Z28FDKaacEnc_SyncBlockSwitchingP23BLOCK_SWITCHING_CONTROLS0_ii", "avformat_get_riff_audio_tags", "avio_wb24", "ff_pred8x8_128_dc_neon", "av_write_uncoded_frame", "av_strncasecmp", "ff_hevc_set_neighbour_available", "ff_dct_end", "x264_frame_delete_list", "ff_h264_idct_add16intra_12_c", "av_codec_get_tag2", "ff_avg_pixels16_xy2_neon", "ff_vc1_pred_mv_intfr", "x264_cabac_mb_skip", "av_get_sample_fmt", "_Z41FDKsbrEnc_InitSbrMissingHarmonicsDetectorP30SBR_MISSING_HARMONICS_DETECTORiiiiiiij", "ff_put_no_rnd_qpel8_mc11_old_c", "avfilter_pad_count", "WebPFree", "ff_framesync_add_frame", "ff_vorbis_comment", "ff_mpeg_framesize_alloc", "swresample_license", "av_bprint_append_data", "ff_h264_idct_add8_422_9_c", "av_hash_get_size", "av_opt_find", "_Z38GetRequiredMemRam_aacEnc_PsyOutChannelv", "av_find_nearest_q_idx", "WebPBlendAlpha", "_Z37FDKaacEnc_GetChannelModeConfiguration12CHANNEL_MODE", "avpriv_split_xiph_headers", "av_sdp_create", "ff_sort_nearly_sorted_floats", "ff_h264_idct_add16_14_c", "ff_id3v2_write_simple", "x264_thread_sync_ratecontrol", "av_compare_ts", "ff_hevc_split_packet", "_Z22FDKaacEnc_updateBitresP15CHANNEL_MAPPINGP8QC_STATEPP6QC_OUT", "ff_vorbiscomment_length", "avcodec_set_dimensions", "avcodec_free_frame", "swr_next_pts", "ff_vector_fmul_reverse_neon", "_Z37GetRequiredMemRam_Sbr_guideVectorDiffv", "avfilter_uninit", "_Z22FDKaacEnc_lookUpPnsUseiiii", "av_frame_set_channel_layout", "_Z29FDKsbrEnc_initInvFiltDetectorP16SBR_INV_FILT_ESTPiij", "_Z7dit_fftPliPK8FIXP_SPKi", "av_stream_get_r_frame_rate", "ff_reduce_index", "ff_iso8601_to_unix_time", "av_xiphlacing", "WebPGetColorPalette", "av_frame_get_qp_table", "ffio_fill", "av_gettime_relative_is_monotonic", "ff_fft_end_fixed", "avcodec_get_context_defaults3", "av_audio_fifo_write", "ff_h264_idct_add8_422_8_c", "FDKsbrEnc_EncodeIcc", "av_image_fill_linesizes", "x264_cabac_init", "ff_hevc_put_qpel_uw_pixels_neon_8", "av_aes_init", "_Z31GetRequiredMemRam_Sbr_guideScfbv", "ff_avg_h264_qpel16_mc10_neon", "av_fifo_generic_write", "av_stereo3d_create_side_data", "ff_h264_idct8_add4_8_c", "ff_intrax8_common_init", "av_image_fill_max_pixsteps", "avcodec_get_class", "avcodec_default_execute2", "ff_mov_read_chan", "av_expr_parse_and_eval", "ff_weight_h264_pixels_8_neon", "WebPEncode", "x264_intra_satd_x3_8x8c_neon", "ff_fdct_ifast248", "avformat_network_init", "avfilter_graph_parse", "avutil_version", "ff_find_last_ts", "ff_aac_is_encoding_err", "swr_inject_silence", "FDKpow", "_Unwind_Backtrace", "ff_put_pixels16_y2_neon", "_Z35GetRequiredMemRam_aacEnc_PsyElementv", "_Z26GetRequiredMemRam_PsEncodev", "ff_get_video_buffer", "sws_getIdentityVec", "swscale_license", "ff_init_block_index", "ff_id3v2_read", "swri_audio_convert", "ff_mpv_idct_init", "ff_pred8x8_vert_neon", "sbrEncoder_EncodeFrame", "FDKstrchr", "ff_celp_circ_addf", "_Z32GetRequiredMemRam_SbrDynamic_RAMv", "avcodec_descriptor_get", "sws_printVec2", "__ashldi3", "ff_hevc_decode_nal_vps", "av_get_random_seed", "ff_tilt_compensation", "av_packet_move_ref", "av_stristart", "ff_hevc_skip_flag_decode", "ff_dualinput_init", "ff_simple_idct248_put", "av_probe_input_buffer2", "ff_hevc_pred_init", "_Z27GetRam_aacEnc_PsyOutChanneli", "av_resample_close", "ff_gradfun_filter_line_c", "av_frame_get_channels", "swri_dither_init", "avio_rb24", "ff_acelp_update_past_gain", "ff_rdft_end", "avfilter_get_audio_buffer_ref_from_frame", "ff_hevc_luma_mv_mvp_mode", "x264_encoder_reconfig", "x264_copy_column8", "_Z28FDKaacEnc_MsStereoProcessingPP8PSY_DATAPP15PSY_OUT_CHANNELPKiPiS7_iiiS6_", "_Z24FDKaacEnc_CalcFormFactorPP14QC_OUT_CHANNELPP15PSY_OUT_CHANNELi", "ff_hevc_sao_type_idx_decode", "ff_all_channel_layouts", "x264_frame_shift", "x264_threadpool_delete", "avio_flush", "ff_h263_decode_init_vlc", "ff_mjpeg_build_huffman_codes", "av_opt_eval_float", "x264_sei_avcintra_vanc_write", "sws_freeVec", "ff_h264_flush_change", "x264_pps_init", "av_sha512_update", "ffurl_open", "av_des_init", "ff_mov_read_stsd_entries", "ff_flv_decode_picture_header", "x264_opencl_precalculate_frame_cost", "FDKsqrt", "_Z23FDKaacEnc_QCMainPrepareP12ELEMENT_INFOP11ATS_ELEMENTP15PSY_OUT_ELEMENTP14QC_OUT_ELEMENT17AUDIO_OBJECT_TYPEja", "ff_mjpeg_encode_init", "x264_predict_4x4_init_arm", "av_fast_padded_malloc", "avpicture_alloc", "x264_pixel_init", "x264_predict_16x16_init_arm", "ff_vc1_loop_filter_iblk", "ffio_set_buf_size", "android_getCpuIdArm", "_Z19FDKaacEnc_TnsEncodeP8TNS_INFOP8TNS_DATAiPK10TNS_CONFIGiPlii", "avcodec_register", "ff_mjpeg_init_hvsample", "_Z23GetRam_aacEnc_QCelementi", "av_thread_message_queue_alloc", "__gtsf2", "ff_simple_idct_8", "ff_h264_idct_add8_422_10_c", "_Z27FreeRam_Sbr_guideVectorOrigPPl", "av_rescale_q", "x264_predict_16x16_h_c", "ff_put_pixels8_l2_8", "sbrEncoder_IsSingleRatePossible", "ff_lock_avcodec", "av_hmac_alloc", "_Z25FDKsbrEnc_UpdateFreqScalePhPiiiii", "av_format_get_opaque", "av_lockmgr_register", "ff_hevc_clear_refs", "swr_convert", "av_stereo3d_alloc", "ff_hevc_hls_residual_coding", "ff_put_qpel16_mc32_old_c", "ff_put_vc1_mspel_mc20_neon", "ff_flac_get_max_frame_size", "ff_h264_fill_default_ref_list", "ff_sbrdsp_init", "ff_hevc_frame_rps", "ff_pix_abs16_x2_armv6", "av_sha512_final", "x264_lookahead_get_frames", "avfilter_mul_matrix", "_Z32FDKsbrEnc_CreateTonCorrParamExtrP16SBR_TON_CORR_ESTi", "ff_mpeg12_init_vlcs", "ff_mpeg1_clean_buffers", "av_frame_ref", "rgb16tobgr32", "ff_avg_h264_qpel16_mc22_neon", "ff_mpv_common_end", "av_packet_shrink_side_data", "ffurl_accept", "avio_open_dir", "av_max_alloc", "avcodec_encode_video", "avcodec_chroma_pos_to_enum", "avfilter_graph_add_filter", "av_xtea_init", "av_murmur3_update", "ff_pred16x16_128_dc_neon", "x264_param2string", "ff_h264_h_loop_filter_luma_neon", "av_dynarray_add_nofree", "ff_thread_report_progress", "x264_macroblock_encode_p8x8", "x264_intra_satd_x3_4x4_neon", "ff_hevc_put_qpel_uw_pixels_w8_neon_8", "av_codec_set_chroma_intra_matrix", "x264_adaptive_quant_frame", "_Z27FreeRam_Sbr_freqBandTableHIPPh", "ff_mkv_stereo3d_conv", "av_murmur3_final", "swr_get_delay", "FDKstrlen", "_Z13PSEnc_DestroyPP19T_PARAMETRIC_STEREO", "avfilter_graph_alloc_filter", "ff_put_h264_qpel8_mc11_neon", "sws_convVec", "ff_hevc_output_frame", "ff_sbr_hf_apply_noise_3_neon", "x264_predict_8x8c_init_arm", "av_frame_alloc", "_Z20FDKaacEnc_DownsampleP11DOWNSAMPLERPsiiS1_Pii", "ffio_limit", "x264_slurp_file", "ff_put_vc1_mspel_mc12_neon", "ff_hevc_put_qpel_v2_neon_8", "ff_dot_productf", "av_frame_get_pkt_pos", "av_get_packet", "FDK_getBitCnt", "av_fast_malloc", "av_opt_set_q", "ff_choose_timebase", "ff_avg_h264_qpel8_mc10_neon", "av_des_mac", "ff_intrax8_common_end", "avcodec_dct_init", "av_codec_is_decoder", "ffurl_handshake", "x264_intra_sad_x3_8x8", "ff_put_h264_qpel16_mc03_neon", "ff_sws_init_output_funcs", "ff_h264_field_end", "ff_rate_estimate_qscale", "av_log_ask_for_sample", "ff_butterflies_float_neon", "ff_choose_chroma_location", "ff_put_h264_qpel8_mc22_neon", "ff_h264_idct8_add4_neon", "avpriv_get_gamma_from_trc", "ff_dct_unquantize_h263_neon", "ff_init_desc_fmt_convert", "ff_mpadsp_apply_window_fixed", "av_color_transfer_name", "_Z29FDKaacEnc_CalcSfbMaxScaleSpecPKlPKiPii", "ffio_read_size", "av_dict_get_string", "ff_mjpeg_decode_dqt", "x264_ratecontrol_new", "ff_set_fixed_vector", "ff_mjpeg_encode_picture_trailer", "ff_hex_to_data", "ff_acelp_vectors_init", "ff_put_no_rnd_qpel16_mc11_old_c", "ff_me_cmp_init", "ff_vc1_init_common", "ff_img_read_header", "ff_lzw_decode_tail", "_Z18FreeRam_SbrElementPP11SBR_ELEMENT", "ff_lpc_calc_coefs", "_Z35FDKaacEnc_calcSfbQuantEnergyAndDistPlPsiiS_S_", "avcodec_align_dimensions", "av_buffersink_get_frame_rate", "ff_pred16x16_dc_neon", "av_get_packed_sample_fmt", "_Z18transportEnc_ClosePP12TRANSPORTENC", "ff_update_picture_tables", "av_parser_init", "avcodec_dct_get_class", "ff_free_stream", "av_set_double", "_Z14adtsWrite_InitP11STRUCT_ADTSP12CODER_CONFIG", "ff_aac_sbr_init", "av_escape", "_Z28FDKsbrEnc_frameInfoGeneratorP18SBR_ENVELOPE_FRAMEPhS1_iPKi", "FDKsbrEnc_EncodeIpd", "av_buffersink_get_frame", "avpriv_float_dsp_alloc", "ff_avg_h264_qpel16_mc03_neon", "av_get_sample_fmt_name", "av_usleep", "ff_fft_init_fixed", "ff_get_2pass_fcode", "ff_aac_adjust_common_prediction", "ff_ps_mul_pair_single_neon", "av_gcd", "FDKsbrEnc_EncodeIid", "av_timecode_check_frame_rate", "ff_faanidct_add", "swr_drop_output", "__adddf3", "ff_iir_filter", "avcodec_default_reget_buffer", "ff_mpv_common_init", "ff_id3v2_match", "av_audio_convert_alloc", "ff_hevc_transform_luma_4x4_neon_8", "av_dict_free", "ff_hevc_no_residual_syntax_flag_decode", "av_expr_free", "ff_merge_samplerates", "_Z25FreeRam_aacEnc_AacEncoderPP7AAC_ENC", "sws_isSupportedEndiannessConversion", "x264_reference_build_list_optimal", "av_stream_get_end_pts", "ff_hevc_put_qpel_v3_neon_8", "ff_vc1dsp_init_neon", "av_hash_names", "_Z19adtsWrite_CrcEndRegP11STRUCT_ADTSP13FDK_BITSTREAMi", "x264_frame_delete", "av_log_default_callback", "avfilter_config_links", "ff_put_h264_qpel16_mc10_neon", "av_dump_format", "avfilter_ref_get_channels", "FDKfwrite", "ffurl_get_multi_file_handle", "_Z28FDKaacEnc_writeExtensionDataP12TRANSPORTENCP16QC_OUT_EXTENSIONijj17AUDIO_OBJECT_TYPEa", "ff_weight_h264_pixels_4_neon", "ff_isom_write_hvcc", "x264_cabac_encode_flush", "x264_encoder_invalidate_reference", "ff_tadd_shorts_metadata", "av_thread_message_queue_set_err_send", "av_int_list_length_for_size", "x264_cabac_block_residual_8x8_rd_c", "swr_set_channel_mapping", "av_aes_alloc", "_Z31FDK_DRC_Generator_setDrcProfileP8DRC_COMP11DRC_PROFILES1_", "ff_put_pixels16_xy2_neon", "x264_predict_8x16c_v_c", "av_fifo_generic_peek", "avfilter_unref_buffer", "ff_put_h264_qpel16_mc02_neon", "ff_acelp_lspd2lpc", "ff_idet_filter_line_c", "ff_hevc_put_qpel_h2_neon_8", "_Z28FDKhybridAnalysisScaleStatesP18FDK_ANA_HYB_FILTERi", "ff_avg_h264_qpel16_mc31_neon", "ff_h264_idct_add8_422_14_c", "___Unwind_RaiseException", "ff_filter_alloc", "x264_bitstream_init", "av_get_colorspace_name", "ff_rgb24toyv12_c", "ff_mpadsp_init_arm", "avpriv_put_string", "av_parser_close", "_Z28GetRequiredMemAACdynamic_RAMv", "x264_predict_16x16_init", "ff_mpadsp_apply_window_fixed_armv6", "ff_shrink88", "ff_vector_fmul_neon", "ff_put_h264_qpel8_mc12_neon", "ff_hevc_split_coding_unit_flag_decode", "ff_h264_decode_picture_parameter_set", "av_timecode_make_string", "WebPCleanupTransparentArea", "ff_pred16x16_top_dc_neon", "x264_hrd_fullness", "ff_j_rev_dct_arm", "ff_me_cmp_init_arm", "ff_get_format", "av_get_double", "ff_mpeg_er_frame_start", "ff_acelp_lsf2lspd", "ff_lzw_decode", "ff_clear_fixed_vector", "ff_tadd_long_metadata", "av_frame_set_metadata", "_Z15Free_AacEncoderPP10AACENCODER", "FDKsin", "ff_avg_vc1_chroma_mc4_neon", "avcodec_decode_subtitle2", "JNI_OnUnload", "_Z8CalcLog2liPi", "_Z30GetRequiredMemRam_aacEnc_QCoutv", "swr_free", "ff_hevc_put_qpel_uw_pixels_w4_neon_8", "ff_hevc_res_scale_sign_flag", "FDKstrstr", "x264_predict_8x8c_v_c", "ff_msmpeg4_decode_ext_header", "_Z32FDK_DRC_Generator_getCompProfileP8DRC_COMP", "av_md5_alloc", "ffurl_alloc", "avpriv_solve_lls", "_Z21qmfSynthesisFilteringP15QMF_FILTER_BANKPPlS2_PK16QMF_SCALE_FACTORiPsiS1_", "swr_init", "_Z39GetRequiredMemRam_Sbr_QmfStatesAnalysisv", "ff_msmpeg4_decode_motion", "av_codec_get_chroma_intra_matrix", "_Z23transportEnc_GetPCEBits12CHANNEL_MODEii", "ff_put_h264_qpel16_mc22_neon", "WebPMemoryWrite", "ff_pred16x16_left_dc_neon", "_Z20FDKaacEnc_codeValuesPsiiP13FDK_BITSTREAM", "_Z21CreateStreamMuxConfigP11LATM_STREAMP13FDK_BITSTREAMiP13CSTpCallBacks", "av_timecode_init_from_string", "av_buffersink_get_samples", "ff_j_rev_dct4", "_Z25FDKsbrEnc_DestroyPSEncodePP11T_PS_ENCODE", "_Z34GetRequiredMemRam_aacEnc_QCelementv", "__udivdi3", "_Z23GetRam_aacEnc_QCchanneliPh", "ff_estimate_b_frame_motion", "ff_hevc_put_pixels_w16_neon_8", "FDKcalloc", "ff_clear_block_neon", "avformat_get_mov_video_tags", "ff_h264_idct_add16_neon", "avfilter_get_audio_buffer_ref_from_arrays_channels", "FDKatol", "av_camellia_alloc", "ff_avg_h264_qpel16_mc32_neon", "shuffle_bytes_3210", "ff_png_pass_row_size", "ff_msmpeg4_decode_block", "av_match_ext", "avcodec_fill_audio_frame", "ff_hevc_put_pixels_w8_neon_8", "_Z17GetRam_SbrChanneli", "avio_pause", "ff_mpv_common_defaults", "FDKaalloc_L", "ffio_read_indirect", "__fixunsdfsi", "avcodec_encode_video2", "FDK_toolsGetLibInfo", "ff_put_no_rnd_qpel16_mc13_old_c", "_Z28FDKaacEnc_InitPreEchoControlPlPiiS_S0_", "ff_adx_calculate_coeffs", "av_fifo_reset", "av_guess_sample_aspect_ratio", "ff_h263_decode_mb", "av_resample_compensate", "av_opt_get", "FDK_put", "ff_hevc_annexb2mp4", "av_samples_alloc", "ff_acelp_reorder_lsf", "_Z14FDKcrcStartRegP11FDK_CRCINFOP13FDK_BITSTREAMi", "WebPSafeMalloc", "av_thread_message_queue_send", "x264_predict_8x8_h_c", "ff_put_h264_qpel16_mc00_neon", "av_register_all", "av_opt_is_set_to_default_by_name", "_Z21FDKaacEnc_dynBitCountP13BITCNTR_STATEPKsPKjPKiiiiiS6_P12SECTION_DATAS6_S6_S6_j", "ff_find_stream_index", "ff_id3v2_read_dict", "ff_h264_alloc_tables", "avcodec_decode_audio4", "ff_aac_apply_main_pred", "FDK_getBwd", "avcodec_get_chroma_sub_sample", "ff_pred8x8_hor_neon", "av_format_get_data_codec", "x264_lookahead_init", "FDK_byteAlign", "ff_h264_idct_add16intra_9_c", "ff_h263_show_pict_info", "av_strerror", "ff_h264_get_profile", "ff_h264_idct_add8_422_12_c", "av_opt_set_defaults2", "ff_hevc_end_of_slice_flag_decode", "WebPPictureAlloc", "_Z34FDKaacEnc_CalcBandEnergyOptimShortPKlPiPKiiPl", "ff_put_h264_qpel8_mc20_neon", "FDKsbrEnc_EncodeOpd", "avio_wb16", "_Z26GetRam_Sbr_freqBandTableLOi", "_Z8fixp_cosli", "ff_h264_idct_dc_add_9_c", "x264_intra_sad_x3_8x8c", "av_write_trailer", "__gtdf2", "ff_vc1_pred_mv", "avio_close_dir", "ff_huffyuvencdsp_init", "FDKafree_L", "av_format_set_control_message_cb", "_Z39GetRequiredMemRam_aacEnc_PsyOutElementsv", "av_seek_frame", "sws_getCachedContext", "avfilter_next", "FDK_ResetBitBuffer", "avfilter_link", "avio_wl64", "ff_avg_h264_qpel16_mc30_neon", "_Z22FDKhybridAnalysisCloseP18FDK_ANA_HYB_FILTER", "av_gettime", "ff_parse_sample_rate", "ff_channel_layouts_unref", "ff_hevc_decode_nal_pps", "ff_framesync_configure", "ff_avg_qpel16_mc11_old_c", "_Z23FDKaacEnc_psyInitStatesP12PSY_INTERNALP10PSY_STATIC17AUDIO_OBJECT_TYPE", "ff_id3v2_free_extra_meta", "sws_getContext", "WebPPictureImportBGRX", "ff_query_formats_all", "ff_framesync_next", "ff_psy_preprocess_init", "_Z25GetRequiredMem_AacEncoderv", "ff_fft_init", "avfilter_graph_dump", "_Z20GetRam_Sbr_guideScfbi", "ff_mlp_checksum8", "av_parser_parse2", "avpicture_get_size", "ff_dv_frame_profile", "ff_diff_pixels_armv6", "_Z37GetRequiredMemRam_aacEnc_BitCntrStatev", "av_frame_copy", "WebPConfigInitInternal", "x264_cqm_parse_file", "x264_opencl_motionsearch", "ff_mpegvideoencdsp_init_arm", "avcodec_get_type", "av_resample_init", "ff_dct_unquantize_h263_inter_neon", "__nesf2", "av_opt_eval_q", "ff_pred8x8_0l0_dc_neon", "ff_lsp2polyf", "av_fifo_freep", "FDKlog", "av_get_bytes_per_sample", "ffio_get_checksum", "avio_w8", "ff_h264_h_loop_filter_chroma_neon", "ff_put_vc1_mspel_mc22_neon", "av_thread_message_queue_free", "avfilter_pad_get_type", "_Z25transportEnc_LatmGetFrameP11LATM_STREAMP13FDK_BITSTREAMPi", "ff_init_ff_sine_windows", "avformat_license", "avpriv_mpegts_parse_close", "av_new_packet", "av_free_packet", "rgb64to48_nobswap", "avcodec_version", "ff_xvid_idct", "ff_pngdsp_init", "ff_decode_sbr_extension", "_Unwind_RaiseException", "_Z25FDKaacEnc_InitElementBitsP8QC_STATEP15CHANNEL_MAPPINGiii", "ff_put_pixels16_y2_no_rnd_armv6", "ff_blend_mask", "ff_aac_tableinit", "avfilter_graph_set_auto_convert", "ff_vbv_update", "___Unwind_Backtrace", "ff_mpeg4videodec_static_init", "av_format_get_metadata_header_padding", "x264_predict_8x16c_p_c", "ff_put_vc1_mspel_mc30_neon", "ff_fft_fixed_calc_neon", "_Z21GetRam_Sbr_envYBufferi", "ff_msmpeg4_pred_dc", "avcodec_open2", "ff_put_pixels8_armv6", "ff_data_to_hex", "av_strdup", "ff_put_pixels8_x2_arm", "avfilter_graph_create_filter", "ff_put_guid", "ff_h264_idct_dc_add_10_c", "ff_pred8x8_plane_neon", "avformat_flush", "x264_macroblock_cache_load_interlaced", "x264_encoder_encode", "ff_celp_lp_synthesis_filter", "ff_hevc_put_qpel_uw_h2v1_neon_8", "ff_draw_round_to_sub", "av_opt_set_image_size", "ff_put_h264_qpel8_mc13_neon", "ff_hevc_set_new_ref", "av_frame_new_side_data", "_Z43GetRequiredMemRam_aacEnc_AdjThrStateElementv", "ff_me_cmp_init_static", "_Z28FDKaacEnc_InitChannelMapping12CHANNEL_MODE13CHANNEL_ORDERP15CHANNEL_MAPPING", "ff_put_pixels8_xy2_neon", "ff_framesync_uninit", "ff_vc1_mc_4mv_luma", "av_tea_alloc", "_Z12PSEnc_CreatePP19T_PARAMETRIC_STEREO", "_Z30FDKsbrEnc_InitSbrHuffmanTablesP12SBR_ENV_DATAP17SBR_CODE_ENVELOPES2_7AMP_RES", "avformat_open_input", "ff_rm_read_mdpr_codecdata", "ff_celp_filter_init", "av_fifo_grow", "WebPEncodeLosslessRGB", "ff_h264_decode_seq_parameter_set", "av_audio_fifo_space", "_Z10FDKcrcInitP11FDK_CRCINFOjjj", "av_ripemd_final", "JNI_OnLoad", "ff_mov_lang_to_iso639", "FDKstrcmp", "avcodec_find_best_pix_fmt2", "WebPPictureHasTransparency", "ff_update_link_current_pts", "av_picture_pad", "ff_h264_execute_ref_pic_marking", "_Z21GetRam_Sbr_signMatrixi", "__divdf3", "ff_mdct_end_fixed_32", "avio_rl16", "ff_h264_idct8_add_10_c", "ff_hevc_pcm_flag_decode", "avfilter_insert_filter", "ffurl_read_complete", "_Z15FDKaacEnc_QCNewPP8QC_STATEiPh", "ff_vc1_decode_entry_point", "ff_h264_filter_mb_fast", "_Z21GetRam_Sbr_envIBufferiPh", "ff_avg_h264_qpel16_mc01_neon", "av_bitstream_filter_close", "x264_macroblock_cache_load_progressive", "ff_hevc_put_qpel_h3v3_neon_8", "av_buffer_pool_uninit", "_Z29FDKsbrEnc_InitSbrCodeEnvelopeP17SBR_CODE_ENVELOPEPiill", "sws_freeContext", "av_get_output_timestamp", "x264_sync_frame_list_pop", "ff_h263_decode_frame", "ff_put_vc1_chroma_mc4_neon", "av_frame_set_channels", "av_vorbis_parse_frame", "_Z24FreeRam_aacEnc_PsyStaticPP10PSY_STATIC", "ff_hevc_put_qpel_uw_pixels_w24_neon_8", "ffurl_get_file_handle", "avcodec_find_decoder", "x264_frame_cond_broadcast", "av_strlcpy", "sbrEncoder_UpdateBuffers", "WebPPictureSharpARGBToYUVA", "avcodec_close", "x264_me_refine_bidir_satd", "ff_fmt_is_in", "x264_noise_reduction_update", "x264_predict_8x8_dc_c", "av_twofish_crypt", "x264_filler_write", "avio_close_dyn_buf", "av_read_frame", "x264_intra_sad_x3_8x16c_neon", "x264_sps_init_reconfigurable", "ff_flac_set_channel_layout", "ff_id3v2_write_apic", "av_frame_get_sample_rate", "WebPPictureARGBToYUVADithered", "ff_h264_idct_dc_add_14_c", "avpriv_vorbis_parse_frame", "_Z18FDKaacEnc_QCOutNewPP6QC_OUTiiiPh", "avio_closep", "_Z30FDKsbrEnc_AssembleSbrBitstreamP11COMMON_DATAP11FDK_CRCINFOij", "avcodec_license", "ff_h264qpel_init", "ff_replaygain_export_raw", "FDK_InitBitBuffer", "av_find_program_from_stream", "ff_pix_abs8_armv6", "ff_mjpeg_find_marker", "ff_h264_decode_init_vlc", "ff_avg_pixels8_armv6", "ff_init_desc_cfmt_convert", "av_dynarray2_add", "avfilter_sub_matrix", "_Unwind_GetDataRelBase", "ff_sbr_hf_apply_noise_2_neon", "av_rdft_end", "ff_set_ref_count", "av_get_bits_per_sample", "ffurl_register_protocol", "ff_put_qpel16_mc33_old_c", "av_opt_query_ranges_default", "av_opt_child_next", "ff_idctdsp_init_arm", "ff_h264_idct8_add4_14_c", "_Z35GetRam_Sbr_prevEnvelopeCompensationi", "ff_parse_channel_layout", "_Z9fixp_atanl", "av_get_pix_fmt_string", "x264_macroblock_deblock_strength", "av_opt_set_video_rate", "ff_idctdsp_init_neon", "ff_fill_rgba_map", "ff_thread_video_encode_frame", "ff_thread_free", "ff_frame_thread_free", "av_image_fill_arrays", "_Z19FDKaacEnc_QCOutInitPP6QC_OUTiPK15CHANNEL_MAPPING", "av_log2_16bit", "avpriv_io_delete", "ff_mov_close_hinting", "ff_simple_idct44_add", "FDKfloor", "shuffle_bytes_1230", "av_thread_message_queue_recv", "ff_mov_iso639_to_lang", "x264_predict_16x16_v_c", "ff_fft_end_fixed_32", "avcodec_register_all", "ff_put_pixels8_y2_arm", "ff_hevc_put_qpel_h1v1_neon_8", "av_strnstr", "_Z12FDKcrcEndRegP11FDK_CRCINFOP13FDK_BITSTREAMi", "ff_h264_idct_add_neon", "FDK_getFreeBits", "__ashrdi3", "ff_avg_qpel8_mc31_old_c", "ff_vc1_decode_end", "ff_frame_thread_encoder_init", "FDKgetchar", "av_hash_final_b64", "__gnu_Unwind_Save_WMMXD", "av_register_hwaccel", "ff_simple_idct_neon", "ff_vector_fmac_scalar_neon", "ff_bswapdsp_init", "av_rescale", "aacEncEncode", "av_set_string3", "av_frame_get_metadata", "avio_put_str", "x264_ratecontrol_end", "av_imdct_calc", "ff_init_vlc_sparse", "_Z12fixp_cos_sinliPlS_", "ff_put_h264_qpel8_mc00_neon", "ff_avg_qpel16_mc31_old_c", "_Z41GetRequiredMemRam_Sbr_guideVectorDetectedv", "ff_put_h264_qpel8_mc03_neon", "ff_mpeg4_decode_picture_header", "_Z26GetRam_aacEnc_BitCntrStatei", "ff_put_bmp_header", "av_base64_decode", "ff_generate_sliding_window_mmcos", "_Z30FDKaacEnc_getChannelAssignment12CHANNEL_MODE13CHANNEL_ORDER", "x264_intra_sad_x3_8x8c_neon", "_Z19FreeRam_bsOutbufferPPh", "_Z30FDKaacEnc_InitPsyConfigurationiiiiiiP17PSY_CONFIGURATION7FB_TYPE", "ff_mpa_synth_filter_float", "FDKaacEnc_Open", "ff_alloc_dir_entry", "avpriv_tak_parse_streaminfo", "ff_hevc_sao_offset_sign_decode", "FDKatof", "x264_mb_encode_chroma", "ff_h264_idct_add16_9_c", "ff_hevc_put_qpel_bi_neon_wrapper", "_Z16autoCorr2nd_realP11ACORR_COEFSPKli", "_Z24GetRam_aacEnc_PsyDynamiciPh", "_Z27FreeRam_Sbr_freqBandTableLOPPh", "av_codec_set_codec_descriptor", "av_format_set_data_codec", "FDKmemmove", "ff_h263_pred_acdc", "av_log_get_flags", "avformat_query_codec", "ff_put_h264_qpel8_mc33_neon", "ff_put_qpel16_mc13_old_c", "ff_iir_filter_free_statep", "av_iformat_next", "ff_h264_idct8_add4_12_c", "x264_analyse_weight_frame", "FDKmemclear", "ff_mdct_fixed_calc_neon", "_Z17FDKaacEnc_TnsSyncP8TNS_DATAPKS_P8TNS_INFOS4_iiPK10TNS_CONFIG", "FDKfree_L", "ff_clear_blocks_neon", "x264_intra_sad_x3_8x16c", "ff_get_extradata", "ff_flac_is_extradata_valid", "ff_h264_idct8_dc_add_8_c", "ff_h264_idct8_dc_add_12_c", "ff_hevc_put_qpel_uw_h1v1_neon_8", "_Z20FDKsbrEnc_AddVecLeftPiS_S_i", "av_fifo_generic_read", "ff_startcode_find_candidate_armv6", "ff_put_h264_chroma_mc4_neon", "av_default_item_name", "avcodec_pix_fmt_to_codec_tag", "ff_fft_calc_vfp", "av_dv_frame_profile", "ff_avg_pixels16_armv6", "ff_hevc_cbf_luma_decode", "ff_gradfun_blur_line_c", "ff_sbr_hf_gen_neon", "ff_msmpeg4_decode_init", "ff_h264_idct_add16_10_c", "av_get_channel_layout_nb_channels", "avpriv_ac3_parse_header2", "_Z22FreeRam_Sbr_signMatrixPPi", "x264_intra_satd_x3_8x16c", "sbrEncoder_GetInputDataDelay", "ff_h264_v_loop_filter_luma_neon", "ff_init_desc_no_chr", "av_image_copy_plane", "av_buffer_pool_init", "ff_avg_h264_chroma_mc2_neon", "av_packet_ref", "av_packet_copy_props", "av_pix_fmt_swap_endianness", "x264_macroblock_tree_read", "FDKmemcmp", "ff_init_filters", "x264_predict_4x4_dc_c", "_Z32FDKsbrEnc_DeleteTonCorrParamExtrP16SBR_TON_CORR_EST", "av_blowfish_init", "ff_h264_chroma_dc_dequant_idct_14_c", "ff_mov_read_esds", "WebPPictureInitInternal", "ff_mdct_calc_c_fixed_32", "avpriv_frame_get_metadatap", "x264_frame_expand_border_lowres", "ff_put_h264_qpel8_mc30_neon", "_Z34FDKsbrEnc_InitSbrTransientDetectorP22SBR_TRANSIENT_DETECTORiiP16sbrConfigurationiiiiiii", "av_parse_cpu_caps", "ff_hevc_split_transform_flag_decode", "av_force_cpu_flags", "ff_qpeldsp_init", "av_fopen_utf8", "ff_mov_get_channel_layout", "av_get_picture_type_char", "ff_id3v2_tag_len", "_Z37FDKsbrEnc_deleteSbrNoiseFloorEstimateP24SBR_NOISE_FLOOR_ESTIMATE", "_Z21transportEnc_writePCEP13FDK_BITSTREAM12CHANNEL_MODEiiiiij", "av_buffer_pool_get", "ff_init_vscale_pfn", "ff_hevc_extract_rbsp", "av_format_get_audio_codec", "av_murmur3_init", "av_packet_merge_side_data", "ff_parse_time_base", "ff_idctdsp_init", "ff_put_pixels16_arm", "av_frame_get_color_range", "ff_exp2", "av_index_search_timestamp", "av_color_primaries_name", "_Z21FDKsbrEnc_AddVecRightPiS_S_i", "avpriv_find_pix_fmt", "av_parse_cpu_flags", "x264_threads_distribute_ratecontrol", "WebPSetWorkerInterface", "ff_all_samplerates", "avio_read_dir", "x264_intra_satd_x3_4x4", "avutil_license", "ff_vorbiscomment_write", "ff_id3v2_finish", "ff_command_queue_pop", "ff_put_h264_qpel16_mc33_neon", "ff_sine_window_init_fixed", "x264_predict_8x16c_h_c", "av_reallocp", "_Z26qmfInitSynthesisFilterBankP15QMF_FILTER_BANKPliiiii", "av_murmur3_init_seeded", "ff_pixblockdsp_init", "ff_null_get_audio_buffer", "_Z12LdDataVectorPlS_i", "ff_sbr_apply", "__restore_core_regs", "ff_acelp_decode_8bit_to_1st_delay3", "_Z28FDKsbrEnc_getSbrStartFreqRAWii", "_Z9CalcLdInti", "ff_put_qpel16_mc12_old_c", "ff_yuv2rgb_c_init_tables", "av_hwaccel_next", "__gnu_Unwind_Resume_or_Rethrow", "_Z15FDKaacEnc_BCNewPP13BITCNTR_STATEPh", "ff_pcm_read_packet", "test", "shuffle_bytes_3012", "ff_mp4_read_descr", "ff_h264_decode_mb_cavlc", "av_get_known_color_name", "_Z20FDK_MetadataEnc_OpenPP20FDK_METADATA_ENCODER", "av_samples_set_silence", "ff_put_pixels8_x2_no_rnd_neon", "_Z20FreeRam_aacEnc_QCoutPP6QC_OUT", "avio_handshake", "av_sha_alloc", "av_frame_set_pkt_size", "av_packet_get_side_data", "ff_mpeg4_clean_buffers", "WebPCopyPixels", "av_rc4_init", "ff_vc1_inv_trans_8x4_dc_neon", "avfilter_copy_buf_props", "_Z25GetRam_aacEnc_ElementBitsi", "ff_thread_flush", "av_fifo_size", "ff_init_cabac_decoder", "ff_get_codec_guid", "avpriv_mpegaudio_decode_header", "_Z18FDKaacEnc_PsyClosePP12PSY_INTERNALPP7PSY_OUT", "_Unwind_Resume", "av_get_int", "av_opt_set_bin", "ff_iir_filter_free_coeffsp", "av_dynarray_add", "ff_h264_pred_direct_motion", "x264_cabac_encode_decision_c", "ff_hevc_put_qpel_h3v2_neon_8", "av_find_best_pix_fmt_of_2", "ff_hevc_transform_add_32x32_neon_8", "ff_guess_image2_codec", "_Z7dct_IIIPlS_iPi", "ff_h264_idct_add16intra_10_c", "__divsi3", "ff_avc_parse_nal_units", "av_audio_fifo_free", "av_bprint_clear", "av_image_get_buffer_size", "FDKprintfErr", "av_codec_get_seek_preroll", "aacEncoder_SetParam", "ff_hevc_put_qpel_h2v2_neon_8", "avpriv_io_move", "ff_put_pixels8_y2_no_rnd_neon", "ff_vc1_interp_mc", "ff_mpv_encode_end", "ff_h263_pred_motion", "_Z26FDKaacEnc_CalcBandNrgMSOptPKlS0_PiS1_PKiiPlS4_iS4_S4_", "_Z23FDKsbrEnc_frameSplitterPPlPiP22SBR_TRANSIENT_DETECTORPhS4_iiiii", "_Z26transportEnc_GetStaticBitsP12TRANSPORTENCi", "ff_weight_h264_pixels_16_neon", "ff_videodsp_init_arm", "_Z17FDKaacEnc_psyMainiP11PSY_ELEMENTP11PSY_DYNAMICP17PSY_CONFIGURATIONP15PSY_OUT_ELEMENTPsPii", "ff_mdct_init_fixed_32", "avpriv_toupper4", "sws_isSupportedOutput", "swri_realloc_audio", "avio_write", "swri_oldapi_conv_flt_to_s16_neon", "av_stream_get_parser", "avpriv_open", "x264_sei_recovery_point_write", "av_log_set_flags", "x264_ratecontrol_start", "ff_avg_qpel8_mc11_old_c", "avsubtitle_free", "ff_sbr_sum_square_neon", "av_cast5_init", "ff_planar_sample_fmts", "ff_videodsp_init_armv5te", "x264_param_apply_profile", "ff_sine_window_init", "ff_pcm_read_seek", "ff_vc1_inv_trans_8x4_neon", "avpriv_strtod", "ff_h264_init_cabac_states", "ff_url_join", "ff_mov_write_packet", "x264_predict_16x16_p_c", "ff_find_unused_picture", "ff_mlp_read_major_sync", "ff_h264_luma_dc_dequant_idct_12_c", "audio_resample", "ff_put_pixels16_x2_armv6", "x264_cqm_init", "ff_hevcdsp_init_arm", "av_get_bits_per_pixel", "av_get_exact_bits_per_sample", "sbrEncoder_LimitBitRate", "ff_h264_idct8_dc_add_neon", "av_bitstream_filter_filter", "x264_lookahead_delete", "ff_celp_math_init", "x264_mb_predict_mv_pskip", "av_packet_from_data", "ff_alloc_packet2", "av_isdigit", "ff_ps_init", "swri_noise_shaping_float", "ff_hevc_put_qpel_uw_h2v2_neon_8", "_Z23FDKsbrEnc_Shellsort_intPii", "_Z26FreeRam_aacEnc_PsyInternalPP12PSY_INTERNAL", "ff_mdct_end_fixed", "avformat_network_deinit", "ff_log2_q15", "av_tree_destroy", "ff_hevc_prev_intra_luma_pred_flag_decode", "ff_hevc_sao_offset_abs_decode", "__gnu_Unwind_Save_WMMXC", "av_buffersrc_add_frame_flags", "ff_raw_read_partial_packet", "avio_put_str16be", "swri_noise_shaping_int32", "av_frame_get_best_effort_timestamp", "avio_open_dyn_buf", "ff_default_query_formats", "av_dict_copy", "ff_parse_pixel_format", "ff_mpa_l2_select_table", "ff_merge_formats", "ff_make_format_list", "ffurl_read", "av_opt_ptr", "ff_vc1_mc_1mv", "avpriv_exif_decode_ifd", "ff_scale_vector_to_given_sum_of_squares", "av_register_input_format", "ff_simple_idct_add_armv6", "ff_mjpeg_decode_end", "_Z6dct_IVPliPi", "ff_get_line", "ff_simple_idct_add_8", "FDKexp", "av_lzo1x_decode", "av_reduce", "av_q2intfloat", "av_opt_copy", "ff_psy_find_group", "ff_vc1_smooth_overlap_filter_iblk", "sbrEncoder_GetHeader", "ff_prores_idct", "_Z30FreeRam_aacEnc_AdjustThresholdPP13ADJ_THR_STATE", "ff_mjpeg_decode_dht", "x264_frame_init_lowres", "_Z10fixp_atan2ll", "ff_avg_h264_qpel16_mc11_neon", "ff_put_pixels8_neon", "x264_intra_sad_x3_16x16", "__gnu_Unwind_Save_VFP", "ff_imdct_half_c", "_Z22FDKaacEnc_prepareSfbPeP15PE_CHANNEL_DATAPKlS2_S2_PKiiii", "avfilter_get_buffer_ref_from_frame", "avio_get_str16le", "ff_fft16_vfp", "ff_h264_chroma422_dc_dequant_idct_14_c", "ff_hevc_put_pixels_w32_neon_8", "ff_all_formats", "ff_biweight_h264_pixels_8_neon", "_Z22FreeRam_aacEnc_QCstatePP8QC_STATE", "av_image_check_sar", "_Z23GetRam_aacEnc_PsyStatici", "av_crc_get_table", "ff_channel_layouts_changeref", "avfilter_unref_bufferp", "ff_get_mb_score", "sws_shiftVec", "x264_pixel_ssd_wxh", "x264_frame_push_blank_unused", "x264_predict_8x8_init_arm", "avcodec_free_context", "ff_thread_can_start_frame", "_Z27GetRam_PsQmfStatesSynthesisi", "_Z28FreeRam_aacEnc_PsyOutChannelPP15PSY_OUT_CHANNEL", "__lesf2", "FDK_DeleteBitBuffer", "ff_h263_loop_filter", "ff_faanidct", "__mulsf3", "_Z34FDKsbrEnc_CreateExtractSbrEnvelopeP20SBR_EXTRACT_ENVELOPEiiPh", "__gnu_unwind_execute", "ff_mpv_report_decode_progress", "_Z29FDKaacEnc_ChannelElementWriteP12TRANSPORTENCP12ELEMENT_INFOPP14QC_OUT_CHANNELP15PSY_OUT_ELEMENTPP15PSY_OUT_CHANNELj17AUDIO_OBJECT_TYPEaPih", "_Z30FDKaacEnc_InitTnsConfigurationiiiiiiP10TNS_CONFIGP17PSY_CONFIGURATIONii", "ff_fft_lut_init", "ff_avg_h264_chroma_mc8_neon", "ff_alloc_extradata", "ff_decode_frame_props", "av_add_index_entry", "av_bitstream_filter_init", "av_frame_get_plane_buffer", "ff_faanidct_put", "aacEncClose", "avcodec_enum_to_chroma_pos", "FDKcos", "rgb16tobgr16", "av_bprint_chars", "__gnu_Unwind_RaiseException", "url_feof", "_Z22qmfAnaPrototypeFirSlotPliPKsiPs", "ff_set_qscale", "av_opt_set_sample_fmt", "_Z25FreeRam_aacEnc_PsyElementPP11PSY_ELEMENT", "av_format_get_subtitle_codec", "avpriv_new_chapter", "av_hash_final_bin", "av_compare_mod", "ff_line_noise_c", "FDKmemset", "_Z36GetRequiredMemRam_aacEnc_ElementBitsv", "ff_mdct_calc_c_fixed", "FDKfflush", "avio_find_protocol_name", "ff_hevc_put_qpel_uw_v2_neon_8", "_Z17GetAACdynamic_RAMi", "ff_hevc_mvp_lx_flag_decode", "_Z8fDivNormllPi", "av_get_padded_bits_per_pixel", "avcodec_find_encoder", "_Z21GetRam_Sbr_v_k_masteri", "av_samples_get_buffer_size", "avpriv_aac_parse_header", "ff_write_pass1_stats", "_Z29FreeRam_aacEnc_PsyOutElementsPP15PSY_OUT_ELEMENT", "av_get_channel_name", "avio_read_to_bprint", "ff_h264_check_intra_pred_mode", "x264_zigzag_init", "ff_put_vc1_mspel_mc03_neon", "_Z24FDKaacEnc_CodePnsChanneliP10PNS_CONFIGPiPlS1_S2_", "ff_index_search_timestamp", "avformat_version", "ff_img_read_packet", "avfilter_open", "ff_rm_free_rmstream", "audio_resample_close", "av_bprint_init", "avfilter_graph_config", "_Z21GetRam_SbrDynamic_RAMi", "ff_framesync_process_frame", "avio_check", "swri_get_dither", "ff_hevc_transform_8x8_neon_8", "ff_init_vscale", "swri_noise_shaping_int16", "_Z9schur_divlli", "__extendsfdf2", "ff_mdct_init_fixed", "avfilter_link_set_closed", "_Z21FDKhybridAnalysisInitP18FDK_ANA_HYB_FILTER15FDK_HYBRID_MODEiii", "_Z24GetRam_aacEnc_PsyElementi", "ff_null_get_video_buffer", "avcodec_encode_subtitle", "sws_convertPalette8ToPacked32", "x264_cpu_detect", "ff_tak_check_crc", "ff_h263dsp_init", "ff_calculate_bounding_box", "swr_alloc", "ff_imdct_calc_c", "av_fft_init", "rgb48tobgr48_nobswap", "x264_intra_sa8d_x3_8x8_neon", "ff_acelp_weighted_vector_sum", "av_frame_set_pkt_duration", "x264_opencl_finalize_cost", "av_probe_input_format2", "ff_hevc_put_qpel_uw_v1_neon_8", "avpriv_init_elbg", "sws_getColorspaceDetails", "ff_hevc_put_qpel_uw_v3_neon_8", "FDKfopen", "ff_avg_pixels8_x2_neon", "_Z23transportEnc_GetLibInfoP8LIB_INFO", "avformat_configuration", "av_blowfish_crypt", "av_hash_alloc", "ff_thread_ref_frame", "av_audio_fifo_realloc", "ff_simple_idct_armv5te", "ff_hevc_put_qpel_uw_h1v2_neon_8", "av_fft_permute", "ff_parse_mpeg2_descriptor", "av_strlcat", "ff_yuv2rgb_get_func_ptr", "_Z22FDKsbrEnc_InitPSEncodeP11T_PS_ENCODE8PS_BANDSl", "av_buffer_get_opaque", "ff_sbr_neg_odd_64_neon", "ff_sbr_qmf_deint_bfly_neon", "ff_h264_idct_add_14_c", "ff_libwebp_error_to_averror", "av_tree_insert", "x264_sei_version_write", "ff_put_pixels8_y2_armv6", "ff_rtp_chain_mux_open", "av_frame_get_side_data", "ff_tread_tag", "av_image_check_size", "WebPCopyPlane", "ff_lzw_encode_flush", "_Z18FDKsbrEnc_AddRightPiS_i", "ff_avg_qpel16_mc13_old_c", "__divdi3", "_Z9InitLdIntv", "WebPGetEncoderVersion", "av_frame_remove_side_data", "ff_mov_get_channel_layout_tag", "av_tree_enumerate", "_Z5f2Powli", "ff_mpa_synth_filter_fixed", "av_audio_fifo_read", "ff_mjpeg_decode_sos", "_Z18FreeRam_SbrChannelPP11SBR_CHANNEL", "ff_mpa_synth_init_float", "ff_codec_get_id", "ff_hpeldsp_init_neon", "av_format_set_audio_codec", "ff_h264_hl_decode_mb", "av_opt_set_double", "ff_png_zfree", "ff_hevc_put_qpel_uw_h3_neon_8", "av_destruct_packet", "av_crc_init", "ff_hevc_transform_add_16x16_neon_8", "av_fifo_alloc", "_Z18FreeAACdynamic_RAMPPl", "ff_ntp_time", "avutil_configuration", "sws_getConstVec", "_Z5fLog2liPi", "ff_fdctdsp_init", "ff_vc1_parse_frame_header_adv", "ff_put_pixels16x16_c", "ff_mpv_motion", "_Z25adtsWrite_EndRawDataBlockP11STRUCT_ADTSP13FDK_BITSTREAMPi", "av_dict_count", "av_dict_parse_string", "av_aes_crypt", "ff_simple_idct_add_armv5te", "av_sha512_alloc", "ff_isom_write_avcc", "avio_open", "av_bprint_escape", "avio_open2", "ff_simple_idct_put_12", "x264_predict_8x16c_dc_c", "__eqdf2", "av_utf8_decode", "av_hmac_calc", "ff_put_vc1_mspel_mc21_neon", "ff_thread_decode_frame", "av_codec_set_lowres", "x264_lookahead_is_empty", "__gnu_unwind_frame", "ff_wav_codec_get_id", "_Z32transportEnc_RegisterSbrCallbackP12TRANSPORTENCPFiPvP13FDK_BITSTREAMiii17AUDIO_OBJECT_TYPE14MP4_ELEMENT_IDiES1_", "_Z19FDKaacEnc_AdjThrNewPP13ADJ_THR_STATEi", "ff_add_channel_layout", "x264_quant_chroma_dc_trellis", "__divsf3", "ff_h264_idct8_dc_add_14_c", "android_setCpu", "_Z42FDKsbrEnc_ResetSbrMissingHarmonicsDetectorP30SBR_MISSING_HARMONICS_DETECTORi", "av_get_pcm_codec", "_Z21FDKaacEnc_noiseDetectPlPiiPKiPsP11NOISEPARAMSS3_", "ff_put_no_rnd_qpel16_mc12_old_c", "ff_imdct_half_c_fixed", "ff_framesync_get_frame", "ff_alloc_picture", "ff_wmv2dsp_init", "ff_hevc_cu_chroma_qp_offset_flag", "ff_set_sar", "x264_plane_copy_interleave_c", "x264_macroblock_analyse", "FDKaacEnc_Close", "ff_mpv_encode_init", "ff_avg_h264_qpel8_mc11_neon", "x264_reduce_fraction", "av_opt_get_channel_layout", "ff_avg_qpel16_mc12_old_c", "x264_predict_lossless_8x8", "avcodec_default_execute", "ff_simple_idct_put_8", "aacEncGetLibInfo", "av_buffersink_read", "ff_dot_product", "swr_get_class", "ff_init_scantable_permutation", "av_log_set_callback", "avcodec_get_edge_width", "avpicture_layout", "x264_prefetch_fenc", "ff_dualinput_filter_frame", "ff_put_vc1_mspel_mc10_neon", "av_dirname", "av_vorbis_parse_frame_flags", "swr_set_compensation", "ff_h264_idct8_dc_add_9_c", "ff_default_get_audio_buffer", "ff_hevc_put_qpel_uw_h3v1_neon_8", "swri_audio_convert_init_arm", "ff_hpeldsp_init_armv6", "_Z18FreeRam_SbrEncoderPP11SBR_ENCODER", "av_frame_get_pkt_duration", "av_buffersink_set_frame_size", "rgb32to24", "avpriv_float_dsp_init", "rgb16to24", "_Z21FDKsbrEnc_UpdateLoResPhPiS_i", "ff_iir_filter_init_coeffs", "ff_mpeg4_decode_partitions", "av_url_split", "ff_vc1_loop_filter_iblk_delayed", "av_log_get_level", "avfilter_graph_parse_ptr", "x264_macroblock_deblock", "ff_put_h264_qpel16_mc23_neon", "_Z20GetRam_aacEnc_PsyOuti", "av_version_info", "avio_get_str16be", "avformat_queue_attached_pictures", "ff_hevc_put_qpel_uw_h1v3_neon_8", "ff_raw_write_packet", "av_bitstream_filter_next", "av_opt_get_video_rate", "ff_put_h264_qpel16_mc12_neon", "ff_h263_decode_motion", "avcodec_alloc_context3", "x264_validate_levels", "avio_rb32", "av_opt_get_int", "FDK_get32", "_Z33FDKaacEnc_CalcBandEnergyOptimLongPKlPiPKiiPlS4_", "ff_h264_idct8_add4_10_c", "ff_tget_short", "ff_msmpeg4_coded_block_pred", "ff_read_frame_flush", "ff_put_no_rnd_qpel8_mc12_old_c", "ff_fdct_ifast", "_Z42FDKsbrEnc_PSEnc_ParametricStereoProcessingP19T_PARAMETRIC_STEREOPPsjPP15QMF_FILTER_BANKPPlS7_S1_S4_Pai", "x264_cabac_encode_bypass_c", "x264_encoder_headers", "ff_kbd_window_init", "ff_h264_chroma422_dc_dequant_idct_12_c", "avcodec_align_dimensions2", "ff_sbr_qmf_deint_neg_neon", "__eqsf2", "av_channel_layout_extract_channel", "av_xtea_crypt", "ff_opus_parse_extradata", "av_color_space_name", "ff_vc1_inv_trans_4x4_neon", "x264_ratecontrol_init_reconfigurable", "__popcountsi2", "ff_mlp_init_crc", "x264_ratecontrol_summary", "x264_encoder_intra_refresh", "av_fifo_realloc2", "_Z26FDKaacEnc_QuantizeSpectrumiiiPiPliS_Ps", "x264_ratecontrol_qp", "ff_avg_h264_qpel8_mc21_neon", "ff_imdct_calc_neon", "av_dv_codec_profile", "av_strndup", "_Z18GetRam_bsOutbufferi", "ff_simple_idct_arm", "av_opt_eval_double", "_Z23qmfChangeOutScalefactorP15QMF_FILTER_BANKi", "av_codec_next", "ff_vc1_decode_init_alloc_tables", "_Z35FDKaacEnc_PostProcessPnsChannelPairiP10PNS_CONFIGP8PNS_DATAS2_PiS3_", "x264_pixel_ssd_nv12"], "allstrings": ["audio/aac,audio/aacp,audio/x-aac", "Internal error, put_bits buffer too small\n", "Assertion %s failed at %s:%d\n", "s->buf_ptr < s->buf_end", "./libavcodec/put_bits.h", "ADTS frame size too large: %u (max %d)\n", "MPEG-4 AOT %d is not allowed in ADTS\n", "Escape sample rate index illegal in ADTS\n", "960/120 MDCT window is not allowed in ADTS\n", "Scalable configurations are not allowed in ADTS\n", "Extension flag is not allowed in ADTS\n", "audio/aac", "aac,adts", "ADTS muxer", "write_id3v2", "Enable ID3v2 tag writing", "write_apetag", "Enable APE tag writing", "invalid packet size: %d\n", "Unsupported file version - %d.%02d\n", "No frames in the file!\n", "Too many frames: %u\n", "Number of seek entries is less than number of frames: %zu vs. %u\n", "File truncated\n", "Decoding file - v%d.%02d, compression level %u\n", "ape,apl,mac", "Invalid APE tag key '%s'.\n", "APE tag size too large.\n", "Skipping binary tag '%s'.\n", "Error reading cover art.\n", "APETAGEX", "Unsupported tag version. (>=%d)\n", "Tag size is way too big\n", "Invalid tag size %u.\n", "Too many tag fields (%u)\n", "APE Tag is a header\n", "Non ASCII keys are not allowed\n", "WM/AlbumTitle", "Author", "Description", "comment", "WM/Composer", "WM/EncodedBy", "encoded_by", "WM/EncodingSettings", "WM/Genre", "genre", "WM/Language", "language", "WM/OriginalFilename", "WM/PartOfSet", "disc", "WM/Publisher", "publisher", "WM/Tool", "WM/TrackNumber", "WM/MediaStationCallSign", "service_provider", "WM/MediaStationName", "service_name", "asf_parse_packet", "asf_read_packet", "Skip due to FRAME_HEADER_SIZE\n", "libavformat/asfdec_f.c", "ret >= 0", "key:%d stream:%d seq:%d offset:%d replic_size:%d num:%X packet_property %X\n", "packet_replic_size %d is invalid\n", "packet_obj_size %d invalid\n", "too long payload\n", "unexpected packet_replic_size of %d\n", "packet_replic_size is invalid\n", "packet_frag_size is invalid (%d>%d-%d+%d)\n", "ff asf skip %d (unknown stream)\n", "asf_st", "skipping asf data pkt with fragment offset for stream:%d, expected:%d but got %d from pkt)\n", "freeing incomplete packet size %d, new %d\n", "Cannot append palette to packet\n", "new packet: stream:%d key:%d packet_key:%d audio:%d size:%d\n", "READ PACKET s:%d  os:%d  o:%d,%d  l:%d   DATA:%p\n", "packet fragment position invalid %u,%u not in %u\n", "discarding ms fart\n", "pkt.size != ds_packet_size * ds_span (%d %d %d)\n", "offset + asf_st->ds_chunk_size <= asf_st->pkt.size", "idx + 1 <= asf_st->pkt.size / asf_st->ds_chunk_size", "ff asf bad header %x  at:%lld\n", "ff asf bad non zero\n", "Invalid ECC byte\n", "invalid packet_length %u at:%lld\n", "invalid padsize %u at:%lld\n", "invalid packet header length %d for pktlen %u-%u at %lld\n", "packet: size=%d padsize=%d  left=%d\n", "asf->packet_size_left < FRAME_HEADER_SIZE || asf->packet_segments < 1", "asf_read_pts failed\n", "WM/Picture", "Invalid attached picture size: %d.\n", "Unknown attached picture type: %d.\n", "Invalid attached picture data size: %d >= %d.\n", "Unsupported byte array in tag %s.\n", "%llu", "Unsupported GUID value in tag %s.\n", "Unsupported value type %d in tag %s.\n", "Unknown attached picture mimetype: %s.\n", "itime:0x%llx, pct:%d, ict:%d\n", "pktnum:%d, pktct:%d  pts: %lld\n", "SEEKTO: %lld\n", "%d stream %d name_len %2d type %d len %4d <%s>\n", "AspectRatioX", "AspectRatioY", "too many streams\n", "author", "copyright", "Payload extension %x %d\n", "Secret data:\n", "ASF_Protection_Type", "ASF_Key_ID", "ASF_License_URL", "Ext DRM protected stream detected, decoding will likely fail!\n", "encryption", "ASF Extended Content Encryption", "Digital signature detected!\n", "gpos mismatch our pos=%llu, end=%lld\n", "i=%d, st->codec->codec_type:%d, asf->dar %d:%d sar=%d:%d\n", "asf demuxer", "no_resync_search", "Don't try to resynchronize by looking for a certain optional start code", "export_xmp", "Export full XMP metadata", "pthread_join(): %s\n", "async_seek: AVSEEK_SIZE: %lld\n", "async_seek: %lld\n", "async_seek: fask_seek %lld from %d dist:%d/%d\n", "async:", "ffurl_open failed : %s, %s\n", "pthread_mutex_init failed : %s\n", "pthread_cond_init failed : %s\n", "pthread_create failed : %s\n", "async", "Async", "NULL", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.", "subfile,", "libavformat/avio.c", "No URL Protocols are registered. Missing call to av_register_all()?\n", "Impossible to open the '%s' protocol for reading\n", "Impossible to open the '%s' protocol for writing\n", "subfile", "Key '%s' not found.\n", "Error parsing options string %s\n", "https:", "https protocol not found, recompile FFmpeg with openssl, gnutls,\nor securetransport enabled.\n", "URLContext", "Invaid UTF8 sequence in avio_put_str16%s\n", "!s->write_flag", "libavformat/aviobuf.c", "Failed to decrease buffer size\n", "len >= s->orig_buffer_size", "Statistics: %d seeks, %d writeouts\n", "Statistics: %lld bytes read, %d seeks\n", "AVIOContext", "ffconcat version 1.0", "Match slave stream #%d with stream #%d id 0x%x\n", "Auto-inserting h264_mp4toannexb bitstream filter\n", "h264_mp4toannexb", "h264_mp4toannexb bitstream filter required for H.264 streams\n", "Impossible to open '%s'\n", "NOPTS", "%.6g", "pkt2.buf", "libavformat/concatdec.c", " -> pts:%s pts_time:%s dts:%s dts_time:%s\n", "file:%d stream:%d pts:%s pts_time:%s dts:%s dts_time:%s", " \t\r\n", "Line %d: filename required\n", "Unsafe file name '%s'\n", "inpoint", "outpoint", "Line %d: %s without file\n", "Line %d: invalid %s '%s'\n", "file_packet_metadata", "Line %d: packet metadata required\n", "Line %d: failed to parse metadata string\n", "exact_stream_id", "Line %d: exact_stream_id without stream\n", "ffconcat", "Line %d: invalid version\n", "Line %d: unknown keyword '%s'\n", "concat demuxer", "enable safe mode", "auto_convert", "automatically convert bitstream format", "data:", "No ',' delimiter in URI\n", "Invalid content-type '%.*s'\n", "Content-type: %.*s\n", "base64", "Ignoring option '%.*s'\n", "Invalid base64 in URI\n", "%08x ", " %02x", "%1.4f %s", "%3.2f %s", "%1.0f %s", "%1.0fk %s", "%sMetadata:\n", "\n%s  %-16s: ", "%s - ", "unknown", "fps, ", "tbr, ", "tbn, ", "dump_separator", "    Stream #%d:%d", "[0x%x]", ", %d, %d/%d", ", SAR %d:%d DAR %d:%d", " (dub)", " (original)", " (comment)", " (lyrics)", " (karaoke)", " (forced)", " (hearing impaired)", " (visual impaired)", " (clean effects)", "%sSide data:\n", "%s  ", "new extradata", "paramchange: ", "channel count %u, ", "channel layout: %s, ", "sample_rate %u, ", "width %u height %u", "unknown param", "h263 macroblock info", "replaygain: ", "invalid data", "track gain", "track peak", "album gain", "album peak", "displaymatrix: rotation of %.2f degrees", "stereo3d: ", "side by side", "top and bottom", "frame alternate", "interleaved lines", "interleaved columns", "side by side (quincunx subsampling)", " (inverted)", "audio service type: ", "effects", "visually impaired", "hearing impaired", "dialogue", "comentary", "emergency", "voice over", "karaoke", "quality factor: %d, pict_type: %c", "unknown side data type %d (%d bytes)", "stream #%d:\n", "  keyframe=%d\n", "  duration=%0.3f\n", "  dts=", "%0.3f", "  pts=", "  size=%d\n", "Output", "Input", "%s #%d, %s, %s '%s':\n", "  Duration: ", "%02d:%02d:%02d.%02d", ", start: ", "%d.%06d", ", bitrate: ", "    Chapter #%d:%d: ", "start %f, ", "end %f\n", "  Program %d %s\n", "  No Program\n", "truncate", "truncate existing files on write", "set I/O operation maximum block size", "Invalid picture type: %d.\n", "Could not read mimetype from an attached picture.\n", "Error reading attached picture description.\n", "Error reading attached picture data.\n", "Error parsing attached picture.\n", "error parsing VorbisComment metadata\n", "WAVEFORMATEXTENSIBLE_CHANNEL_MASK", "Invalid value of WAVEFORMATEXTENSIBLE_CHANNEL_MASK\n", "fLaC", "flac", "NGINX RTMP", "Found invalid index entries, clearing the index.\n", "Audio codec (%x)", "Video codec (%x)", "true", "false", "AMF_DATA_TYPE_STRING parsing failed\n", "Skipping duplicate index\n", "times", "filepositions", "Invalid keyframes object, skipping.\n", "Keyframe index parsing failed\n", "Missing AMF_END_OF_OBJECT in AMF_DATA_TYPE_OBJECT\n", "Missing AMF_END_OF_OBJECT in AMF_DATA_TYPE_MIXEDARRAY\n", "unsupported amf type %d\n", "videodatarate", "audiodatarate", "datastream", "videocodecid", "audiocodecid", "audiosamplerate", "audiosamplesize", "filesize", "type:%d, size:%d, dts:%lld pos:%lld\n", "onTextData", "onCaption", "onCaptionInfo", "onMetaData", "onCuePoint", "Unknown type %s\n", "OnTextData packet", "Skipping flv packet: type %d, size %d, flags %d.\n", "Stream discovered after head already parsed\n", "%d %X %d \n", "Negative cts, previous timestamps might be wrong.\n", "invalid timestamps %lld %lld\n", "Omnia A/XE", "live_flv", "live_flvdec", "flv_metadata", "Allocate streams according to the onMetaData array", "image2", "ssegment", "image2pipe", "Probing %s score:%d size:%d\n", "Specified probe size value %u cannot be < %u\n", "mime_type", "Format %s detected only with low score of %d, misdetection possible!\n", "Format %s probed with size=%d and score=%d\n", "NETSCAPE2.0", "Invalid palette extradata\n", "PAL8 packet is missing palette in extradata\n", "GIF muxer supports only a single video GIF stream.\n", "video_enc->pix_fmt == AV_PIX_FMT_PAL8", "libavformat/gif.c", "image/gif", "GIF muxer", "Number of times to loop the output: -1 - no loop, 0 - infinite loop", "final_delay", "Force delay (in centiseconds) after the last frame", "GIF87aGIF89aGraphic Control Extension block's size less than 4.\n", "lzw minimum code size must be >= 1\n", "invalid block label\n", "GIF demuxer", "min_delay", "minimum valid delay between frames (in hundredths of second)", "max_gif_delay", "maximum valid delay between frames (in hundredths of seconds)", "default_delay", "default delay between frames (in hundredths of second)", "ignore_loop", "ignore loop setting (netscape extension)", "h261", "h261 demuxer", "h263", "h263 demuxer", "h264 demuxer", "configurationVersion:                %u\n", "general_profile_space:               %u\n", "general_tier_flag:                   %u\n", "general_profile_idc:                 %u\n", "general_profile_compatibility_flags: 0x%08x\n", "general_constraint_indicator_flags:  0x%012llx\n", "general_level_idc:                   %u\n", "min_spatial_segmentation_idc:        %u\n", "parallelismType:                     %u\n", "chromaFormat:                        %u\n", "bitDepthLumaMinus8:                  %u\n", "bitDepthChromaMinus8:                %u\n", "avgFrameRate:                        %u\n", "constantFrameRate:                   %u\n", "numTemporalLayers:                   %u\n", "temporalIdNested:                    %u\n", "lengthSizeMinusOne:                  %u\n", "numOfArrays:                         %u\n", "array_completeness[%u]:               %u\n", "NAL_unit_type[%u]:                    %u\n", "numNalus[%u]:                         %u\n", "nalUnitLength[%u][%u]:                 %u\n", "hevc", "hevc,h265,265", "hevc demuxer", "com.apple.streaming.transportStreamTimestamp", "cookies", "user-agent", "headers", "seekable", "end_offset", "HLS request for url '%s', offset %lld, playlist %d\n", "Unable to read key file %s\n", "Unable to open key file %s\n", "crypto+%s", "crypto:%s", "SAMPLE-AES encryption is not supported yet\n", "Unable to seek to offset %lld of HLS segment '%s'\n", "URI=", "BYTERANGE=", "TYPE=", "GROUP-ID=", "ASSOC-LANGUAGE=", "NAME=", "DEFAULT=", "FORCED=", "CHARACTERISTICS=", "METHOD=", "BANDWIDTH=", "AUDIO=", "VIDEO=", "SUBTITLES=", "#EXTM3U", "#EXT-X-STREAM-INF:", "#EXT-X-KEY:", "AES-128", "SAMPLE-AES", "#EXT-X-MEDIA:", "public.accessibility.describes-music-and-sound", "public.accessibility.describes-video", "#EXT-X-TARGETDURATION:", "#EXT-X-MEDIA-SEQUENCE:", "#EXT-X-PLAYLIST-TYPE:", "EVENT", "#EXT-X-MAP:", "#EXT-X-ENDLIST", "#EXTINF:", "#EXT-X-BYTERANGE:", "No longer receiving playlist %d\n", "Failed to reload playlist %d\n", "skipping %d segments ahead, expired from playlists\n", "Failed to open an initialization section in playlist %d\n", "Downloading an initialization section of size %lld\n", "Failed to open segment of playlist %d\n", "Too large HLS ID3 tag (%d > %lld bytes)\n", "Stripped %d HLS ID3 bytes\n", "Stripped additional %d HLS ID3 bytes\n", "PRIV", "Invalid HLS ID3 audio timestamp %lld\n", "APIC", "!pls->id3_deferred_extra", "libavformat/hls.c", "Changing ID3 metadata in HLS audio elementary stream", "Now receiving playlist %d, segment %d\n", "Empty playlist\n", "Error when loading first segment '%s'\n", "No expected HTTP requests have been made\n", "variant_bitrate", "hls,applehttp", "user_agent", "live_start_index", "segment index to start live streams at (negative values are from the end)", "Blues", "Classic Rock", "Country", "Dance", "Disco", "Grunge", "Hip-Hop", "New Age", "Oldies", "Other", "Reggae", "Alternative", "Death Metal", "Pranks", "Soundtrack", "Euro-Techno", "Ambient", "Trip-Hop", "Vocal", "Jazz+Funk", "Trance", "Classical", "Instrumental", "Acid", "Game", "Sound Clip", "Gospel", "Noise", "AlternRock", "Space", "Meditative", "Instrumental Pop", "Instrumental Rock", "Ethnic", "Gothic", "Darkwave", "Techno-Industrial", "Electronic", "Pop-Folk", "Eurodance", "Dream", "Southern Rock", "Comedy", "Cult", "Top 40", "Christian Rap", "Pop/Funk", "Jungle", "Native American", "Cabaret", "New Wave", "Psychadelic", "Rave", "Showtunes", "Trailer", "Lo-Fi", "Tribal", "Acid Punk", "Acid Jazz", "Polka", "Retro", "Musical", "Rock & Roll", "Hard Rock", "Folk-Rock", "National Folk", "Swing", "Fast Fusion", "Bebob", "Latin", "Revival", "Celtic", "Bluegrass", "Avantgarde", "Gothic Rock", "Progressive Rock", "Psychedelic Rock", "Symphonic Rock", "Slow Rock", "Big Band", "Chorus", "Easy Listening", "Acoustic", "Humour", "Speech", "Chanson", "Opera", "Chamber Music", "Sonata", "Symphony", "Booty Bass", "Primus", "Porn Groove", "Satire", "Slow Jam", "Club", "Tango", "Samba", "Folklore", "Power Ballad", "Rhythmic Soul", "Freestyle", "Duet", "Punk Rock", "Drum Solo", "A capella", "Euro-House", "Dance Hall", "Drum & Bass", "Club-House", "Hardcore", "Terror", "Indie", "BritPop", "Negerpunk", "Polsk Punk", "Beat", "Christian Gangsta", "Heavy Metal", "Black Metal", "Crossover", "Contemporary Christian", "Christian Rock", "Merengue", "Salsa", "Thrash Metal", "Anime", "JPop", "SynthPop", "image/gif", "image/jpeg", "image/jpg", "image/png", "image/tiff", "image/bmp", "TDATTIMETORYTRDATSIZTYER", "TDENTDORTDRCTDRLTDTGTIPLTMCLTMOOTPROTSOATSOPTSOTTSST", "TALBTBPMTCOMTCONTCOPTDLYTENCTEXTTFLTTIT1TIT2TIT3TKEYTLANTLENTMEDTOALTOFNTOLYTOPETOWNTPE1TPE2TPE3TPE4TPOSTPUBTRCKTRSNTRSOTSRCTSSE", "Error opening memory stream\n", "Cannot read BOM value, input too short\n", "Incorrect BOM value\n", "Unknown encoding\n", "Error reading frame %s, skipped\n", "TCON", "(%d)", "TXXX", "Unknown attached picture mimetype: %s, skipping.\n", "Unknown attached picture type %d.\n", "Error decoding attached picture description.\n", "Failed to alloc %zu bytes\n", "Failed to alloc %d bytes\n", "Error reading GEOB frame, data truncated.\n", "GEOB", "No AVFormatContext, skipped ID3 chapter data\n", "encrypted", "encrypted and compressed", "extended header too long.", "invalid extended header length", "compression", "id3v2 ver:%d flags:%02X len:%d\n", "Invalid empty frame %s, skipping.\n", "Skipping %s ID3v2 frame %s.\n", "USLT", "Compresssed frame %s tlen=%d dlen=%ld\n", "Failed to alloc %ld bytes\n", "Failed to read compressed tag\n", "Failed to uncompress tag: %d\n", "lyrics-%s%s%s", "Error reading lyrics, skipped\n", "invalid frame id, assuming padding\n", "ID3v2.%d tag skipped, cannot handle %s\n", "TYER", "TDAT", "-%.2s-%.2s", " %.2s:%.2s", "32x32 pixels 'file icon'", "Other file icon", "Cover (front)", "Cover (back)", "Leaflet page", "Media (e.g. label side of CD)", "Lead artist/lead performer/soloist", "Artist/performer", "Conductor", "Band/Orchestra", "Lyricist/text writer", "Recording Location", "During recording", "During performance", "Movie/video screen capture", "A bright coloured fish", "Illustration", "Band/artist logotype", "Publisher/Studio logotype", "TCMP", "compilation", "TDRC", "TDRL", "TDEN", "creation_time", "TSOA", "album-sort", "TSOP", "artist-sort", "TSOT", "title-sort", "TALB", "TCOM", "TCOP", "TENC", "TIT2", "TLAN", "TPE1", "TPE2", "TPE3", "TPOS", "TPUB", "TRCK", "TSSE", "lyrics", "CHAP", "%.2s%.2s", "No mimetype is known for stream %d, cannot write an attached picture.\n", "ljpg", "pgmyuv", "mpg1-img", "mpg2-img", "mpg4-img", "ffv1-img", "pict", "im24", "im32", "sunras", "yuv10", "xface", "SDPX", "XPDS", "Exif", "Could not open file : %s\n", "No such pixel format: %s.\n", "POSIX.1-2008 not supported, nanosecond file timestamps unavailable\n", "Could find no file with path '%s' and index in the range %d-%d\n", "Pattern type 'glob' was selected but globbing is not supported by this libavformat build\n", "Unknown value '%d' for pattern_type option\n", "webp_pipe", "tiff_pipe", "sunrast_pipe", "sgi_pipe", "qdraw_pipe", "png_pipe", "pictor_pipe", "jpegls_pipe", "jpeg_pipe", "j2k_pipe", "exr_pipe", "dpx_pipe", "dds_pipe", "bmp_pipe", "set the video framerate", "force loop over input file sequence", "pattern_type", "set pattern type", "glob_sequence", "select glob/sequence pattern type", "glob", "select glob pattern type", "select sequence pattern type", "disable pattern matching", "pixel_format", "set video pixel format", "start_number", "set first number in the sequence", "start_number_range", "set range for looking at the first sequence number", "video_size", "set video size", "frame_size", "force frame size in bytes", "ts_from_file", "set frame timestamp from file's one", "ts_type", "nano second precision", "webp demuxer", "tiff demuxer", "sunrast demuxer", "sgi demuxer", "qdraw demuxer", "png demuxer", "pictor demuxer", "jpegls demuxer", "j2k demuxer", "exr demuxer", "dpx demuxer", "dds demuxer", "bmp demuxer", "image2 demuxer", "UVAx", "Could not get frame filename with strftime\n", "Could not get frame filename number %d from pattern '%s' (either set updatefirst or use a pattern like %%03d within the filename pattern)\n", "bmp,dpx,jls,jpeg,jpg,ljpg,pam,pbm,pcx,pgm,pgmyuv,png,ppm,sgi,tga,tif,tiff,jp2,j2c,j2k,xwd,sun,ras,rs,im1,im8,im24,sunras,xbm,xface,pix,y", "image2 muxer", "updatefirst", "continuously overwrite one file", "update", "strftime", "use strftime for filename", "tx3g806cc608", "sac3", "alac", ".mp1", "twos", "lpcm", "lpcm\r", "in24\f", "in24\t", "WMA2cvessevcvmssssmv", "dmb1\t", "SVQ3\r", "mp4v\r", "DIVX\r", "XVID\r", "VP31+", "rpza,", "cvid1", "8BPS2", "smc 8", "rle RIGSrle1.", "WRLE;", "mp2vY", "mjp2^", "tga a", "tiffb", "gif >", "png >", "MNG G", "vc-1X", "avs2u", "dracd", "AVupf", "ap4x3", "HapY", "562H#", "MPEG4 description: tag=0x%02x len=%d\n", "codec open in read_dec_config_descr\n", "esds object type id 0x%02x\n", "Specific MPEG4 header len=%d\n", "mp4a config channels %d obj %d ext obj %d sample rate %d ext sample rate %d\n", "loas", "m4v demuxer", "text/plain", "application/x-truetype-font", "application/x-font", "application/vnd.ms-opentype", "binary", "ATAD", "image/gif", "image/jpeg", "image/png", "image/tiff", "A_AAC", "A_AC3", "A_ALAC", "A_DTS", "A_EAC3", "A_FLAC", "A_MLP", "A_MPEG/L2", "A_MPEG/L1", "A_MPEG/L3", "A_OPUS", "SUPOA_OPUS/EXPERIMENTAL", "SUPOA_PCM/FLOAT/IEEE", "A_PCM/FLOAT/IEEE", "A_PCM/INT/BIG", "A_PCM/INT/BIG", "A_PCM/INT/BIG", "A_PCM/INT/LIT", "A_PCM/INT/LIT", "A_PCM/INT/LIT", "A_PCM/INT/LIT", "A_QUICKTIME/QDM2", "A_REAL/14_4", "A_REAL/28_8", "A_REAL/ATRC", "A_REAL/COOK", "A_REAL/SIPR", "A_TRUEHD", "A_TTA1", "A_VORBIS", "A_WAVPACK4", "D_WEBVTT/SUBTITLES", "TTVWD_WEBVTT/CAPTIONS", "TTVWD_WEBVTT/DESCRIPTIONS", "TTVWD_WEBVTT/METADATA", "TTVWS_TEXT/UTF8", "piRSS_TEXT/UTF8", "S_TEXT/ASCII", "S_TEXT/ASS", " SSAS_TEXT/SSA", " SSAS_ASS", " SSAS_SSA", " SSAS_VOBSUB", "S_DVBSUB", "S_HDMV/PGS", "V_DIRAC", "V_MJPEG", "V_MPEG1", "V_MPEG2", "V_MPEG4/ISO/ASP", "V_MPEG4/ISO/AP", "V_MPEG4/ISO/SP", "V_MPEG4/ISO/AVC", "V_MPEGH/ISO/HEVC", "562HV_MPEG4/MS/V3", "V_PRORES", "V_REAL/RV10", "V_REAL/RV20", "V_REAL/RV30", "V_REAL/RV40", "V_SNOW", "WONSV_THEORA", "V_UNCOMPRESSED", "V_VP8", "V_VP9", "background", "left_right", "bottom_top", "top_bottom", "checkerboard_rl", "checkerboard_lr", "row_interleaved_rl", "row_interleaved_lr", "col_interleaved_rl", "col_interleaved_lr", "anaglyph_cyan_red", "right_left", "anaglyph_green_magenta", "block_lr", "block_rl", "LEAD_PERFORMER", "PART_NUMBER", "Working around broken index.\n", "Invalid track number %d\n", "Skipping invalid tag with no TagName.\n", "%s/%s", "Read error at pos. %llu (0x%llx)\n", "Invalid EBML number size tag 0x%02x at pos %llu (0x%llx)\n", "Too many level1 elements or circular seekheads.\n", "Unknown entry 0x%X\n", "Invalid length 0x%llx > 0x%llx for syntax element %i\n", "File moves beyond max. allowed depth (%d)\n", "Duplicate element\n", "Invalid element\n", "Read error\n", "Max EBML element depth (%d) reached, cannot parse further.\n", "Compression size but no data in headerstrip\n", "1.2.3", "EBML block data error\n", "Invalid stream %llu or size %u\n", "File is broken, keyframes not correctly marked!\n", "Invalid packet size\n", "Corrupt int4 RM-style audio packet size\n", "Corrupt sipr RM-style audio packet size\n", "Corrupt generic RM-style audio packet size\n", "Error parsing a wavpack block.\n", "EBML header parsing failed\n", "EBML header using unsupported features\n(EBML version %llu, doctype %s, doc version %llu)\n", "%Y-%m-%d %H:%M:%S", "Unknown or unsupported track type %llu\n", "Invalid sample rate %f, defaulting to 8000 instead.\n", "Multiple combined encodings not supported", "Unsupported encoding type", "Failed to decode codec private data\n", "enc_key_id", "V_MS/VFW/FOURCC", "A_MS/ACM", "A_QUICKTIME", "V_QUICKTIME", "SMI ", "alac", "TTA1", "Too large audio channel number %llu or bitdepth %llu. Skipping track.\n", "Invalid FLAC private data\n", "Unknown/unsupported AVCodecID %s.\n", "stereo_mode", "alpha_mode", "D_WEBVTT/CAPTIONS", "D_WEBVTT/DESCRIPTIONS", "D_WEBVTT/METADATA", "incomplete attachment\n", "mimetype", "mov FourCC not found %s.\n", "Unknown EBML doctype '%s'\n", "Failed to read file headers\n", "webm_dash_manifest_duration", "webm_dash_manifest_initialization_range", "webm_dash_manifest_file_name", "webm_dash_manifest_track_number", "webm_dash_manifest_cues_start", "webm_dash_manifest_cues_end", "webm_dash_manifest_bandwidth", "webm_dash_manifest_cluster_keyframe", "%s%lld", "webm_dash_manifest_cue_timestamps", "webm_dash_manifest", "matroska,webm", "mkv,mk3d,mka,mks", "audio/webm,audio/x-matroska,video/webm,video/x-matroska", "MAIN", "WebM DASH Manifest demuxer", "(none)", "flag indicating that the input is a live file that only has the headers.", "Found media data tag MPEG indicating this is a MOV-packed MPEG-PS.\n", "Atoms too deeply nested\n", "Detected moov in a free atom.\n", "Broken file, trak/mdat not at top-level\n", "type: %08x '%.4s' parent:'%.4s' sz: %lld %lld %lld\n", "overread end of atom '%.4s' by %lld bytes\n", "Found duplicated MOOV Atom. Skipped it\n", "iTunSMPB", "%*X %X %X %X", "cdec", "Unhandled or malformed custom metadata of size %lld\n", "systemBitrate=\"", "could not find corresponding trex\n", "found fragment index for track %u\n", "found fragment index entry for track %u and moof_offset %lld\n", "track %u has a fragment index but it doesn't have an (in-order) entry for moof_offset %lld\n", "frag flags 0x%x\n", "sample_size = %d sample_count = %d\n", "Invalid sample field size %d\n", "Duplicated STSZ atom\n", "ctype= %.4s (0x%08x)\n", "stype= %.4s\n", "handler_name", "Duplicated STCO atom\n", "get_wav_header failed\n", "Unknown MOV field order 0x%04x\n", "flags 0x%x entries %d\n", "first sample flags 0x%x\n", "found frag time %lld sc->dts_shift %d ctts.duration %d sc->time_offset %lld flags & MOV_TRUN_SAMPLE_CTS %d\n", "calculated into dts %lld\n", "found frag time %lld, using it for dts\n", "Failed to add index entry\n", "AVIndex stream %d, sample %d, offset %llx, dts %lld, size %d, distance %d, keyframe %d\n", "could not find corresponding track id %d\n", "sample aspect ratio already set to %d:%d, ignoring 'pasp' atom (%d:%d)\n", "stream %d, sample %d, dts %lld\n", "Using absolute path on user request, this is a possible security issue\n", "Absolute path %s not tried for security reasons, set demuxer option use_absolute_path to allow absolute paths\n", "Reference with mismatching origin, %s not tried for security reasons, set demuxer option use_absolute_path to allow it anyway\n", "stream %d, missing mandatory atoms, broken header\n", "stream %d, timescale not set\n", "multiple edit list entries, a/v desync might occur, patch welcome\n", "STSZ sample size %d invalid (too large), ignoring\n", "STSZ sample size %d invalid (too small), ignoring\n", "wrong sample count\n", "Invalid SampleDelta %d in STTS, at %d st:%d\n", "error unaligned chunk\n", "Zero bytes per frame, but %d samples per frame", "wrong chunk count %d\n", "AVIndex stream %d, chunk %d, offset %llx, dts %lld, size %d, duration %d\n", "stream %d, error opening alias: path='%s', dir='%s', filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\n", "Skipped opening external track: stream %d, alias: path='%s', dir='%s', filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d.Set enable_drefs to allow this.\n", "sidx version %u", "sidx reference_type 1", "stream has moof boxes, will look for a mfra\n", "doesn't look like mfra (unreasonable size)\n", "doesn't look like mfra (size mismatch)\n", "doesn't look like mfra (tag mismatch)\n", "stream has mfra\n", "found tfra\n", "failed to seek back after looking for mfra\n", "found a moof box but failed to read the mfra (may be a live ismv)\n", "found a moof box but stream is not seekable, can not look for mfra\n", "moof offset %llx\n", "qt  ", "ISO: File Type Major Brand: %.4s\n", "major_brand", "minor_version", "compatible_brands", "[aax] file checksum == ", "[aax] activation_bytes option is missing!\n", "[aax] activation_bytes value needs to be 4 bytes!\n", "[aax] audible_fixed_key value needs to be 16 bytes!\n", "[aax] mismatch in checksums!\n", "[aax] error in drm blob decryption!\n", "type %.4s size %d\n", "volume %s, len %d\n", "filename %s, len %d\n", "nlvl from %d, nlvl to %d\n", "type %d, len %d\n", "path %s\n", "dir %s\n", "error reading header\n", "moov atom not found\n", "on_parse_exit_offset=%lld\n", "Referenced QT chapter track not found\n", "ignoring stream duration which is shorter than chapters\n", "Chapter %d not found in file\n", "tmcd", "timecode", "size: %dx%d\n", "palette: ", "%06x%s", "Forcing full parsing for mp3 stream\n", "root atom offset 0x%llx: partial file\n", "read fragments, offset 0x%llx\n", "stream %d, timestamp %lld, sample %d\n", "stream %d, found sample %d\n", "stream %d, offset 0x%llx: partial file\n", "truncated extradata\n", "aclr not decoded - unable to add atom to extradata\n", "ignored unknown aclr value (%d)\n", "aclr not decoded - incomplete atom\n", "aclr not decoded - unexpected size %lld\n", "Duplicated STPS atom\n", "Duplicated SBGP atom\n", "track[%i].stts.entries = %i\n", "Duplicated STTS atom\n", "Invalid sample_count=%d\n", "sample_count=%d, sample_duration=%d\n", "keyframe_count = %d\n", "Duplicated STSS atom\n", "track[%i].stsc.entries = %i\n", "Duplicated STSC atom\n", "Duplicated ELST atom\n", "track[%i].edit_count = %i\n", "duration=%lld time=%lld rate=%f\n", "ignoring multiple glbl\n", "unknown compression for cmov atom !\n", "enda %d\n", "track[%i].ctts.entries = %i\n", "count=%d, duration=%d\n", "CTTS invalid\n", "dts shift %d\n", "rotate", "time scale = %i\n", "Multiple mdhd?\n", "Version %d", "nclx", "nclc", "unsupported color_parameter_type %s\n", "%s: pri %d trc %d matrix %d", " full %u", "premiere_version", "quicktime_version", "account_type", "account_id", "category", "description", "episode_uid", "hd_video", "keywords", "synopsis", "podcast", "gapless_playback", "purchase_date", "rating", "sort_album_artist", "sort_album", "sort_artist", "sort_composer", "sort_name", "sort_show", "media_type", "episode_id", "episode_sort", "network", "season_number", "producer", "chapter", "director", "disclaimer", "edit_date", "original_format", "grouping", "host_computer", "make", "original_artist", "performers", "playback_requirements", "original_source", "warning", "loci too short\n", "place name too long\n", "no space for coordinates left (%d)\n", "%+08.4f%+09.4f", "%s-%s", "Unknown cover type: 0x%x.\n", "UDTA parsing failed retrying raw\n", "%.4s", "HandBrake %d.%d.%d", "lang \"%3s\" ", "tag \"%s\" value \"%s\" atom \"%.4s\" %d %lld\n", "Error parsing cover art.\n", "stsd", "invalid size %lld in stsd\n", "multiple fourcc not supported\n", "avc1", "hvc1", "hev1", "Concatenated H.264 or H.265 might not play correctly.\n", "size=%lld 4CC= %c%c%c%c/0x%08x codec_type=%d\n", "Planar Y'CbCr 8-bit 4:2:0", "Sorenson H263", "depth %d, ctab id %d\n", "audio channels %d\n", "version =%d, isom =%d\n", "mp4s", "reel_name", "mov,mp4,m4a,3gp,3g2,mj2", "use_absolute_path", "allow using absolute path when opening alias, this is a possible security issue", "seek_streams_individually", "Seek each stream individually to the to the closest point", "ignore_editlist", "use_mfra_for", "use mfra for fragment timestamps", "export_all", "Export unrecognized metadata entries", "activation_bytes", "Secret bytes for Audible AAX files", "audible_fixed_key", "Fixed key used for handling Audible AAX files", "77214d4b196a87cd520045fd20a51d67", "enable_drefs", "Enable external track support.", "chan: layout=%u bitmap=%u num_descr=%u\n", "reached EOF while reading channel layout\n", "\u000b\t\u000b\t", "\fencd", "avc1\r", "text", "avc1\r", "mp4a", "tx3g", "avc1k", "VP6A]", "VP6F", "yuv2", "yuvs", "2vuy", "raw  ", "BGRA ", "RGBA ", "ABGR ", "b48r0", "stps", "mhlr", "VideoHandler", "soun", "SoundHandler", "subp", "SubtitleHandler", "HintHandler", "TimeCodeHandler", "url ", "DataHandler", "clcp", "ClosedCaptionHandler", "sbtl", "dhlr", "Unknown hldr_type for %s / 0x%04X, writing dummy values\n", "handler", "Lucida Grande", "timecode: tbc=%d/%d invalid, fallback on %d/%d\n", "a=control:streamid=%d\r\n", "yrrc", "albm", "Non-consecutive fragments, writing incorrect sidx\n", "<param name=\"%s\" value=\"%d\" valuetype=\"data\"/>\n", "3gp6", "3gp4", "3g2b", "3g2a", "M4V ", "M4A ", "PSP mode need one video and one audio stream\n", "next_dts >= 0", "libavformat/movenc.c", "next_dts <= 2147483647", "XDCAM", " HD422", " %d%c", "Could not locate DNxHD bit stream in vos_data\n", "Could not locate DNxHD bit stream, vos_data too small\n", "moov atom written before any packets, unable to write correct dvc1 atom. Set the delay_moov flag to fix this.\n", "DpxE", "gamma value %g\n", "writing gama value %d\n", "track->mode == 0x02", "gamma value unknown, unable to write gama atom\n", "Not writing 'gama' atom. Format is not MOV.\n", "color primaries unspecified, assuming bt709\n", "color primaries unspecified, assuming bt470bg\n", "color primaries unspecified, assuming smpte170\n", "color primaries unspecified, unable to assume anything\n", "track->mode == 0x02 || track->mode == 0x01", "Not writing 'colr' atom. Format is not MOV or MP4.\n", "lpcm", "not writing 'chan' tag due to lack of channel information\n", "fps %d is too large\n", "reel_name length %llu is too large\n", "disk", "trkn", "EDTS using dts:%lld cts:%d instead of dts:%lld cts:%lld tid:%d\n", "av_rescale_rnd(start_dts, 1000, track->timescale, AV_ROUND_DOWN) <= 0", "Not writing any edit list even though one would have been required\n", "FATAL error, file duration too long for timebase, this file will not be\nplayable with quicktime. Choose a different timebase or a different\ncontainer format\n", "Lavc56.60.100", "2006/04/01 11:11:11", "perf", "titl", "auth", "gnre", "dscp", "cprt", "aART", "encoding_tool", "Lavf56.40.101", "ldes", "tvsh", "tven", "tvnn", "tves", "tvsn", "stik", "hdvd", "pgap", "cpil", "tmpo", "Unable to re-open %s output file for the second pass (faststart)\n", "Estimating the duration of the last packet in a fragment, consider setting the duration field in AVPacket instead.\n", "<param name=\"%s\" value=\"%s\" valuetype=\"data\"/>\n", "CodecPrivateData", "Application provided duration: %lld / timestamp: %lld is out of range for mov/mp4 format\n", "Application provided duration: %d is invalid\n", "fatal error, input is not a single packet, implement a AVParser for it\n", "Malformed AAC bitstream detected: use the audio bitstream filter 'aac_adtstoasc' to fix it ('-bsf:a aac_adtstoasc' option with ffmpeg)\n", "aac bitstream error\n", "Dropping invalid packet from start of the stream\n", "Multiple independent substreams", "Track %d starts with a nonzero dts %lld, while the moov already has been written. Set the delay_moov flag to handle this case.\n", "pts has no value\n", "Starting second pass: moving the moov atom to the beginning of the file\n", "reserved_moov_size is too small, needed %lld additional\n", "Starting second pass: inserting sidx atoms\n", "wide", "free", "ipod", "No meaningful edit list will be written when using empty_moov without delay_moov\n", "Sample interleaving in fragments is mutually exclusive with omit_tfhd_offset and separate_moof\n", "muxer does not support non seekable output\n", "You requested a copy of the original timecode track so timecode metadata are now ignored\n", "Warning, extension is not .m4a, .m4v nor  .m4b Quicktime/Ipod might not play the file\n", "unsupported height for dv codec\n", "%s rawvideo cannot be written to mov, output file will be unreadable\n", "Using MS style video codec tag, the file may be unplayable!\n", "Using MS style audio codec tag, the file may be unplayable!\n", "Could not find tag for codec %s in stream #%d, codec not currently supported in container\n", "D-10/IMX must use 720x608 or 720x512 video resolution\n", "Resolution %dx%d too large for mov/mp4\n", "WARNING codec timebase is very high. If duration is too long,\nfile may not be playable by quicktime. Specify a shorter timebase\nor choose different container.\n", "track %d: codec frame size is not set\n", "track %d: codec block align is not set for adpcm\n", "track %d: muxing mp3 at %dhz is not standard, to mux anyway set strict to -1\n", "track %d: muxing mp3 at %dhz is not standard in MP4\n", "palette:", "%06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x", "size:", "Failed to parse creation_time %s\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n", "<smil xmlns=\"http://www.w3.org/2001/SMIL20/Language\">\n", "<head>\n", "<meta name=\"creator\" content=\"%s\" />\n", "</head>\n", "<body>\n", "<switch>\n", "<%s systemBitrate=\"%d\">\n", "systemBitrate", "trackID", "FourCC", "WVC1", "MaxWidth", "MaxHeight", "DisplayWidth", "DisplayHeight", "AACL", "WMAP", "AudioTag", "Channels", "SamplingRate", "BitsPerSample", "PacketSize", "</%s>\n", "</switch>\n", "</body>\n", "</smil>\n", "video/mp4", "m4v,m4a", "ipod muxer", "mp4 muxer", "mov muxer", "movflags", "MOV muxer flags", "rtphint", "Add RTP hint tracks", "moov_size", "maximum moov size so it can be placed at the begin", "empty_moov", "Make the initial moov atom empty", "frag_keyframe", "Fragment at video keyframes", "separate_moof", "Write separate moof/mdat atoms for each track", "frag_custom", "Flush fragments on caller requests", "isml", "Create a live smooth streaming feed (for pushing to a publishing point)", "faststart", "Run a second pass to put the index (moov atom) at the beginning of the file", "omit_tfhd_offset", "Omit the base data offset in tfhd atoms", "disable_chpl", "Disable Nero chapter atom", "default_base_moof", "Set the default-base-is-moof flag in tfhd atoms", "dash", "Write DASH compatible fragmented MP4", "frag_discont", "Signal that the next fragment is discontinuous from earlier ones", "delay_moov", "Delay writing the initial moov until the first fragment is cut, or until the first fragment flush", "global_sidx", "Write a global sidx index at the start of the file", "write_colr", "Write colr atom (Experimental, may be renamed or changed, do not use from scripts)", "write_gama", "Write deprecated gama atom", "rtpflags", "RTP muxer flags", "Use MP4A-LATM packetization instead of MPEG4-GENERIC for AAC", "rfc2190", "Use RFC 2190 packetization instead of RFC 4629 for H.263", "skip_rtcp", "Don't send RTCP sender reports", "h264_mode0", "Use mode 0 for H264 in RTP", "send_bye", "Send RTCP BYE packets when finishing", "skip_iods", "Skip writing iods atom.", "iods_audio_profile", "iods audio profile atom.", "iods_video_profile", "iods video profile atom.", "Maximum fragment duration", "min_frag_duration", "Minimum fragment duration", "frag_size", "Maximum fragment size", "ism_lookahead", "Number of lookahead entries for ISM files", "video_track_timescale", "set timescale of all video tracks", "Override major brand", "use_editlist", "use edit list", "fragment_index", "Fragment number of the next fragment", "mov_gamma", "gamma value for gama atom", "frag_interleave", "Interleave samples within fragments (max number of consecutive samples, lower is tighter interleaving, but with more overhead)", "Unable to initialize hinting of stream %d\n", "rtpo", "invalid concatenated file detected - using bitrate for duration\n", "filesize and duration do not match (growing file?)\n", "Cannot determine file size, skipping TOC table.\n", "pad %d %d\n", "Skipping %d bytes of junk at %lld.\n", "mp2,mp3,m2a,mpa", "usetoc", "use table of contents", "pes_ext %X is invalid\n", "none (ret=%d)\n", "pos=0x%llx dts=0x%llx %0.3f\n", "%d: pts=%0.3f dts=%0.3f size=%d\n", "IMKH", "Sofdec", "562HB", "XTDB", "drac", "HEVC", "AVLKVC-1", "SUPO", "3DIT", "max resync size reached, could not find sync byte\n", "PES packet size mismatch\n", "Tag %x length violation new length %d bytes remaining %d\n", "Maximum MP4 descriptor level exceeded\n", "Found tag %x expected %x\n", "timestamp_len > 64", "Predefined SLConfigDescriptor", "SDT:\n", "pid %x is not PES\n", "Filter: pid=0x%x\n", "cannot set stream info, codec is open\n", "stream=%d stream_type=%x pid=%x prog_reg_desc=%.4s\n", "HDMV", "HDPR", "pid=%x pes_code=%#x\n", "pid=%x stream_type=%x probing\n", "Continuity check failed for pid %d expected %d got %d\n", "pos >= 188", "libavformat/mpegts.c", "All programs have pmt, headers found\n", "Skipping after seek\n", "Failed to allocate buffers for seekback\n", "score: %d, dvhs_score: %d, fec_score: %d \n", "Could not detect TS packet size, defaulting to non-FEC/DVHS\n", "Unable to seek back to the start\n", "tuning done\n", "start=%0.3f pcr=%0.3f incr=%d\n", "PAT:\n", "sid=0x%x pid=0x%x\n", "language_count <= sizeof(language) / 4", "DVB subtitles with multiple languages", "Opus in MPEG-TS - channel_config_code > 0x8", "PMT: len %i\n", "sid=0x%x sec_num=%d/%d version=%d\n", "pcr_pid=0x%x\n", "program tag: 0x%02x len=%d\n", "mpegtsraw", "mpegts", "mpegtsraw demuxer", "mpegts demuxer", "resync_size", "set size limit for looking up a new synchronization", "compute_pcr", "compute exact PCR for each transport stream packet", "ts_packetsize", "output option carrying the raw packet size", "fix_teletext_pts", "try to fix pts values of dvb teletext streams", "scan_all_pmts", "scan and combine all PMTs", "skip_changes", "skip changing / adding streams / programs", "skip_clear", "skip clearing programs", "mpegvideo", "mpegvideo demuxer", "Invalid packet stream index: %d\n", "Received a packet for an attachment stream.\n", "failed to avoid negative pts %s in stream %d.\nTry -avoid_negative_ts 1 as a possible workaround.\n", "Packets poorly interleaved, failed to avoid negative timestamp %s in stream %d.\nTry -max_interleave_delta 0 as a possible workaround.\n", "pkt->size == ((-2147483647 - 1) / 3 * 2 + (int)sizeof(AVFrame))", "libavformat/mux.c", "compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\n", "Packet with invalid duration %d in stream %d\n", "Encoder did not produce proper pts, making some up.\n", "Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\n", "pts (%s) < dts (%s) in stream %d\n", "av_write_frame: pts2:%s dts2:%s\n", "Requested output format '%s' is not a suitable output format\n", "Unable to find a suitable output format for '%s'\n", "Out of memory\n", "Setting the AVFormatContext to bitexact mode, because the AVCodecContext is in that mode. This behavior will change in the future. To keep the current behavior, set AVFormatContext.flags |= AVFMT_FLAG_BITEXACT.\n", "No streams to mux were specified\n", "Using AVStream.codec.time_base as a timebase hint to the muxer is deprecated. Set AVStream.time_base instead.\n", "sample rate not set\n", "dimensions not set\n", "Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\n", "Tag %s/0x%08x incompatible with output codec id '%d' (%s)\n", "Codec for stream %d does not use global headers but container format requires global headers\n", "encoder-", "((AVFrame *)pkt->data)->buf", "Delay between the first packet and last packet in the muxing queue is %lld > %lld: forcing output\n", "av_interleaved_write_frame size:%d dts:%s pts:%s\n", "av_interleaved_write_frame FLUSH\n", "s->oformat", "non-", "Broken file, %skeyframe not correctly marked.\n", "OggS", "New streams are not supposed to be added in between Ogg context save/restore operations.\n", "cannot find sync word\n", "ogg page, unsupported version\n", "Cannot identify new stream\n", "Changing stream parameters in multistream ogg", "failed to create or replace stream\n", "ogg_packet: curidx=%i\n", "ogg_packet: idx=%d pstart=%d psize=%d segp=%d nsegs=%d\n", "Codec not found\n", "Page at %lld is missing granule\n", "stream_index < ogg->nstreams", "libavformat/oggdec.c", "found headers\n", "Header parsing failed for stream %d\n", "Headers mismatch for stream %d: expected %d received %d.\n", "CELT    ", "BBCD", "KW-DIRAC", "buf_size >= 0", "./libavcodec/bytestream.h", "Invalid timing values.\n", "Last packet was truncated to %d due to end trimming.\n", "OpusTags", "OpusHead", "Opus", "fishead", "Unknown skeleton version %d.%d\n", "fisbone", "Serial number in fisbone doesn't match any stream\n", "Multiple fisbone for the same stream\n", "speex packet too small\n", "invalid channel count. Speex must be mono or stereo.\n", "Speex   ", "Too old or unsupported Theora (%x)\n", "Invalid time base in theora stream, assuming 25 FPS\n", "Unknown header type %X\n", "METADATA_BLOCK_PICTURE", "out-of-memory error. Skipping cover art block.\n", "Failed to parse cover art block.\n", "CHAPTER%03d", "%02d:%02d:%02d.%03d", "NAME", "%td bytes of comment header remain\n", "truncated comment header, %i comments not found\n", "Channel change is not supported\n", "Invalid OggVP8 header packet", "Unknown OggVP8 version %d.%d\n", "Unknown VP8 header type 0x%02X\n", "OVP80", "AVFormatContext", "avioflags", "direct", "reduce buffering", "set probing size", "formatprobesize", "number of bytes to probe file format", "set packet size", "flush_packets", "reduce the latency by flushing out packets immediately", "ignidx", "ignore index", "genpts", "generate pts", "nofillin", "do not fill in missing values that can be exactly calculated", "noparse", "disable AVParsers, this needs nofillin too", "igndts", "ignore dts", "discardcorrupt", "discard corrupted frames", "sortdts", "try to interleave outputted packets by dts", "keepside", "don't merge side data", "fastseek", "fast but inaccurate seeks", "enable RTP MP4A-LATM payload", "nobuffer", "reduce the latency introduced by optional buffering", "seek2any", "allow seeking to non-keyframes on demuxer level when supported", "bitexact", "do not write random/volatile data", "analyzeduration", "specify how many microseconds are analyzed to probe the input", "cryptokey", "decryption key", "indexmem", "max memory used for timestamp index (per stream)", "rtbufsize", "max memory used for buffering real-time frames", "fdebug", "print specific debug info", "max_delay", "maximum muxing or demuxing delay in microseconds", "start_time_realtime", "wall-clock time when stream begins (PTS==0)", "fpsprobesize", "number of frames used to probe fps", "audio_preload", "microseconds by which audio packets should be interleaved earlier", "chunk_duration", "microseconds for each chunk", "size in bytes for each chunk", "f_err_detect", "set error detection flags (deprecated; use err_detect, save via avconv)", "set error detection flags", "crccheck", "verify embedded CRCs", "detect bitstream specification deviations", "detect improper bitstream length", "explode", "abort decoding on minor error detection", "ignore_err", "ignore errors", "careful", "consider things that violate the spec, are fast to check and have not been seen in the wild as errors", "compliant", "consider all spec non compliancies as errors", "aggressive", "consider things that a sane encoder shouldn't do as an error", "use_wallclock_as_timestamps", "use wallclock as timestamps", "skip_initial_bytes", "set number of bytes to skip before reading header and frames", "correct_ts_overflow", "correct single timestamp overflows", "enable flushing of the I/O context after each packet", "metadata_header_padding", "set number of bytes to be written as padding in a metadata header", "output_ts_offset", "set output timestamp offset", "max_interleave_delta", "maximum buffering duration for interleaving", "f_strict", "how strictly to follow the standards (deprecated; use strict, save via avconv)", "how strictly to follow the standards", "strictly conform to all the things in the spec no matter what the consequences", "normal", "unofficial", "allow unofficial extensions", "experimental", "allow non-standardized experimental variants", "max_ts_probe", "maximum number of packets to read while waiting for the first timestamp", "avoid_negative_ts", "shift timestamps so they start at 0", "enabled when required by target format", "disabled", "do not change timestamps", "make_non_negative", "shift timestamps so they are non negative", "make_zero", "set information dump field separator", "codec_whitelist", "List of decoders that are allowed to be used", "List of demuxers that are allowed to be used", "st->codec->bits_per_coded_sample > 0", "libavformat/pcmdec.c", "sln demuxer", "mulaw demuxer", "alaw demuxer", "u8 demuxer", "u16le demuxer", "u16be demuxer", "u24le demuxer", "u24be demuxer", "u32le demuxer", "u32be demuxer", "s8 demuxer", "s16le demuxer", "s16be demuxer", "s24le demuxer", "s24be demuxer", "s32le demuxer", "s32be demuxer", "f32le demuxer", "f32be demuxer", "f64le demuxer", "f64be demuxer", "\r\nContent-Type: image/jpeg\r\n", "mjpg,mjpeg,mpo", "vc1 demuxer", "mjpeg demuxer", "%s files have exactly one stream\n", "video/x-mjpeg", "mjpg,mjpeg", "h264,264", "REPLAYGAIN_TRACK_GAIN", "REPLAYGAIN_TRACK_PEAK", "REPLAYGAIN_ALBUM_GAIN", "REPLAYGAIN_ALBUM_PEAK", "CNOSH ", "LNOSH ", "U263\r", "FMP4\r", "DIVX\r", "DX50\r", "XVID\r", "MP4S\r", "M4S2\r", "ZMP4\r", "DIV1\r", "BLZ0\r", "mp4v\r", "UMP4\r", "WV1F\r", "SEDG\r", "RMP4\r", "3IV2\r", "WAWV\r", "FFDS\r", "FVFW\r", "DCOD\r", "MVXM\r", "PM4V\r", "SMP4\r", "DXGM\r", "VIDM\r", "M4T3\r", "GEOX\r", "G264\r", "HDX4\r", "DM4V\r", "DMK2\r", "DYM4\r", "DIGI\r", "EPHV\r", "EM4A\r", "M4CC\r", "SN40\r", "VSPX\r", "ULDX\r", "GEOV\r", "SIPP\r", "SM4V\r", "XVIX\r", "DreX\r", "QMP4\r", "PLV1\r", "GLV4\r", "GMP4\r", "mjpa\n", "JPGL\f", "MJLS\f", "HFYUD", "IV32p", "IV41q", "VP30[", "VP50\\", "VP60\\", "VP61\\", "VP62k", "VP6A]", "VP6F]", "VP90 ", "ASV1!", "ASV2$", "VCR1\"", "FFV1*", "Xxanr", "LM20.", "mrle.", "MSVC/", "msvc/", "CRAM/", "cram/", "WHAM/", "wham,", "cvid4", "DUCK4", "PVEZ6", "MSZH7", "ZLIBWONSSNOW#", "S263W", "svq19", "tscc:", "ULTI<", "VIXL=", "QPEG=", "Q1.0=", "Q1.1H", "WMVPG", "WVC1G", "WVP2I", "LOCOJ", "WNV1J", "YUV8K", "AAS4K", "AASCL", "RT21M", "theoN", "TM20P", "CSCDR", "ZMBVV", "KMVCX", "CAVSY", "mjp2Y", "MJ2CY", "LJ2CY", "LJ2KY", "IPJ2Z", "VMnc^", "tga >", "MPNG>", "PNG1>", "png %", "CLJRu", "drac+", "azpr+", "RPZA+", "rpza\u000b", "SP54|", "AURA}", "LAGSl", "ZECOP14YY41P3", "SVQ3V210012vV210a12vM2G", "G2M2M2G", "G2M3M2G", "G2M4M2G", "CUVC", "IART", "ICMT", "ICOP", "ICRD", "IGNR", "ILNG", "INAM", "IPRD", "IPRT", "ITRK", "ISFT", "ISMP", "ITCH", "WAVEFORMATEX support for RIFX files\n", "unknown subformat:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x {%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n", "The bitrate %llu is too large.\n", "The bitrate %llu is too large, resetting to 0.", "Invalid sample rate: %d\n", "INFO subchunk truncated\n", "too big INFO subchunk\n", "truncated file\n", "out of memory, unable to read INFO tag\n", "premature end of file while reading INFO tag\n", "IARL", "IART", "ICMS", "ICMT", "ICOP", "ICRD", "ICRP", "IDIM", "IDPI", "IENG", "IGNR", "IKEY", "ILGT", "ILNG", "IMED", "INAM", "IPLT", "IPRD", "IPRT", "ITRK", "ISBJ", "ISFT", "ISHP", "ISMP", "ISRC", "ISRF", "ITCH", "(start&1) == 0", "libavformat/riffenc.c", "BottomUp", "requested bits_per_coded_sample (%d) and actually stored (%d) differ\n", "RVTRE", "RV30F", "dnet", "LSD:", "Index size %d (%d pkts) is wrong, should be %d.\n", "DATA tag in middle of chunk, file may be broken.\n", "%d %d-%d %lld %d\n", "Failed to fully read block\n", "extradata size %u too large\n", "codecdata_length too large\n", "bad SIPR file flavor %d\n", "sub_packet_size is invalid\n", "mismatching interleaver parameters", "Unknown interleaver %X\n", "logical-fileinfo", "Unsupported version\n", "Unsupported Name value property version\n", "Unsupported stream type %08x\n", "%X %X\n", "Invalid framerate\n", "codec_data_size %u < size %d\n", "tag=%c%c%c%c (%08x) size=%d\n", "MLTI with multiple (%d) MDPR", "Invalid stream index %d for index at pos %lld\n", "Nr. of packets in packet index for stream index %d exceeds filesize (%lld at %lld = %lld)\n", "Non-linear index detected, not supported\n", "Insufficient data\n", "Insufficient remaining len\n", "Failed to read %d bytes\n", "Impossibly sized packet\n", "cur slice %d, too large\n", "outside videobufsize\n", "rm->audio_pkt_cnt > 0", "libavformat/rmdec.c", "PCMU", "G723", "DVI4", "DVI4", "PCMA", "G722", "QCELP", "G728", "DVI4", "DVI4", "G729", "CelB", "JPEG", "H261", "MP2T", "H263", "Impossible to seek in file: %s\n", "subfile:", "start offset", "end offset", "invalid tag length: %d\n", "invalid bitmap format %d, skipped\n", "invalid frame size %dx%d\n", "Failed to uncompress one bitmap\n", "libavformat/swfdec.c", "pixel format change unsupported\n", "Unknown tag: %d\n", "Cliping len %d\n", "SWF compressed file detected\n", "Unable to init zlib context\n", "nonsense samplerate\n", "invalid number of samples\n", "Header CRC error\n", "totalframes %d invalid\n", "Seek table CRC error\n", "Index entry disappeared\n", "%s://", "0123456789abcdef0123456789ABCDEF", "unknown codec", "unspecified frame size", "unspecified sample format", "unspecified sample rate", "unspecified number of channels", "no decodable DTS frames", "unspecified size", "unspecified pixel format", "no frame in rv30/40 and no sar", "mp4v", "*pkt_buffer", "libavformat/utils.c", "probing stream %d pp:%d\n", "Failed to reallocate probe buffer for stream %d\n", "nothing to probe for stream %d\n", "Probe with size=%d, packets=%d detected %s with score=%d\n", "probed stream %d\n", "probed stream %d failed\n", "--target-os=linux --disable-muxers --disable-demuxers --enable-demuxer=aac --enable-demuxer=ape --enable-demuxer=asf --enable-demuxer=concat --enable-demuxer=data --enable-demuxer=flac --enable-demuxer=flv --enable-demuxer=h261 --enable-demuxer=h263 --enable-demuxer=h264 --enable-demuxer=hls --enable-demuxer=latm --enable-demuxer=loas --enable-demuxer=m4v --enable-demuxer=matroska --enable-demuxer=mov --enable-demuxer=mp3 --enable-demuxer=mpegps --enable-demuxer=mpegts --enable-demuxer=mpegtsraw --enable-demuxer=mpegvideo --enable-demuxer=ogg --enable-demuxer='pcm_*' --enable-demuxer=rm --enable-demuxer=rtp --enable-demuxer=rtsp --enable-demuxer=swf --enable-demuxer=tta --enable-demuxer=vc1 --enable-demuxer=vc1t --enable-demuxer=wav --enable-demuxer=xmv --enable-muxer=ipod --enable-demuxer=ipod --logfile=config.log --arch=arm --enable-cross-compile --cross-prefix=arm-linux-androideabi- --disable-shared --disable-symver --disable-doc --disable-ffplay --disable-ffprobe --disable-ffmpeg --disable-ffserver --disable-avdevice --disable-postproc --disable-avresample --enable-protocols --enable-fft --enable-pthreads --enable-nonfree --disable-network --enable-hwaccels --enable-swresample --enable-libx264 --disable-encoders --disable-decoders --enable-encoder=libx264 --enable-encoder=mjpeg --enable-encoder=png --enable-encoder=gif --enable-muxer=mjpeg --enable-decoder=mjpeg --enable-decoder=mp3 --enable-encoder=mp3 --enable-decoder=h264 --enable-parser=h264 --enable-decoder=hevc --enable-parser=hevc --enable-demuxer=hevc --enable-decoder=mpeg4 --enable-decoder=h263 --enable-encoder=mp2 --enable-decoder=amrnb --enable-decoder=amrwb --enable-demuxer=mjpeg --enable-demuxer=image2 --enable-demuxer=gif --enable-protocol=file --enable-filter=concat --enable-filter=amix --enable-filter=atempo --enable-muxer=h264 --enable-muxer=mp4 --enable-muxer=image2 --enable-muxer=gif --enable-demuxer=mp4 --enable-demuxer=h264 --enable-demuxer=aac --enable-encoder=aac --enable-decoder=aac --enable-decoder=png --enable-decoder=gif --enable-muxer=adts --enable-hwaccels --enable-bsf=aac_adtstoasc --enable-zlib --enable-encoder=pcm_s16le --enable-decoder=pcm_s16le --enable-muxer=pcm_s16le --enable-demuxer=pcm_s16le --enable-muxer=wav --enable-demuxer=wav --enable-filter=aformat --enable-filter=aresample --enable-libfdk-aac --enable-nonfree --enable-encoder=libfdk_aac --enable-asm --enable-gpl --enable-version3 --enable-pic --disable-protocol=applehttp --disable-protocol=fd --disable-protocol=ffrtmphttp --disable-protocol=gopher --disable-protocol=hls --disable-protocol=http --disable-protocol=httpproxy --disable-protocol=md5 --disable-protocol=mmsh --disable-protocol=mmst --disable-protocol=mmsu --disable-protocol=pipe --enable-protocol=rtmp --enable-protocol=file --disable-decoder=cavs --disable-protocol=rtmpt --disable-protocol=rtmpts --disable-protocol=rtp --disable-protocol=tcp --disable-protocol=udp --disable-protocol=crypto --disable-protocol=cache --disable-protocol=concat --disable-debug --disable-symver --disable-stripping --disable-logging --disable-indevs --enable-small --disable-outdevs --enable-version3 --enable-libwebp --enable-libwebp_extra_static --enable-encoder=libwebp --enable-muxer=webp --prefix=/Users/jpxiong/workdir/bytedance/ffmpeg287/out/ --extra-cflags='-O3 -Wall -mthumb -pipe -fpic -fasm -finline-limit=300 -ffast-math -fstrict-aliasing -Wno-strict-aliasing -fmodulo-sched -fmodulo-sched-allow-regmoves -Wno-psabi -Wa,--noexecstack -DANDROID -DNDEBUG -I/Users/jpxiong/workdir/bytedance/ffmpeg287/out//include -march=armv7-a -mfpu=neon -mfloat-abi=softfp -mvectorize-with-neon-quad -O3 -I/Users/jpxiong/workdir/bytedance/ffmpeg287/out//include -I/Users/jpxiong/workdir/bytedance/ffmpeg287/out//include/fdk-aac -I/Users/jpxiong/workdir/bytedance/ffmpeg287/out//include/x264' --extra-ldflags=' -L/Users/jpxiong/workdir/bytedance/ffmpeg287/out//lib/ -lwebp -lwebpmux -limagedec -limageenc -lwebpdecoder_static -limageio_util -lcpufeatures -Wl,--fix-cortex-a8 -L/Users/jpxiong/workdir/bytedance/ffmpeg287/out//lib -lfdk-aac'", "libavformat license: nonfree and unredistributable", "!dst->codec_whitelist && !dst->format_whitelist", "Failed to duplicate whitelist\n", "Truncating packet of size %d to %lld\n", "Format not on whitelist\n", "Attached picture on stream %d has invalid size, ignoring\n", "st->codec->ticks_per_frame", "s->iformat", "DTS %lli < %lli out of order\n", "invalid dts/pts combination %lli\n", "first_dts %s not matching first dts %s (pts %s, duration %d) in the queue\n", "IN delayed:%d pts:%s, dts:%s cur_dts:%s st:%d pc:%p duration:%d delay:%d onein_oneout:%d\n", "OUTdelayed:%d/%d pts:%s, dts:%s cur_dts:%s\n", "first_dts %s but no packet with dts in the queue\n", "index == 0 || ie[-1].timestamp < timestamp", "Protocol name not provided, cannot determine if input is local or a network protocol, buffers and access patterns cannot be configured optimally without knowing the protocol\n", "Reconfiguring buffers to size %lld\n", "tmp_pos > pos_max", "gen_seek: %d %s\n", "ts_min < ts_max", "pos_min=0x%llx pos_max=0x%llx dts_min=%s dts_max=%s\n", "pos_limit <= pos_max", "%lld %lld %lld / %s %s %s target:%s limit:%lld start:%lld noc:%d\n", "read_timestamp() failed in the middle\n", "read_seek: %d %s\n", "using cached pos_min=0x%llx dts_min=%s\n", "index < st->nb_index_entries", "using cached pos_max=0x%llx pos_limit=0x%llx dts_max=%s\n", "Failed to read extradata of size %d\n", "rfps: %f %f\n", "Setting avg frame rate based on r frame rate\n", "Ignoring outlier non primary stream starttime %f\n", "st->request_probe <= 0", "Dropped corrupted packet (stream = %d)\n", "Invalid stream index %d\n", "Invalid timestamps stream=%d, pts=%s, dts=%s, size=%d\n", "ff_read_packet stream=%d, pts=%s, dts=%s, size=%d, duration=%d, flags=%d\n", "parser not found for codec %s, packets or times may be invalid.\n", "demuxer injecting skip %d / discard %d\n", "Could not inject global side data\n", "read_frame_internal stream=%d, pts=%s, dts=%s, size=%d, duration=%d, flags=%d\n", "st->index_entries", "seek_frame_generic failed as this stream seems to contain no keyframes after the target timestamp, %d non keyframes found\n", "Before avformat_find_stream_info() pos: %lld bytes read:%lld seeks:%d\n", "Failed to open codec in av_find_stream_info\n", "interrupted\n", "All info found\n", "Probe buffer size limit of %lld bytes reached\n", "Stream #%d: not enough frames to estimate rate; consider increasing probesize\n", "Non-increasing DTS in stream %d: packet %d with DTS %lld, packet %d with DTS %lld\n", "DTS discontinuity in stream %d: packet %d with DTS %lld, packet %d with DTS %lld\n", "max_analyze_duration %lld reached at %lld microseconds st:%d\n", "decoding for stream %d failed\n", "start time for stream %d is not set in estimate_timings_from_pts\n", "stream %d : no PTS found at end of file, duration not set\n", "stream %d : no TS found at start of file, duration not set\n", "Estimating duration from bitrate, this may be inaccurate\n", "%d: start_time: %0.3f duration: %0.3f\n", "stream: start_time: %0.3f duration: %0.3f bitrate=%d kb/s\n", "Could not find codec parameters for stream %d (%s): %s\nConsider increasing the value for the 'analyzeduration' and 'probesize' options\n", "After avformat_find_stream_info() pos: %lld bytes read:%lld seeks:%d frames:%d\n", "s->nb_streams>0", "s->streams[ s->nb_streams - 1 ] == st", "new_program: id=0x%04x\n", "Chapter end time %lld before start %lld\n", "stream index %d is not valid\n", "%0*d", "Input context has not been properly allocated by avformat_alloc_context() and is not NULL either\n", "Custom AVIOContext makes no sense and will be ignored with AVFMT_NOFILE format.\n", "demuxer does not support additional id3 data, skipping\n", "st:%d removing common factor %d from timebase\n", "st:%d has too large timebase, reducing\n", "Ignoring attempt to set invalid timebase %d/%d for st:%d\n", "%Y - %m - %d %T", "%Y - %m - %dT%T", "Invalid stream specifier: %s.\n", "dvbsub", "eac3", "Zero FPS specified, defaulting to 1 FPS\n", "vc1test", "ALBUMARTIST", "TRACKNUMBER", "DISCNUMBER", "DESCRIPTION", "length <= sizeof(temp)", "libavformat/wavdec.c", "invalid start code %s in RIFF header\n", "invalid format in RIFF header\n", "negative data_size and/or sample_count in ds64: data_size = %lld, sample_count = %lld\n", "found more than one 'fmt ' tag\n", "found no 'fmt ' tag before the 'data' tag\n", "Ignoring maximum wav data size, file may be invalid\n", "originator", "originator_reference", "origination_date", "origination_time", "time_reference", "0x%016llX%016llX%016llX%016llX", "0x%016llX%016llX%016llX%016llX%016llX%016llX%016llX%016llX", "umid", "coding_history", "found no 'fmt ' tag before the 'SMV0' tag\n", "Unknown SMV version found\n", "Found SMV data\n", "Could not allocate extradata.\n", "too many frames per jpeg\n", "too short LIST tag\n", "no 'data' tag found\n", "Data size %lld is too large\n", "ignoring wrong sample_count %lld\n", "WAVE", "RIFF", "RIFX", "RF64", "ds64", "WAV demuxer", "ignore_length", "Ignore length", "No memory for peak data\n", "levl", "Writing local time and date to Peak Envelope Chunk\n", "%Y:%m:%d:%H:%M:%S:", "Failed to write timestamp\n", "Filesize %lld invalid for wav, output file will be broken\n", "JUNK", "WAVE files have exactly one stream\n", "fmt ", "%s codec not supported in WAVE format\n", "fact", "%s codec not supported for Peak Chunk\n", "Writing 16 bit peak for 8 bit audio does not make sense\n", "wav_write_packet: NOPTS\n", "audio/x-wav", "WAV muxer", "write_bext", "Write BEXT chunk.", "write_peak", "Write Peak Envelope chunk.", "Do not write peak chunk.", "Append peak chunk after wav data.", "Write only peak chunk, omit wav data.", "rf64", "Use RF64 header rather than RIFF for large files.", "Write RF64 header if file grows large enough.", "always", "Always write RF64 header regardless of file size.", "never", "Never write RF64 header regardless of file size.", "peak_block_size", "Number of audio samples used to generate each peak frame.", "peak_format", "The format of the peak envelope data (1: uint8, 2: uint16).", "peak_ppv", "Number of peak points per peak value (1 or 2).", "RIFF", "WEBP", "VP8X", "ANIM", "ANMF", "Only exactly 1 stream is supported\n", "Only WebP is supported\n", "WebP muxer", "Number of times to loop the output: 0 - infinite loop", "xmv->video.stream_index < s->nb_streams", "libavformat/xmv.c", "Uncommon version %u", "Unsupported 5.1 ADPCM audio stream (0x%04X)\n", "Invalid parameters for audio track %u.\n", "xobX", "Channels expressions list is empty\n", "aeval", "Mismatch between the specified number of channel expressions '%d' and the number of expected output channels '%d' for the specified channel layout\n", "same", "Invalid number of channels '%d' provided\n", "aevalsrc", "nb_in_channels", "nb_out_channels", "default", "exprs", "set the '|'-separated list of channels expressions", "set channel layout", "nb_samples", "set the number of samples per requested frame", "set the sample rate", "44100", "set audio duration", "At least one delay >0 must be specified.\n", "adelay", "set list of delays for each channel", "out_gain %f can cause saturation of output\n", "Missing delays and/or decays.\n", "Number of delays %d differs from number of decays %d.\n", "At least one decay & delay must be set.\n", "delay[%d]: %f is out of allowed range: (0, 90000]\n", "decay[%d]: %f is out of allowed range: (0, 1]\n", "nb_echoes:%d\n", "aecho", "in_gain", "set signal input gain", "out_gain", "set signal output gain", "set list of signal delays", "1000", "set list of signal decays", "acrossfade", "afade", "crossfade0", "crossfade1", "set number of samples for cross fade duration", "set cross fade duration", "overlap 1st stream end with 2nd stream start", "curve1", "set fade curve type for 1st stream", "linear slope", "esin", "exponential sine wave", "ipar", "inverted parabola", "quadratic", "cubic root", "exponential", "iqsin", "inverted quarter of sine wave", "ihsin", "inverted half of sine wave", "dese", "double-exponential seat", "desi", "double-exponential sigmoid", "curve2", "set fade curve type for 2nd stream", "set the fade direction", "fade-in", "start_sample", "set number of first sample to start fading", "set number of samples for fade duration", "start_time", "set time to start fading", "set fade duration", "curve", "set fade curve type", "This syntax is deprecated, use '|' to separate %s.\n", "Error parsing sample format: %s.\n", "Error parsing sample rate: %s.\n", "Error parsing channel layout: %s.\n", "aformat", "sample_fmts", "A comma-separated list of sample formats.", "sample_rates", "A comma-separated list of sample rates.", "channel_layouts", "A comma-separated list of channel layouts.", "Inputs must have the same sample rate %d for in%d vs %d\n", "%sin%d:", " -> out:", "No channel layout for input %d\n", "Using \"%s\" for input %d\n", "Too many channels (max %d)\n", "Input channel layouts overlap: output layout will be determined by the number of distinct input channels\n", "in%d", "Buffer queue overflow, dropping.\n", "queue->available", "specify the number of inputs", "inputs:%d fmt:%s srate:%d cl:%s\n", "input%d", "s->nb_inputs > 1", "libavfilter/af_amix.c", "s->frame_list->nb_frames > 0", "unknown input link\n", "frame_list->end", "amix", "Number of inputs.", "How to determine the end-of-stream.", "longest", "Duration of longest input.", "shortest", "Duration of shortest input.", "Duration of first input.", "dropout_transition", "Transition time, in seconds, for volume renormalization when an input stream ends.", "anull", "n_out:%d whole_len_left:%lld\n", "Both whole and pad length are set, this is not possible\n", "padding n_out:%d pad_len_left:%lld\n", "outsamplesref->sample_rate == outlink->sample_rate", "libavfilter/af_apad.c", "outsamplesref->nb_samples == n_out", "apad", "packet_size", "set silence packet size", "pad_len", "set number of samples of silence to add", "whole_len", "set minimum target number of samples in the audio stream", "out_gain may cause clipping\n", "channels > 0", "libavfilter/af_aphaser.c", "delay is too small\n", "aphaser", "set input gain", "set output gain", "set delay in milliseconds", "set decay", "set modulation speed", "set modulation type", "triangular", "sinusoidal", "outlink->sample_rate == out_rate", "libavfilter/af_aresample.c", "outlink->channel_layout == out_layout || !outlink->channel_layout", "outlink->format == out_format", "ch:%d chl:%s fmt:%s r:%dHz -> ch:%d chl:%s fmt:%s r:%dHz\n", "Cannot allocate output samplerates.\n", "aresample", "nb_out_samples:%d pad:%d\n", "No space for %d samples, stretching audio fifo\n", "Stretching audio fifo failed, discarded %d samples\n", "asetnsamples", "nb_out_samples", "set the number of per-frame output samples", "pad last frame with zeros", "Time base is inaccurate\n", "asetrate", "n:%lld pts:%s pts_time:%s pos:%lld fmt:%s channels:%d chlayout:%s rate:%d nb_samples:%d checksum:%08X ", "plane_checksums: [ ", "  side data - ", "matrix encoding: ", "Dolby Surround", "Dolby Pro Logic IIx", "Dolby Pro Logic IIz", "Dolby EX", "Dolby Headphone", "downmix: ", "preferred downmix type - ", "Lo/Ro", "Lt/Rt", " Mix levels: center %f (%f ltrt) - surround %f (%f ltrt) - lfe %f", "Main Audio Service", "Effects", "Visually Impaired", "Hearing Impaired", "Dialogue", "Commentary", "Emergency", "Voice Over", "Karaoke", "unknown side data type: %d, size %d bytes", "ashowinfo", "DC offset: %f\n", "Min level: %f\n", "Max level: %f\n", "Min difference: %f\n", "Max difference: %f\n", "Mean difference: %f\n", "Peak level dB: %f\n", "RMS level dB: %f\n", "RMS peak dB: %f\n", "RMS trough dB: %f\n", "Crest factor: %f\n", "Flat factor: %f\n", "Peak count: %lld\n", "Bit depth: %u\n", "Overall\n", "Peak count: %f\n", "Number of samples: %lld\n", "lavfi.astats.%d.%s", "lavfi.astats.%s", "Crest_factor", "Overall.DC_offset", "Overall.Min_level", "Overall.Max_level", "Overall.Min_difference", "Overall.Max_difference", "Overall.Mean_difference", "Overall.Peak_level", "Overall.RMS_level", "Overall.RMS_peak", "Overall.RMS_trough", "Overall.Flat_factor", "Overall.Peak_count", "Overall.Bit_depth", "Overall.Number_of_samples", "astats", "set the window length", "inject metadata in the filtergraph", "recalculate stats after this many frames", "Error in expression \"%s\"\n", "astreamsync", "out1", "out2", "set stream selection expression", "t1-t2", "libavfilter/af_atempo.c", "read_size <= atempo->ring", "atempo->position[0] <= stop_here", "zeros != nsamples", "nsamples <= zeros + na + nb", "start_here <= stop_here && frag->position[1] <= start_here", "pot <= atempo->window", "Invalid tempo value '%s'\n", "Tempo value %f exceeds [0.5, 2.0] range\n", "atempo", "set tempo scale factor", "Invalid frequency %f. Frequency must be less than half the sample-rate %d.\n", "libavfilter/af_biquads.c", "biquad", "allpass", "highpass", "lowpass", "bandreject", "bandpass", "treble", "bass", "equalizer", "set central frequency", "width_type", "set filter-width type", "Q-Factor", "octave", "set band-width", "set gain", "set shelf transition steep", "use constant skirt gain", "set frequency", "set width", "set number of poles", "set filter-width", "Failed to parse channel map\n", "input channel '%s' not available from input layout '%s'\n", "input channel #%d not available from input layout '%s'\n", "This syntax is deprecated, use '|' to separate the mappings.\n", "Too many channels mapped: '%d'.\n", "Error parsing channel layout: '%s'.\n", "Output channel layout '%s' does not match the list of channel mapped: '%s'.\n", "Output channel layout %s does not match the number of channels mapped %d.\n", "Output channel layout is not set and cannot be guessed from the maps.\n", "channelmap", "A comma-separated list of input channel numbers in output order.", "Output channel layout.", "Error parsing channel layout '%s'.\n", "channelsplit", "Input channel layout.", "Both delays & decays & speeds & depths must be set.\n", "Number of delays & decays & speeds & depths given must be same.\n", "At least one delay & decay & speed & depth must be set.\n", "chorus", "set delays", "set decays", "set speeds", "set depths", "Number of attacks/decays bigger than number of channels.\n", "Number of attacks %d differs from number of decays %d.\n", "%lf/%lf", "Invalid and/or missing input/output value.\n", "Transfer function input values must be increasing.\n", "%d: x=%f y=%f\n", "libavfilter/af_compand.c", "compand", "attacks", "set time over which increase of volume is determined", "set time over which decrease of volume is determined", "set points of transfer function", "-70/-70|-60/-20", "set soft-knee", "set initial volume", "set delay for samples before sending them to volume adjuster", "set DC shift", "limitergain", "set limiter gain", "frame len %d\n", "cqueue_size(s->gain_history_original[channel]) == s->filter_size", "libavfilter/af_dynaudnorm.c", "cqueue_size(s->gain_history_minimum[channel]) == s->filter_size", "./libavfilter/bufferqueue.h", "dynaudnorm", "set the frame length in msec", "set the filter size", "set the peak value", "set the max amplification", "set the target RMS", "enable channel coupling", "enable DC correction", "enable alternative boundary mode", "set the compress factor", "base delay in milliseconds", "added swept delay in milliseconds", "regen", "percentage regeneration (delayed signal feedback)", "percentage of delayed signal mixed with original", "sweeps per second (Hz)", "swept wave shape", "swept wave percentage phase-shift for multi-channel", "delay-line interpolation", "itype", "Requested channel %s is not present in input stream #%d.\n", "Could not find input channel for output channel '%s'.\n", "mappings: ", "%d.%s => %s ", "No channels are used from input stream %d.\n", "Missing separator '-' in channel map '%s'\n", "Invalid output channel: %s.\n", "Channel map describes more than one output channel.\n", "Output channel '%s' is not present in requested channel layout.\n", "Multiple maps for output channel '%s'.\n", "Invalid input stream index: %d.\n", "Invalid input channel: %s.\n", "Channel map describes more than one input channel.\n", "i < ctx->nb_inputs", "libavfilter/af_join.c", "!s->input_frames[i]", "join", "Number of input streams.", "Channel layout of the output stream.", "A comma-separated list of channels maps in the format 'input_stream.input_channel-output_channel.", "af_pan support a maximum of %d channels. Feel free to ask for a higher limit.\n", "Degenerate coefficients while renormalizing\n", "%s%.3g i%d", "o%d = %s\n", "Pure channel mapping detected:", "%7[A-Z]%n", "c%d%n", "pan filter needs a channel layout and a set of channels definitions as parameter\n", "Expected out channel name, got \"%.8s\"\n", "Channel \"%.8s\" does not exist in the chosen layout\n", "Invalid out channel name \"%.8s\"\n", "Syntax error after channel name in \"%.8s\"\n", "%lf%n *%n", "Expected in channel name, got \"%.8s\"\n", "Can not mix named and numbered channels\n", "Syntax error near \"%.8s\"\n", "args", "track_peak = %.6f\n", "i < (sizeof(freqinfos) / sizeof((freqinfos)[0]))", "libavfilter/af_replaygain.c", "replaygain", "libavfilter/af_sidechaincompress.c", "No channel layout for input 1\n", "sidechaincompress", "sidechain", "set threshold", "set ratio", "set attack", "set release", "makeup", "set make up gain", "set knee", "link", "set link type", "average", "maximum", "set detection", "silence_start: %s\n", "lavfi.silence_end", "lavfi.silence_duration", "silence_end: %s | silence_duration: %s\n", "silencedetect", "set noise tolerance", "set minimum duration in seconds", "start_periods", "start_duration", "start_threshold", "stop_periods", "stop_duration", "stop_threshold", "leave_silence", "Error when evaluating the volume expression '%s'\n", "n:%f t:%f pts:%f precision:%s ", "volume_i:%d/255 ", "volume:%f volume_dB:%f\n", "tb:%f sample_rate:%f nb_channels:%f\n", "Both ReplayGain gain values are unknown.\n", "Using gain %f dB from replaygain side data.\n", "nb_channels", "nb_consumed_samples", "startpts", "startt", "fixed", "float", "double", "set volume adjustment expression", "select mathematical precision", "select 8-bit fixed-point", "select 32-bit floating-point", "select 64-bit floating-point", "specify when to evaluate expressions", "eval volume expression once", "eval volume expression per-frame", "Apply replaygain side data when present", "drop", "replaygain side data is dropped", "ignore", "replaygain side data is ignored", "track gain is preferred", "album gain is preferred", "replaygain_preamp", "Apply replaygain pre-amplification", "replaygain_noclip", "Apply replaygain clipping prevention", "power <= 0x8000 * 0x8000", "libavfilter/af_volumedetect.c", "mean_volume: %.1f dB\n", "max_volume: %.1f dB\n", "histogram_%ddb: %lld\n", "volumedetect", "anullsink", "sample_rate:%d channel_layout:'%s' nb_samples:%d\n", "anullsrc", "set channel_layout", "set sample rate", "set the sine frequency", "beep_factor", "set the beep fequency factor", "set the audio duration", "samples_per_frame", "set the number of samples per frame", "channels == av_get_channel_layout_nb_channels(link->channel_layout) || !av_get_channel_layout_nb_channels(link->channel_layout)", "libavfilter/audio.c", "channel_layout == 0 || channels == av_get_channel_layout_nb_channels(channel_layout)", "Layout indicates a different number of channels than actually present\n", "libavfilter/avcodec.c", "src->video", "src->audio", "aphasemeter", "set video rate", "800x400", "set red contrast", "set green contrast", "set blue contrast", "set median phase color", "set mode", "lissajous", "lissajous_xy", "polar", "400x400", "set alpha contrast", "set red fade", "set green fade", "set blue fade", "set alpha fade", "set zoom factor", "Input link %s parameters (size %dx%d, SAR %d:%d) do not match the corresponding output link %s parameters (%dx%d, SAR %d:%d)\n", "EOF on %s, %d streams left in segment.\n", "in%d:%c%d", "out:%c%d", "Segment finished at pts=%lld\n", "Frame after EOF on input %s\n", "specify the number of segments", "specify the number of video streams", "specify the number of audio streams", "unsafe", "enable unsafe mode", "EF G A BC D ", "Rate (%u) is not divisible by fps*count (%u*%u)\n", "Freetype is not available, ignoring fontfile option\n", "Calculating spectral kernel, please wait\n", "at freq %g: tlength is %g, setting it to %g\n", "at freq %g: volume is %g, setting it to %g\n", "Elapsed time %.6f s (fft_len=%u, num_coeffs=%u)\n", "showcqt", "a_weighting", "b_weighting", "c_weighting", "midi", "set volume", "tlength", "set transform length", "384/f*tc/(384/f+tc)", "set timeclamp", "set coeffclamp", "set gamma", "gamma2", "set gamma of bargraph", "fullhd", "set full HD resolution", "set video fps", "set number of transform per frame", "fontfile", "set font file", "fontcolor", "set font color", "st(0, (midi(f)-59.5)/12);st(1, if(between(ld(0),0,1), 0.5-0.5*cos(2*PI*ld(0)), 0));r(1-ld(1)) + b(ld(1))", "libavfilter/avf_showfreqs.c", "overlap %f too big\n", "showfreqs", "1024x512", "set display mode", "show lines", "show bars", "show dots", "ascale", "set amplitude scale", "cbrt", "fscale", "set frequency scale", "rlog", "reverse logarithmic", "set window size", "w128", "w256", "w512", "w1024", "w2048", "w4096", "w8192", "w16384", "w32768", "w65536", "win_func", "set window function", "Rectangular", "bartlett", "Bartlett", "hanning", "Hanning", "hamming", "Hamming", "blackman", "Blackman", "welch", "Welch", "flattop", "Flat-top", "bharris", "Blackman-Harris", "bnuttall", "Blackman-Nuttall", "bhann", "Bartlett-Hann", "Sine", "set window overlap", "set time averaging", "set channels colors", "red|green|blue|yellow|orange|lime|pink|magenta|brown", "Unable to create RDFT context. The window size might be too high.\n", "libavfilter/avf_showspectrum.c", "s:%dx%d RDFT window size:%d\n", "insamples->nb_samples <= win_size", "insamples->nb_samples == win_size", "showspectrum", "640x512", "slide", "set sliding mode", "replace", "replace old columns with new", "scroll from right to left", "fullframe", "return full frames", "set channel display mode", "combined", "combined mode", "separate", "separate mode", "set channel coloring", "separate color for each channel", "intensity based coloring", "set display scale", "saturation", "color saturation multiplier", "Hann window", "Hamming window", "Blackman window", "VOLUME", "CHANNEL", "set border width", "set channel width", "set channel height", "set fade", "set volume color expression", "if(gte(VOLUME,-2), if(gte(VOLUME,-1),0xff0000ff, 0xff00ffff),0xff00ff00)", "display channel names", "s:%dx%d r:%f n:%d\n", "showwavespic", "Too few samples\n", "Create frame averaging %lld samples per column\n", "col < outlink->w", "libavfilter/avf_showwaves.c", "showwaves", "600x240", "split_channels", "draw channels separately", "select display mode", "draw a point for each sample", "draw a line for each sample", "draw a line between samples", "cline", "draw a centered line for each sample", "set how many samples to show in the same point", "FFmpeg version 2.8.7", "Timeline ('enable' option) not supported with filter '%s'\n", "Error when evaluating the expression '%s' for enable\n", "No option name near '%s'\n", "Unable to parse '%s': %s\n", "Setting '%s' to value '%s'\n", "Option '%s' not found\n", "libavfilter license: nonfree and unredistributable", "Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\n", "auto-inserting filter '%s' between the filter '%s' and the filter '%s'\n", "Not all input and output are properly linked (%d).\n", "circular filter chain detected\n", "Source filters and filters with more than one input must set config_props() callbacks on all outputs\n", "Failed to configure output pad on %s\n", "Video source filters must set their output link's width and height\n", "Failed to configure input pad on %s\n", "pong from:%s %s\n", "enable", "Copying data in avfilter.\n", "Processing command time:%f command:%s arg:%s\n", "!link->frame_requested", "libavfilter/avfilter.c", "!link->frame_requested || link->flags & FF_LINK_FLAG_REQUEST_LOOP", "(filter->flags & ((1 << 16) | (1 << 17))) != ((1 << 16) | (1 << 17))", "!input->filter_frame || (!input->start_frame && !input->end_frame)", "Error applying generic filter options.\n", "Error applying options to the filter.\n", "This filter does not take any options, but options were provided: %s.\n", "noformat", "frei0r", "frei0r_src", "This syntax is deprecated. Use '|' to separate the list items.\n", "compat: called with args=[%s]\n", "No such option: %s.\n", "Samples dropped due to memory allocation failure.\n", "AVFilter", "thread_type", "Allowed thread types", "slice", "set enable expression", "picking %s out of %d ref:%s alpha:%d\n", "picking %s out of %d ref:%s\n", "Cannot select sample rate for the link between filters %s and %s.\n", "Cannot select channel layout for the link between filters %s and %s.\n", "Unknown channel layouts not supported, try specifying a channel layout using 'aformat=channel_layouts=something'.\n", "All layouts set on non-empty list\n", "All counts without all layouts\n", "index >= 0", "libavfilter/avfiltergraph.c", "Query format failed for '%s': %s\n", "Error initializing threading.\n", "'scale' filter not present, cannot convert pixel formats.\n", "auto-inserted scaler %d", "'aresample' filter not present, cannot convert audio formats.\n", "auto-inserted resampler %d", "inlink-> in_formats->refcount > 0", "inlink->out_formats->refcount > 0", "outlink-> in_formats->refcount > 0", "outlink->out_formats->refcount > 0", "inlink-> in_samplerates->refcount > 0", "inlink->out_samplerates->refcount > 0", "outlink-> in_samplerates->refcount > 0", "outlink->out_samplerates->refcount > 0", "inlink-> in_channel_layouts->refcount > 0", "inlink->out_channel_layouts->refcount > 0", "outlink-> in_channel_layouts->refcount > 0", "outlink->out_channel_layouts->refcount > 0", "Impossible to convert between the formats supported by the filter '%s' and the filter '%s'\n", "query_formats: %d queried, %d merged, %d already done, %d delayed\n", "The following filters could not choose their formats: %s\nConsider inserting the (a)format filter near their input or output.\n", "Input pad \"%s\" with type %s of the filter instance \"%s\" of %s not connected to any source\n", "Output pad \"%s\" with type %s of the filter instance \"%s\" of %s not connected to any destination\n", "afifo", "auto-inserted fifo %d", "query_formats not finished\n", "best_idx >= 0", "n == sink_links_count", "EOF on sink link %s:%s.\n", "AVFilterGraph", "Maximum number of threads", "scale_sws_opts", "default scale filter options", "aresample_swr_opts", "default aresample filter options", "Failed to allocate qp_table\n", "ref->buf->refcount > 0", "libavfilter/buffer.c", "%d buffers queued in %s, something may be wrong.\n", "Invalid size for sample_fmts: %d, should be multiple of %d\n", "Invalid size for sample_rates: %d, should be multiple of %d\n", "Invalid size for channel_layouts: %d, should be multiple of %d\n", "Invalid size for channel_counts: %d, should be multiple of %d\n", "Conflicting all_channel_counts and list in options\n", "Invalid size for pixel_fmts: %d, should be multiple of %d\n", "all_channel_counts", "Failed to allocate fifo\n", "pix_fmts", "ffbuffersink", "ffabuffersink", "!strcmp(ctx->filter->name, \"buffersink\") || !strcmp(ctx->filter->name, \"abuffersink\") || !strcmp(ctx->filter->name, \"ffbuffersink\") || !strcmp(ctx->filter->name, \"ffabuffersink\")", "libavfilter/buffersink.c", "!strcmp(ctx->filter->name, \"buffersink\") || !strcmp(ctx->filter->name, \"ffbuffersink\")", "set the supported sample formats", "set the supported sample rates", "set the supported channel layouts", "set the supported channel counts", "accept all channel counts", "set the supported pixel formats", "Sample format was not set or was invalid\n", "Invalid channel layout %s.\n", "Mismatching channel count %d and layout '%s' (%d channels)\n", "Neither number of channels nor channel layout specified\n", "tb:%d/%d samplefmt:%s samplerate:%d chlayout:%s\n", "Invalid parameters provided.\n", "w:%d h:%d pixfmt:%s tb:%d/%d fr:%d/%d sar:%d/%d sws_param:%s\n", "Changing frame properties on the fly is not supported by all filters.\n", "Changing frame properties on the fly is not supported.\n", "abuffer", "time_base", "pix_fmt", "time_base_num", "deprecated, do not use", "time_base_den", "sar_num", "sar_den", "pixel_aspect", "frame_rate", "sws_param", "pix_desc", "libavfilter/drawutils.c", "Color conversion not implemented for %s\n", "mainpic", "libavfilter/dualinput.c", "adrawgraph", "set 1st metadata key", "set 1st foreground color expression", "0xffff0000", "set 2nd metadata key", "set 2nd foreground color expression", "0xff00ff00", "set 3rd metadata key", "set 3rd foreground color expression", "0xffff00ff", "set 4th metadata key", "set 4th foreground color expression", "0xffffff00", "set background color", "white", "set minimal value", "set maximal value", "set graph mode", "draw bars", "draw dots", "draw lines", "set slide mode", "draw new frames", "rscroll", "scroll from left to right", "set graph size", "900x256", "M:%6.1f S:%6.1f     I:%6.1f LUFS     LRA:%6.1f LU     ", "%.3f", "lavfi.r128.M", "lavfi.r128.S", "lavfi.r128.I", "lavfi.r128.LRA", "lavfi.r128.LRA.low", "lavfi.r128.LRA.high", "lavfi.r128.sample_peaks_ch%d", "lavfi.r128.true_peaks_ch%d", "t: %-10s M:%6.1f S:%6.1f     I:%6.1f LUFS     LRA:%6.1f LU", "  SPK:", " %5.1f", "  FTPK:", "  TPK:", "Summary:\n\n  Integrated loudness:\n    I:         %5.1f LUFS\n    Threshold: %5.1f LUFS\n\n  Loudness range:\n    LRA:       %5.1f LU\n    Threshold: %5.1f LUFS\n    LRA low:   %5.1f LUFS\n    LRA high:  %5.1f LUFS", "\n\n  Sample peak:\n    Peak:      %5.1f dBFS", "\n\n  True peak:\n    Peak:      %5.1f dBFS", "out0", "out%d", "EBU +%d scale\n", "in_channel_layout", "in_sample_fmt", "out_channel_layout", "out_sample_rate", "out_sample_fmt", "Video size %dx%d is too small, minimum size is 640x480\n", "ebur128", "set video output", "640x480", "set scale meter (+9 to +18)", "framelog", "force frame logging level", "information logging level", "verbose", "verbose logging level", "set peak mode", "disable any peak mode", "enable peak-sample mode", "enable true-peak mode", "Parameters for input link %s (size %dx%d, SAR %d:%d) do not match the corresponding output link parameters (%dx%d, SAR %d:%d)\n", "libavfilter/f_interleave.c", "queue:%d -> frame time:%f\n", "NOPTS value for input frame cannot be accepted, frame discarded\n", "frame pts:%f -> queue idx:%d available:%d\n", "ainterleave", "set number of inputs", " (no-op)", "%s -> %s%s\n", "random seed: 0x%08x\n", "aperms", "select permissions mode", "do nothing", "set all output frames read-only", "set all output frames writable", "toggle", "switch permissions", "set permissions randomly", "set the seed for the random mode", "areverse", "n:%f pts:%f t:%f key:%d", " interlace_type:%c pict_type:%c scene:%f", " samples_n:%d consumed_samples_n:%f", " -> select:%f select_out:%d\n", "Error while parsing expression '%s'\n", "scene", "output%d", "Scene detection is ignored in aselect filter\n", "aselect", "start_pts", "prev_pts", "prev_selected_pts", "start_t", "prev_t", "prev_selected_t", "PICT_TYPE_I", "PICT_TYPE_P", "PICT_TYPE_B", "PICT_TYPE_S", "PICT_TYPE_SI", "PICT_TYPE_SP", "PICT_TYPE_BI", "interlace_type", "PROGRESSIVE", "TOPFIRST", "BOTTOMFIRST", "consumed_samples_n", "prev_selected_n", "set an expression to use for selecting frames", "set the number of outputs", "[%s] interval #%d start_ts:%f end_ts:%f ts:%f\n", "Processing command #%d target:%s command:%s arg:%s\n", "Command reply for command #%d: ret:%s res:%s\n", " \f\t\n\r", "Unknown flag '%s' in interval #%d, command #%d\n", "Invalid flags char '%c' in interval #%d, command #%d\n", "Missing flag terminator or extraneous data found at the end of flags in interval #%d, command #%d\n", " \f\t\n\r,;", "No target specified in interval #%d, command #%d\n", "No command specified in interval #%d, command #%d\n", "Could not (re)allocate command array\n", "Missing separator or extraneous data found at the end of interval #%d, in command #%d\n", "Command was parsed as: flags:[%s] target:%s command:%s arg:%s\n", "One and only one of the filename or commands options must be specified\n", "Invalid start time specification '%s' in interval #%d\n", "Invalid end time specification '%s' in interval #%d\n", "Invalid end time '%s' in interval #%d: cannot be lesser than start time '%s'\n", "No interval specified for interval #%d\n", "Missing terminator or extraneous data found at the end of interval #%d\n", "Could not (re)allocate intervals array\n", "No commands were specified\n", "Parsed commands:\n", "start_time:%f end_time:%f index:%d\n", "    [%s] target:%s command:%s arg:%s index:%d\n", "asendcmd", "set commands", "set commands file", "frame->nb_samples > offset", "libavfilter/fifo.c", "request_samples changed before the buffer was returned.\n", "s->root.next", "fifo->root.next", "Invalid pixel format '%s'\n", "Invalid sample format '%s'\n", "Invalid time base '%s'\n", "Invalid sample rate '%s'\n", "Invalid channel layout '%s'\n", "framesync", "level <= fs->sync_level", "libavfilter/framesync.c", "Sync level %u\n", "!fs->in[in].have_next", "Impossible to set time base\n", "Selected %d/%d time base\n", "!fs->frame_ready", "fs->on_event", "libavfilter/generate_wave_table.c", "[%dx%d %d:%d %s]", "[%dHz %s:%s]", "%s:%s", "%*s%-*s", "%*s(%s)%*s", "Bad (empty?) label found in the following: \"%s\".\n", "Mismatched '[' found in the following: \"%s\".\n", "=,;[\n", "[],;\n", "Parsed_%s_%d", "No such filter: '%s'\n", "Error creating filter '%s'\n", "Error initializing filter '%s'", " with args '%s'", "No output pad can be associated to link label '%s'.\n", "Cannot create the link %s:%d -> %s:%d\n", "sws_flags=", "sws_flags not terminated with ';'.\n", "Too many inputs specified for the \"%s\" filter.\n", "Unable to parse graph description substring: \"%s\"\n", "Not enough inputs specified for the \"%s\" filter.\n", "Invalid filterchain containing an unlabelled output pad: \"%s\"\n", "[in]", "[out]", "Failed to open input file '%s'\n", "Find stream info failed\n", "Failed to find codec\n", "Failed to open codec\n", "Failed to alloc frame\n", "Failed to read frame from file\n", "Failed to decode image from file\n", "Error loading image file '%s'\n", "Impossible to create scale context for the conversion fmt:%s s:%dx%d -> fmt:%s s:%dx%d\n", "TB:%f FRAME_RATE:%f SAMPLE_RATE:%f\n", "N:%lld PTS:%s T:%f POS:%s", " INTERLACED:%lld", " NB_SAMPLES:%lld NB_CONSUMED_SAMPLES:%lld", " -> PTS:%s T:%f\n", "asetpts", "FRAME_RATE", "INTERLACED", "NB_CONSUMED_SAMPLES", "NB_SAMPLES", "PREV_INPTS", "PREV_INT", "PREV_OUTPTS", "PREV_OUTT", "SAMPLE_RATE", "STARTPTS", "STARTT", "RTCTIME", "RTCSTART", "Expression determining the frame timestamp", "Invalid expression '%s' for timebase.\n", "Invalid non-positive values for the timebase num:%d or den:%d.\n", "tb:%d/%d -> tb:%d/%d\n", "tb:%d/%d pts:%lld -> tb:%d/%d pts:%lld\n", "asettb", "AVTB", "intb", "set expression determining the output timebase", "asplit", "set number of outputs", "matched only already used streams", "did not match any stream", "No filename provided!\n", "amovie", "Loop with several streams is currently unsupported\n", "Failed to avformat_open_input '%s'\n", "Failed to find stream info\n", "%s: seek value overflow with start_time:%lld seek_point:%lld\n", "%s: could not seek to position %lld\n", "d%1[av]%d%c", "No %s stream with index '%d' found\n", "Invalid stream specifier \"%s\"\n", "Ambiguous stream specifier \"%s\", using #%d\n", "Stream specifier \"%s\" %s\n", "Stream specifier \"%s\" matched a %s stream,currently unsupported by libavfilter\n", "Failed to find any codec\n", "Channel layout is not set in stream %d, and could not be guessed from the number of channels (%d)\n", "Channel layout is not set in output stream %d, guessed channel layout is '%s'\n", "seek_point:%lli format_name:%s file_name:%s stream_index:%d\n", "Unable to loop: %s\n", "Stream finished, looping.\n", "Decode error: %s\n", "Format changed %s -> %s, discarding frame\n", "format_name", "set format name", "stream_index", "set stream index", "seek_point", "set seekpoint (seconds)", "set streams", "set loop count", "start_sample < end_sample || (start_sample == end_sample && !frame->nb_samples)", "libavfilter/trim.c", "atrim", "starti", "Timestamp of the first frame that should be passed", "endi", "Timestamp of the first frame that should be dropped again", "Timestamp of the first frame that should be  passed", "end_pts", "durationi", "Maximum duration of the output", "Number of the first audio sample that should be passed to the output", "end_sample", "Number of the first audio sample that should be dropped again", "Timestamp in seconds of the first frame that should be passed", "Timestamp in seconds of the first frame that should be dropped again", "Maximum duration of the output in seconds", "start_frame", "Number of the first frame that should be passed to the output", "Number of the first frame that should be dropped again", "alphamerge", "Error when evaluating the expression '%s'\n", "Invalid string '%s' for aspect ratio\n", "num:den syntax is deprecated, please use num/den or named options instead\n", "Unable to parse ratio numerator \"%s\"\n", "w:%d h:%d sar:%d/%d dar:%d/%d -> sar:%d/%d dar:%d/%d\n", "w:%d h:%d dar:%d/%d sar:%d/%d -> dar:%d/%d sar:%d/%d\n", "setsar", "setdar", "set sample (pixel) aspect ratio", "set max value for nominator or denominator in the ratio", "set display aspect ratio", "dar_den", "set threshold A for 1st plane", "set threshold B for 1st plane", "set threshold A for 2nd plane", "set threshold B for 2nd plane", "set threshold A for 3rd plane", "set threshold B for 3rd plane", "set how many frames to use", "lavfi.bbox.x1", "lavfi.bbox.x2", "lavfi.bbox.y1", "lavfi.bbox.y2", "lavfi.bbox.w", "lavfi.bbox.h", " x1:%d x2:%d y1:%d y2:%d w:%d h:%d crop=%d:%d:%d:%d drawbox=%d:%d:%d:%d", "bbox", "min_val", "set minimum luminance value for bounding box", "black_min_duration:%s pixel_black_th:%f pixel_black_th_i:%d picture_black_ratio_th:%f\n", "frame:%lld picture_black_ratio:%f pts:%s t:%s type:%c\n", "lavfi.black_start", "lavfi.black_end", "blackdetect", "set minimum detected black duration in seconds", "black_min_duration", "picture_black_ratio_th", "set the picture black ratio threshold", "pic_th", "pixel_black_th", "set the pixel black threshold", "pix_th", "lavfi.blackframe.pblack", "blackframe", "Percentage of the pixels that have to be below the threshold for the frame to be considered black.", "threshold below which a pixel value is considered black", "First input link %s parameters (size %dx%d, SAR %d:%d) do not match the corresponding second input link %s parameters (%dx%d, SAR %d:%d)\n", "tblend", "BOTTOM", "c0_mode", "set component #0 blend mode", "c1_mode", "set component #1 blend mode", "c2_mode", "set component #2 blend mode", "c3_mode", "set component #3 blend mode", "all_mode", "set blend mode for all components", "addition", "burn", "darken", "difference128", "divide", "dodge", "exclusion", "glow", "hardlight", "hardmix", "lighten", "linearlight", "multiply", "negation", "overlay", "phoenix", "pinlight", "reflect", "screen", "softlight", "subtract", "vividlight", "c0_expr", "set color component #0 expression", "c1_expr", "set color component #1 expression", "c2_expr", "set color component #2 expression", "c3_expr", "set color component #3 expression", "all_expr", "set expression for all color components", "c0_opacity", "set color component #0 opacity", "c1_opacity", "set color component #1 opacity", "c2_opacity", "set color component #2 opacity", "c3_opacity", "set color component #3 opacity", "all_opacity", "set opacity for all color components", "force termination when the shortest input terminates", "repeatlast", "repeat last bottom frame", "Error when evaluating luma radius expression '%s'\n", "Error when evaluating chroma radius expression '%s'\n", "Error when evaluating alpha radius expression '%s'\n", "luma_radius:%d luma_power:%d chroma_radius:%d chroma_power:%d alpha_radius:%d alpha_power:%d w:%d chroma_w:%d h:%d chroma_h:%d\n", "Invalid luma radius value %d, must be >= 0 and <= %d\n", "Invalid chroma radius value %d, must be >= 0 and <= %d\n", "Invalid alpha radius value %d, must be >= 0 and <= %d\n", "Luma radius expression is not set.\n", "boxblur", "luma_radius", "Radius of the luma blurring box", "luma_power", "How many times should the boxblur be applied to luma", "chroma_radius", "Radius of the chroma blurring box", "chroma_power", "How many times should the boxblur be applied to chroma", "alpha_radius", "Radius of the alpha blurring box", "alpha_power", "How many times should the boxblur be applied to alpha", "set motion vectors to visualize", "forward predicted MVs of P-frames", "forward predicted MVs of B-frames", "backward predicted MVs of B-frames", "set red shadows", "set green shadows", "set blue shadows", "set red midtones", "set green midtones", "set blue midtones", "set red highlights", "set green highlights", "set blue highlights", "set the red gain for the red channel", "set the green gain for the red channel", "set the blue gain for the red channel", "set the alpha gain for the red channel", "set the red gain for the green channel", "set the green gain for the green channel", "set the blue gain for the green channel", "set the alpha gain for the green channel", "set the red gain for the blue channel", "set the green gain for the blue channel", "set the blue gain for the blue channel", "set the alpha gain for the blue channel", "set the red gain for the alpha channel", "set the green gain for the alpha channel", "set the blue gain for the alpha channel", "set the alpha gain for the alpha channel", "set the colorkey key color", "similarity", "set the colorkey similarity value", "set the colorkey key blend value", "rimin", "set input red black point", "gimin", "set input green black point", "bimin", "set input blue black point", "aimin", "set input alpha black point", "rimax", "set input red white point", "gimax", "set input green white point", "bimax", "set input blue white point", "aimax", "set input alpha white point", "romin", "set output red black point", "gomin", "set output green black point", "bomin", "set output blue black point", "aomin", "set output alpha black point", "romax", "set output red white point", "gomax", "set output green white point", "bomax", "set output blue white point", "aomax", "set output alpha white point", "error calculating conversion coefficients\n", "Input frame does not specify a supported colorspace, and none has been specified as source either\n", "Unspecified destination color space\n", "Source and destination color space must not be identical\n", "colormatrix", "bt709", "bt601", "smpte240m", "set source color matrix", "color_mode", "set destination color matrix", "set BT.709 colorspace", "set FCC colorspace   ", "set BT.601 colorspace", "bt470", "set BT.470 colorspace", "bt470bg", "smpte170m", "set SMTPE-170M colorspace", "set SMPTE-240M colorspace", "copy", "lavfi.rect.y", "lavfi.rect.w", "lavfi.rect.h", "cover filename not set\n", "cover image is not a YUV420 image\n", "cover_rect", "cover", "cover bitmap filename", "set removal mode", "cover area with bitmap", "blur area", "Too big value or invalid expression for out_w/ow or out_h/oh. Maybe the expression for out_w:'%s' or for out_h:'%s' is self-referencing.\n", "w:%d h:%d sar:%d/%d -> w:%d h:%d sar:%d/%d\n", "Invalid too big or non positive size for width '%d' or height '%d'\n", "n:%d t:%f pos:%f x:%d y:%d x+w:%d y+h:%d\n", "out_w", "out_h", "set the width crop area expression", "set the height crop area expression", "set the x crop area expression", "(in_w-out_w)/2", "set the y crop area expression", "(in_h-out_h)/2", "keep_aspect", "keep aspect ratio", "limit:%f round:%d reset_count:%d\n", "lavfi.cropdetect.x1", "lavfi.cropdetect.x2", "lavfi.cropdetect.y1", "lavfi.cropdetect.y2", "lavfi.cropdetect.w", "lavfi.cropdetect.h", "lavfi.cropdetect.x", "lavfi.cropdetect.y", "x1:%d x2:%d y1:%d y2:%d w:%d h:%d x:%d y:%d pts:%lld t:%f crop=%d:%d:%d:%d\n", "cropdetect", "limit", "Threshold below which the pixel is considered black", "Value by which the width/height should be divisible", "Recalculate the crop area after this many frames", "reset_count", "max_outliers", "Threshold count of outliers", "%f/%f ", "curves %d (intid=%d) [%d points]: [%s]\n", "Invalid key point coordinates (%f;%f), x and y must be in the [0;1] range.\n", "Key point coordinates (%f;%f) and (%f;%f) are too close from each other or not strictly increasing on the x-axis\n", "libavfilter/vf_curves.c", "point->next", "x_start >= 0 && x_start <= 255 && x_end >= 0 && x_end <= 255", "f(%f)=%f -> y[%d]=%d\n", "#%d points:", " (%f;%f)", "#%d values:", " %02X", "curves", "0/1 0.129/1 0.466/0.498 0.725/0 1/0", "0/1 0.109/1 0.301/0.498 0.517/0 1/0", "0/1 0.098/1 0.235/0.498 0.423/0 1/0", "0.25/0.156 0.501/0.501 0.686/0.745", "0.25/0.188 0.38/0.501 0.745/0.815 1/0.815", "0.231/0.094 0.709/0.874", "0.5/0.4", "0.149/0.066 0.831/0.905 0.905/0.98", "0.4/0.5", "0.305/0.286 0.694/0.713", "0.286/0.219 0.639/0.643", "0/1 1/0", "0.301/0.196 0.592/0.6 0.686/0.737", "0/0.11 0.42/0.51 1/0.95", "0.50/0.48", "0/0.22 0.49/0.44 1/0.8", "select a color curves preset", "preset_name", "color_negative", "cross_process", "darker", "increase_contrast", "lighter", "linear_contrast", "medium_contrast", "strong_contrast", "vintage", "master", "set master points coordinates", "set red points coordinates", "set green points coordinates", "set blue points coordinates", "set points coordinates for all components", "psfile", "set Photoshop curves file name", "The last %d horizontal pixels won't be denoised\n", "The last %d vertical pixels won't be denoised\n", "threads: [max=%d hmax=%d user=%d] => %d\n", "Overlap value can not except %d with a block size of %dx%d\n", "dctdnoiz", "sigma", "set noise sigma constant", "set number of block overlapping pixels", "set coefficient factor expression", "set the block size, expressed in bits", "1thr", "set 1st plane threshold", "2thr", "set 2nd plane threshold", "3thr", "set 3rd plane threshold", "4thr", "set 4th plane threshold", "set range", "set direction", "enable blur", "FPS: %d/%d -> %d/%d\n", " dup", " lowest", " [DROP]", "1/%d frame drop:\n", "  #%d: totdiff=%08llx maxbdiff=%08llx%s%s%s%s\n", "clean_src", "blockx and blocky settings must be power of two\n", "cycle", "set the number of frame from which one will be dropped", "dupthresh", "set duplicate threshold", "scthresh", "set scene change threshold", "blockx", "set the size of the x-axis blocks used during metric calculations", "blocky", "set the size of the y-axis blocks used during metric calculations", "ppsrc", "mark main input as a pre-processed input and activate clean source input stream", "set whether or not chroma is considered in the metric calculations", "cycle:%d\n", "%lld\t", "next=%lld, new=%lld\n", "dejudder", "set the length of the cycle to use for dejuddering", "x:%d y:%d, w:%d h:%d band:%d show:%d\n", "delogo", "set logo x position", "set logo y position", "set logo width", "set logo height", "set delogo area band size", "show delogo area", "rx must be a multiple of 16\n", "Ori x, Avg x, Fin x, Ori y, Avg y, Fin y, Ori angle, Avg angle, Fin angle, Ori zoom, Avg zoom, Fin zoom\n", "OpenCL support was not enabled in this build, cannot be selected\n", "cx: %d, cy: %d, cw: %d, ch: %d, rx: %d, ry: %d, edge: %d blocksize: %d contrast: %d search: %d\n", "deshake", "set x for the rectangular search area", "set y for the rectangular search area", "set width for the rectangular search area", "set height for the rectangular search area", "set edge mode", "blank", "fill zeroes at blank locations", "original image at blank locations", "extruded edge value at blank locations", "mirrored edge at blank locations", "set motion search blocksize", "set contrast threshold for blocks", "set search strategy", "smode", "exhaustive", "less exhaustive search", "set motion search detailed log file name", "opencl", "use OpenCL filtering capabilities", "TB: %d/%d -> %d/%d\n", "No pattern provided.\n", "Provided pattern includes non-numeric characters.\n", "Detelecine pattern %s removes up to %d frames per frame, pts advance factor: %d/%d\n", "detelecine", "first_field", "select first field", "select top field first", "select bottom field first", "pattern that describe for how many fields a frame is to be displayed", "position of first frame with respect to the pattern if stream is cut", "x:%d y:%d w:%d h:%d color:0x%02X%02X%02X%02X\n", "Error when evaluating the expression '%s'.\n", "invert", "drawgrid", "drawbox", "set horizontal offset", "set vertical offset", "set width of grid cell", "set height of grid cell", "set color of the grid", "set grid line thickness", "set horizontal position of the left box edge", "set vertical position of the top box edge", "set width of the box", "set height of the box", "set color of the box", "set the box thickness", "edgedetect", "set high threshold", "set low threshold", "wires", "white/gray wires on black", "colormix", "mix colors", "elbg", "codebook_length", "set codebook length", "nb_steps", "set max number of steps used to compute the mapping", "set the random seed", "pal8", "set the pal8 output", "brightness", "gamma_r", "gamma_g", "gamma_b", "gamma_weight", "set the contrast adjustment, negative values give a negative image", "set the brightness adjustment", "set the saturation adjustment", "set the initial gamma value", "gamma value for red", "gamma value for green", "gamma value for blue", "set the gamma weight which reduces the effect of gamma on bright areas", "init", "eval expressions once during initialization", "eval expressions per-frame", "alphaextract", "extractplanes", "set planes", "set luma plane", "set u plane", "set v plane", "set red plane", "set green plane", "set blue plane", "set alpha plane", "libavfilter/vf_fade.c", "type:%s start_frame:%d nb_frames:%d alpha:%d\n", "type:%s start_time:%f duration:%f alpha:%d\n", "'in' or 'out' for fade-in/fade-out", "Number of the first frame to which to apply the effect.", "nb_frames", "Number of frames to which the effect should be applied.", "fade alpha if it is available on the input", "Number of seconds of the beginning of the effect.", "Duration of the effect in seconds.", "set color", "weight_Y", "weight_U", "weight_V", "dc_Y", "adjust gain in Y plane", "dc_U", "adjust gain in U plane", "dc_V", "adjust gain in V plane", "set luminance expression in Y plane", "set chrominance expression in U plane", "set chrominance expression in V plane", "w:%d h:%d type:%s -> w:%d h:%d\n", "set field type (top or bottom)", "field_type", "select top field", "select bottom field", "fm->prv && fm->src && fm->nxt", "fm->prv2 && fm->src2 && fm->nxt2", "order == 0 || order == 1 || field == 0 || field == 1", "COMBS: %3d %3d %3d %3d %3d\n", "Frame #%lld at %s is still interlaced\n", "SC:%d | COMBS: %3d %3d %3d %3d %3d (combpel=%d) match=%d combed=%s\n", "Combed pixel should not be larger than blockx x blocky\n", "fieldmatch", "specify the assumed field order", "auto detect parity", "assume bottom field first", "assume top field first", "set the matching mode or strategy to use", "2-way match (p/c)", "pc_n", "2-way match + 3rd match on combed (p/c + u)", "pc_u", "2-way match + 3rd match (same order) on combed (p/c + u)", "pc_n_ub", "2-way match + 3rd match on combed + 4th/5th matches if still combed (p/c + u + u/b)", "3-way match (p/c/n)", "pcn_ub", "3-way match + 4th/5th matches on combed (p/c/n + u/b)", "set the field to match from", "automatic (same value as 'order')", "mchroma", "set whether or not chroma is included during the match comparisons", "define an exclusion band which excludes the lines between y0 and y1 from the field matching decision", "set scene change detection threshold", "combmatch", "set combmatching mode", "disable combmatching", "enable combmatching only on scene change", "enable combmatching all the time", "combdbg", "enable comb debug", "dbglvl", "no forced calculation", "calculate p/c/n", "pcnub", "calculate p/c/n/u/b", "set the area combing threshold used for combed frame detection", "set whether or not chroma is considered in the combed frame decision", "set the x-axis size of the window used during combed frame detection", "set the y-axis size of the window used during combed frame detection", "combpel", "set the number of combed pixels inside any of the blocky by blockx size blocks on the frame for the frame to be detected as combed", "frame with same field order", "progressive frame", "down", "Skipping %s.\n", "picture will move %s one line\n", "fieldorder", "output field order", "libavfilter/vf_find_rect.c", "Found at %d %d score %f\n", "object filename not set\n", "object image is not a grayscale image\n", "find_rect", "object", "object bitmap filename", "set mipmaps", "xmin", "ymin", "xmax", "ymax", "Empty output format string.\n", "A '|'-separated list of pixel formats", "Set first pts to (in:%lld out:%lld)\n", "Discarding initial frame(s) with no timestamp.\n", "Dropping %d frame(s).\n", "Duplicating frame.\n", "%d frames in, %d frames out; %d frames dropped, %d frames duplicated.\n", "fps=%d/%d\n", "A string describing desired output framerate", "Assume the first PTS should be this value.", "set rounding method for timestamps", "round towards 0", "round away from 0", "round towards -infty", "round towards +infty", "round to nearest", "Left and right time bases differ (%d/%d vs %d/%d).\n", "Left and right framerates differ (%d/%d vs %d/%d).\n", "Unknown packing mode.", "framepack", "Frame pack output format", "Views are packed next to each other", "Views are packed on top of each other", "frameseq", "Views are one after the other", "Views are interleaved by lines", "Views are interleaved by columns", "config_output() input time base:%u/%u (%f)\n", "time base:%u/%u -> %u/%u exact:%d\n", "Timebase conversion is not exact\n", "config_output() output time base:%u/%u (%f) w:%d h:%d\n", "fps -> fps:%u/%u scene score:%f interpolate start:%d end:%d\n", "set_srce_frame_output_pts()\n", "set_work_frame_pts()\n", "s->srce[s->next]", "libavfilter/vf_framerate.c", "s->srce[s->crnt]", "set_work_frame_pts() srce crnt pts:%lld\n", "set_work_frame_pts() srce next pts:%lld\n", "set_work_frame_pts() srce prev pts:%lld\n", "set_work_frame_pts() initial average srce pts:%lld\n", "set_work_frame_pts() average srce pts:%lld\n", "set_work_frame_pts() average srce pts:%lld at dest time base:%u/%u\n", "Buggy path reached, use settb filter before this filter!\n", "set_frame_pts() average output pts from input timebase\n", "set_work_frame_pts() average dest pts delta:%lld\n", "set_work_frame_pts() calculated pts:%lld at dest time base:%u/%u\n", "next_source()\n", "next_source() unlink %d\n", "next_source() copy %d to %d\n", "next_source() make %d null\n", "process_work_frame()\n", "process_work_frame() pending_input_frames %d\n", "process_work_frame() srce prev pts:%lld\n", "process_work_frame() srce crnt pts:%lld\n", "process_work_frame() srce next pts:%lld\n", "process_work_frame() no current frame cached: move on to next frame, do not output a frame\n", "process_work_frame() work crnt pts:%lld\n", "process_work_frame() work next pts:%lld\n", "process_work_frame() srce prev pts:%lld at dest time base:%u/%u\n", "process_work_frame() srce crnt pts:%lld at dest time base:%u/%u\n", "process_work_frame() srce next pts:%lld at dest time base:%u/%u\n", "process_work_frame() work crnt pts >= srce next pts: SKIP FRAME, move on to next frame, do not output a frame\n", "process_work_frame() interpolate:%d/256\n", "process_work_frame() source is:NEXT\n", "process_work_frame() source is:PREV\n", "process_work_frame() interpolate source is:NEXT\n", "process_work_frame() interpolate source is:PREV\n", "get_scene_score()\n", "get_scene_score() process\n", "get_scene_score() result is:%f\n", "process_work_frame() interpolate scene score:%f\n", "process_work_frame() INTERPOLATE to create work frame\n", "process_work_frame() CUT - DON'T INTERPOLATE\n", "process_work_frame() COPY to the work frame\n", "process_work_frame() REPEAT FRAME\n", "process_work_frame() CONSUME FRAME, move to next frame\n", "process_work_frame() output a frame\n", "request_frame() call source's request_frame()\n", "request_frame() source's request_frame() returned error:%d\n", "request_frame() source's request_frame() returned:%d\n", "request_frame() REPEAT or FLUSH\n", "request_frame() nothing else to do, return:EOF\n", "request_frame() FLUSH\n", "request_frame() copy:%d to:%d\n", "Interlaced frame found - the output will not be correct.\n", "required output frames per second rate", "interp_start", "point to start linear interpolation", "interp_end", "point to end linear interpolation", "scene change level", "set flags", "scene_change_detect", "enable scene change detection", "step:%d frame_rate:%d/%d(%f) -> frame_rate:%d/%d(%f)\n", "framestep", "set frame step", "w * h <= fspp->non_b_qp_alloc_size", "libavfilter/vf_fspp.c", "fspp", "set quality", "force a constant quantizer parameter", "set filter strength", "use_bframe_qp", "use B-frames' QP", "Either YCbCr or RGB but not both must be specified\n", "g(X,Y)", "b(X,Y)", "r(X,Y)", "libavfilter/vf_geq.c", "lum_expr", "set luminance expression", "cb_expr", "set chroma blue expression", "cr_expr", "set chroma red expression", "alpha_expr", "set alpha expression", "red_expr", "set red expression", "green_expr", "set green expression", "blue_expr", "set blue expression", "threshold:%.2f radius:%d\n", "gradfun", "The maximum amount by which the filter will change any one pixel.", "The neighborhood to fit the gradient to.", "hflip", "histeq", "set the strength", "set the intensity", "set the antibanding level", "apply no antibanding", "weak", "apply weak antibanding", "strong", "apply strong antibanding", "This mode is deprecated, please use waveform filter instead.\n", "This mode is deprecated, use vectorscope filter instead.", "set histogram mode", "standard histogram", "waveform", "per row/column luminance graph", "chroma values in vectorscope", "color2", "level_height", "set level height", "scale_height", "set scale height", "set waveform step value", "waveform_mode", "set waveform mode", "column", "waveform_mirror", "set waveform mirroring", "display_mode", "parade", "levels_mode", "set levels mode", "set color components to display", "hqdn3d", "luma_spatial", "spatial luma strength", "chroma_spatial", "spatial chroma strength", "luma_tmp", "temporal luma strength", "chroma_tmp", "temporal chroma strength", "set scale factor", "Brightness value not in range [%d,%d]: clipping value to %0.1f\n", "H:%0.1f*PI h:%0.1f s:%0.1f b:%0.f t:%0.1f n:%d\n", "Error when evaluating the expression '%s' for %s\n", "H and h options are incompatible and cannot be specified at the same time\n", "H_expr:%s h_deg_expr:%s s_expr:%s b_expr:%s\n", "set the hue angle degrees expression", "set the saturation expression", "set the hue angle radians expression", "set the brightness expression", "Repeated Fields: Neither:%6lld Top:%6lld Bottom:%6lld\n", "Single frame detection: TFF:%6lld BFF:%6lld Progressive:%6lld Undetermined:%6lld\n", "Multi frame detection: TFF:%6lld BFF:%6lld Progressive:%6lld Undetermined:%6lld\n", "%lld.%0*lld", "Repeated Field:%12s, Single frame:%12s, Multi frame:%12s\n", "lavfi.idet.repeated.current_frame", "lavfi.idet.repeated.neither", "lavfi.idet.repeated.top", "lavfi.idet.repeated.bottom", "lavfi.idet.single.current_frame", "lavfi.idet.single.tff", "lavfi.idet.single.bff", "lavfi.idet.single.progressive", "lavfi.idet.single.undetermined", "lavfi.idet.multiple.current_frame", "lavfi.idet.multiple.tff", "lavfi.idet.multiple.bff", "lavfi.idet.multiple.progressive", "lavfi.idet.multiple.undetermined", "Final flag accuracy %d\n", "idet", "intl_thres", "set interlacing threshold", "prog_thres", "set progressive threshold", "rep_thres", "set repeat threshold", "half_life", "half life of cumulative statistics", "analyze_interlaced_flag", "set number of frames to use to determine if the interlace flag is accurate", "luma_mode", "select luma mode", "deinterleave", "chroma_mode", "select chroma mode", "select alpha mode", "luma_swap", "swap luma fields", "chroma_swap", "swap chroma fields", "alpha_swap", "swap alpha fields", "without", "input video height is too small\n", "Lowpass filter is disabled, the resulting video will be aliased rather than interlaced.\n", "%s interlacing %s lowpass filter\n", "cols >= 0 || lines >= 0", "libavfilter/vf_interlace.c", "video is already interlaced, adjusting framerate only\n", "scanning mode", "enable vertical low-pass filter", "set the threshold", "set the map", "set the order", "enable sharpening", "enable twoway", "set relative center x", "set relative center y", "set quadratic distortion factor", "set double quadratic distortion factor", "val[%d][%d] = %d\n", "negval", "negate_alpha:%d\n", "negate", "lutrgb", "lutyuv", "minval", "clipval", "gammaval", "gammaval709", "negate_alpha", "set component #0 expression", "set component #1 expression", "set component #2 expression", "set component #3 expression", "set Y expression", "set U expression", "set V expression", "set R expression", "set G expression", "set B expression", "set A expression", "Unexpected EOF\n", "3DLUTSIZE ", "Too large or invalid 3D LUT size\n", "%f %f %f", "%d %d %d", "LUT_3D_SIZE ", "DOMAIN_", "MIN ", "MAX ", "min: %f %f %f | max: %f %f %f\n", "values", "in and out must be defined\n", "invalid in (%d) or out (%d)\n", "Unrecognized '.%s' file type\n", "3D LUT is empty\n", "libavfilter/vf_lut3d.c", "Padding on the right (%dpx) of the Hald CLUT will be ignored\n", "Padding at the bottom (%dpx) of the Hald CLUT will be ignored\n", "The Hald CLUT width does not match the level\n", "Too large Hald CLUT (maximum level is %d, or %dx%d CLUT)\n", "haldclut", "lut3d", "continue applying the last clut after eos", "select interpolation mode", "interp_mode", "use values from the nearest defined points", "trilinear", "interpolate values using the 8 points defining a cube", "tetrahedral", "interpolate values using a tetrahedron", "set 3D LUT file name", "memc_only", "no_bitstream", "mcdeint", "medium", "extra_slow", "set the assumed picture field parity", "set qp", "input #%d link %s SAR %d:%d does not match output link %s SAR %d:%d\n", "input %d does not have %d plane\n", "output plane %d depth %d does not match input %d plane %d depth %d\n", "output plane %d width %d does not match input %d plane %d width %d\n", "output plane %d height %d does not match input %d plane %d height %d\n", "Only planar formats with more than one component are supported.\n", "Mapping with out of range input and/or plane number.\n", "s->nb_inputs && s->nb_inputs <= 4", "libavfilter/vf_mergeplanes.c", "mergeplanes", "set input to output plane mapping", "set output pixel format", "%d>=hi ", "lo:%d>=%d ", "lo:%d<%d ", "%s pts:%s pts_time:%s drop_count:%d\n", "max_drop_count:%d hi:%d lo:%d frac:%f\n", "mpdecimate", "set the maximum number of consecutive dropped frames (positive), or the minimum interval between dropped frames (negative)", "set high dropping threshold", "set low dropping threshold", "frac", "set fraction dropping threshold", "dilation", "deflate", "inflate", "threshold0", "set threshold for 1st plane", "threshold1", "set threshold for 2nd plane", "threshold2", "set threshold for 3rd plane", "threshold3", "set threshold for 4th plane", "set coordinates", "all_seed", "set component #0 noise seed", "all_strength", "set component #0 strength", "alls", "all_flags", "set component #0 flags", "allf", "averaged noise", "(semi)regular pattern", "temporal noise", "uniform noise", "c0_seed", "c0_strength", "c0_flags", "c1_seed", "set component #1 noise seed", "c1_strength", "set component #1 strength", "c1_flags", "set component #1 flags", "c2_seed", "set component #2 noise seed", "c2_strength", "set component #2 strength", "c2_flags", "set component #2 flags", "c3_seed", "set component #3 noise seed", "c3_strength", "set component #3 strength", "c3_flags", "set component #3 flags", "main w:%d h:%d fmt:%s overlay w:%d h:%d fmt:%s eof_action:%s\n", "Incoming frame (time:%s) from link #%d\n", "n:%f t:%f pos:%f x:%f xi:%d y:%f yi:%d\n", "libavfilter/vf_overlay.c", "repeat", "endall", "main_w", "main_h", "overlay_w", "overlay_h", "set the x expression", "set the y expression", "eof_action", "Action to take when encountering EOF from secondary input ", "Repeat the previous frame.", "End both streams.", "Pass through the main input.", "force packed RGB in input and output (deprecated)", "set output format", "yuv420", "yuv422", "yuv444", "repeat overlay of the last overlay frame", "set depth", "luma_strength", "set luma strength", "chroma_strength", "set chroma strength", "w:%d h:%d -> w:%d h:%d x:%d y:%d color:0x%02X%02X%02X%02X\n", "Input area %d:%d:%d:%d not within the padded area 0:0:%d:%d or zero-sized\n", "Direct padding impossible allocating new frame\n", "set the pad area width expression", "set the pad area height expression", "set the x offset expression for the input image position", "set the y offset expression for the input image position", "set the color of the padded area border", "Unable to allocate references for %d different colors\n", "libavfilter/vf_palettegen.c", "new_box->len >= 1", "lavfi.color_quant_ratio", "%d%s colors generated out of %d colors; ratio=%f\n", "Dupped color: %08X\n", "s->nb_boxes < 256", "palettegen", "max_colors", "set the maximum number of colors to use in the palette", "reserve_transparent", "reserve a palette entry for transparency", "stats_mode", "set statistics mode", "compute full frame histograms", "compute histograms only for the part that differs from previous frame", "%*cnode%d [label=\"%c%02X%c%02X%c%02X%c\" fillcolor=\"#%02x%02x%02x\" fontcolor=\"#%06X\"]\n", "%*cnode%d -> node%d\n", "Cannot open file '%s' for writing: %s\n", "digraph {\n", "    node [style=filled fontsize=10 shape=box]\n", "/!\\ %02X%02X%02X: %d ! %d (%06X ! %06X) / dist: %d ! %d\n", "Accuracy check passed\n", "MEP:%.3f TotalMEP:%.3f\n", "paletteuse", "select dithering mode", "dithering_mode", "bayer", "ordered 8x8 bayer dithering (deterministic)", "heckbert", "dithering as defined by Paul Heckbert in 1982 (simple error diffusion)", "floyd_steinberg", "Floyd and Steingberg dithering (error diffusion)", "sierra2", "Frankie Sierra dithering v2 (error diffusion)", "sierra2_4a", "Frankie Sierra dithering v2 \"Lite\" (error diffusion)", "bayer_scale", "set scale for bayer dithering", "diff_mode", "set frame difference mode", "process smallest different rectangle", "debug_kdtree", "save Graphviz graph of the kdtree in specified file", "color_search", "set reverse colormap color search method", "nns_iterative", "iterative search", "nns_recursive", "recursive search", "bruteforce", "brute-force into the palette", "mean_err", "compute and print mean error", "debug_accuracy", "test color search accuracy", "perspective", "set top left x coordinate", "set top left y coordinate", "set top right x coordinate", "set top right y coordinate", "set bottom left x coordinate", "set bottom left y coordinate", "set bottom right x coordinate", "set bottom right y coordinate", "set interpolation", "sense", "specify the sense of the coordinates", "specify locations in source to send to corners in destination", "specify locations in destination to send corners of source", "mode=%c tdiff=%f bdiff=%f pdiff=%f\n", "set phase mode", "top first", "bottom first", "top first analyze", "bottom first analyze", "full analyze", "auto analyze", "pixdesctest", "set thresholding mode", "hard", "hard thresholding", "soft", "soft thresholding", "medium thresholding", "Inputs must be of same pixel format.\n", " %c:%0.2f", "PSNR%s average:%0.2f min:%0.2f max:%0.2f\n", "Could not open stats file %s: %s\n", "%s%c", "lavfi.psnr.mse.", "lavfi.psnr.psnr.", "lavfi.psnr.mse_avg", "lavfi.psnr.psnr_avg", "n:%lld mse_avg:%0.2f ", "mse_%c:%0.2f ", "psnr_avg:%0.2f ", "psnr_%c:%0.2f ", "psnr", "stats_file", "Set file where to store per-frame difference information", "w: %d h: %d\n", "offset: %d length: %d\n", "Could not get buffer!\n", "pullup", "set left junk size", "set right junk size", "set top junk size", "set bottom junk size", "set strict breaks", "set metric plane", "chroma blue", "chroma red", "set qp expression", "set number of frames in cache", "set the seed", "set mode for 1st plane", "set mode for 2nd plane", "set mode for 3rd plane", "set mode for 4th plane", "The bitmap file name is mandatory\n", "full x1:%d x2:%d y1:%d y2:%d max_mask_size:%d\n", "half x1:%d x2:%d y1:%d y2:%d max_mask_size:%d\n", "removelogo", "set bitmap filename", "Unexpected field flags: state=%d top_field_first=%d repeat_first_field=%d\n", "repeatfields", "Error parsing or evaluating expression for option %s: invalid expression '%s' or non-positive or indefinite value %f\n", "n:%f time:%f angle:%f/PI\n", "Error when parsing the expression '%s' for angle command\n", "rotw", "roth", "set angle (in radians)", "set output width expression", "set output height expression", "fillcolor", "set background fill color", "use bilinear interpolation", "set luma radius", "luma_pre_filter_radius", "set luma pre-filter radius", "lpfr", "set chroma radius", "chroma_pre_filter_radius", "set chroma pre-filter radius", "cpfr", "Rescaled value for width or height is too big.\n", "srcw", "srch", "src_format", "dstw", "dsth", "dst_format", "sws_flags", "param0", "param1", "src_range", "dst_range", "src_h_chr_pos", "src_v_chr_pos", "dst_h_chr_pos", "dst_v_chr_pos", "w:%d h:%d fmt:%s sar:%d/%d -> w:%d h:%d fmt:%s sar:%d/%d flags:0x%0x\n", "Error when evaluating the expression '%s'.\nMaybe the expression for out_w:'%s' or for out_h:'%s' is self-referencing.\n", "Size and width/height expressions cannot be set at the same time.\n", "Invalid size '%s'\n", "w:%s h:%s flags:'%s' interl:%d\n", "Detected unsupported YCgCo colorspace.\n", "scale2ref", "ohsub", "Output video width", "Output video height", "Flags to pass to libswscale", "interl", "set interlacing", "in_color_matrix", "set input YCbCr type", "out_color_matrix", "set output YCbCr type", "in_range", "set input color range", "out_range", "set output color range", "in_v_chr_pos", "input vertical chroma position in luma grid/256", "in_h_chr_pos", "input horizontal chroma position in luma grid/256", "out_v_chr_pos", "output vertical chroma position in luma grid/256", "out_h_chr_pos", "output horizontal chroma position in luma grid/256", "force_original_aspect_ratio", "decrease or increase w/h if necessary to keep the original AR", "force_oar", "disable", "decrease", "increase", "Scaler param 0", "Scaler param 1", "height must be even\n", "separatefields", "setfield", "select interlace mode", "keep the same input field", "mark as bottom-field-first", "mark as top-field-first", "prog", "mark as progressive", "config %s time_base: %d/%d, frame_rate: %d/%d\n", "n:%4lld pts:%7s pts_time:%-7s pos:%9lld fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c checksum:%08X plane_checksum:[%08X", " %08X", "] mean:[", "%3.1f ", "pan/scan", "A/53 closed captions (%d bytes)", "stereoscopic information: ", "afd: value of %u", "set pixel box size", "Non-existing input plane #%d mapped to output plane #%d.\n", "Cannot map between a subsampled chroma plane and a luma or alpha plane.\n", "Cannot map between a palette plane and a data plane.\n", "shuffleplanes", "map0", "Index of the input plane to be used as the first output plane ", "map1", "Index of the input plane to be used as the second output plane ", "map2", "Index of the input plane to be used as the third output plane ", "map3", "Index of the input plane to be used as the fourth output plane ", "lavfi.signalstats.YLOW", "lavfi.signalstats.YAVG", "lavfi.signalstats.YHIGH", "lavfi.signalstats.YMAX", "lavfi.signalstats.UMIN", "lavfi.signalstats.ULOW", "lavfi.signalstats.UAVG", "lavfi.signalstats.UHIGH", "lavfi.signalstats.UMAX", "lavfi.signalstats.VMIN", "lavfi.signalstats.VLOW", "lavfi.signalstats.VAVG", "lavfi.signalstats.VHIGH", "lavfi.signalstats.VMAX", "lavfi.signalstats.SATMIN", "lavfi.signalstats.SATLOW", "lavfi.signalstats.SATAVG", "lavfi.signalstats.SATHIGH", "lavfi.signalstats.SATMAX", "lavfi.signalstats.HUEMED", "lavfi.signalstats.HUEAVG", "lavfi.signalstats.YDIF", "lavfi.signalstats.UDIF", "lavfi.signalstats.VDIF", "lavfi.signalstats.%s", "signalstats", "Generate statistics from video analysis.", "TOUT", "VREP", "BRNG", "stat", "set statistics filters", "tout", "analyze pixels for temporal outliers", "vrep", "analyze video lines for vertical line repetition", "brng", "analyze for pixels outside of broadcast range", "set video filter", "highlight pixels that depict temporal outliers", "highlight video lines that depict vertical line repetition", "highlight pixels that are outside of broadcast range", "set highlight color", "yellow", "smartblur", "luma_threshold", "set luma threshold", "chroma_threshold", "set chroma threshold", "w * h <= s->non_b_qp_alloc_size", "libavfilter/vf_spp.c", "SSIM%s All:%f (%f)\n", "lavfi.ssim.", "lavfi.ssim.All", "lavfi.ssim.dB", "n:%lld ", "%c:%f ", "ssim", "Input %d width %d does not match input %d width %d.\n", "Input %d height %d does not match input %d height %d.\n", "vstack", "hstack", "height must be multiple of 4\n", "input format %d is not supported\n", "output format %d is not supported\n", "libavfilter/vf_stereo3d.c", "stereo3d", "set input format", "ab2l", "above below half height left first", "ab2r", "above below half height right first", "above below left first", "above below right first", "alternating frames left first", "alternating frames right first", "sbs2l", "side by side half width left first", "sbs2r", "side by side half width right first", "sbsl", "side by side left first", "sbsr", "side by side right first", "agmc", "anaglyph green magenta color", "agmd", "anaglyph green magenta dubois", "agmg", "anaglyph green magenta gray", "agmh", "anaglyph green magenta half color", "arbg", "anaglyph red blue gray", "arcc", "anaglyph red cyan color", "arcd", "anaglyph red cyan dubois", "arcg", "anaglyph red cyan gray", "anaglyph red cyan half color", "argg", "anaglyph red green gray", "aybc", "anaglyph yellow blue color", "aybd", "anaglyph yellow blue dubois", "aybg", "anaglyph yellow blue gray", "aybh", "anaglyph yellow blue half color", "interleave rows left first", "interleave rows right first", "mono left", "mono right", "swapuv", "Telecine pattern %s yields up to %d frames per frame, pts advance factor: %d/%d\n", "Allocation failure, try to lower the number of frames\n", "batch size: %d frames\n", "thumbnail", "set the frames batch size", "Tile size %ux%u is insane.\n", "nb_frames must be less than or equal to %dx%d=%d\n", "Total width %ux%u is too much.\n", "Total height %ux%u is too much.\n", "tile", "set grid size", "set maximum number of frame to render", "margin", "set outer border margin in pixels", "set inner border thickness in pixels", "set the color of the unused area", "mode:%d filter:%s h:%d -> h:%d\n", "libavfilter/vf_tinterlace.c", "tinterlace", "merge fields", "drop_even", "drop even fields", "drop_odd", "drop odd fields", "pad alternate lines with black", "interleave_top", "interleave top and bottom fields", "interleave_bottom", "interleave bottom and top fields", "interlacex2", "interlace fields from two consecutive frames", "low_pass_filter", "vlpf", "exact_tb", "force a timebase which can represent timestamps exactly", "counterclockwise", "dir values greater than 3 are deprecated, use the passthrough option instead\n", "w:%d h:%d -> w:%d h:%d (passthrough mode)\n", "w:%d h:%d dir:%d -> w:%d h:%d rotation:%s vflip:%d\n", "transpose", "set transpose direction", "cclock_flip", "rotate counter-clockwise with vertical flip", "rotate clockwise", "cclock", "rotate counter-clockwise", "rotate clockwise with vertical flip", "passthrough", "do not apply transposition if the input matches the specified geometry", "always apply transposition", "portrait", "preserve portrait geometry", "landscape", "preserve landscape geometry", "Invalid even size for %s matrix size %dx%d\n", "effect:%s type:%s msize_x:%d msize_y:%d amount:%0.2f\n", "unsharp", "luma_msize_x", "set luma matrix horizontal size", "luma_msize_y", "set luma matrix vertical size", "luma_amount", "set luma effect strength", "chroma_msize_x", "set chroma matrix horizontal size", "chroma_msize_y", "set chroma matrix vertical size", "chroma_amount", "set chroma effect strength", "SNOW encoder not found.\n", "avctx_enc->codec", "libavfilter/vf_uspp.c", "w * h <= uspp->non_b_qp_alloc_size", "uspp", "set vectorscope mode", "color3", "color4", "set color component on X axis", "set color component on Y axis", "set intensity", "set envelope", "peak+instant", "vflip", "Unable to parse expression for 'angle'\n", "Unable to parse expression for 'x0'\n", "Unable to parse expression for 'y0'\n", "vignette", "set lens angle", "PI/5", "set circle center position on x-axis", "set circle center position on y-axis", "set forward/backward mode", "forward", "backward", "eval expressions for each frame", "set dithering", "set aspect ratio", "specify the filter", "simple", "complex", "specify which frames to deinterlace", "deinterlace all frames", "only deinterlace frames marked as interlaced", "set components to display", "set envelope to display", "set filter", "aflat", "achroma", "libavfilter/vf_yadif.c", "Reallocating frame due to differing stride\n", "Failed to reallocate frame\n", "yadif", "specify the interlacing mode", "send_frame", "send one frame for each frame", "send_field", "send one frame for each field", "send_frame_nospatial", "send one frame for each frame, but skip spatial interlacing check", "send_field_nospatial", "send one frame for each field, but skip spatial interlacing check", "specify the assumed picture field parity", "pduration", "pzoom", "set the zoom expression", "set the duration expression", "set the output image size", "hd720", "320x518", "Only one of the filename or pattern options can be used\n", "s:%dx%d r:%d/%d rule:%d stitch:%d scroll:%d full:%d seed:%u\n", "cellauto", "read initial pattern from file", "set initial pattern", "set rule", "random_fill_ratio", "set fill ratio for filling initial grid randomly", "random_seed", "set the seed for filling the initial grid randomly", "scroll pattern downward", "start_full", "start filling the whole video", "stitch", "stitch boundaries", "320x240", "bBsS", "Invalid rule code '%s' provided\n", "Mold color is set while mold isn't, ignoring the color.\n", "h:%d max_w:%d\n", "The specified size is %dx%d which cannot contain the provided file size of %dx%d\n", "%d:%d %c\n", "s:%dx%d r:%d/%d rule:%s stay_rule:%d born_rule:%d stitch:%d seed:%u\n", "set source file", "B3/S23", "mold", "set mold speed for dead cells", "life_color", "set life color", "death_color", "set death color", "mold_color", "set mold color", "mandelbrot", "set frame size", "set frame rate", "maxiter", "set max iterations number", "start_x", "set the initial x position", "start_y", "set the initial y position", "start_scale", "set the initial scale value", "end_scale", "set the terminal scale value", "set the terminal pts value", "bailout", "set the bailout value", "morphxf", "set morph x frequency", "morphyf", "set morph y frequency", "morphamp", "set morph amplitude", "outer", "set outer coloring mode", "set iteration count mode", "normalized_iteration_count", "set normalized iteration count mode", "set white mode", "outz", "set outz mode", "inner", "set inner coloring mode", "set black mode", "set period mode", "show time until convergence", "mincol", "color based on point closest to the origin of the iterations", "rate:%d/%d duration:%f\n", "mptestsrc", "set video duration", "set test to perform", "dc_luma", "dc_chroma", "freq_luma", "freq_chroma", "amp_luma", "amp_chroma", "ring1", "ring2", "size:%dx%d rate:%d/%d duration:%f sar:%d/%d\n", "x + w <= test->w", "libavfilter/vsrc_testsrc.c", "y + h <= test->h", "w == h && w == level*level*level", "allrgb", "allyuv", "smptehdbars", "smptebars", "rgbtestsrc", "haldclutsrc", "set video sample aspect ratio", "decimals", "set number of decimals to show", "set level", "Error parsing ADTS frame header!\n", "Multiple RDBs per frame with CRC", "PCE-based channel configuration without PCE as first syntax element", "aac_adtstoasc", "AAC LD is only defined for ONLY_LONG_SEQUENCE but window sequence %d found.\n", "Invalid Predictor Reset Group.\n", "Prediction is not allowed in AAC-LC.\n", "LTP in ER AAC LD not yet implemented.\n", "Number of scalefactor bands in group (%d) exceeds limit (%d).\n", "TNS filter order %d is greater than maximum %d.\n", "Dependent coupling is not supported together with LTP\n", "libavcodec/aacdec_template.c", "Sample rate index in program config element does not match the sample rate index configured by the container.\n", "decode_pce: Input buffer exhausted before END element found\n", "FILL:%s\n", "libfaac %d.%d", "Remapped id too large\n", "Too many channels\n", "invalid default channel configuration (%d)\n", "Assuming an incorrectly encoded 7.1 channel layout instead of a spec-compliant 7.1(wide) layout, use -strict %d to decode according to the specification instead.\n", "SBR+", "Audio specific config size is invalid\n", "invalid sampling rate index %d\n", "invalid low delay sampling rate index %d\n", "960/120 MDCT window", "AAC data resilience (flags %x)", "epConfig %d", "Low Delay SBR", "Audio object type %s%d", "Non-byte-aligned audio-specific config", "audio config changed\n", "initializing latmctx\n", "mono with CPE\n", "stereo with SCE\n", "This stream seems to incorrectly report its last channel as %s[%d], mapping to LFE[0]\n", "This stream seems to incorrectly report its last channel as %s[%d], mapping to SCE[1]\n", "ChannelElement %d.%d missing \n", "invalid band type\n", "decode_band_types: Input buffer exhausted before END element found\n", "Number of bands (%d) exceeds limit (%d).\n", "If you heard an audible artifact, there may be a bug in the decoder. Clipped intensity stereo position (%d -> %d)", "If you heard an audible artifact, there may be a bug in the decoder. Clipped noise gain (%d -> %d)", "Scalefactor (%d) out of range.\n", "Pulse tool not allowed in eight short sequence.\n", "Pulse data corrupt or invalid.\n", "error in spectral data, ESC overflow\n", "ms_present = 3 is reserved.\n", "Unknown ER channel configuration %d", "channel element %d.%d is not allocated\n", "no frame data found\n", "More than one AAC RDB per ADTS frame", "Error decoding AAC frame header.\n", "Elem type:%x id:%x\n", "skip_data_stream_element: Input buffer exhausted before END element found\n", "Not evaluating a further program_config_element as this construct is dubious at best.\n", "TYPE_FIL: Input buffer exhausted before END element found\n", "extension type: %d len:%d\n", "SBR was found before the first channel element.\n", "SBR signaled to be not-present but was found in the bitstream.\n", "Implicit SBR was found with a first occurrence after the first frame.\n", "Multiple programs", "Multiple layers", "no decoder config found\n", "incomplete frame\n", "frame length mismatch %d << %d\n", "ADTS header detected, probably as result of configuration misparsing\n", "aac_latm", "Main", "HE-AAC", "HE-AACv2", "AAC decoder", "dual_mono_mode", "Select the channel to decode for dual mono", "autoselection", "Select Main/Left channel", "Select Sub/Right channel", "both", "Select both channels", "Input contains NaN/+-Inf\n", "diff >= 0 && diff <= 120", "libavcodec/aacenc.c", "Unsupported sample rate %d\n", "Unsupported number of channels: %d\n", "Too many bits per frame requested, clamping to max\n", "Prediction requested, changing profile to AAC-Main\n", "Unsupported profile %d\n", "Cannot allocate memory.\n", "AAC encoder", "Stereo coding method", "Selected by the Encoder", "ms_off", "Disable Mid/Side coding", "ms_force", "Force Mid/Side for the whole frame if possible", "aac_coder", "Coding algorithm", "faac", "FAAC-inspired method", "anmr", "ANMR method", "twoloop", "Two loop searching method", "Constant quantizer", "aac_pns", "Perceptual Noise Substitution", "Disable perceptual noise substitution", "Enable perceptual noise substitution", "aac_is", "Intensity stereo coding", "intensity_stereo", "Disable intensity stereo coding", "Enable intensity stereo coding", "aac_tns", "Temporal noise shaping", "Disable temporal noise shaping", "Enable temporal noise shaping", "aac_pred", "Disable AAC-Main prediction", "Enable AAC-Main prediction", "icc_mode %d is reserved.\n", "illegal iid\n", "illegal icc\n", "ps extension overflow %d\n", "iid_par invalid\n", "icc_par invalid\n", "Expected to read %d PS bits actually read %d.\n", "Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\n", "bs_pointer >= 0", "libavcodec/aacsbr_template.c", "Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n", "Not strictly monotone time borders\n", "Invalid n_master: %d\n", "Invalid bitstream, crossover band index beyond array bounds: %d\n", "Unsupported sample rate for SBR: %d\n", "Invalid bs_stop_freq: %d\n", "Invalid bitstream, too many QMF subbands: %d\n", "Invalid num_bands_0: %d\n", "Invalid vDk0[%d]: %d\n", "Invalid vDk1[%d]: %d\n", "Stop frequency border too high: %d\n", "Start frequency border too high: %d\n", "Too many noise floor scale factors: %d\n", "patch construction failed\n", "Too many patches: %d\n", "SBR reset failed. Switching SBR to pure upsampling mode.\n", "Invalid bitstream - cannot apply SBR to element type %d\n", "Parametric Stereo signaled to be not-present but was found in the bitstream.\n", "Reserved SBR extensions", "SBR Extension over read.\n", "Expected to read %d SBR bytes actually read %d.\n", "element type mismatch %d != %d\n", "No quantized data read for sbr_dequant.\n", "envelope scalefactor overflow in dequant\n", "sbr->data[ch].bs_num_env > 0", "ERROR : no subband found for frequency %d\n", "kx != f_table{high,low}[0]. Derived frequency tables were not regenerated.\n", "))/113//+++((", "overflow that would need cliping in ff_acelp_interpolate()\n", "libavcodec/acelp_vectors.c", "(c)CRI", "Support for this ADX format", "dtx mode", "Note: libopencore_amrnb supports dtx\n", "The file is corrupted, pitch_lag = 0 is not allowed\n", "multi-channel AMR", "amrnb", "Frame too small (%d bytes). Truncated file?\n", "Encountered a bad or corrupted frame\n", "SID mode", "amrwb", "%d frames left in the queue on closing\n", "Queue input is backward in time\n", "Trying to remove %d samples, but the queue is empty\n", "!afq->frame_count", "libavcodec/audio_frame_queue.c", "afq->remaining_samples == afq->remaining_delay", "Trying to remove %d more samples than there are in the queue\n", "AVDCT", "DCT algorithm", "autoselect a good one (default)", "fastint", "fast integer (experimental / for debugging)", "accurate integer", "experimental / for debugging", "altivec", "faan", "floating point AAN DCT (experimental / for debugging)", "select IDCT implementation", "simplemmx", "simplearm", "simplearmv5te", "simplearmv6", "simpleneon", "simplealpha", "xvid", "xvidmmx", "faani", "floating point AAN IDCT (experimental / for debugging)", "simpleauto", "libavcodec/avpacket.c", "(unsigned)pkt->size <= 2147483647 - 32", "Palette", "New Extradata", "Param Change", "H263 MB Info", "Replay Gain", "Display Matrix", "Stereo 3D", "Audio Service Type", "Skip Samples", "JP Dual Mono", "Strings Metadata", "Subtitle Position", "Matroska BlockAdditional", "WebVTT ID", "WebVTT Settings", "Metadata Update", "p-pkt->data == pkt->size", "size<=2147483647 - 5 && p - pkt->data >= size", "length <= put_bits_left(pb)", "libavcodec/bitstream.c", "nb_codes + 1 <= (sizeof(localbuf) / sizeof((localbuf)[0]))", "symbols_size <= 2 || !symbols", "Too long VLC (%d) in init_vlc\n", "Invalid code in init_vlc\n", "needed %d had %d\n", "mpeg1video", "mpeg2video", "mpegvideo_xvmc", "rv10", "rv20", "mjpegb", "rawvideo", "msmpeg4v1", "msmpeg4v2", "msmpeg4v3", "wmv1", "wmv2", "h263p", "h263i", "flv1", "svq1", "svq3", "dvvideo", "huffyuv", "cyuv", "indeo3", "asv1", "asv2", "ffv1", "vcr1", "cljr", "mdec", "interplayvideo", "xan_wc3", "xan_wc4", "rpza", "cinepak", "ws_vqa", "msrle", "msvideo1", "idcin", "8bps", "flic", "truemotion1", "vmdvideo", "mszh", "zlib", "qtrle", "snow", "tscc", "qdraw", "vixl", "qpeg", "ffvhuff", "rv30", "rv40", "loco", "wnv1", "aasc", "indeo2", "fraps", "truemotion2", "cscd", "mmvideo", "zmbv", "smackvideo", "kmvc", "flashsv", "cavs", "jpeg2000", "vmnc", "vp6f", "dsicinvideo", "tiertexseqvideo", "dnxhd", "bethsoftvid", "vp6a", "indeo4", "indeo5", "mimic", "escape124", "dirac", "motionpixels", "aura", "aura2", "v210x", "v210", "frwu", "flashsv2", "cdgraphics", "r210", "binkvideo", "iff_ilbm", "iff_byterun1", "kgv1", "pictor", "a64_multi", "a64_multi5", "r10k", "mvc1", "mvc2", "mxpeg", "lagarith", "prores", "utvideo", "bmv_video", "vble", "dxtory", "v410", "cdxl", "zerocodec", "mss1", "msa1", "tscc2", "mts2", "cllc", "mss2", "y41p", "escape130", "avrp", "012v", "avui", "ayuv", "targa_y216", "v308", "v408", "yuv4", "avrn", "cpia", "smvjpeg", "hnm4video", "paf_video", "sanm", "sgirle", "hq_hqa", "alias_pix", "ansi", "brender_pix", "jpegls", "ljpeg", "sp5x", "sunrast", "tdsc", "vc1image", "wmv3image", "apng", "pcm_s16le", "pcm_s16be", "pcm_u16le", "pcm_u16be", "pcm_s8", "pcm_u8", "pcm_mulaw", "pcm_alaw", "pcm_s32le", "pcm_s32be", "pcm_u32le", "pcm_u32be", "pcm_s24le", "pcm_s24be", "pcm_u24le", "pcm_u24be", "pcm_s24daud", "pcm_zork", "pcm_s16be_planar", "pcm_s16le_planar", "pcm_s24le_planar", "pcm_s32le_planar", "pcm_dvd", "pcm_f32be", "pcm_f32le", "pcm_f64be", "pcm_f64le", "pcm_bluray", "pcm_lxf", "s302m", "pcm_s8_planar", "adpcm_ima_qt", "adpcm_ima_wav", "adpcm_ima_dk3", "adpcm_ima_dk4", "adpcm_ima_ws", "adpcm_ima_smjpeg", "adpcm_ms", "adpcm_4xm", "adpcm_xa", "adpcm_adx", "adpcm_ea", "adpcm_g726", "adpcm_ct", "adpcm_swf", "adpcm_yamaha", "adpcm_sbpro_4", "adpcm_sbpro_3", "adpcm_sbpro_2", "adpcm_thp", "adpcm_thp_le", "adpcm_ima_amv", "adpcm_ea_r1", "adpcm_ea_r3", "adpcm_ea_r2", "adpcm_ima_ea_sead", "adpcm_ima_ea_eacs", "adpcm_ea_xas", "adpcm_ea_maxis_xa", "adpcm_ima_iss", "adpcm_g722", "adpcm_ima_apc", "adpcm_afc", "adpcm_ima_oki", "adpcm_dtk", "adpcm_ima_rad", "adpcm_g726le", "adpcm_vima", "amr_nb", "amr_wb", "ra_144", "ra_288", "roq_dpcm", "interplay_dpcm", "xan_dpcm", "sol_dpcm", "dvaudio", "wmav1", "wmav2", "mace3", "mace6", "vmdaudio", "mp3adu", "mp3on4", "shorten", "westwood_snd1", "qdm2", "cook", "truespeech", "smackaudio", "qcelp", "wavpack", "dsicinaudio", "musepack7", "gsm_ms", "atrac3", "voxware", "nellymoser", "musepack8", "speex", "wmavoice", "wmapro", "wmalossless", "atrac3p", "sipr", "twinvq", "truehd", "mp4als", "atrac1", "binkaudio_rdft", "binkaudio_dct", "qdmc", "celt", "g723_1", "dss_sp", "g729", "8svx_exp", "8svx_fib", "bmv_audio", "ralf", "ilbc", "wavesynth", "sonic", "sonicls", "opus", "comfortnoise", "metasound", "paf_audio", "evrc", "dsd_lsbf", "dsd_msbf", "dsd_lsbf_planar", "dsd_msbf_planar", "dvd_subtitle", "dvb_subtitle", "xsub", "mov_text", "hdmv_pgs_subtitle", "dvb_teletext", "subrip", "microdvd", "mpl2", "eia_608", "jacosub", "sami", "realtext", "subviewer1", "subviewer", "vplayer", "webvtt", "hdmv_text_subtitle", "bintext", "xbin", "dvd_nav_packet", "timed_id3", "bin_data", "brender_pix_deprecated", "escape130_deprecated", "exr_deprecated", "g2m_deprecated", "hevc_deprecated", "paf_video_deprecated", "sanm_deprecated", "vp7_deprecated", "webp_deprecated", "adpcm_vima_deprecated", "opus_deprecated", "paf_audio_deprecated", "pcm_s24le_planar_deprecated", "pcm_s32le_planar_deprecated", "pcm_s16be_planar_deprecated", "tak_deprecated", "image/jpeg", "image/x-ms-bmp", "image/jp2", "image/x-portable-pixmap", "image/x-pcx", "image/png", "image/x-targa", "image/x-tga", "image/tiff", "image/webp", "image/x-xwindowdump", "application/x-truetype-font", "application/x-font", "application/vnd.ms-opentype", "application/octet-stream", "Stream is old and may not work\n", "Stream may have unhandled features\n", "Unknown chroma format %d\n", "Bitdepth greater than 8\n", "Dimensions must be an integer multiple of the chroma subsampling\n", "Unsupported picture coding mode %d\n", "next_pu_offset %d is invalid\n", "prev_pu_offset %d is invalid\n", "dump_extra", "Junk in packet\n", "Parser input %d too small\n", "s->quarter_sample", "libavcodec/error_resilience.c", "guess_dc() is out of memory\n", "internal error, slice end before start\n", "ignoring last missing slice\n", "Cannot use previous picture in error concealment\n", "Cannot use next picture in error concealment\n", "Warning MVs not available\n", "%2X ", "concealing %d DC, %d AC, %d MV errors in %c frame\n", "s->avctx->codec_id != AV_CODEC_ID_H264", "GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "ImageWidth", "Invalid TIFF tag type 0 found for %s with size %d\n", "TIFF tag type (%u)", "invalid sync code\n", "invalid channel mode: %d\n", "invalid sample size code (%d)\n", "broken stream, invalid padding\n", "sample/frame number invalid; utf8 fscked\n", "reserved blocksize code: 0\n", "illegal sample rate code %d\n", "header crc mismatch\n", "extradata NULL or too small.\n", "extradata contains %d bytes too many.\n", "extradata too small.\n", "invalid max blocksize: %d\n", "sample rate change detected in adjacent frames\n", "bits per sample change detected in adjacent frames\n", "blocking strategy change detected in adjacent frames\n", "number of channels change detected in adjacent frames\n", "sample/frame number mismatch in adjacent frames\n", "crc check failed from offset %i (frame %lld) to %i (frame %lld)\n", "couldn't allocate fifo_buf\n", "couldn't reallocate wrap buffer of size %d", "couldn't allocate FLACHeaderMarker\n", "couldn't allocate link_penalty\n", "dropping low score %i frame header from offset %i to %i\n", "couldn't reallocate buffer of size %td\n", "find_new_headers couldn't allocate FLAC header\n", "Junk frame till offset %i\n", "Bad picture start code\n", "Bad picture format\n", "%c esc_type:%d, qp:%d num:%d\n", "Forcing thread count to 1 for MJPEG encoding, use -thread_type slice or a constant quantizer if you want to use multiple cpu cores\n", "MJPEG CBR encoding works badly with frame multi-threading, consider using -threads 1, -thread_type slice or a constant quantizer.\n", "non_deterministic", "Forcing thread count to 1 for huffyuv encoding with first pass or context 1\n", "!avctx->internal->frame_thread_encoder", "libavcodec/frame_thread_encoder.c", "!thread_avctx->internal->frame_thread_encoder", "ff_frame_thread_encoder_init failed\n", "%dx%d image at pos (%d;%d) [area:%dx%d]\n", "No available color, can not use transparency\n", "GIF does not support resolutions above 65535x65535\n", "avctx->pix_fmt == AV_PIX_FMT_PAL8", "libavcodec/gif.c", "GIF encoder", "gifflags", "set GIF flags", "enable picture offsetting", "transdiff", "enable transparency detection between frames", "GIF87aGIF89acannot decode frame without keyframe\n", "code=%02x '%c'\n", "picture doesn't have either global or local palette.\n", "Invalid image width.\n", "Invalid image height.\n", "Image too wide by %d, truncating.\n", "Image too high by %d, truncating.\n", "LZW init failed\n", "LZW decode failed\n", "gif decoder", "trans_color", "color value (ARGB) that is used instead of transparent color", "Error at MB: %d\n", "discarding %d junk bits at end, next would be %X\n", "overreading %d bits\n", "slice end not reached but screenspace end (%d left %06X, score= %d)\n", "this codec does not support truncated bitstreams\n", "Discarding excessive bitstream in packed xvid\n", "Reverting picture dimensions change due to header decoding failure\n", "format change not supported\n", "GEOV", "GEOX", "Unsupported codec %d\n", "L263", "S263", "Invalid POC %d<%d\n", "Increasing reorder buffer to %d\n", "pics <= 16", "libavcodec/h264.c", "no picture %s\n", "Invalid UE golomb code\n", "Reference not available for error concealing\n", "Reference invalid\n", "top block unavailable for requested intra4x4 mode %d at %d %d\n", "left block unavailable for requested intra4x4 mode %d at %d %d\n", "out of range intra chroma pred mode at %d %d\n", "top block unavailable for requested intra mode at %d %d\n", "left block unavailable for requested intra mode at %d %d\n", "AVC: nal size %d\n", "NAL %d/%d at %d/%d length %d\n", "AVC: Consumed only %d bytes instead of %d\n", "Ignoring NAL %d in global header/extradata\n", "Invalid inter IDR frame\n", "invalid mixed IDR / non IDR frames cannot be decoded in slice multithreading mode\n", "data partitioning", "SPS decoding failure, trying again with the complete NAL\n", "next_avc - buf_index + consumed == nalsize", "Unknown NAL code: %d (%d bits)\n", "decode_slice_header error\n", "avcC %d too short\n", "Decoding sps %d from avcC failed\n", "Decoding pps %d from avcC failed\n", "buf_index <= buf_size", "Q264", "no frame!\n", "Duplicating field %d to fill missing\n", "pict->buf[0] || !*got_frame", "luma_log2_weight_denom %d is out of range\n", "chroma_log2_weight_denom %d is out of range\n", "reference overflow %u > %u or %u > %u\n", "Error resilience with slice threads is enabled. It is unsafe and unsupported and may crash. Use it at your own risk\n", "H264 Decoder", "is_avc", "is avc", "nal_length_size", "enable_er", "Enable error resilience on damaged frames (unsafe)", "Reference %d >= %d\n", "gray chroma\n", "cabac decode of qscale diff failed at %d %d\n", "Invalid level prefix\n", "negative number of zero coeffs at %d %d\n", "offset == (sizeof(coeff_token_vlc_tables) / sizeof((coeff_token_vlc_tables)[0]))", "libavcodec/h264_cavlc.c", "mb_type %d in %c slice too large at %d %d\n", "Not enough data for an intra PCM block.\n", "B sub_mb_type %u out of range at %d %d\n", "P sub_mb_type %u out of range at %d %d\n", "ref %u overflow\n", "cbp too large (%u) at %d %d\n", "dquant out of range (%d) at %d %d\n", "Too big extradata size, corrupted stream or invalid MP4/AVCC bitstream\n", "Packet header is not contained in global extradata, corrupted stream or invalid MP4/AVCC bitstream\n", "Warning: SPS NALU missing or invalid. The resulting stream may not play.\n", "Warning: PPS NALU missing or invalid. The resulting stream may not play.\n", "SPS not present in the stream, nor in AVCC, stream may be unreadable\n", "PPS not present in the stream, nor in AVCC, stream may be unreadable\n", "AVC-parser: nal size %d remaining %d\n", "pps_id %u out of range\n", "non-existing PPS %u referenced\n", "non-existing SPS %u referenced\n", "illegal reordering_of_pic_nums_idc %d\n", "reference count %d overflow\n", "illegal memory management control operation %d\n", "missing picture in access unit with size %d\n", "!dst->f->buf[0]", "libavcodec/h264_picture.c", "src->f->buf[0]", "hardware accelerator failed to decode picture\n", "Gray", "PIC-AFF", "MB-AFF", "sps_id %u out of range\n", "chroma_format_idc %u", "separate color planes are not supported\n", "Different chroma and luma bit depth", "illegal bit depth value (%d, %d)\n", "log2_max_frame_num_minus4 out of range (0-12): %d\n", "log2_max_poc_lsb (%d) is out of range\n", "poc_cycle_length overflow %d\n", "illegal POC type %d\n", "too many reference frames %d\n", "mb_width/height overflow\n", "discarding sps cropping, original values are l:%d r:%d t:%d b:%d\n", "Reducing left cropping to %d chroma samples to preserve alignment.\n", "crop values invalid %d %d %d %d / %d %d\n", "illegal aspect ratio\n", "Truncated VUI\n", "time_scale/num_units_in_tick invalid or unsupported (%u/%u)\n", "Clipping illegal num_reorder_frames %d\n", "Overread %s by %d bits\n", "sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %d/%d b%d reo:%d\n", "CABAC", "CAVLC", "LPAR", "CONSTR", "REDU", "8x8DCT", "Invalid luma bit depth=%d\n", "Unimplemented luma bit depth=%d\n", "FMO not supported\n", "reference overflow (pps)\n", "Current profile doesn't provide more RBSP data in PPS, skipping\n", "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n", "MMCO opcode [%d, %d] at %d mismatches between slices\n", "remove short %d count %d\n", "%d %d %p\n", "short term list:\n", "%u fn:%d poc:%d %p\n", "long term list:\n", "index < def_len", "libavcodec/h264_refs.c", "len <= 32", "Discarding mismatching reference\n", "reference count overflow\n", "abs_diff_pic_num overflow\n", "long_term_pic_idx overflow\n", "illegal modification_of_pic_nums_idc %u\n", "Missing reference picture, default is %d\n", "av_buffer_get_ref_count(sl->ref_list[list][index].parent->f->buf[0]) > 0", "reference picture missing during reorder\n", "Inconsistent MMCO state between slices [%d, %d]\n", "no mmco here\n", "mmco:%d %d %d\n", "mmco: unref short failure\n", "mmco: unref short %d count %d\n", "mmco: unref long failure\n", "mmco: cannot assign current picture to short and long at the same time\n", "mmco: cannot assign current picture to 2 long term references\n", "!h->cur_pic_ptr->long_ref", "illegal short term reference assignment for second field in complementary field pair (first field is long term)\n", "illegal short term buffer state detected\n", "number of reference frames (%d+%d) exceeds max (%d; probably corrupt input), discarding one\n", "illegal long ref in memory management control operation %d\n", "x264 - core 0000", "user data:\"%s\"\n", "SEI %d len:%d\n", "SEI type %d size %d truncated at %d\n", "ct_type:%X pic_struct:%d\n", "sei_recovery_frame_cnt: %d\n", "non-existing SPS %d referenced in buffering period\n", "SEI FPA %d %d %d %d %d %d\n", "Green Metadata Info SEI message\n", "green_metadata_type                            = %d\n", "green_metadata_period_type                     = %d\n", "green_metadata_num_seconds                     = %d\n", "green_metadata_num_pictures                    = %d\n", "SEI GREEN Complexity Metrics                   = %f %f %f %f\n", "xsd_metric_type                                = %d\n", "xsd_metric_value                               = %f\n", "unknown SEI type %d\n", "Could not allocate memory\n", "VDPAU decoding does not support video colorspace.\n", "Unsupported bit depth %d\n", "too many threads/slices %d, reducing to %d\n", "context_init() failed.\n", "Attempt to start a frame outside SETUP state\n", "no frame buffer available\n", "!pic->f->data[0]", "libavcodec/h264_slice.c", "!pic->hwaccel_picture_private", "h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * sl->linesize * ((scan8[15] - scan8[0]) >> 3)", "Slice overlaps with next at %d\n", "bytestream overread %td\n", "error while decoding MB %d %d, bytestream %td\n", "error while decoding MB %d %d\n", "h264_slice_header_init() failed", " fix", " IDR", "TEMP", "SPAT", "!h->setup_finished", "Too many fields\n", "Cannot decode multiple access units as slice threads\n", "Broken frame packetizing\n", "slice type %d too large at %d\n", "A non-intra slice in an IDR NAL unit.\n", "PPS change from %d to %d forbidden\n", "PPS changed between slices\n", "SPS changed in the middle of the frame\n", "Delayed frames seen. Reenabling low delay requires a codec flush.\n", "h->sps.crop_right + h->sps.crop_left < (unsigned)h->width", "h->sps.crop_top + h->sps.crop_bottom < (unsigned)h->height", "Invalid cropped dimensions: %dx%d.\n", "Ignoring cropping information.\n", "changing width %d -> %d / height %d -> %d on slice %d\n", "Reinit context to %dx%d, pix_fmt: %s\n", "h264_slice_header_init() failed\n", "Cannot (re-)initialize context during parallel decoding.\n", "Frame num change from %d to %d\n", "This stream was generated by a broken encoder, invalid 8x8 inference\n", "Changing field mode (%d -> %d) between slices is not allowed\n", "unset cur_pic_ptr on slice %d\n", "h->cur_pic_ptr", "h->cur_pic_ptr->f->buf[0]", "Invalid field mode combination %d/%d\n", "Found reference and non-reference fields in the same frame, which", "Frame num gap %d %d\n", "first_mb_in_slice overflow\n", "cabac_init_idc %u overflow\n", "QP %u out of range\n", "deblocking_filter_idc %u out of range\n", "deblocking filter parameters %d %d out of range\n", "Cannot parallelize slice decoding with deblocking filter type 1, decoding such frames in sequential order\nTo parallelize slice decoding you need video encoded with disable_deblocking_filter_idc set to 2 (deblock only edges that do not cross slices).\nSetting the flags2 libavcodec option to +fast (-flags2 +fast) will disable deblocking across slices and enable parallel slice decoding but will generate non-standard-compliant output.\n", "Deblocking switched inside frame.\n", "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n", "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n", "context_count && h->slice_ctx[context_count - 1].mb_y < h->mb_height", "bit_depth<=8", "libavcodec/h264dsp.c", "The cu_qp_delta %d is outside the valid range [%d, %d].\n", "cu_chroma_qp_offset_idx not yet tested.\n", "Error splitting the input into NAL units.\n", "PPS id out of range: %d\n", "PPS changed between slices.\n", "Invalid slice segment address: %u.\n", "Unknown slice type: %d.\n", "Inter slices in an IRAP frame.\n", "Ignoring POC change between slices: %d -> %d\n", "No ref lists in the SPS.\n", "Too many refs: %d/%d.\n", "Zero refs for a frame with P or B slices.\n", "Invalid collocated_ref_idx: %d.\n", "luma_log2_weight_denom %d is invalid\n", "Invalid number of merging MVP candidates: %d.\n", "Independent slice segment missing.\n", "num_entry_point_offsets %d is invalid\n", "offset_len %d is invalid\n", "Failed to allocate memory\n", "too many slice_header_extension_data_bytes\n", "The slice_qp %d is outside the valid range [%d, 51].\n", "Impossible slice segment.\n", "Overread slice header by %d bits\n", "Error constructing the frame RPS.\n", "First slice in a frame missing.\n", "Non-matching NAL types of the VCL NALUs: %d %d\n", "Error constructing the reference lists for the current slice.\n", "WPP ctb addresses are wrong (%d %d %d %d)\n", "entry_point_offset table is corrupted\n", "Skipping NAL unit %d\n", "Error parsing NAL unit #%d.\n", "Invalid long term RPS.\n", "Verifying checksum for frame with POC %d: ", "plane %d - correct ", "mismatching checksum of plane %d - ", " != ", "Decoded frame with POC %d.\n", "Invalid NAL unit size in extradata.\n", "Decoding nal unit %d %d from hvcC failed\n", "Impossible initial tile.\n", "Previous slice segment missing\n", "HEVC decoder", "apply_defdispwin", "Apply default display window from VUI", "strict-displaywin", "stricly apply default display window size", "The input looks like it is Annex B already\n", "Invalid NAL unit type in extradata: %d\n", "No parameter sets in the extradata\n", "hevc_mp4toannexb", "libavcodec/hevc_parse.c", "TRAIL_N", "TRAIL_R", "STSA_N", "STSA_R", "RADL_N", "RADL_R", "RASL_N", "RASL_R", "BLA_W_LP", "BLA_W_RADL", "BLA_N_LP", "IDR_W_RADL", "IDR_N_LP", "CRA_NUT", "EOS_NUT", "EOB_NUT", "FD_NUT", "SEI_PREFIX", "SEI_SUFFIX", "Invalid NAL unit size.\n", "No start code is found.\n", "nal_unit_type: %d(%s), nuh_layer_id: %d, temporal_id: %d\n", "Invalid NAL unit %d, skipping.\n", "Invalid NAL unit: %d\n", "SPS id out of range: %d\n", "missing picture in access unit\n", "Main profile bitstream\n", "Main 10 profile bitstream\n", "Main Still Picture profile bitstream\n", "Range Extension profile bitstream\n", "Unknown HEVC profile: %d\n", "nb_cpb %d invalid\n", "PTL information too short\n", "PTL information for sublayer %i too short\n", "Not enough data for sublayer %i level_idc\n", "Invalid delta in scaling list data: %d.\n", "!(s->sps_list[id] && s->sps == (HEVCSPS*)s->sps_list[id]->data)", "libavcodec/hevc_ps.c", "Invalid value of delta_idx in slice header RPS: %d > %d.\n", "Invalid value of abs_delta_rps: %d\n", "Too many refs in a short term RPS.\n", "Decoding VPS\n", "VPS id out of range: %d\n", "vps_reserved_three_2bits is not three\n", "vps_reserved_ffff_16bits is not 0xffff\n", "vps_max_sub_layers out of range: %d\n", "vps_max_dec_pic_buffering_minus1 out of range: %d\n", "vps_max_num_reorder_pics out of range: %d\n", "too many layer_id_included_flags\n", "vps_num_hrd_parameters %d is invalid\n", "Overread VPS by %d bits\n", "VPS %d does not exist\n", "sps_max_sub_layers out of range: %d\n", "chroma_format_idc %d is invalid\n", "discarding sps conformance window, original values are l:%u r:%u t:%u b:%u\n", "Luma bit depth (%d) is different from chroma bit depth (%d), this is unsupported.\n", "4:2:0, 4:2:2, 4:4:4 supports are currently specified for 8, 10 and 12 bits.\n", "chroma_format_idc is %d, depth is %d", "log2_max_pic_order_cnt_lsb_minus4 out range: %d\n", "sps_max_dec_pic_buffering_minus1 out of range: %d\n", "sps_max_num_reorder_pics out of range: %d\n", "Invalid value %d for log2_min_cb_size", "Invalid value %d for log2_diff_max_min_coding_block_size", "Invalid value for log2_min_tb_size", "Invalid value %d for log2_diff_max_min_transform_block_size", "PCM bit depth (%d) is greater than normal bit depth (%d)\n", "Too many short term RPS: %d.\n", "num_long_term_ref_pics_sps %d is out of range.\n", "Decoding VUI\n", "Unknown SAR index: %u.\n", "Invalid default display window\n", "discarding vui default display window, original values are l:%u r:%u t:%u b:%u\n", "Strange VUI timing information, retrying...\n", "Retry got %i/%i fps\n", "extended_precision_processing_flag not yet implemented\n", "high_precision_offsets_enabled_flag not yet implemented\n", "cabac_bypass_alignment_enabled_flag not yet implemented\n", "Reducing left output window to %d chroma samples to preserve alignment.\n", "Invalid visible frame dimensions: %dx%d.\n", "Displaying the whole video surface.\n", "CTB size out of range: 2^%d\n", "log2_ctb_size %d differs from the bounds of any known profile\n", "log2_ctb_size %d", "Invalid coded frame dimensions.\n", "max_transform_hierarchy_depth_inter out of range: %d\n", "max_transform_hierarchy_depth_intra out of range: %d\n", "max transform block size out of range: %d\n", "Overread SPS by %d bits\n", "Decoding SPS\n", "Parsed SPS: id %d; coded wxh: %dx%d; cropped wxh: %dx%d; pix_fmt: %s.\n", "Decoding PPS\n", "SPS %u does not exist.\n", "diff_cu_qp_delta_depth %d is invalid\n", "pps_cb_qp_offset out of range: %d\n", "pps_cr_qp_offset out of range: %d\n", "num_tile_columns_minus1 out of range: %d\n", "num_tile_rows_minus1 out of range: %d\n", "Invalid tile widths.\n", "Invalid tile heights.\n", "pps_beta_offset_div2 out of range: %d\n", "pps_tc_offset_div2 out of range: %d\n", "log2_parallel_merge_level_minus2 out of range: %d\n", "chroma_qp_offset_list_len_minus1 shall be in the range [0, 5].\n", "cb_qp_offset_list not tested yet.\n", "Overread PPS by %d bits\n", "!frame->hwaccel_picture_private", "libavcodec/hevc_refs.c", "Error allocating frame, DPB full.\n", "Could not find ref with POC %d\n", "Duplicate POC in a sequence: %d.\n", "Output frame with POC %d.\n", "Zero refs in the frame RPS.\n", "Invalid reference index.\n", "Decoding SEI\n", "BOTTOM Field\n", "TOP Field\n", "Skipped PREFIX SEI %d\n", "num_sps_ids_minus1 %d invalid\n", "active_parameter_set_id %d invalid\n", "Skipped SUFFIX SEI %d\n", "Butterworth filter currently only supports low-pass filter mode\n", "Butterworth filter currently only supports even filter orders\n", "Biquad filter currently only supports high-pass and low-pass filter modes\n", "Biquad filter must have order of 2\n", "filter type is not currently implemented\n", "libavcodec/imgconvert.c", "imx bitstream filter only applies to mpeg2video codec\n", "imxdump", "Marker bit missing at %d of %d %s\n", "after picture_number", "Bad H263 id\n", "Intel H263 free format not supported\n", "Wrong Intel H263 format\n", "Bad value for reserved field\n", "Invalid marker\n", "in dimensions", "Invalid aspect ratio.\n", "table size %i does not match needed %i\n", "s->mb_width>0", "libavcodec/intrax8.c", "illegal dc %d at %d %d\n", "illegal ac vlc code at %dx%d\n", "run overflow at %dx%d i:%d\n", " UMV", " LONG", " AIC", " AIV", " LOOP", "qp:%d %c size:%d rnd:%d%s%s%s%s%s%s%s%s%s %d/%d\n", "before MBA", "after MBA", "after SQUANT", "b mb_type damaged at %d %d\n", "b cbpy damaged at %d %d\n", "I cbpc damaged at %d %d\n", "I cbpy damaged at %d %d\n", "Header looks like RTP instead of H.263\n", "in PTYPE", "H263 SAC not supported\n", "Syntax-based Arithmetic Coding (SAC) not supported\n", "Reference Picture Selection not supported\n", "Independent Segment Decoding not supported\n", "Bad UFEP type (%d)\n", "zero framerate\n", "rectangular slices not supported\n", "unordered slices not supported\n", "SEPB1", "SEPB2", "ZYGO", " %5d", "n <= 1024", "libavcodec/kbdwin.c", "No error", "Invalid handle", "Memory allocation error", "Unsupported parameter", "Invalid config", "Initialization error", "AAC library initialization error", "SBR library initialization error", "Transport library initialization error", "Metadata library initialization error", "Encoding error", "End of file", "Unknown error", "Unable to encode frame: %s\n", "Unable to open the encoder: %s\n", "Unable to set the AOT %d: %s\n", "Unable to enable SBR for ELD: %s\n", "Unable to set the sample rate %d: %s\n", "Unsupported number of channels %d\n", "Unable to set channel mode %d: %s\n", "Unable to set wav channel order %d: %s\n", "VBR quality %d out of range, should be 1-5\n", "Note, the VBR setting is unsupported and only works with some parameter combinations\n", "Unable to set the VBR bitrate mode %d: %s\n", "Unable to set the bitrate %d: %s\n", "Unable to set the transmux format: %s\n", "Unable to set header period: %s\n", "Unable to set signaling mode %d: %s\n", "Unable to set afterburner to %d: %s\n", "cutoff valid range is %d-20000\n", "Unable to set the encoder bandwidth to %d: %s\n", "Unable to initialize the encoder: %s\n", "Unable to get encoder info: %s\n", "libfdk_aac", "afterburner", "Afterburner (improved quality)", "eld_sbr", "Enable SBR for ELD (for SBR in other configurations, use the -profile parameter)", "SBR/PS signaling style", "Choose signaling implicitly (explicit hierarchical by default, implicit if global header is disabled)", "implicit", "Implicit backwards compatible signaling", "explicit_sbr", "Explicit SBR, implicit PS signaling", "explicit_hierarchical", "Explicit hierarchical signaling", "Output LATM/LOAS encapsulated data", "header_period", "StreamMuxConfig and PCE repetition period (in frames)", "VBR mode (1-5)", "WebPEncode() failed with error: %d\n", "libwebp", "compression_level", "global_quality", "Use lossless mode", "Configuration preset", "do not use a preset", "default preset", "digital picture, like portrait, inner shot", "photo", "outdoor photograph, with natural lighting", "drawing", "hand or line drawing, with high-contrast details", "small-sized colorful images", "text-like", "cr_threshold", "Conditional replenishment threshold", "cr_size", "Conditional replenishment block size", "Quality", "Lossy", "invalid compression level: %d\n", "%s - quality=%.1f method=%d\n", "Picture size is too large. Max is %dx%d.\n", "Using libwebp for RGB-to-YUV conversion. You may want to consider passing in YUV instead for lossy encoding.\n", "Copying frame due to differing chroma linesizes.\n", "Using libwebp for YUV-to-RGB conversion. You may want to consider passing in RGB instead for lossless encoding.\n", "-qscale is ignored, -crf is recommended.\n", "Error setting preset/tune %s/%s.\n", "Possible presets:", "Possible tunes:", "weightp", "bad option '%s': '%s'\n", "bad value for '%s': '%s'\n", "Failed to parse level\n", "psy-rd", "Error parsing option '%s' with value '%s'.\n", "deblock", "partitions", "baseline", "high10", "high422", "high444", "Error setting profile %s.\n", "Possible profiles:", "%255[^:=]=%255[^:]", "Error parsing option '%s = %s'.\n", "libx264rgb", "libx264", "ultrafast", "superfast", "veryfast", "faster", "slower", "veryslow", "placebo", "animation", "stillimage", "fastdecode", "zerolatency", "flags2", "i_qfactor", "b_qfactor", "qmin", "qdiff", "qblur", "qcomp", "sc_threshold", "trellis", "me_range", "me_method", "subq", "b_strategy", "keyint_min", "+cgop", "rc_init_occupancy", "Set the encoding preset (cf. x264 --fullhelp)", "tune", "Tune the encoding params (cf. x264 --fullhelp)", "Set profile restrictions (cf. x264 --fullhelp) ", "fastfirstpass", "Use fast settings when encoding first pass", "Specify level (as defined by Annex A)", "passlogfile", "Filename for 2 pass stats", "wpredp", "Weighted prediction for P-frames", "x264opts", "x264 options", "Select the quality for constant quality mode", "crf_max", "In CRF mode, prevents VBV from lowering quality beyond this point.", "Constant quantization parameter rate control method", "aq-mode", "AQ method", "aq_mode", "Variance AQ (complexity mask)", "autovariance", "Auto-variance AQ", "autovariance-biased", "Auto-variance AQ with bias to dark scenes", "aq-strength", "AQ strength. Reduces blocking and blurring in flat and textured areas.", "Use psychovisual optimizations.", "Strength of psychovisual optimization, in <psy-rd>:<psy-trellis> format.", "rc-lookahead", "Number of frames to look ahead for frametype and ratecontrol", "weightb", "Weighted prediction for B-frames.", "Weighted prediction analysis method.", "smart", "Calculate and print SSIM stats.", "intra-refresh", "Use Periodic Intra Refresh instead of IDR frames.", "bluray-compat", "Bluray compatibility workarounds.", "b-bias", "Influences how often B-frames are used", "b-pyramid", "Keep some B-frames as references.", "b_pyramid", "Strictly hierarchical pyramid", "Non-strict (not Blu-ray compatible)", "mixed-refs", "One reference per partition, as opposed to one reference per macroblock", "8x8dct", "High profile 8x8 transform.", "fast-pskip", "Use access unit delimiters.", "mbtree", "Use macroblock tree ratecontrol.", "Loop filter parameters, in <alpha:beta> form.", "cplxblur", "Reduce fluctuations in QP (before curve compression)", "A comma-separated list of partitions to consider. Possible values: p8x8, p4x4, b8x8, i8x8, i4x4, none, all", "direct-pred", "Direct MV prediction mode", "temporal", "slice-max-size", "Limit the size of each slice in bytes", "nal-hrd", "Signal HRD information (requires vbv-bufsize; cbr not allowed in .mp4)", "avcintra-class", "AVC-Intra class 50/100/200", "motion-est", "Set motion estimation method", "tesa", "forced-idr", "If forcing keyframes, force them as IDR frames.", "x264-params", "Override the x264 configuration using a :-separated list of key=value parameters", "lpc_type == FF_LPC_TYPE_CHOLESKY || lpc_type == FF_LPC_TYPE_LEVINSON", "libavcodec/lpc.c", "s->maxbits >= 9 && s->maxbits <= 12", "libavcodec/lzwenc.c", "input is truncated\n", "AVI1", "input is not MJPEG/AVI1\n", "mjpeg2jpeg", "mjpega bitstream filter only applies to mjpeg codec\n", "mjpg", "bitstream already formatted\n", "could not find SOS marker in bitstream\n", "mjpegadump", "Single field\n", "mjpeg_decode_dc: bad vlc: %d:%d (%p)\n", "nb_codes <= 256", "libavcodec/mjpegdec.c", "dqt: len %d is too large\n", "dqt: invalid precision\n", "index=%d\n", "qscale[%d]: %d\n", "dht: len %d is too large\n", "class=%d index=%d nb_codes=%d\n", "using external huffman table\n", "error using external huffman table, switching back to internal\n", "bottom field first\n", "MJPG", "AVID: len:%d %d\n", "bits %d is invalid\n", "Changeing bps to %d\n", "lowres is not possible with lossless jpeg\n", "sof0: picture: %dx%d\n", "nb_components changing in interlaced picture\n", "JPEG-LS that is not <= 8 bits/component or 16-bit gray", "quant_index is invalid\n", "Invalid sampling factor in component %d %d:%d\n", "component %d %d:%d id: %d quant:%d\n", "Subsampling in JPEG-LS", "progressively coded interlaced picture", "pix fmt id %x\n", "s->nb_components == 3", "s->nb_components == 4", "Unhandled pixel format 0x%x bits:%d\n", "lowres not supported for weird subsampling\n", "Unsupported number of components %d\n", "Could not get a pixel format descriptor.\n", "decode_sof0: error, len(%d) mismatch\n", "Unsupported coding and pixel format combination\n", "sequential DCT", "PRCT", "Can not process SOS before SOF, skipping\n", "s->picture_ptr->data[0]", "decode_sos: nb_components (%d) unsupported\n", "decode_sos: invalid len (%d)\n", "component: %d\n", "decode_sos: index(%d) out of components\n", "CJPG", "%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\n", "s->picture_ptr == s->picture", "nb_components>=1 && nb_components<=4", "ss>=0 && Ah>=0 && Al>=0", "SS/SE %d/%d is invalid\n", "error count: %d\n", "ZRL overflow: %d\n", "error y=%d x=%d\n", "mb_bitmask_size mismatches\n", "overread %d\n", "error dc\n", "AVRn interlaced picture marker found\n", "decode_sos: ac/dc index out of range\n", "escaping removed %td bytes\n", "Invalid escape sequence\n", "MJPEG packet 0x%x too big (%d/%d), corrupt data?\n", "marker=%x avail_size_in_buf=%td\n", "invalid buffer\n", "startcode: %X\n", "restart marker: %d\n", "APPx (%s / %8X) len=%d\n", "polarity %d\n", "JFIF", "mjpeg: JFIF header found (version: %x.%x) SAR=%d/%d\n", "Adob", "mjpeg: Adobe header found, transform=%d\n", "LJIF", "Pegasus lossless jpeg header found\n", "unknown colorspace %d\n", "Mismatching LJIF tag\n", "COLR %d\n", "xfrm", "XFRM %d\n", "_JPS", "_JPSJPS_\n", "mjpeg: invalid TIFF header in EXIF data\n", "mjpeg: error decoding EXIF data\n", "mjpeg: Apple MJPEG-A header found\n", "mjpeg: error, decode_app parser read over the end\n", "comment: '%s'\n", "AVID", "CS=ITU601", "Intel(R) JPEG Library, version 1", "Metasoft MJPEG Codec", "MULTISCOPE II", "JPEG-LS support not enabled.\n", "huffman table decode error\n", "Found EOI before any SOF, ignoring\n", "QP: %d\n", "restart interval: %d\n", "mjpeg: unsupported coding type (%x)\n", "marker parser used %d bytes (%d bits)\n", "EOI missing, emulating\n", "No JPEG data found in image\n", "avctx->pix_fmt == AV_PIX_FMT_YUVJ444P || avctx->pix_fmt == AV_PIX_FMT_YUV444P || avctx->pix_fmt == AV_PIX_FMT_YUVJ440P || avctx->pix_fmt == AV_PIX_FMT_YUV440P || avctx->pix_fmt == AV_PIX_FMT_YUVA444P || avctx->pix_fmt == AV_PIX_FMT_YUVJ420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P16LE|| avctx->pix_fmt == AV_PIX_FMT_YUVA420P || avctx->pix_fmt == AV_PIX_FMT_YUVA420P16LE|| avctx->pix_fmt == AV_PIX_FMT_GBRP || avctx->pix_fmt == AV_PIX_FMT_GBRAP", "w > 0", "avctx->pix_fmt == AV_PIX_FMT_YUVJ444P || avctx->pix_fmt == AV_PIX_FMT_YUV444P || avctx->pix_fmt == AV_PIX_FMT_YUVJ422P || avctx->pix_fmt == AV_PIX_FMT_YUV422P || avctx->pix_fmt == AV_PIX_FMT_YUVJ420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P || avctx->pix_fmt == AV_PIX_FMT_YUV440P || avctx->pix_fmt == AV_PIX_FMT_YUVJ440P || avctx->pix_fmt == AV_PIX_FMT_YUVA444P || avctx->pix_fmt == AV_PIX_FMT_YUVA420P || avctx->pix_fmt == AV_PIX_FMT_YUVA420P16LE|| avctx->pix_fmt == AV_PIX_FMT_GBRP || avctx->pix_fmt == AV_PIX_FMT_GBRAP", "decode frame unused %td bytes\n", "MJPEG decoder", "extern_huff", "Use external huffman table.", "JPEG does not support resolutions above 65500x65500\n", "mjpeg encoder", "Cannot store exact aspect ratio %d:%d\n", "libavcodec/mjpegenc_common.c", "avctx->codec->priv_data_size == sizeof(MpegEncContext)", "n <= s->buf_end - s->buf_ptr", "Buffer reallocation failed\n", "packet too short, unable to read major sync\n", "major sync info header checksum error\n", "ff_combine_frame failed\n", "mlpparse: Parity check failed.\n", "ME_MAP size is too small for SAB diamond\n", "me_method is only allowed to be set to zero and epzs; for hex,umh,full and others see dia_size\n", "ME_MAP size may be a little small for the selected diamond size\n", "s->quarter_sample==0 || s->quarter_sample==1", "libavcodec/motion_est.c", "s->linesize == c->stride", "s->uvlinesize == c->uvstride", "s->pict_type==AV_PICTURE_TYPE_P", "range <= 16 || !s->msmpeg4_version", "range <=256 || !(s->codec_id == AV_CODEC_ID_MPEG2VIDEO && s->avctx->strict_std_compliance >= 0)", "mov2textsub", "text2movsub", "FFCMP3 0.0", "Extradata invalid %d\n", "Could not find bitrate_index.\n", "mp3decomp", "libavcodec/mpeg12.c", "The mpeg4_unpack_bframes bitstream filter is only useful for mpeg4.\n", "Updating DivX userdata (remove trailing 'p') in extradata.\n", "Found %d VOP startcode(s) in this packet.\n", "Missing one N-VOP packet, discarding one B-frame.\n", "Found %d VOP headers in one packet, only unpacking one.\n", "Skipping N-VOP.\n", "Updating DivX userdata (remove trailing 'p').\n", "mpeg4_unpack_bframes", "Failed to parse extradata\n", "DivX%db%d%c", "FFmpe%*[^b]b%d", "FFmpeg v%d.%d.%d / libavcodec build: %d", "Lavc%d.%d.%d", "ffmpeg", "XviD%d", "after new_pred", "before sprite_trajectory", "after sprite_trajectory", "dc<0 at %dx%d\n", "dc overflow at %dx%d\n", "illegal dc vlc\n", "dc marker bit missing\n", "1. marker bit missing in rvlc esc\n", "2. marker bit missing in rvlc esc\n", "reverse esc missing\n", "1. marker bit missing in 3. esc\n", "2. marker bit missing in 3. esc\n", "|level| overflow in 3. esc, qp=%d\n", "ac-tex damaged at %d %d\n", "mcbpc damaged at %d %d\n", "P cbpy damaged at %d %d\n", "illegal MB_type\n", "texture corrupted at %d %d %d\n", "marker does not match f_code\n", "illegal mb_num in video packet (%d %d) \n", "before time_increment in video packed header", "before vop_coding_type in video packed header", "untested\n", "Error, video packet header damaged (f_code=0)\n", "Error, video packet header damaged (b_code=0)\n", "mcbpc corrupted at %d %d\n", "DC corrupted at %d %d\n", "slice below monitor ...\n", "marker missing after first I partition at %d %d\n", "marker missing after first P partition at %d %d\n", "I cbpy corrupted at %d %d\n", "P cbpy corrupted at %d %d\n", "XVID", "XVIX", "RMP4", "ZMP4", "SIPP", "DIVX", "UMP4", "bugs: %X lavc_build:%d xvid_build:%d divx_version:%d divx_build:%d %s\n", "scalability ", "qpel ", "partition ", "rvlc ", " VOLC", "WV1F", "QMP4", "frame skip %d\n", "startcode: %3X ", "Video Object Start", "Video Object Layer Start", "Reserved", "FGS bp start", "Visual Object Seq Start", "Visual Object Seq End", "User Data", "Group of VOP start", "Video Session Error", "Visual Object Start", "Video Object Plane start", "slice start", "extension start", "fgs start", "FBA Object start", "FBA Object Plane start", "Mesh Object start", "Mesh Object Plane start", "Still Texture Object start", "Texture Spatial Layer start", "Texture SNR Layer start", "Texture Tile start", "Texture Shape Layer start", "stuffing start", "System start", "illegal chroma format\n", "after first_half_bitrate", "after latter_half_bitrate", "after first_half_vbv_buffer_size", "after first_half_vbv_occupancy", "after latter_half_vbv_occupancy", "only rectangular vol supported\n", "Gray shape not supported\n", "before time_increment_resolution", "framerate==0\n", "before fixed_vop_rate", "before width", "before height", "after height", "MP4S", "MPEG4 OBMC not supported (very likely buggy encoder)\n", "Static Sprites not supported\n", "after sprite_width", "after sprite_height", "after sprite_left", "after sprite_top", "%d sprite_warping_points\n", "N-bit not supported\n", "quant precision %d\n", "insufficient data for custom matrix\n", "VOL Header truncated\n", "in complexity estimation part 1", "in complexity estimation part 2", "Invalid Complexity estimation method %d\n", "new pred not supported\n", "reduced resolution VOP not supported\n", "scalability not supported\n", "tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\n", "GOP header invalid\n", "in gop_header", "low_delay flag set incorrectly, clearing it\n", "before time_increment", "time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\n", "time_increment_bits set to %d bits, based on bitstream analysis\n", "before vop_coded", "vop not coded\n", "after width", "after hor_spat_ref", "sprite_brightness_change not supported\n", "static sprite not supported\n", "Error, header damaged or not MPEG4 header (qscale=0)\n", "Error, header damaged or not MPEG4 header (f_code=0)\n", "Error, header damaged or not MPEG4 header (b_code=0)\n", "qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%lld tincr:%d\n", "load backward shape isn't supported\n", "looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n", "Video uses a non-standard and wasteful way to store B-frames ('packed B-frames'). Consider using the mpeg4_unpack_bframes bitstream filter without encoding but stream copy to fix it.\n", "MPEG4 Video Decoder", "1/4 subpel MC", "divx_packed", "divx style packed b frames", "Interlaced error concealment is not fully implemented\n", "MP3ADU full parser", "big_values too big\n", "invalid block type\n", "switch point in 8khz", "overread, skip %d enddists: %d %d\n", "bits_left=%d\n", "offset == (sizeof(huff_vlc_tables) / sizeof((huff_vlc_tables)[0]))", "libavcodec/mpegaudiodec_template.c", "invalid old backstep %d\n", "invalid new backstep %d\n", "s->frame", "discarding ID3 tag\n", "Header missing\n", "incorrect frame size - multiple frames in buffer?\n", "Error while decoding MPEG audio frame.\n", "*padding >= 0", "libavcodec/mpegaudioenc_template.c", "encoding %d channel(s) is not allowed in mp2\n", "Sampling rate %d is not allowed in mp2\n", "bitrate %d is not allowed in mp2\n", "Image too small, temporary buffers cannot function\n", "libavcodec/mpegpicture.c", "Internal error, picture buffer overflow\n", "!pic->f->buf[0]", "get_buffer() failed (%d %p)\n", "alloc_frame_buffer() failed (hwaccel private data allocation)\n", "get_buffer() failed (stride changed)\n", "get_buffer() failed (uv stride mismatch)\n", "get_buffer() failed to allocate context scratch buffers.\n", "Error allocating a picture.\n", "decoding to AV_PIX_FMT_NONE is not supported.\n", "too many threads/slices (%d), reducing to %d\n", "s != s1", "libavcodec/mpegvideo.c", "!s->picture || s->picture != s1->picture", "Failed to allocate context scratch buffers.\n", "Context scratch buffers could not be allocated due to unknown size.\n", "releasing zombie picture\n", "allocating dummy last picture for B frame\n", "warning: first frame is no keyframe\n", "allocate dummy last picture for field based first keyframe\n", "s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr && s->last_picture_ptr->f->buf[0])", "Adding %d MVs info to frame %d\n", "New frame, type: %c\n", "ref->size >= offset + s->mb_stride * ((f->height+15)/16)", "DCT coeffs of MB at %dx%d:\n", "warning, clipping %d dct coefficients to %d..%d\n", "s->linesize >= 32", "libavcodec/mpegvideo_enc.c", "Warning, QMAT_SHIFT is larger than %d, overflows possible\n", "Invalid pts (%lld) <= last (%lld)\n", "Warning: AVFrame.pts=? trying to guess (%lld)\n", "scale >= 0 && scale <= 3", "illegal b frame strategy\n", "warning, too many b frames in a row\n", "s->pb.buf == avctx->internal->byte_buffer", "reencoding frame due to VBV\n", "s->avctx->rc_max_rate", "stuffing too large\n", "vbv buffer overflow\n", "Internal error, negative bits\n", "vbv_delay < 0xFFFF", "only YUV420 and YUV422 are supported\n", "only YUV420 is supported\n", "keyframe interval too large!, reducing it from %d to %d\n", "Too many B-frames requested, maximum is %d.\n", "intra dc precision must be positive, note some applications use 0 and some 8 as base meaning 8bit, the value must not be smaller than that\n", "intra dc precision too large\n", "Automatically choosing VBV buffer size of %d kbyte\n", "Either both buffer size and max rate or neither must be specified\n", "Warning min_rate > 0 but min_rate != max_rate isn't recommended!\n", "bitrate below min bitrate\n", "bitrate above max bitrate\n", "impossible bitrate constraints, this will fail\n", "VBV buffer too small for bitrate\n", "bitrate tolerance %d too small for bitrate %d, overriding\n", "Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n", "4MV not supported by codec\n", "OBMC is only supported with simple mb decision\n", "qpel not supported by codec\n", "b frames not supported by codec\n", "max b frames must be 0 or positive for mpegvideo based encoders\n", "Invalid pixel aspect ratio %i/%i, limit is 255/255 reducing\n", "H.263 does not support resolutions above 2048x1152\n", "w/h must be a multiple of 4\n", "MPEG-1 does not support resolutions above 4095x4095\n", "MPEG-2 does not support resolutions above 16383x16383\n", "width and height must be a multiple of 16\n", "width and height must be a multiple of 4\n", "width must be multiple of 2\n", "interlacing not supported by codec\n", "mpeg2 style quantization not supported by codec\n", "CBP RD needs trellis quant\n", "QP RD needs mbd=2\n", "closed gop with scene change detection are not supported yet, set threshold to 1000000000\n", "low delay forcing is only available for mpeg2\n", "b frames cannot be used with low delay\n", "non linear quant only supports qmax <= 28 currently\n", "multi threaded encoding not supported by codec\n", "automatic thread number detection not supported by codec, patch welcome\n", "framerate not set\n", "notice: b_frame_strategy only affects the first pass\n", "removing common factors from framerate\n", "qmin and or qmax are invalid, they must be 0 < min <= max\n", "intra_quant_bias = %d inter_quant_bias = %d\n", "timebase %d/%d not supported by MPEG 4 standard, the maximum admitted value for the timebase denominator is %d\n", "colorspace not supported in jpeg\n", "Cannot reallocate putbit buffer\n", "8*buffer_size > s->size_in_bits", "encoded frame too large\n", "encoded partitioned frame too large\n", "illegal MB type\n", "mpv_flags", "Flags common for all mpegvideo-based encoders.", "skip_rd", "RD optimal MB level residual skipping", "strict_gop", "Strictly enforce gop size", "qp_rd", "Use rate distortion optimization for qp selection", "cbp_rd", "use rate distortion optimization for CBP", "normalize adaptive quantization", "always try a mb with mv=<0,0>", "luma_elim_threshold", "single coefficient elimination threshold for luminance (negative values also consider dc coefficient)", "chroma_elim_threshold", "single coefficient elimination threshold for chrominance (negative values also consider dc coefficient)", "quantizer_noise_shaping", "error_rate", "Simulate errors in the bitstream to test error concealment.", "qsquish", "how to keep quantizer between qmin and qmax (0 = clip, 1 = use differentiable function)", "rc_qmod_amp", "experimental quantizer modulation", "rc_qmod_freq", "rc_eq", "Set rate control equation. When computing the expression, besides the standard functions defined in the section 'Expression Evaluation', the following functions are available: bits2qp(bits), qp2bits(qp). Also the following constants are available: iTex pTex tex mv fCode iCount mcVar var isI isP isB avgQP qComp avgIITex avgPITex avgPPTex avgBPTex avgTex.", "rc_init_cplx", "initial complexity for 1-pass encoding", "rc_buf_aggressivity", "currently useless", "border_mask", "increase the quantizer for macroblocks close to borders", "minimum Lagrange factor (VBR)", "maximum Lagrange factor (VBR)", "ibias", "intra quant bias", "pbias", "inter quant bias", "rc_strategy", "ratecontrol method", "motion_est", "motion estimation algorithm", "epzs", "xone", "wmv1 encoder", "msmpeg4v3 encoder", "msmpeg4v2 encoder", "H.263p encoder", "H.263 encoder", "Use unlimited motion vectors.", "Use alternative inter VLC.", "obmc", "use overlapped block motion compensation.", "structured_slices", "Write slice start position at every GOB header instead of just GOB number.", "mb_info", "emit macroblock info for RFC 2190 packetization, the parameter value is the maximum payload size", "Failed to set dimensions\n", "ext header missing, %d left\n", "I frame too long, ignoring ext header\n", "invalid startcode\n", "invalid picture type\n", "invalid qscale\n", "invalid slice height %d\n", "error, slice code was %X\n", "qscale:%d rlc:%d rl:%d dc:%d mbrl:%d slice:%d   \n", "skip:%d rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d   \n", "dc overflow- block: %d qscale: %d//\n", "dc overflow+ L qscale: %d//\n", "dc overflow+ C qscale: %d//\n", "ignoring overflow at %d %d\n", "cbpc %d invalid at %d %d\n", "cbpy %d invalid at %d %d\n", "\nerror while decoding block: %d x %d (%d)\n", "illegal MV code at %d %d\n", "libavcodec/options.c", "Tried to copy AVCodecContext %p into already-initialized %p\n", "dest->subtitle_header_size == src->subtitle_header_size", "AVCodecContext", "AVFrame", "AVSubtitleRect", "set bitrate (in bits/s)", "Set video bitrate tolerance (in bits/s). In 1-pass mode, bitrate tolerance specifies how far ratecontrol is willing to deviate from the target average bitrate value. This is not related to minimum/maximum bitrate. Lowering tolerance too much has an adverse effect on quality.", "unaligned", "allow decoders to produce unaligned output", "use four motion vectors per macroblock (MPEG-4)", "use 1/4-pel motion compensation", "use loop filter", "use fixed qscale", "use gmc", "input_preserved", "pass1", "use internal 2-pass ratecontrol in first  pass mode", "pass2", "use internal 2-pass ratecontrol in second pass mode", "only decode/encode grayscale", "emu_edge", "do not draw edges", "error[?] variables will be set during encoding", "truncated", "ildct", "use interlaced DCT", "low_delay", "force low delay", "global_header", "place global headers in extradata instead of every keyframe", "use only bitexact functions (except (I)DCT)", "H.263 advanced intra coding / MPEG-4 AC prediction", "ilme", "interlaced motion estimation", "closed GOP", "output_corrupt", "Output even potentially corrupted frames", "allow non-spec-compliant speedup tricks", "noout", "skip bitstream encoding", "ignorecrop", "ignore cropping information from sps", "local_header", "place global headers at every keyframe instead of in extradata", "Frame data might be split into multiple chunks", "showall", "Show all frames before the first keyframe", "export_mvs", "export motion vectors through frame side data", "skip_manual", "do not skip samples and export skip information as frame side data", "set motion estimation method", "zero motion estimation (fastest)", "full motion estimation (slowest)", "EPZS motion estimation (default)", "esa motion estimation (alias for full)", "tesa motion estimation", "diamond motion estimation (alias for EPZS)", "log motion estimation", "phods", "phods motion estimation", "X1 motion estimation", "hex motion estimation", "umh motion estimation", "iter motion estimation", "set the group of picture (GOP) size", "set audio sampling rate (in Hz)", "set number of audio channels", "set cutoff bandwidth", "frame_number", "video quantizer scale compression (VBR). Constant of ratecontrol equation. Recommended range for default rc_eq: 0.0-1.0", "video quantizer scale blur (VBR)", "minimum video quantizer scale (VBR)", "maximum video quantizer scale (VBR)", "maximum difference between the quantizer scales (VBR)", "set maximum number of B frames between non-B-frames", "QP factor between P- and B-frames", "strategy to choose between I/P/B-frames", "RTP payload size in bytes", "mv_bits", "header_bits", "i_tex_bits", "p_tex_bits", "i_count", "skip_count", "misc_bits", "frame_bits", "work around not autodetected encoder bugs", "autodetect", "old_msmpeg4", "some old lavc-generated MSMPEG4v3 files (no autodetection)", "xvid_ilace", "Xvid interlacing bug (autodetected if FOURCC == XVIX)", "ump4", "(autodetected if FOURCC == UMP4)", "no_padding", "padding bug (autodetected)", "ac_vlc", "illegal VLC bug (autodetected per FOURCC)", "qpel_chroma", "std_qpel", "old standard qpel (autodetected per FOURCC/version)", "qpel_chroma2", "direct_blocksize", "direct-qpel-blocksize bug (autodetected per FOURCC/version)", "edge padding bug (autodetected per FOURCC/version)", "hpel_chroma", "dc_clip", "work around various bugs in Microsoft's broken decoders", "trunc", "truncated frames", "very", "strictly conform to a older more strict version of the spec or reference software", "allow non-standardized experimental things", "b_qoffset", "QP offset between P- and B-frames", "consider things that a sane encoder should not do as an error", "has_b_frames", "block_align", "mpeg_quant", "use MPEG quantizers instead of H.263", "deprecated, use encoder private options instead", "rc_override_count", "maxrate", "maximum bitrate (in bits/s). Used for VBV together with bufsize.", "minrate", "minimum bitrate (in bits/s). Most useful in setting up a CBR encode. It is of little use otherwise.", "set ratecontrol buffer size (in bits)", "QP factor between P- and I-frames", "i_qoffset", "QP offset between P- and I-frames", "fast integer", "floating point AAN DCT", "lumi_mask", "compresses bright areas stronger than medium ones", "tcplx_mask", "temporal complexity masking", "scplx_mask", "spatial complexity masking", "p_mask", "inter masking", "dark_mask", "compresses dark areas stronger than medium ones", "deprecated, for compatibility only", "floating point AAN IDCT", "slice_count", "set error concealment strategy", "guess_mvs", "iterative motion vector (MV) search (slow)", "use strong deblock filter for damaged MBs", "favor_inter", "favor predicting from the previous frame", "bits_per_coded_sample", "prediction method", "median", "picture info", "rate control", "macroblock (MB) type", "per-block quantization parameter (QP)", "motion vector", "dct_coeff", "green_metadata", "startcode", "error recognition", "mmco", "memory management control operations (H.264)", "vis_qp", "visualize quantization parameter (QP), lower QP are tinted greener", "vis_mb_type", "visualize block types", "buffers", "picture buffer allocations", "thread_ops", "threading operations", "nomc", "skip motion compensation", "vismv", "visualize motion vectors (MVs) (deprecated)", "debug_mv", "full-pel ME compare function", "cmp_func", "subcmp", "sub-pel ME compare function", "mbcmp", "macroblock compare function", "ildctcmp", "interlaced DCT compare function", "diamond type & size for motion estimation", "last_pred", "amount of motion predictors from the previous frame", "preme", "pre motion estimation", "precmp", "pre motion estimation compare function", "sum of absolute differences, fast (default)", "sum of squared errors", "satd", "sum of absolute Hadamard transformed differences", "sum of absolute DCT transformed differences", "sum of squared quantization errors (avoid, low quality)", "number of bits needed for the block", "rate distortion optimal, slow", "vsad", "sum of absolute vertical differences", "vsse", "sum of squared vertical differences", "nsse", "noise preserving sum of squared differences", "dctmax", "pre_dia_size", "diamond type & size for motion estimation pre-pass", "sub-pel motion estimation quality", "dtg_active_format", "limit motion vectors range (1023 for DivX player)", "variable length coder / Huffman coder", "arithmetic coder", "raw (no encoding)", "run-length coder", "deflate-based coder", "context", "context model", "slice_flags", "xvmc_acceleration", "macroblock decision algorithm (high quality mode)", "use mbcmp (default)", "use fewest bits", "use best rate distortion", "stream_codec_tag", "noise reduction", "number of bits which should be loaded into the rc buffer before decoding starts", "autodetect a suitable number of threads to use", "me_threshold", "motion estimation threshold", "mb_threshold", "macroblock threshold", "intra_dc_precision", "nssew", "nsse weight", "skip_top", "number of macroblock rows at the top which are skipped", "skip_bottom", "number of macroblock rows at the bottom which are skipped", "aac_main", "aac_ssr", "aac_ltp", "aac_he_v2", "aac_ld", "aac_eld", "mpeg2_aac_low", "mpeg2_aac_he", "dts_es", "dts_96_24", "dts_hd_hra", "dts_hd_ma", "mpeg4_sp", "mpeg4_core", "mpeg4_main", "mpeg4_asp", "lowres", "decode at 1= 1/2, 2=1/4, 3=1/8 resolutions", "skip_threshold", "frame skip threshold", "skip_factor", "frame skip factor", "skip_exp", "frame skip exponent", "skipcmp", "frame skip compare function", "mblmin", "minimum macroblock Lagrange factor (VBR)", "mblmax", "maximum macroblock Lagrange factor (VBR)", "mepc", "motion estimation bitrate penalty compensation (1.0 = 256)", "skip_loop_filter", "skip loop filtering process for the selected frames", "avdiscard", "skip_idct", "skip IDCT/dequantization for the selected frames", "skip_frame", "skip decoding for the selected frames", "discard no frame", "discard useless frames", "noref", "discard all non-reference frames", "bidir", "discard all bidirectional frames", "nokey", "discard all frames except keyframes", "nointra", "discard all frames except I frames", "discard all frames", "bidir_refine", "refine the two motion vectors used in bidirectional macroblocks", "brd_scale", "downscale frames for dynamic B-frame decision", "minimum interval between IDR-frames", "reference frames to consider for motion compensation", "chromaoffset", "chroma QP offset from luma", "rate-distortion optimal quantization", "sc_factor", "multiplied by qscale for each frame and added to scene_change_score", "mv0_threshold", "b_sensitivity", "adjust sensitivity of b_frame_strategy 1", "min_prediction_order", "max_prediction_order", "timecode_frame_start", "GOP timecode frame start number, in non-drop-frame format", "request_channels", "set desired number of audio channels", "bits_per_raw_sample", "request_channel_layout", "rc_max_vbv_use", "rc_min_vbv_use", "color_primaries", "color primaries", "color_primaries_type", "BT.709", "unspecified", "Unspecified", "bt470m", "BT.470 M", "BT.470 BG", "SMPTE 170 M", "SMPTE 240 M", "Film", "bt2020", "BT.2020", "color_trc", "color transfer characteristics", "color_trc_type", "gamma22", "gamma28", "Linear", "log_sqrt", "Log square root", "iec61966_2_4", "IEC 61966-2-4", "bt1361", "BT.1361", "iec61966_2_1", "IEC 61966-2-1", "bt2020_10bit", "BT.2020 - 10 bit", "bt2020_12bit", "BT.2020 - 12 bit", "color space", "colorspace_type", "ycocg", "YCOCG", "bt2020_ncl", "BT.2020 NCL", "bt2020_cl", "BT.2020 CL", "color_range", "color_range_type", "MPEG (219*2^(n-8))", "JPEG (2^n-1)", "chroma_sample_location", "chroma sample location", "chroma_sample_location_type", "Left", "Center", "topleft", "Top-left", "bottomleft", "Bottom-left", "Bottom", "log_level_offset", "set the log level offset", "number of slices, used in parallelized encoding", "select multithreading type", "audio_service_type", "audio service type", "request_sample_fmt", "sample format audio decoders should prefer", "pkt_timebase", "sub_charenc", "set input text subtitles character encoding", "sub_charenc_mode", "set input text subtitles character encoding mode", "do_nothing", "pre_decoder", "refcounted_frames", "side_data_only_packets", "skip_alpha", "Skip processing alpha", "field_order", "Field order", "set pixel format", "best_effort_timestamp", "pkt_pos", "pkt_size", "sample_aspect_ratio", "forced", "Invalid extradata size: %d\n", "Extradata version %d", "Zero channel count specified in the extadata\n", "Channel mapping 0 is only specified for up to 2 channels\n", "Invalid stream/stereo stream count: %d/%d\n", "Channel mapping 1 is only specified for up to 8 channels\n", "Mapping type %d", "Invalid channel map for output channel %d: %d\n", "Error parsing Ogg extradata.\n", "Error parsing Opus packet header.\n", "index > -0x20000000", "libavcodec/parser.c", "Failed to reallocate parser buffer to %d\n", "Invalid sample_size\n", "Invalid number of channels\n", "codec ids mismatch\n", "Invalid PCM packet, data has size %d but at least a size of %d was expected\n", "PCM channels out of bounds\n", "inflateInit returned error %d\n", "%d bytes left\n", "chunk too big\n", "png: tag=%c%c%c%c length=%u\n", "IHDR after IDAT\n", "Multiple IHDR\n", "Invalid image size\n", "width=%d height=%d depth=%d color_type=%d compression_type=%d filter_type=%d interlace_type=%d\n", "pHYs after IDAT\n", "IDAT without IHDR\n", "unsupported bit depth %d and color type %d\n", "bit depth %d and color type %d with TRNS", "inflate returned error %d\n", "%d undecompressed bytes left in buffer\n", "Broken tEXt chunk\n", "Broken zTXt chunk\n", "IEND without all image\n", "MPNG", "bpp || !pred", "libavcodec/pngenc.c", "Input contains more than one unique palette. APNG does not support multiple palettes.\n", "Only one of 'dpi' or 'dpm' options should be set\n", "APNG encoder", "Set image resolution (in dots per inch)", "Set image resolution (in dots per meter)", "WIDTH", "HEIGHT", "DEPTH", "MAXVAL", "TUPLTYPE", "TUPLETYPE", "ENDHDR", "Invalid maxval: %d\n", "Unsupported pixel format\n", "Application has requested %d threads. Using a thread count greater than %d is not recommended.\n", "p->avctx->codec_type == AVMEDIA_TYPE_VIDEO || p->avctx->codec_type == AVMEDIA_TYPE_AUDIO", "libavcodec/pthread_frame.c", "%p finished %d field %d\n", "thread awaiting %d field %d from %p\n", "Multiple ff_thread_finish_setup() calls\n", "A frame threaded decoder did not free the frame on failure. This is a bug, please report it.\n", "Final thread update failed\n", "get_format() cannot be called after ff_thread_finish_setup()\n", "get_buffer() cannot be called after ff_thread_finish_setup()\n", "thread_get_buffer() failed\n", "thread_release_buffer called on pic %p\n", "qp<=0.0\n", "bits<0.9\n", "qmin <= qmax", "libavcodec/ratecontrol.c", "limiting QP %f -> %f\n", "in:%d out:%d type:%d q:%d itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%lld var:%lld icount:%d skipcount:%d hbits:%d;\n", "rc buffer underflow\n", "max bitrate possibly too small or try trellis with large lmax or increase qmax\n", "stuffing %d bytes\n", "tex^qComp", "Error parsing rc_eq \"%s\"\n", " in:%d ", "picture_number >= 0", "picture_number < rcc->num_entries", " in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%lld var:%lld icount:%d skipcount:%d hbits:%d", "statistics are damaged at line %d, parser out=%d\n", "requested bitrate is too low\n", "filter_size % 2 == 1", "toobig <= 40", "[lavc rc] requested bitrate: %lld bps  expected bitrate: %lld bps\n", "[lavc rc] estimated target average qp: %.3f\n", "[lavc rc] Using all of requested bitrate is not necessary for this video with these parameters.\n", "[lavc rc] Error: bitrate too low for this video with these parameters.\n", "[lavc rc] Error: 2pass curve failed to converge\n", "Xvid ratecontrol requires libavcodec compiled with Xvid support.\n", "qblur too large\n", "Input is longer than 2-pass log file\n", "pict_type == rce->new_pict_type", "q > 0.0", "%c qp:%d<%2.1f<%d %d want:%d total:%d comp:%f st_q:%2.2f size:%d var:%lld/%lld br:%lld fps:%d\n", "iTex", "pTex", "fCode", "iCount", "mcVar", "avgQP", "avgIITex", "avgPITex", "avgPPTex", "avgBPTex", "avgTex", "bits2qp", "qp2bits", "I420", "IYUV", "YV16\f", "I420\f", "IYUV\f", "YV12\r", "Y42B\r", "YUNVw", "NV21.", "RGB\f@", "BGR\f?", "\fBGRA", "422P\r", "422P!", "440P\"", "444P\t", "B1W0\n", "R4BY*", "RGB0)", "0RGBD", "BGR0C", "0BGR ", "Y3\u000b\nG", "\n\u000b3YJ", "Y3\n\nI", "\n\n3YN", "Y4\u000b\t[", "\t\u000b4Y^", "Y4\n\t]", "\t\n4Y`", "Y4\u000b\na", "\n\u000b4Yd", "Y4\n\nc", "\n\n4Yf", "XYZ$o", "DVOO.", "L555,", "L565+", "b16g)", "b48r,", "remove_extra", "audioresample", "Resampling with input channels greater than %d is unsupported.\n", "Unsupported audio resampling. Allowed output channels for %d input channel%s", "Can't allocate memory for resample context.\n", "Cannot convert %s sample format to s16 sample format\n", "Cannot convert s16 sample format to %s sample format\n", "Could not allocate buffer\n", "Audio sample format conversion failed\n", "ReSampleContext", "libavcodec/rl.c", "missing sync id\n", "%s%7i", "%s%.15g", "%s%5i", "%s%3i", "FFmpeg version 2.8.7", "s->codec_type == AVMEDIA_TYPE_VIDEO", "libavcodec/utils.c", "val || !min_size", "./libavutil/mem_internal.h", "This decoder does not support parameter changes, but PARAM_CHANGE side data was sent to it.\n", "Invalid channel count", "Invalid sample rate", "PARAM_CHANGE side data too small.\n", "Failed to set dimensions %d %d\n", "ignoring invalid SAR: %d/%d\n", "desc->flags & (1 << 4)", "pic->data[0]!=NULL in avcodec_default_get_buffer\n", "default_get_buffer called on pic %p\n", "frame->nb_extended_buf == 0", "default_get_buffer called on frame %p", "ignoring invalid SAR: %u/%u\n", "Inconsistent channel configuration.\n", "Too many channels: %d.\n", "video_get_buffer: image parameters invalid\n", "avctx->codec_type == AVMEDIA_TYPE_VIDEO", "Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\n", "reget_buffer() failed\n", "Invalid negative user packet size %d\n", "Invalid minimum required packet size %lld (max allowed is %d)\n", "!avpkt->data || avpkt->data != avctx->internal->byte_buffer", "User packet is too small (%d < %lld)\n", "Failed to allocate packet of size %lld\n", "Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\n", "more samples than frame size (avcodec_encode_audio2)\n", "nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\n", "avctx->codec->encode2", "Provided packet is too small, needs to be %d\n", "AVFrame.format is not set\n", "AVFrame.width or height is not set\n", "ret <= 0", "buffer smaller than minimum size\n", "start_display_time must be 0.\n", "Invalid media type for video\n", "Error applying parameter changes.\n", "!picture->extended_data || picture->extended_data == picture->data", "invalid packet: NULL data, size != 0\n", "Invalid media type for audio\n", "ret <= tmp.size", "skip %d / discard %d samples due to side data\n", "skip whole frame, skip left: %d\n", "Could not update timestamps for skipped samples.\n", "skip %d/%d samples\n", "Could not update timestamps for discarded samples.\n", "discard %d/%d samples\n", "Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\n", "Please port your application to avcodec_decode_audio4()\n", "output buffer size is too small for the current frame (%d < %d)\n", "Invalid media type for subtitles\n", "requesting subtitles recoding without iconv", "Invalid UTF-8 in decoded subtitles text; maybe missing -sub_charenc option\n", "unknown_codec", "Codec 0x%x is not in the full list.\n", "[%d]", "libavcodec license: nonfree and unredistributable", "%s: %s", " (%s)", ", %d reference frame%s", " (%s / 0x%04X)", "%d bpc, ", "%s/%s/%s, ", " (%dx%d)", " [SAR %d:%d DAR %d:%d]", ", q=%d-%d", ", Closed Captions", ", lossless", "%d Hz, ", ", %s", " (%d bit)", ", %dx%d", ", pass 1", ", pass 2", ", %d kb/s", ", max. %d kb/s", "avcodec_encode_audio() does not support this codec\n", "If you want to help, upload a sample of this file to ftp://upload.ffmpeg.org/incoming/ and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\n", "%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\n", "Ignoring experimental hwaccel: %s\n", "choices[n] != AV_PIX_FMT_NONE", "Could not find an AVHWAccel for the pixel format: %s", "Insufficient thread locking. At least %d threads are calling avcodec_open2() at the same time right now.\n", "No lock manager is set, please see av_lockmgr_register()\n", "!ff_avcodec_locked", "!dst->progress", "No codec provided to avcodec_open2()\n", "This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\n", "Codec (%s) not on whitelist\n", "Ignoring invalid width/height values\n", "Codec type or id mismatches\n", "The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\n", "Alternatively use the non experimental %s '%s'.\n", "The maximum value for lowres supported by the decoder is %d\n", "The 'vismv' option is deprecated, see the codecview filter instead.\n", "Specified sample format %s is invalid or not supported\n", "Specified pixel format %s is invalid or not supported\n", "Specified sample rate %d is not supported\n", "Channel layout not specified\n", "Channel layout '%s' with %d channels does not match number of specified channels %d\n", "Specified number of channels %d is not supported\n", "Bitrate %d is extremely low, maybe you mean %dk\n", "gray decoding requested but not enabled at configuration time\n", "Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\n", "Character encoding is only supported with subtitles codecs\n", "Codec '%s' is bitmap-based, subtitles character encoding will be ignored\n", "Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\n", "*(const AVClass **)avctx->priv_data == codec->priv_class", "Specified channel layout '%s' is not supported\n", "p <= end", "invalid NORM-6 VLC\n", "bfraction invalid\n", "Header: %0X\n", "WMV3 Complex Profile is not fully supported\n", "Reserved LEVEL %i\n", "Only 4:2:0 chroma format supported\n", "Advanced Profile level %i:\nfrmrtq_postproc=%i, bitrtq_postproc=%i\nLoopFilter=%i, ChromaFormat=%i, Pulldown=%i, Interlace: %i\nTFCTRflag=%i, FINTERPflag=%i\n", "Progressive Segmented Frame mode: not supported (yet)\n", "Display extended info:\n", "Display dimensions: %ix%i\n", "Aspect: %i:%i\n", "Old interlaced mode is not supported\n", "LOOPFILTER shall not be enabled in Simple Profile\n", "FASTUVMC unavailable in Simple Profile\n", "Extended MVs unavailable in Simple Profile\n", "1 for reserved RES_TRANSTAB is forbidden\n", "RANGERED should be set to 0 in Simple Profile\n", "Unsupported sprite feature\n", "Old WMV3 version detected, some frames may be decoded incorrectly\n", "Profile %i:\nfrmrtq_postproc=%i, bitrtq_postproc=%i\nLoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\nRangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\nDQuant=%i, Quantizer mode=%i, Max B frames=%i\n", "Entry point: %08X\n", "Luma scaling is not supported, expect wrong picture\n", "Chroma scaling is not supported, expect wrong picture\n", "Entry point info:\nBrokenLink=%i, ClosedEntry=%i, PanscanFlag=%i\nRefDist=%i, Postproc=%i, FastUVMC=%i, ExtMV=%i\nDQuant=%i, VSTransform=%i, Overlap=%i, Qmode=%i\n", "MB MV Type plane encoding: Imode: %i, Invert: %i\n", "MB Skip plane encoding: Imode: %i, Invert: %i\n", "VOP DQuant info\n", "MB Direct Type plane encoding: Imode: %i, Invert: %i\n", "v->s.mb_height == v->s.height + 15 >> 4 || v->s.mb_height == (((v->s.height + 15 >> 4)+(2)-1)&~((2)-1))", "libavcodec/vc1.c", "Pan-scan", "FIELDTX plane encoding: Imode: %i, Invert: %i\n", "ACPRED plane encoding: Imode: %i, Invert: %i\n", "CONDOVER plane encoding: Imode: %i, Invert: %i\n", "SKIPMB plane encoding: Imode: %i, Invert: %i\n", "B Fields\n", "MB Forward Type plane encoding: Imode: %i, Invert: %i\n", "Intensity compensation set for B picture\n", "Overriding invalid mquant %d\n", "Bits overconsumption: %i > %i\n", "index < esc", "libavcodec/vc1_block.c", "Mixed field/frame direct mode not supported\n", "Mixed frame/field direct mode not supported\n", "Bits overconsumption: %i > %i at %ix%i\n", "!v->field_mode", "libavcodec/vc1_pred.c", "pict_type: %c\n", "Sprite decoder: expected I-frame\n", "image too short\n", "Skipping B frame without reference frames\n", "parsing header for second field failed", "mb_height > 0", "libavcodec/vc1dec.c", "Slice %d starts beyond picture boundary (%d >= %d)\n", "(s->mb_height & 1) == 0", "Field header damaged\n", "Slice header damaged\n", "first field slice count too large\n", "end mb y %d %d invalid\n", "missing cbpcy_vlc\n", "Extra data: %i bits left, value: %X\n", "Read %i bits in overflow\n", "Extradata size too small: %i\n", "Incomplete extradata\n", "odd sprites support", "Id header is too short\n", "Wrong packet type in Id header\n", "Invalid packet signature in Id header\n", "Invalid framing bit in Id header\n", "Setup header is too short\n", "Wrong packet type in Setup header\n", "Invalid packet signature in Setup header\n", "Invalid Setup header\n", "%d modes (either a false positive or a sample from an unknown encoder)", "Unsupported mode count: %d\n", "Invalid packet\n", "Invalid mode in packet\n", "Vorbis parser", "Superframe packet size too big: %u > %d\n", "plane_count == nb_components - 1", "libswscale/alphablend.c", "libswscale/swscale_internal.h", "swscaler", "SWScaler", "scaler flags", "fast_bilinear", "fast bilinear", "bicubic", "nearest neighbor", "averaging area", "bicublin", "luma bicubic, chroma bilinear", "gauss", "gaussian", "sinc", "lanczos", "natural bicubic spline", "print_info", "print info", "accurate_rnd", "accurate rounding", "full_chroma_int", "full chroma interpolation", "full_chroma_inp", "full chroma input", "error_diffusion", "error diffusion dither", "source width", "source height", "destination width", "destination height", "source format", "destination format", "source range", "destination range", "scaler param 0", "scaler param 1", "source vertical chroma position in luma grid/256", "source horizontal chroma position in luma grid/256", "destination vertical chroma position in luma grid/256", "destination horizontal chroma position in luma grid/256", "sws_dither", "set dithering algorithm", "leave choice to sws", "bayer dither", "error diffusion", "a_dither", "arithmetic addition dither", "x_dither", "arithmetic xor dither", "gamma correct scaling", "alphablend", "mode for alpha -> non alpha", "ignore alpha", "uniform_color", "blend onto a uniform color", "blend onto a checkerboard", "n == s->plane[ii].available_lines", "libswscale/slice.c", "firstLumSrcY >= lastInLumBuf - vLumBufSize + 1", "libswscale/swscale.c", "firstChrSrcY >= lastInChrBuf - vChrBufSize + 1", "One of the input parameters to sws_scale() is NULL, please check the calling code\n", "Slice parameters %d, %d are invalid\n", "bad src image pointers\n", "bad dst image pointers\n", "Slices start in the middle!\n", "unsupported conversion to planar RGB %s -> %s\n", "internal error %s -> %s converter\n", "srcSliceH > 1", "libswscale/swscale_unscaled.c", "unsupported bayer conversion\n", "libswscale/utils.c", "filter2Size > 0", "minFilterSize > 0", "SwScaler: reducing / aligning filtersize %d -> %d\n", "(*filterPos)[i] >= 0", "(*filterPos)[i] < srcW", "(*filterPos)[i] + j < srcW || !filter[i * filterSize + j]", "SwScaler: zero vector in scaling\n", "sws: initFilter failed\n", "libswscale license: nonfree and unredistributable", "%1.3f ", "ehh flags invalid?!", "dithered ", "deprecated pixel format used, make sure you did set range correctly\n", "%s is not supported as input pixel format\n", "%s is not supported as output pixel format\n", "Exactly one scaler algorithm must be chosen, got %X\n", "%dx%d -> %dx%d is invalid scaling dimension\n", "Forcing full internal H chroma due to odd output size\n", "Forcing full internal H chroma due to input having non subsampled chroma\n", "Desired dithering only supported in full chroma interpolation for destination format '%s'\n", "Ordered dither is not supported in full chroma interpolation for destination format '%s'\n", "%s output is not supported with half chroma resolution, switching to full\n", "full chroma interpolation for destination format '%s' not yet implemented\n", "c->dstBpc > 14", "c->chrDstH <= dstH", "%s scaler, from %s to %s%s ", "using %s\n", "%dx%d -> %dx%d\n", "lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n", "chr srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n", "using alpha blendaway %s -> %s special converter\n", "using unscaled %s -> %s special converter\n", "YUV color matrix differs for YUV->YUV, using intermediate RGB to convert\n", "area averaging", "luma bicubic / chroma bilinear", "Gaussian", "Lanczos", "nearest neighbor / point", "Optimized 2 tap filter code cannot be used\n", "No accelerated colorspace conversion found from %s to %s.\n", "%ibpp not supported by yuv2rgb\n", "ctx->channels == out->ch_count", "libswresample/audioconvert.c", "libswresample/dither.c", "Requested noise shaping dither not available at this sampling rate, using triangular hp dither\n", "!s->preout.count", "SWResampler", "set input channel count", "in_channel_count", "set output channel count", "out_channel_count", "set used channel count", "used_channel_count", "set input sample rate", "set output sample rate", "set input sample format", "set output sample format", "set internal sample format", "internal_sample_fmt", "set input channel layout", "set output channel layout", "clev", "set center mix level", "center_mix_level", "slev", "set surround mix level", "surround_mix_level", "set surround mix Level", "lfe_mix_level", "set LFE mix level", "rmvol", "set rematrix volume", "rematrix_volume", "rematrix_maxval", "set rematrix maxval", "swr_flags", "force resampling", "dither_scale", "set dither scale", "dither_method", "set dither method", "rectangular", "select rectangular dither", "select triangular dither", "triangular_hp", "select triangular dither with high pass", "lipshitz", "select lipshitz noise shaping dither", "select shibata noise shaping dither", "low_shibata", "select low shibata noise shaping dither", "high_shibata", "select high shibata noise shaping dither", "f_weighted", "select f-weighted noise shaping dither", "modified_e_weighted", "select modified-e-weighted noise shaping dither", "improved_e_weighted", "select improved-e-weighted noise shaping dither", "set swr resampling filter size", "phase_shift", "set swr resampling phase shift", "linear_interp", "enable linear interpolation", "set cutoff frequency ratio", "resample_cutoff", "resampler", "set resampling Engine", "select SW Resampler", "soxr", "select SoX Resampler", "set soxr resampling precision (in bits)", "cheby", "enable soxr Chebyshev passband & higher-precision irrational ratio approximation", "min_comp", "set minimum difference between timestamps and audio data (in seconds) below which no timestamp compensation of either kind is applied", "min_hard_comp", "set minimum difference between timestamps and audio data (in seconds) to trigger padding/trimming the data.", "comp_duration", "set duration (in seconds) over which data is stretched/squeezed to make it match the timestamps.", "max_soft_comp", "set maximum factor by which data is stretched/squeezed to make it match the timestamps.", "simplified 1 parameter audio timestamp matching, 0(disabled), 1(filling and trimming), >1(maximum stretch/squeeze in samples per second)", "first_pts", "Assume the first pts should be this value (in samples).", "matrix_encoding", "set matrixed stereo encoding", "select none", "dolby", "select Dolby", "dplii", "select Dolby Pro Logic II", "filter_type", "select swr filter type", "select cubic", "blackman_nuttall", "select Blackman Nuttall Windowed Sinc", "kaiser", "select Kaiser Windowed Sinc", "kaiser_beta", "set swr Kaiser Window Beta", "output_sample_bits", "set swr number of output sample bits", "Treating %s as mono\n", "Input channel layout '%s' is not supported\n", "Output channel layout '%s' is not supported\n", "libswresample/rematrix.c", "!s->out_ch_layout || out->ch_count == av_get_channel_layout_nb_channels(s->out_ch_layout)", "!s-> in_ch_layout || in ->ch_count == av_get_channel_layout_nb_channels(s-> in_ch_layout)", "libswresample/resample.c", "Filter length too large\n", "a->planar", "FFmpeg version 2.8.7", "out->planar == in->planar", "libswresample/swresample.c", "out->bps == in->bps", "out->ch_count == in->ch_count", "libswresample license: nonfree and unredistributable", "Failed to set option\n", "Requested input sample format %d is invalid\n", "Requested output sample format %d is invalid\n", "Input channel layout 0x%llx is invalid or unsupported.\n", "Output channel layout 0x%llx is invalid or unsupported.\n", "Requested resampling engine is unavailable\n", "Input channel layout has a different number of channels than the number of used channels, ignoring layout\n", "Using %s internally between filters\n", "Requested sample format %s is not supported internally, S16/S32/FLT/DBL is supported\n", "Failed to initialize resampler\n", "Resampling only supported with internal s16/s32/flt/dbl\n", "!s->in_ch_layout", "Input channel count and layout are unset\n", "Output channel layout %s mismatches specified channel count %d\n", "Input channel layout %s mismatches specified channel count %d\n", "Rematrix is needed between %s and %s but there is not enough information to do it\n", "a->bps", "a->ch_count", "s->in.planar", "s->dither.noise.ch_count == preout->ch_count", "!s->resample", "s->midbuf.ch_count == s->used_ch_count", "s->midbuf.ch_count == s->out.ch_count", "Context has not been initialized\n", "s->drop_output", "discarding %d audio samples\n", "adding %d audio samples of silence\n", "s->out_sample_rate == s->in_sample_rate", "Failed to compensate for timestamp delta of %f\n", "compensating audio timestamp drift:%f compensation:%d in:%d\n", "+infinity", "+inf", "-infinity", "-inf", "+nan", "-nan", "/proc/self/auxv", "/proc/cpuinfo", "Features", "libavutil/avstring.c", "'\\''", "%d channels", "Single channel layout '%.*s' is interpreted as a number of channels, switch to the syntax '%.*sc' otherwise it will be interpreted as a channel layout number in a later version\n", "3.0(back)", "quad(side)", "5.0(side)", "5.1(side)", "6.0(front)", "hexagonal", "6.1(back)", "6.1(front)", "7.0(front)", "7.1(wide)", "7.1(wide-side)", "octagonal", "hexadecagonal", "downmix", "low frequency", "front left-of-center", "front right-of-center", "side left", "side right", "top center", "top front left", "top front center", "top front right", "top back left", "top back center", "top back right", "downmix left", "downmix right", "wide left", "wide right", "surround direct left", "surround direct right", "LFE2", "low frequency 2", "detected %d logical cores\n", "cpuflags", "armv6t2", "vfpv3", "setend", "BSF_NOT_FOUND", "Bitstream filter not found", "Internal bug, should not have happened", "BUG2", "BUFFER_TOO_SMALL", "Buffer too small", "DECODER_NOT_FOUND", "Decoder not found", "DEMUXER_NOT_FOUND", "Demuxer not found", "ENCODER_NOT_FOUND", "Encoder not found", "EXIT", "Immediate exit requested", "EXTERNAL", "Generic error in an external library", "FILTER_NOT_FOUND", "Filter not found", "INPUT_CHANGED", "Input changed", "INVALIDDATA", "Invalid data found when processing input", "Muxer not found", "OPTION_NOT_FOUND", "Option not found", "Output changed", "PATCHWELCOME", "Not yet implemented in FFmpeg, patches welcome", "PROTOCOL_NOT_FOUND", "Protocol not found", "STREAM_NOT_FOUND", "Stream not found", "UNKNOWN", "Unknown error occurred", "EXPERIMENTAL", "Experimental feature", "INPUT_AND_OUTPUT_CHANGED", "Input and output changed", "HTTP_BAD_REQUEST", "Server returned 400 Bad Request", "HTTP_UNAUTHORIZED", "Server returned 401 Unauthorized (authorization failed)", "HTTP_FORBIDDEN", "Server returned 403 Forbidden (access denied)", "HTTP_NOT_FOUND", "Server returned 404 Not Found", "HTTP_OTHER_4XX", "Server returned 4XX Client Error, but not one of 40{0,1,3,4}", "HTTP_SERVER_ERROR", "Server returned 5XX Server Error reply", "Missing ')' in '%s'\n", "Missing ')' or too many args in '%s'\n", "sinh", "cosh", "tanh", "atan", "acos", "isnan", "isinf", "while", "taylor", "floor", "ceil", "print", "hypot", "ifnot", "bitand", "bitor", "between", "Unknown function in '%s'\n", "Invalid chars '%s' at the end of expression '%s'\n", "Eval", "QP2LAMBDA", "Cannot read file '%s': %s\n", "Error occurred in fstat(): %s\n", "Error occurred in mmap(): %s\n", "ff_tempfile: Cannot allocate file name\n", "/tmp/%sXXXXXX", "ff_tempfile: Cannot open temporary file %s\n", "FILE", "Failed to set close on exec\n", "AVPanScan", "ATSC A53 Part 4 Closed Captions", "Stereoscopic 3d metadata", "AVMatrixEncoding", "Metadata relevant to a downmix procedure", "AVReplayGain", "3x3 displaymatrix", "Motion vectors", "YCgCo", "murmur3", "RIPEMD128", "RIPEMD160", "RIPEMD256", "RIPEMD320", "SHA160", "SHA224", "SHA256", "SHA512/224", "SHA512/256", "SHA384", "SHA512", "CRC32", "adler32", "Picture size %ux%u is invalid\n", "abs(src_linesize) >= bytewidth", "libavutil/imgutils.c", "abs(dst_linesize) >= bytewidth", "av_image_get_linesize failed\n", "IMGUTILS", "quiet", "fatal", "panic", "[%s @ %p] ", "[%s] ", "TERM", "NO_COLOR", "AV_LOG_FORCE_NOCOLOR", "AV_LOG_FORCE_COLOR", "AV_LOG_FORCE_256COLOR", "256color", "%s%s%s%s", "    Last message repeated %d times\r", "    Last message repeated %d times\n", "libavutil/lzo.c", "libavutil/mathematics.c", "duration >= 0", "Value %f for parameter '%s' out of range [%g - %g]\n", "Value %f for parameter '%s' is not a valid set of 32bit integer flags\n", "Unable to parse option value \"%s\" as %s\n", "Value %d for parameter '%s' out of %s format range [%d - %d]\n", "INT_MAX", "INT_MIN", "UINT32_MAX", "I64_MAX", "I64_MIN", "-FLT_MAX", "-FLT_MIN", "-DBL_MAX", "-DBL_MIN", "Unable to parse option value \"%s\" as color\n", "Unable to parse option value \"%s\" as image size\n", "Unable to parse option value \"%s\" as video rate\n", "AVOption type %d of option %s not implemented yet\n", "0x%08X", "%d%*1[:/]%d%c", "const_values array too small for %s\n", "Unable to parse option value \"%s\"\n", "The value for option '%s' is not a channel layout.\n", "The value for option '%s' is not a %s format.\n", "pixel", "The value for option '%s' is not an image size.\n", "%lli:%02d:%02d.%06d", "0x%02x%02x%02x%02x", "0x%llx", "The value set by option '%s' is not a channel layout.\n", "The value set by option '%s' is not a %s format", "The value set by option '%s' is not a video rate.\n", "The value set by option '%s' is not an image size.\n", "Invalid negative size value %dx%d for size '%s'\n", "Unable to parse option value \"%s\" as duration\n", "Unable to parse option value \"%s\" as channel layout\n", "Invalid option type.\n", "Error setting option %s to value %s.\n", "Missing key or no key/value separator found after key '%s'\n", "Setting entry with key '%s' to value '%s'\n", "     %-15s ", "  %s%-17s ", "%-12s ", "<flags>", "<int>", "<int64>", "<double>", "<float>", "<string>", "<rational>", "<binary>", "<image_size>", "<video_rate>", "<pix_fmt>", "<sample_fmt>", "<duration>", "<color>", "<channel_layout>", " (from ", " to ", " (default ", "%llX", "\"%s\"", "%s AVOptions:\n", "Not supported option type: %d, option name: %s\n", "Invalid separator(s) found.", "%d:%d%c", "bikeshed", "0123456789ABCDEFabcdef", "Invalid 0xRRGGBB[AA] color string: '%s'\n", "Cannot find color '%s'\n", "Invalid alpha value specifier '%s' in '%s'\n", "%Y-%m-%d", "%Y%m%d", "%H%M%S", "%J:%M:%S", "qntsc", "qpal", "sntsc", "spal", "ntsc-film", "sqcif", "4cif", "16cif", "qqvga", "svga", "qxga", "wvga", "wxga", "wsxga", "wuxga", "woxga", "wqsxga", "wquxga", "whsxga", "whuxga", "hd480", "hd1080", "2kdci", "2kflat", "2kscope", "4kdci", "4kflat", "4kscope", "hqvga", "fwqvga", "hvga", "uhd2160", "uhd4320", "AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "BlueViolet", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "CornflowerBlue", "Cornsilk", "Crimson", "DarkBlue", "DarkCyan", "DarkGoldenRod", "DarkGray", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "Darkorange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenRodYellow", "LightGreen", "LightGrey", "LightPink", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Maroon", "MediumAquaMarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "PaleGoldenRod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Plum", "PowderBlue", "RosyBrown", "RoyalBlue", "SaddleBrown", "SandyBrown", "SeaShell", "Sienna", "Silver", "Snow", "Teal", "Thistle", "Tomato", "Wheat", "WhiteSmoke", "YellowGreen", "yuvj", "bgra", "rgba", "rgb32", "bgr32", "name nb_components nb_bits", "%-11s %7d %10d", "d->log2_chroma_w <= 3", "libavutil/pixdesc.c", "d->log2_chroma_h <= 3", "d->nb_components <= 4", "d->name && d->name[0]", "(d->nb_components==4 || d->nb_components==2) == !!(d->flags & (1 << 7))", "!c->plane && !c->step_minus1 && !c->offset_plus1 && !c->shift && !c->depth_minus1", "c->step_minus1 >= c->depth_minus1", "8*(c->step_minus1+1) >= c->depth_minus1+1", "bayer_", "tmp[0] == 0 && tmp[1] == 0", "yuv420p", "yuyv422", "rgb24", "bgr24", "yuv422p", "yuv444p", "yuv410p", "yuv411p", "gray8,y8", "monow", "monob", "yuvj420p", "yuvj422p", "yuvj444p", "xvmcmc", "xvmcidct", "uyvy422", "uyyvyy411", "bgr8", "bgr4", "bgr4_byte", "rgb8", "rgb4", "rgb4_byte", "nv12", "nv21", "argb", "abgr", "gray16be", "gray16le", "yuv440p", "yuvj440p", "yuva420p", "vdpau_h264", "vdpau_mpeg1", "vdpau_mpeg2", "vdpau_wmv3", "vdpau_vc1", "rgb48be", "rgb48le", "rgb565be", "rgb565le", "rgb555be", "rgb555le", "bgr565be", "bgr565le", "bgr555be", "bgr555le", "vaapi_moco", "vaapi_idct", "vaapi_vld", "yuv420p16le", "yuv420p16be", "yuv422p16le", "yuv422p16be", "yuv444p16le", "yuv444p16be", "vdpau_mpeg4", "dxva2_vld", "rgb444le", "rgb444be", "bgr444le", "bgr444be", "gray8a", "bgr48be", "bgr48le", "yuv420p9be", "yuv420p9le", "yuv420p10be", "yuv420p10le", "yuv422p10be", "yuv422p10le", "yuv444p9be", "yuv444p9le", "yuv444p10be", "yuv444p10le", "yuv422p9be", "yuv422p9le", "vda_vld", "gbrp", "gbrp9be", "gbrp9le", "gbrp10be", "gbrp10le", "gbrp16be", "gbrp16le", "yuva420p9be", "yuva420p9le", "yuva422p9be", "yuva422p9le", "yuva444p9be", "yuva444p9le", "yuva420p10be", "yuva420p10le", "yuva422p10be", "yuva422p10le", "yuva444p10be", "yuva444p10le", "yuva420p16be", "yuva420p16le", "yuva422p16be", "yuva422p16le", "yuva444p16be", "yuva444p16le", "vdpau", "xyz12le", "xyz12be", "nv16", "nv20le", "nv20be", "yvyu422", "ya16be", "ya16le", "mmal", "d3d11va_vld", "rgba64be", "rgba64le", "bgra64be", "bgra64le", "0rgb", "rgb0", "0bgr", "bgr0", "yuva444p", "yuva422p", "yuv420p12be", "yuv420p12le", "yuv420p14be", "yuv420p14le", "yuv422p12be", "yuv422p12le", "yuv422p14be", "yuv422p14le", "yuv444p12be", "yuv444p12le", "yuv444p14be", "yuv444p14le", "gbrp12be", "gbrp12le", "gbrp14be", "gbrp14le", "gbrap", "gbrap16be", "gbrap16le", "yuvj411p", "bayer_bggr8", "bayer_rggb8", "bayer_gbrg8", "bayer_grbg8", "bayer_bggr16le", "bayer_bggr16be", "bayer_rggb16le", "bayer_rggb16be", "bayer_gbrg16le", "bayer_gbrg16be", "bayer_grbg16le", "bayer_grbg16be", "yuv440p10le", "yuv440p10be", "yuv440p12le", "yuv440p12be", "ayuv64le", "ayuv64be", "videotoolbox_vld", "log100", "log316", "iec61966-2-4", "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-20", "ycgco", "bt2020nc", "bt2020c", "/dev/urandom", "/dev/random", "sizeof(tmp) >= av_sha_size", "libavutil/random_seed.c", "s16p", "s32p", "fltp", "dblp", "name   depth", "%-6s   %2d ", "Timecode frame rate must be specified\n", "Drop frame is only allowed with 30000/1001 or 60000/1001 FPS\n", "Timecode frame rate %d/%d not supported\n", "%s%02d:%02d:%02d%c%02d", "%02u:%02u:%02u%c%02u", "%d:%d:%d%c%d", "Unable to parse timecode, syntax: hh:mm:ss[:;.]ff\n", "IPBSipb", "FFmpeg version 2.8.7", "2.8.7", "Libavutil has been build with a broken binutils, please upgrade binutils and rebuild\n", "libavutil license: nonfree and unredistributable", "attachment", "!\"valid element size\"", "libavutil/utils.c", "<fBBf<", "fffffff", "fff$", "000`", "<00000000<", "<\f\f\f\f\f\f\f\f<", "<ll>", "8ll8", "8ll8", "|||||||", "<fBBf<", "0xx00", "x00000x", "x`````x", "p000x", "p00000x", "p000x", "p000x", "p000x", "<ll>", "8ll8", "8ll8", "<<<<", "error", "warning", "info", "debug", "unknown", "x264 [%s]: ", "true", "false", "x264_2pass.log", "auto", "threads", "lookahead-threads", "sliced-threads", "sync-lookahead", "deterministic", "n-deterministic", "cpu-independent", "level", "level-idc", "bluray-compat", "avcintra-class", "%d/%d", "overscan", "videoformat", "fullrange", "colorprim", "transfer", "colormatrix", "chromaloc", "%u/%u", "frameref", "dpb-size", "min-keyint", "keyint-min", "scenecut", "intra-refresh", "bframes", "b-adapt", "b-bias", "b-pyramid", "open-gop", "filter", "deblock", "%d,%d", "slice-max-size", "slice-max-mbs", "slice-min-mbs", "slices", "slices-max", "cabac", "cabac-idc", "interlaced", "constrained-intra", "flat", "cqmfile", "cqm4", "cqm8", "cqm4i", "cqm4p", "cqm4iy", "cqm4ic", "cqm4py", "cqm4pc", "cqm8i", "cqm8p", "dump-yuv", "analyse", "partitions", "i4x4", "i8x8", "p8x8", "p4x4", "b8x8", "8x8dct", "weightb", "weight-b", "weightp", "direct", "direct-pred", "chroma-qp-offset", "merange", "me-range", "mvrange", "mv-range", "mvrange-thread", "mv-range-thread", "subme", "subq", "psy-rd", "%f:%f", "%f,%f", "%f|%f", "chroma-me", "mixed-refs", "trellis", "fast-pskip", "dct-decimate", "deadzone-inter", "deadzone-intra", "bitrate", "qp_constant", "crf-max", "rc-lookahead", "qpmin", "qp-min", "qpmax", "qp-max", "qpstep", "qp-step", "ratetol", "vbv-maxrate", "vbv-bufsize", "vbv-init", "ipratio", "ip-factor", "pbratio", "pb-factor", "aq-mode", "aq-strength", "pass", "stats", "qcomp", "mbtree", "qblur", "cplxblur", "cplx-blur", "zones", "crop-rect", "%u,%u,%u,%u", "psnr", "ssim", "sps-id", "global-header", "repeat-headers", "annexb", "force-cfr", "nal-hrd", "filler", "pic-struct", "fake-interlaced", "frame-packing", "stitchable", "opencl", "opencl-clbin", "opencl-device", "baseline", "main", "high", "high10", "high422", "high444", "%s profile doesn't support lossless\n", "%s profile doesn't support 4:4:4\n", "%s profile doesn't support 4:2:2\n", "baseline profile doesn't support interlacing\n", "baseline profile doesn't support fake interlacing\n", "invalid profile: %s\n", "malloc of size %d failed\n", "ultrafast", "superfast", "veryfast", "faster", "medium", "slower", "veryslow", "placebo", "invalid preset '%s'\n", ",./-+", "film", "animation", "grain", "stillimage", "fastdecode", "zerolatency", "touhou", "invalid tune '%s'\n", "only 1 psy tuning can be used: ignoring tune %s\n", "fake", "2pass", "%dx%d ", "fps=%u/%u ", "timebase=%u/%u ", "bitdepth=%d ", "opencl=%d ", "cabac=%d", " ref=%d", " deblock=%d:%d:%d", " analyse=%#x:%#x", " me=%s", " subme=%d", " psy=%d", " psy_rd=%.2f:%.2f", " mixed_ref=%d", " me_range=%d", " chroma_me=%d", " trellis=%d", " 8x8dct=%d", " cqm=%d", " deadzone=%d,%d", " fast_pskip=%d", " chroma_qp_offset=%d", " threads=%d", " lookahead_threads=%d", " sliced_threads=%d", " slices=%d", " slices_max=%d", " slice_max_size=%d", " slice_max_mbs=%d", " slice_min_mbs=%d", " nr=%d", " decimate=%d", " interlaced=%s", " bluray_compat=%d", " stitchable=%d", " constrained_intra=%d", " bframes=%d", " b_pyramid=%d b_adapt=%d b_bias=%d direct=%d weightb=%d open_gop=%d", " weightp=%d", " keyint=infinite", " keyint=%d", " keyint_min=%d scenecut=%d intra_refresh=%d", " rc_lookahead=%d", " rc=%s mbtree=%d", " crf=%.1f", " bitrate=%d ratetol=%.1f", " qcomp=%.2f qpmin=%d qpmax=%d qpstep=%d", " cplxblur=%.1f qblur=%.1f", " vbv_maxrate=%d vbv_bufsize=%d", " crf_max=%.1f", " qp=%d", " nal_hrd=%s filler=%d", " crop_rect=%u,%u,%u,%u", " frame-packing=%d", " ip_ratio=%.2f", " pb_ratio=%.2f", " aq=%d", " zones=%s", " zones", "none", "bt709", "undef", "bt470bg", "smpte170m", "smpte240m", "YCgCo", "bt2020nc", "bt2020c", "smpte2085", "bt470m", "linear", "log100", "log316", "iec61966-2-4", "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-12", "smpte2084", "smpte428", "bt2020", "smpte431", "smpte432", "component", "ntsc", "secam", "show", "crop", "strict", "normal", "tesa", "spatial", "temporal", "x264 - core %d%s - H.264/MPEG-4 AVC codec - Copy%s 2003-2017 - http://www.videolan.org/x264.html - options: %s", " r2800 2cb792a", "left", "AVC-Intra SEI is too large (%d)\n", "frame MB size (%dx%d) > level limit (%d)\n", "DPB size (%d frames, %d mbs) > level limit (%d frames, %d mbs)\n", "VBV bitrate (%lld) > level limit (%d)\n", "VBV buffer (%lld) > level limit (%d)\n", "MV range (%lld) > level limit (%d)\n", "interlaced (%lld) > level limit (%d)\n", "fake interlaced (%lld) > level limit (%d)\n", "MB rate (%lld) > level limit (%d)\n", "pf_log not set! did you forget to call x264_param_default?\n", "invalid width x height (%dx%d)\n", "invalid CSP (only I420/YV12/NV12/NV21/I422/YV16/NV16/I444/YV24/BGR/BGRA/RGB supported)\n", "width not divisible by %d (%dx%d)\n", "height not divisible by %d (%dx%d)\n", "invalid crop-rect %u,%u,%u,%u\n", "crop-rect %u,%u,%u,%u not divisible by %dx%d\n", "OpenCL: frame size is too small, disabling opencl\n", "OpenCL: device id and device skip count configured; dropping skip\n", "ignoring unknown frame packing value\n", "cropped resolution %dx%d not compatible with tile format frame packing\n", "broken ffmpeg default settings detected\n", "use an encoding preset (e.g. -vpre medium)\n", "preset usage: -vpre <speed> -vpre <profile>\n", "speed presets are listed in x264 --help\n", "profile is optional; x264 defaults to high\n", "no ratecontrol method specified\n", "%2d-bit AVC-Intra is not widely compatible\n", "10-bit x264 is required to encode AVC-Intra\n", "bitrate not specified\n", "VBV is incompatible with constant QP, ignored.\n", "VBV maxrate unspecified, assuming CBR\n", "VBV bufsize set but maxrate unspecified, ignored\n", "max bitrate less than average bitrate, assuming CBR\n", "VBV maxrate specified, but no bufsize, ignored\n", "interlace + slice-min-mbs is not implemented\n", "slice-min-mbs > row mb size (%d) not implemented\n", "subme=0 + direct=temporal is not supported\n", "b-pyramid normal + intra-refresh is not supported\n", "ref > 1 + intra-refresh is not supported\n", "intra-refresh is not compatible with open-gop\n", "lookaheadless mb-tree requires intra refresh or infinite keyint\n", "--%s used with psy on: results will be invalid!\n", "--ssim used with AQ off: results will be invalid!\n", "--psnr used with AQ on: results will be invalid!\n", "interlace + me=esa is not implemented\n", "interlace + weightp is not implemented\n", "using mv_range_thread = %d\n", "NAL HRD parameters require VBV parameters\n", "CBR HRD requires constant bitrate\n", "--tune %s should be used if attempting to benchmark %s!\n", "invalid level_idc: %d\n", "invalid DTS: PTS is less than DTS\n", " PSNR Y:%5.2f U:%5.2f V:%5.2f", " SSIM Y:%.5f", "frame=%4d QP=%.2f NAL=%d Slice:%c Poc:%-3d I:%-4d P:%-4d SKIP:%-4d size=%d bytes%s\n", "slice-max-size violated (frame %d, cause: slice-min-mbs)\n", "Main", "Constrained Baseline", "High", "High 4:4:4 Predictive", "High 10", "High 4:2:2", "High 4:4:4 Intra", "High 4:2:2 Intra", "High 10 Intra", "Effective timebase denominator %u exceeds H.264 maximum\n", "cannot create valid sample aspect ratio\n", "using SAR=%d/%d\n", "using cpu capabilities:", "SSE2", "SSE3", "SSE4.1", "BMI1", " none!", "MV cost test failed: x264 has been miscompiled!\n", "CLZ test failed: x264 has been miscompiled!\n", "failed to load OpenCL\n", "HRD bitrate: %i bits/sec\n", "CPB size: %i bits\n", "dump_yuv: can't write to %s\n", "dump_yuv: incompatible with non-regular file %s\n", "%d.%d", "profile %s, level %s\n", "profile %s, level %s, %s %d-bit\n", "x264_encoder_invalidate_reference is not supported with B-frames enabled\n", "x264_encoder_invalidate_reference is not supported with intra refresh enabled\n", "lookahead thread is already stopped\n", "non-strictly-monotonic PTS\n", "uvDC", "uvAC", "frame %c:%-5d Avg QP:%5.2f  size:%6.0f  PSNR Mean Y:%5.2f U:%5.2f V:%5.2f Avg:%5.2f Global:%5.2f\n", "frame %c:%-5d Avg QP:%5.2f  size:%6.0f\n", "consecutive B-frames:%s\n", " %4.1f%%", "mb I  %s\n", "mb P  %s  P16..4: %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%%    skip:%4.1f%%\n", "  B16..8: %4.1f%% %4.1f%% %4.1f%%  direct:%4.1f%%  skip:%4.1f%%", "  L0:%4.1f%% L1:%4.1f%% BI:%4.1f%%", "mb B  %s\n", " inter:%.1f%%", " skip:%.1f%%", "field mbs: intra: %.1f%%%s\n", "8x8 transform intra:%.1f%%%s\n", "direct mvs  spatial:%.1f%% temporal:%.1f%%\n", " inter: %.1f%% %.1f%% %.1f%%", "coded y,%s,%s intra: %.1f%% %.1f%% %.1f%%%s\n", "i16 v,h,dc,p: %2.0f%% %2.0f%% %2.0f%% %2.0f%%\n", "i%d v,h,dc,ddl,ddr,vr,hd,vl,hu: %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%%\n", "i8c dc,h,v,p: %2.0f%% %2.0f%% %2.0f%% %2.0f%%\n", "Weighted P-Frames: Y:%.1f%% UV:%.1f%%\n", "ref %c L%d:%s\n", "SSIM Mean Y:%.7f (%6.3fdb)\n", "PSNR Mean Y:%6.3f U:%6.3f V:%6.3f Avg:%6.3f Global:%6.3f kb/s:%.2f\n", "kb/s:%.2f\n", "I16..4%s: %4.1f%% %4.1f%% %4.1f%%", "..PCM", "4:0:0", "4:2:0", "4:2:2", "4:4:4", "f4b6c29ca248858bb7177e64694e42a8", "#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\nconstant sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n/* 7.18.1.1  Exact-width integer types */\ntypedef signed char int8_t;\ntypedef unsigned char   uint8_t;\ntypedef short  int16_t;\ntypedef unsigned short  uint16_t;\ntypedef int  int32_t;\ntypedef unsigned   uint32_t;\ntypedef uint8_t  pixel;\ntypedef uint16_t sum_t;\ntypedef uint32_t sum2_t;\n#define LOWRES_COST_MASK ((1<<14)-1)\n#define LOWRES_COST_SHIFT 14\n#define COST_MAX (1<<28)\n#define PIXEL_MAX 255\n#define BITS_PER_SUM (8 * sizeof(sum_t))\n/* Constants for offsets into frame statistics buffer */\n#define COST_EST    0\n#define COST_EST_AQ 1\n#define INTRA_MBS   2\n#define COPY2_IF_LT( x, y, a, b )\\\nif( (y) < (x) )\\\n{\\\n(x) = (y);\\\n(a) = (b);\\\n}\nconstant int2 dia_offs[4] =\n{\n{0, -1}, {-1, 0}, {1, 0}, {0, 1},\n};\ninline pixel x264_clip_pixel( int x )\n{\nreturn (pixel) clamp( x, (int) 0, (int) PIXEL_MAX );\n}\ninline int2 x264_median_mv( short2 a, short2 b, short2 c )\n{\nshort2 t1 = min(a, b);\nshort2 t2 = min(max(a, b), c);\nreturn convert_int2(max(t1, t2));\n}\ninline sum2_t abs2( sum2_t a )\n{\nsum2_t s = ((a >> (BITS_PER_SUM - 1)) & (((sum2_t)1 << BITS_PER_SUM) + 1)) * ((sum_t)-1);\nreturn (a + s) ^ s;\n}\n#define HADAMARD4( d0, d1, d2, d3, s0, s1, s2, s3 ) {\\\nsum2_t t0 = s0 + s1;\\\nsum2_t t1 = s0 - s1;\\\nsum2_t t2 = s2 + s3;\\\nsum2_t t3 = s2 - s3;\\\nd0 = t0 + t2;\\\nd2 = t0 - t2;\\\nd1 = t1 + t3;\\\nd3 = t1 - t3;\\\n}\n#define HADAMARD4V( d0, d1, d2, d3, s0, s1, s2, s3 ) {\\\nint2 t0 = s0 + s1;\\\nint2 t1 = s0 - s1;\\\nint2 t2 = s2 + s3;\\\nint2 t3 = s2 - s3;\\\nd0 = t0 + t2;\\\nd2 = t0 - t2;\\\nd1 = t1 + t3;\\\nd3 = t1 - t3;\\\n}\n#define SATD_C_8x4_Q( name, q1, q2 )\\\nint name( q1 pixel *pix1, int i_pix1, q2 pixel *pix2, int i_pix2 )\\\n{\\\nsum2_t tmp[4][4];\\\nsum2_t a0, a1, a2, a3;\\\nsum2_t sum = 0;\\\nfor( int i = 0; i < 4; i++, pix1 += i_pix1, pix2 += i_pix2 )\\\n{\\\na0 = (pix1[0] - pix2[0]) + ((sum2_t)(pix1[4] - pix2[4]) << BITS_PER_SUM);\\\na1 = (pix1[1] - pix2[1]) + ((sum2_t)(pix1[5] - pix2[5]) << BITS_PER_SUM);\\\na2 = (pix1[2] - pix2[2]) + ((sum2_t)(pix1[6] - pix2[6]) << BITS_PER_SUM);\\\na3 = (pix1[3] - pix2[3]) + ((sum2_t)(pix1[7] - pix2[7]) << BITS_PER_SUM);\\\nHADAMARD4( tmp[i][0], tmp[i][1], tmp[i][2], tmp[i][3], a0, a1, a2, a3 );\\\n}\\\nfor( int i = 0; i < 4; i++ )\\\n{\\\nHADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );\\\nsum += abs2( a0 ) + abs2( a1 ) + abs2( a2 ) + abs2( a3 );\\\n}\\\nreturn (((sum_t)sum) + (sum>>BITS_PER_SUM)) >> 1;\\\n}\n/*\n* Utility function to perform a parallel sum reduction of an array of integers\n*/\nint parallel_sum( int value, int x, volatile local int *array )\n{\narray[x] = value;\nbarrier( CLK_LOCAL_MEM_FENCE );\nint dim = get_local_size( 0 );\nwhile( dim > 1 )\n{\ndim >>= 1;\nif( x < dim )\narray[x] += array[x + dim];\nif( dim > 32 )\nbarrier( CLK_LOCAL_MEM_FENCE );\n}\nreturn array[0];\n}\nint mv_cost( uint2 mvd )\n{\nfloat2 mvdf = (float2)(mvd.x, mvd.y) + 1.0f;\nfloat2 cost = round( log2(mvdf) * 2.0f + 0.718f + (float2)(!!mvd.x, !!mvd.y) );\nreturn (int) (cost.x + cost.y);\n}\n/* Mode selection routines, select the least SATD cost mode for each lowres\n* macroblock.  When measuring B slices, this includes measuring the cost of\n* three bidir modes.  */\n/* Four threads cooperatively measure 8x8 BIDIR cost with SATD */\nint bidir_satd_8x8_ii_coop4( read_only image2d_t fenc_lowres,\nint2 fencpos,\nread_only image2d_t fref0_planes,\nint2 qpos0,\nread_only image2d_t fref1_planes,\nint2 qpos1,\nint weight,\nlocal sum2_t *tmpp,\nint idx )\n{\nvolatile local sum2_t( *tmp )[4] = (volatile local sum2_t( * )[4])tmpp;\nsum2_t b0, b1, b2, b3;\nsum2_t sum = 0;\nint2 fref0Apos = (int2)(qpos0.x>>2, qpos0.y>>2);\nint hpel0A = ((qpos0.x&2)>>1) + (qpos0.y&2);\nint2 qpos0B = (int2)qpos0 + (int2)(((qpos0.x&1)<<1), ((qpos0.y&1)<<1));\nint2 fref0Bpos = (int2)(qpos0B.x>>2, qpos0B.y>>2);\nint hpel0B = ((qpos0B.x&2)>>1) + (qpos0B.y&2);\nint2 fref1Apos = (int2)(qpos1.x>>2, qpos1.y>>2);\nint hpel1A = ((qpos1.x&2)>>1) + (qpos1.y&2);\nint2 qpos1B = (int2)qpos1 + (int2)(((qpos1.x&1)<<1), ((qpos1.y&1)<<1));\nint2 fref1Bpos = (int2)(qpos1B.x>>2, qpos1B.y>>2);\nint hpel1B = ((qpos1B.x&2)>>1) + (qpos1B.y&2);\nuint mask_shift0A = 8 * hpel0A, mask_shift0B = 8 * hpel0B;\nuint mask_shift1A = 8 * hpel1A, mask_shift1B = 8 * hpel1B;\nuint vA, vB;\nuint enc, ref0, ref1;\nuint a0, a1;\nconst int weight2 = 64 - weight;\n#define READ_BIDIR_DIFF( OUT, X )\\\nenc = read_imageui( fenc_lowres, sampler, fencpos + (int2)(X, idx) ).s0;\\\nvA = (read_imageui( fref0_planes, sampler, fref0Apos + (int2)(X, idx) ).s0 >> mask_shift0A) & 0xFF;\\\nvB = (read_imageui( fref0_planes, sampler, fref0Bpos + (int2)(X, idx) ).s0 >> mask_shift0B) & 0xFF;\\\nref0 = rhadd( vA, vB );\\\nvA = (read_imageui( fref1_planes, sampler, fref1Apos + (int2)(X, idx) ).s0 >> mask_shift1A) & 0xFF;\\\nvB = (read_imageui( fref1_planes, sampler, fref1Bpos + (int2)(X, idx) ).s0 >> mask_shift1B) & 0xFF;\\\nref1 = rhadd( vA, vB );\\\nOUT = enc - ((ref0 * weight + ref1 * weight2 + (1 << 5)) >> 6);\n#define READ_DIFF_EX( OUT, a, b )\\\nREAD_BIDIR_DIFF( a0, a );\\\nREAD_BIDIR_DIFF( a1, b );\\\nOUT = a0 + (a1<<BITS_PER_SUM);\n#define ROW_8x4_SATD( a, b, c )\\\nfencpos.y += a;\\\nfref0Apos.y += b;\\\nfref0Bpos.y += b;\\\nfref1Apos.y += c;\\\nfref1Bpos.y += c;\\\nREAD_DIFF_EX( b0, 0, 4 );\\\nREAD_DIFF_EX( b1, 1, 5 );\\\nREAD_DIFF_EX( b2, 2, 6 );\\\nREAD_DIFF_EX( b3, 3, 7 );\\\nHADAMARD4( tmp[idx][0], tmp[idx][1], tmp[idx][2], tmp[idx][3], b0, b1, b2, b3 );\\\nHADAMARD4( b0, b1, b2, b3, tmp[0][idx], tmp[1][idx], tmp[2][idx], tmp[3][idx] );\\\nsum += abs2( b0 ) + abs2( b1 ) + abs2( b2 ) + abs2( b3 );\nROW_8x4_SATD( 0, 0, 0 );\nROW_8x4_SATD( 4, 4, 4 );\n#undef READ_BIDIR_DIFF\n#undef READ_DIFF_EX\n#undef ROW_8x4_SATD\nreturn (((sum_t)sum) + (sum>>BITS_PER_SUM)) >> 1;\n}\n/*\n* mode selection - pick the least cost partition type for each 8x8 macroblock.\n* Intra, list0 or list1.  When measuring a B slice, also test three bidir\n* possibilities.\n*\n* fenc_lowres_mvs[0|1] and fenc_lowres_mv_costs[0|1] are large buffers that\n* hold many frames worth of motion vectors.  We must offset into the correct\n* location for this frame's vectors:\n*\n*   CPU equivalent: fenc->lowres_mvs[0][b - p0 - 1]\n*   GPU equivalent: fenc_lowres_mvs0[(b - p0 - 1) * mb_count]\n*\n* global launch dimensions for P slice estimate:  [mb_width, mb_height]\n* global launch dimensions for B slice estimate:  [mb_width * 4, mb_height]\n*/\nkernel void mode_selection( read_only image2d_t   fenc_lowres,\nread_only image2d_t   fref0_planes,\nread_only image2d_t   fref1_planes,\nconst global short2  *fenc_lowres_mvs0,\nconst global short2  *fenc_lowres_mvs1,\nconst global short2  *fref1_lowres_mvs0,\nconst global int16_t *fenc_lowres_mv_costs0,\nconst global int16_t *fenc_lowres_mv_costs1,\nconst global uint16_t *fenc_intra_cost,\nglobal uint16_t      *lowres_costs,\nglobal int           *frame_stats,\nlocal int16_t        *cost_local,\nlocal sum2_t         *satd_local,\nint                   mb_width,\nint                   bipred_weight,\nint                   dist_scale_factor,\nint                   b,\nint                   p0,\nint                   p1,\nint                   lambda )\n{\nint mb_x = get_global_id( 0 );\nint b_bidir = b < p1;\nif( b_bidir )\n{\n/* when mode_selection is run for B frames, it must perform BIDIR SATD\n* measurements, so it is launched with four times as many threads in\n* order to spread the work around more of the GPU.  And it can add\n* padding threads in the X direction. */\nmb_x >>= 2;\nif( mb_x >= mb_width )\nreturn;\n}\nint mb_y = get_global_id( 1 );\nint mb_height = get_global_size( 1 );\nint mb_count = mb_width * mb_height;\nint mb_xy = mb_x + mb_y * mb_width;\n/* Initialize int frame_stats[4] for next kernel (sum_inter_cost) */\nif( mb_x < 4 && mb_y == 0 )\nframe_stats[mb_x] = 0;\nint bcost = COST_MAX;\nint list_used = 0;\nif( !b_bidir )\n{\nint icost = fenc_intra_cost[mb_xy];\nCOPY2_IF_LT( bcost, icost, list_used, 0 );\n}\nif( b != p0 )\n{\nint mv_cost0 = fenc_lowres_mv_costs0[(b - p0 - 1) * mb_count + mb_xy];\nCOPY2_IF_LT( bcost, mv_cost0, list_used, 1 );\n}\nif( b != p1 )\n{\nint mv_cost1 = fenc_lowres_mv_costs1[(p1 - b - 1) * mb_count + mb_xy];\nCOPY2_IF_LT( bcost, mv_cost1, list_used, 2 );\n}\nif( b_bidir )\n{\nint2 coord = (int2)(mb_x, mb_y) << 3;\nint mb_i = get_global_id( 0 ) & 3;\nint mb_in_group = get_local_id( 1 ) * (get_local_size( 0 ) >> 2) + (get_local_id( 0 ) >> 2);\ncost_local += mb_in_group * 4;\nsatd_local += mb_in_group * 16;\n#define TRY_BIDIR( mv0, mv1, penalty )\\\n{\\\nint2 qpos0 = (int2)((coord.x<<2) + mv0.x, (coord.y<<2) + mv0.y);\\\nint2 qpos1 = (int2)((coord.x<<2) + mv1.x, (coord.y<<2) + mv1.y);\\\ncost_local[mb_i] = bidir_satd_8x8_ii_coop4( fenc_lowres, coord, fref0_planes, qpos0, fref1_planes, qpos1, bipred_weight, satd_local, mb_i );\\\nint cost = cost_local[0] + cost_local[1] + cost_local[2] + cost_local[3];\\\nCOPY2_IF_LT( bcost, penalty * lambda + cost, list_used, 3 );\\\n}\n/* temporal prediction */\nshort2 dmv0, dmv1;\nshort2 mvr = fref1_lowres_mvs0[mb_xy];\ndmv0 = (mvr * (short) dist_scale_factor + (short) 128) >> (short) 8;\ndmv1 = dmv0 - mvr;\nTRY_BIDIR( dmv0, dmv1, 0 )\nif( as_uint( dmv0 ) || as_uint( dmv1 ) )\n{\n/* B-direct prediction */\ndmv0 = 0; dmv1 = 0;\nTRY_BIDIR( dmv0, dmv1, 0 );\n}\n/* L0+L1 prediction */\ndmv0 = fenc_lowres_mvs0[(b - p0 - 1) * mb_count + mb_xy];\ndmv1 = fenc_lowres_mvs1[(p1 - b - 1) * mb_count + mb_xy];\nTRY_BIDIR( dmv0, dmv1, 5 );\n#undef TRY_BIDIR\n}\nlowres_costs[mb_xy] = min( bcost, LOWRES_COST_MASK ) + (list_used << LOWRES_COST_SHIFT);\n}\n/*\n* parallel sum inter costs\n*\n* global launch dimensions: [256, mb_height]\n*/\nkernel void sum_inter_cost( const global uint16_t *fenc_lowres_costs,\nconst global uint16_t *inv_qscale_factor,\nglobal int           *fenc_row_satds,\nglobal int           *frame_stats,\nint                   mb_width,\nint                   bframe_bias,\nint                   b,\nint                   p0,\nint                   p1 )\n{\nint y = get_global_id( 1 );\nint mb_height = get_global_size( 1 );\nint row_satds = 0;\nint cost_est = 0;\nint cost_est_aq = 0;\nint intra_mbs = 0;\nfor( int x = get_global_id( 0 ); x < mb_width; x += get_global_size( 0 ))\n{\nint mb_xy = x + y * mb_width;\nint cost = fenc_lowres_costs[mb_xy] & LOWRES_COST_MASK;\nint list = fenc_lowres_costs[mb_xy] >> LOWRES_COST_SHIFT;\nint b_frame_score_mb = (x > 0 && x < mb_width - 1 && y > 0 && y < mb_height - 1) || mb_width <= 2 || mb_height <= 2;\nif( list == 0 && b_frame_score_mb )\nintra_mbs++;\nint cost_aq = (cost * inv_qscale_factor[mb_xy] + 128) >> 8;\nrow_satds += cost_aq;\nif( b_frame_score_mb )\n{\ncost_est += cost;\ncost_est_aq += cost_aq;\n}\n}\nlocal int buffer[256];\nint x = get_global_id( 0 );\nrow_satds   = parallel_sum( row_satds, x, buffer );\ncost_est    = parallel_sum( cost_est, x, buffer );\ncost_est_aq = parallel_sum( cost_est_aq, x, buffer );\nintra_mbs   = parallel_sum( intra_mbs, x, buffer );\nif( b != p1 )\ncost_est = (int)((float)cost_est * 100.0f / (120.0f + (float)bframe_bias));\nif( get_global_id( 0 ) == 0 )\n{\nfenc_row_satds[y] = row_satds;\natomic_add( frame_stats + COST_EST, cost_est );\natomic_add( frame_stats + COST_EST_AQ, cost_est_aq );\natomic_add( frame_stats + INTRA_MBS, intra_mbs );\n}\n}\n/*\n* downscale lowres luma: full-res buffer to down scale image, and to packed hpel image\n*\n* --\n*\n* fenc_img is an output image (area of memory referenced through a texture\n* cache). A read of any pixel location (x,y) returns four pixel values:\n*\n* val.s0 = P(x,y)\n* val.s1 = P(x+1,y)\n* val.s2 = P(x+2,y)\n* val.s3 = P(x+3,y)\n*\n* This is a 4x replication of the lowres pixels, a trade-off between memory\n* size and read latency.\n*\n* --\n*\n* hpel_planes is an output image that contains the four HPEL planes used for\n* subpel refinement. A read of any pixel location (x,y) returns a UInt32 with\n* the four planar values C | V | H | F\n*\n* launch dimensions:  [lowres-width, lowres-height]\n*/\nkernel void downscale_hpel( const global pixel *fenc,\nwrite_only image2d_t fenc_img,\nwrite_only image2d_t hpel_planes,\nint stride )\n{\nint x = get_global_id( 0 );\nint y = get_global_id( 1 );\nuint4 values;\nfenc += y * stride * 2;\nconst global pixel *src1 = fenc + stride;\nconst global pixel *src2 = (y == get_global_size( 1 )-1) ? src1 : src1 + stride;\nint2 pos = (int2)(x, y);\npixel right, left;\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s0 = rhadd( right, left );           // F\nright = rhadd( fenc[2*x+1], src1[2*x+1] );\nleft  = rhadd( fenc[2*x+2], src1[2*x+2] );\nvalues.s1 = rhadd( right, left );           // H\nright = rhadd( src1[2*x], src2[2*x] );\nleft  = rhadd( src1[2*x+1], src2[2*x+1] );\nvalues.s2 = rhadd( right, left );           // V\nright = rhadd( src1[2*x+1], src2[2*x+1] );\nleft  = rhadd( src1[2*x+2], src2[2*x+2] );\nvalues.s3 = rhadd( right, left );           // C\nuint4 val = (uint4) ((values.s3 & 0xff) << 24) | ((values.s2 & 0xff) << 16) | ((values.s1 & 0xff) << 8) | (values.s0 & 0xff);\nwrite_imageui( hpel_planes, pos, val );\nx = select( x, x+1, x+1 < get_global_size( 0 ) );\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s1 = rhadd( right, left );\nx = select( x, x+1, x+1 < get_global_size( 0 ) );\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s2 = rhadd( right, left );\nx = select( x, x+1, x+1 < get_global_size( 0 ) );\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s3 = rhadd( right, left );\nwrite_imageui( fenc_img, pos, values );\n}\n/*\n* downscale lowres hierarchical motion search image, copy from one image to\n* another decimated image.  This kernel is called iteratively to generate all\n* of the downscales.\n*\n* launch dimensions:  [lower_res width, lower_res height]\n*/\nkernel void downscale1( read_only image2d_t higher_res, write_only image2d_t lower_res )\n{\nint x = get_global_id( 0 );\nint y = get_global_id( 1 );\nint2 pos = (int2)(x, y);\nint gs = get_global_size( 0 );\nuint4 top, bot, values;\ntop = read_imageui( higher_res, sampler, (int2)(x*2, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2, 2*y+1) );\nvalues.s0 = rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) );\n/* these select statements appear redundant, and they should be, but tests break when\n* they are not here.  I believe this was caused by a driver bug\n*/\nvalues.s1 = select( values.s0, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 1 < gs) );\ntop = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y+1) );\nvalues.s2 = select( values.s1, rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) ), ( x + 2 < gs ) );\nvalues.s3 = select( values.s2, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 3 < gs ) );\nwrite_imageui( lower_res, pos, (uint4)(values) );\n}\n/*\n* Second copy of downscale kernel, no differences. This is a (no perf loss)\n* workaround for a scheduling bug in current Tahiti drivers.  This bug has\n* theoretically been fixed in the July 2012 driver release from AMD.\n*/\nkernel void downscale2( read_only image2d_t higher_res, write_only image2d_t lower_res )\n{\nint x = get_global_id( 0 );\nint y = get_global_id( 1 );\nint2 pos = (int2)(x, y);\nint gs = get_global_size( 0 );\nuint4 top, bot, values;\ntop = read_imageui( higher_res, sampler, (int2)(x*2, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2, 2*y+1) );\nvalues.s0 = rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) );\nvalues.s1 = select( values.s0, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 1 < gs) );\ntop = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y+1) );\nvalues.s2 = select( values.s1, rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) ), ( x + 2 < gs ) );\nvalues.s3 = select( values.s2, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 3 < gs ) );\nwrite_imageui( lower_res, pos, (uint4)(values) );\n}\n/* OpenCL 1.2 finally added a memset command, but we're not targeting 1.2 */\nkernel void memset_int16( global int16_t *buf, int16_t value )\n{\nbuf[get_global_id( 0 )] = value;\n}\n/* Lookahead lowres intra analysis\n*\n* Each intra analysis function has been implemented twice, once for scalar GPUs\n* (NV) and once for vectorized GPUs (AMD pre-Southern Islands).  x264 detects\n* the GPU type and sets the -DVECTORIZE compile flag accordingly.\n*\n* All the intra analysis functions were based on their C versions in pixel.c\n* and produce the exact same results.\n*/\n/* force all clamp arguments and return value to int, prevent ambiguous types */\n#define clamp_int( X, MIN, MAX ) (int) clamp( (int)(X), (int)(MIN), (int)(MAX) )\n#if VECTORIZE\nint satd_8x4_intra_lr( const local pixel *data, int data_stride, int8 pr0, int8 pr1, int8 pr2, int8 pr3 )\n{\nint8 a_v, d_v;\nint2 tmp00, tmp01, tmp02, tmp03, tmp10, tmp11, tmp12, tmp13;\nint2 tmp20, tmp21, tmp22, tmp23, tmp30, tmp31, tmp32, tmp33;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr0).s04152637;\nHADAMARD4V( tmp00, tmp01, tmp02, tmp03, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\ndata += data_stride;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr1).s04152637;\nHADAMARD4V( tmp10, tmp11, tmp12, tmp13, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\ndata += data_stride;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr2).s04152637;\nHADAMARD4V( tmp20, tmp21, tmp22, tmp23, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\ndata += data_stride;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr3).s04152637;\nHADAMARD4V( tmp30, tmp31, tmp32, tmp33, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\nuint8 sum_v;\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp00, tmp10, tmp20, tmp30 );\nsum_v = abs( a_v );\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp01, tmp11, tmp21, tmp31 );\nsum_v += abs( a_v );\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp02, tmp12, tmp22, tmp32 );\nsum_v += abs( a_v );\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp03, tmp13, tmp23, tmp33 );\nsum_v += abs( a_v );\nuint4 sum2 = sum_v.hi + sum_v.lo;\nuint2 sum3 = sum2.hi + sum2.lo;\nreturn ( sum3.hi + sum3.lo ) >> 1;\n}\n#else\nSATD_C_8x4_Q( satd_8x4_lp, const local, private )\n#endif\n/****************************************************************************\n* 8x8 prediction for intra luma block\n****************************************************************************/\n#define F1            rhadd\n#define F2( a, b, c ) ( a+2*b+c+2 )>>2\n#if VECTORIZE\nint x264_predict_8x8_ddl( const local pixel *src, int src_stride, const local pixel *top )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = ( 2 + top[0] + 2*top[1] + top[2] ) >> 2;\npr0.s1 = ( 2 + top[1] + 2*top[2] + top[3] ) >> 2;\npr0.s2 = ( 2 + top[2] + 2*top[3] + top[4] ) >> 2;\npr0.s3 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr0.s4 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr0.s5 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr0.s6 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr0.s7 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr1.s0 = ( 2 + top[1] + 2*top[2] + top[3] ) >> 2;\npr1.s1 = ( 2 + top[2] + 2*top[3] + top[4] ) >> 2;\npr1.s2 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr1.s3 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr1.s4 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr1.s5 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr1.s6 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr1.s7 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr2.s0 = ( 2 + top[2] + 2*top[3] + top[4] ) >> 2;\npr2.s1 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr2.s2 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr2.s3 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr2.s4 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr2.s5 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr2.s6 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr2.s7 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr3.s0 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr3.s1 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr3.s2 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr3.s3 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr3.s4 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr3.s5 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr3.s6 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr3.s7 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr0.s1 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr0.s2 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr0.s3 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr0.s4 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr0.s5 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr0.s6 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr0.s7 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr1.s0 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr1.s1 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr1.s2 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr1.s3 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr1.s4 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr1.s5 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr1.s6 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr1.s7 = ( 2 + top[12] + 2*top[13] + top[14] ) >> 2;\npr2.s0 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr2.s1 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr2.s2 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr2.s3 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr2.s4 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr2.s5 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr2.s6 = ( 2 + top[12] + 2*top[13] + top[14] ) >> 2;\npr2.s7 = ( 2 + top[13] + 2*top[14] + top[15] ) >> 2;\npr3.s0 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr3.s1 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr3.s2 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr3.s3 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr3.s4 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr3.s5 = ( 2 + top[12] + 2*top[13] + top[14] ) >> 2;\npr3.s6 = ( 2 + top[13] + 2*top[14] + top[15] ) >> 2;\npr3.s7 = ( 2 + top[14] + 3*top[15] ) >> 2;\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_ddr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nint8 pr0, pr1, pr2, pr3;\npr3.s0 = F2( left[1], left[2], left[3] );\npr2.s0 = pr3.s1 = F2( left[0], left[1], left[2] );\npr1.s0 = pr2.s1 = pr3.s2 = F2( left[1], left[0], left_top );\npr0.s0 = pr1.s1 = pr2.s2 = pr3.s3 = F2( left[0], left_top, top[0] );\npr0.s1 = pr1.s2 = pr2.s3 = pr3.s4 = F2( left_top, top[0], top[1] );\npr0.s2 = pr1.s3 = pr2.s4 = pr3.s5 = F2( top[0], top[1], top[2] );\npr0.s3 = pr1.s4 = pr2.s5 = pr3.s6 = F2( top[1], top[2], top[3] );\npr0.s4 = pr1.s5 = pr2.s6 = pr3.s7 = F2( top[2], top[3], top[4] );\npr0.s5 = pr1.s6 = pr2.s7 = F2( top[3], top[4], top[5] );\npr0.s6 = pr1.s7 = F2( top[4], top[5], top[6] );\npr0.s7 = F2( top[5], top[6], top[7] );\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr3.s0 = F2( left[5], left[6], left[7] );\npr2.s0 = pr3.s1 = F2( left[4], left[5], left[6] );\npr1.s0 = pr2.s1 = pr3.s2 = F2( left[3], left[4], left[5] );\npr0.s0 = pr1.s1 = pr2.s2 = pr3.s3 = F2( left[2], left[3], left[4] );\npr0.s1 = pr1.s2 = pr2.s3 = pr3.s4 = F2( left[1], left[2], left[3] );\npr0.s2 = pr1.s3 = pr2.s4 = pr3.s5 = F2( left[0], left[1], left[2] );\npr0.s3 = pr1.s4 = pr2.s5 = pr3.s6 = F2( left[1], left[0], left_top );\npr0.s4 = pr1.s5 = pr2.s6 = pr3.s7 = F2( left[0], left_top, top[0] );\npr0.s5 = pr1.s6 = pr2.s7 = F2( left_top, top[0], top[1] );\npr0.s6 = pr1.s7 = F2( top[0], top[1], top[2] );\npr0.s7 = F2( top[1], top[2], top[3] );\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_vr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nint8 pr0, pr1, pr2, pr3;\npr2.s0 = F2( left[1], left[0], left_top );\npr3.s0 = F2( left[2], left[1], left[0] );\npr1.s0 = pr3.s1 = F2( left[0], left_top, top[0] );\npr0.s0 = pr2.s1 = F1( left_top, top[0] );\npr1.s1 = pr3.s2 = F2( left_top, top[0], top[1] );\npr0.s1 = pr2.s2 = F1( top[0], top[1] );\npr1.s2 = pr3.s3 = F2( top[0], top[1], top[2] );\npr0.s2 = pr2.s3 = F1( top[1], top[2] );\npr1.s3 = pr3.s4 = F2( top[1], top[2], top[3] );\npr0.s3 = pr2.s4 = F1( top[2], top[3] );\npr1.s4 = pr3.s5 = F2( top[2], top[3], top[4] );\npr0.s4 = pr2.s5 = F1( top[3], top[4] );\npr1.s5 = pr3.s6 = F2( top[3], top[4], top[5] );\npr0.s5 = pr2.s6 = F1( top[4], top[5] );\npr1.s6 = pr3.s7 = F2( top[4], top[5], top[6] );\npr0.s6 = pr2.s7 = F1( top[5], top[6] );\npr1.s7 = F2( top[5], top[6], top[7] );\npr0.s7 = F1( top[6], top[7] );\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr2.s0 = F2( left[5], left[4], left[3] );\npr3.s0 = F2( left[6], left[5], left[4] );\npr0.s0 = pr2.s1 = F2( left[3], left[2], left[1] );\npr1.s0 = pr3.s1 = F2( left[4], left[3], left[2] );\npr0.s1 = pr2.s2 = F2( left[1], left[0], left_top );\npr1.s1 = pr3.s2 = F2( left[2], left[1], left[0] );\npr1.s2 = pr3.s3 = F2( left[0], left_top, top[0] );\npr0.s2 = pr2.s3 = F1( left_top, top[0] );\npr1.s3 = pr3.s4 = F2( left_top, top[0], top[1] );\npr0.s3 = pr2.s4 = F1( top[0], top[1] );\npr1.s4 = pr3.s5 = F2( top[0], top[1], top[2] );\npr0.s4 = pr2.s5 = F1( top[1], top[2] );\npr1.s5 = pr3.s6 = F2( top[1], top[2], top[3] );\npr0.s5 = pr2.s6 = F1( top[2], top[3] );\npr1.s6 = pr3.s7 = F2( top[2], top[3], top[4] );\npr0.s6 = pr2.s7 = F1( top[3], top[4] );\npr1.s7 = F2( top[3], top[4], top[5] );\npr0.s7 = F1( top[4], top[5] );\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n#undef PRED\n}\nint x264_predict_8x8_hd( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = F1( left_top, left[0] ); pr0.s1 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\npr0.s2 = F2( top[1], top[0], left_top ); pr0.s3 = F2( top[2], top[1], top[0] );\npr0.s4 = F2( top[3], top[2], top[1] ); pr0.s5 = F2( top[4], top[3], top[2] );\npr0.s6 = F2( top[5], top[4], top[3] ); pr0.s7 = F2( top[6], top[5], top[4] );\npr1.s0 = F1( left[0], left[1] ); pr1.s1 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr1.s2 = F1( left_top, left[0] ); pr1.s3 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\npr1.s4 = F2( top[1], top[0], left_top ); pr1.s5 = F2( top[2], top[1], top[0] );\npr1.s6 = F2( top[3], top[2], top[1] ); pr1.s7 = F2( top[4], top[3], top[2] );\npr2.s0 = F1( left[1], left[2] ); pr2.s1 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr2.s2 = F1( left[0], left[1] ); pr2.s3 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr2.s4 = F1( left_top, left[0] ); pr2.s5 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\npr2.s6 = F2( top[1], top[0], left_top ); pr2.s7 = F2( top[2], top[1], top[0] );\npr3.s0 = F1( left[2], left[3] ); pr3.s1 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr3.s2 = F1( left[1], left[2] ); pr3.s3 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr3.s4 = F1( left[0], left[1] ); pr3.s5 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr3.s6 = F1( left_top, left[0] ); pr3.s7 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = F1( left[3], left[4] ); pr0.s1 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr0.s2 = F1( left[2], left[3] ); pr0.s3 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr0.s4 = F1( left[1], left[2] ); pr0.s5 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr0.s6 = F1( left[0], left[1] ); pr0.s7 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr1.s0 = F1( left[4], left[5] ); pr1.s1 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr1.s2 = F1( left[3], left[4] ); pr1.s3 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr1.s4 = F1( left[2], left[3] ); pr1.s5 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr1.s6 = F1( left[1], left[2] ); pr1.s7 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr2.s0 = F1( left[5], left[6] ); pr2.s1 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr2.s2 = F1( left[4], left[5] ); pr2.s3 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr2.s4 = F1( left[3], left[4] ); pr2.s5 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr2.s6 = F1( left[2], left[3] ); pr2.s7 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr3.s0 = F1( left[6], left[7] ); pr3.s1 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr3.s2 = F1( left[5], left[6] ); pr3.s3 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr3.s4 = F1( left[4], left[5] ); pr3.s5 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr3.s6 = F1( left[3], left[4] ); pr3.s7 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_vl( const local pixel *src, int src_stride, const local pixel *top )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = F1( top[0], top[1] );\npr1.s0 = F2( top[0], top[1], top[2] );\npr2.s0 = pr0.s1 = F1( top[1], top[2] );\npr3.s0 = pr1.s1 = F2( top[1], top[2], top[3] );\npr2.s1 = pr0.s2 = F1( top[2], top[3] );\npr3.s1 = pr1.s2 = F2( top[2], top[3], top[4] );\npr2.s2 = pr0.s3 = F1( top[3], top[4] );\npr3.s2 = pr1.s3 = F2( top[3], top[4], top[5] );\npr2.s3 = pr0.s4 = F1( top[4], top[5] );\npr3.s3 = pr1.s4 = F2( top[4], top[5], top[6] );\npr2.s4 = pr0.s5 = F1( top[5], top[6] );\npr3.s4 = pr1.s5 = F2( top[5], top[6], top[7] );\npr2.s5 = pr0.s6 = F1( top[6], top[7] );\npr3.s5 = pr1.s6 = F2( top[6], top[7], top[8] );\npr2.s6 = pr0.s7 = F1( top[7], top[8] );\npr3.s6 = pr1.s7 = F2( top[7], top[8], top[9] );\npr2.s7 = F1( top[8], top[9] );\npr3.s7 = F2( top[8], top[9], top[10] );\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = F1( top[2], top[3] );\npr1.s0 = F2( top[2], top[3], top[4] );\npr2.s0 = pr0.s1 = F1( top[3], top[4] );\npr3.s0 = pr1.s1 = F2( top[3], top[4], top[5] );\npr2.s1 = pr0.s2 = F1( top[4], top[5] );\npr3.s1 = pr1.s2 = F2( top[4], top[5], top[6] );\npr2.s2 = pr0.s3 = F1( top[5], top[6] );\npr3.s2 = pr1.s3 = F2( top[5], top[6], top[7] );\npr2.s3 = pr0.s4 = F1( top[6], top[7] );\npr3.s3 = pr1.s4 = F2( top[6], top[7], top[8] );\npr2.s4 = pr0.s5 = F1( top[7], top[8] );\npr3.s4 = pr1.s5 = F2( top[7], top[8], top[9] );\npr2.s5 = pr0.s6 = F1( top[8], top[9] );\npr3.s5 = pr1.s6 = F2( top[8], top[9], top[10] );\npr2.s6 = pr0.s7 = F1( top[9], top[10] );\npr3.s6 = pr1.s7 = F2( top[9], top[10], top[11] );\npr2.s7 = F1( top[10], top[11] );\npr3.s7 = F2( top[10], top[11], top[12] );\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_hu( const local pixel *src, int src_stride, const local pixel *left )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = F1( left[0], left[1] ); pr0.s1 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr0.s2 = F1( left[1], left[2] ); pr0.s3 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr0.s4 = F1( left[2], left[3] ); pr0.s5 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr0.s6 = F1( left[3], left[4] ); pr0.s7 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr1.s0 = F1( left[1], left[2] ); pr1.s1 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr1.s2 = F1( left[2], left[3] ); pr1.s3 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr1.s4 = F1( left[3], left[4] ); pr1.s5 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr1.s6 = F1( left[4], left[5] ); pr1.s7 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr2.s0 = F1( left[2], left[3] ); pr2.s1 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr2.s2 = F1( left[3], left[4] ); pr2.s3 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr2.s4 = F1( left[4], left[5] ); pr2.s5 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr2.s6 = F1( left[5], left[6] ); pr2.s7 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr3.s0 = F1( left[3], left[4] ); pr3.s1 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr3.s2 = F1( left[4], left[5] ); pr3.s3 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr3.s4 = F1( left[5], left[6] ); pr3.s5 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr3.s6 = F1( left[6], left[7] ); pr3.s7 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = F1( left[4], left[5] ); pr0.s1 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr0.s2 = F1( left[5], left[6] ); pr0.s3 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr0.s4 = F1( left[6], left[7] ); pr0.s5 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\npr0.s6 = left[7]; pr0.s7 = left[7];\npr1.s0 = F1( left[5], left[6] ); pr1.s1 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr1.s2 = F1( left[6], left[7] ); pr1.s3 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\npr1.s4 = left[7]; pr1.s5 = left[7];\npr1.s6 = left[7]; pr1.s7 = left[7];\npr2.s0 = F1( left[6], left[7] ); pr2.s1 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\npr2.s2 = left[7]; pr2.s3 = left[7];\npr2.s4 = left[7]; pr2.s5 = left[7];\npr2.s6 = left[7]; pr2.s7 = left[7];\npr3 = (int8)left[7];\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8c_h( const local pixel *src, int src_stride )\n{\nconst local pixel *src_l = src;\nint8 pr0, pr1, pr2, pr3;\npr0 = (int8)src[-1]; src += src_stride;\npr1 = (int8)src[-1]; src += src_stride;\npr2 = (int8)src[-1]; src += src_stride;\npr3 = (int8)src[-1]; src += src_stride;\nint satd = satd_8x4_intra_lr( src_l, src_stride, pr0, pr1, pr2, pr3 );\npr0 = (int8)src[-1]; src += src_stride;\npr1 = (int8)src[-1]; src += src_stride;\npr2 = (int8)src[-1]; src += src_stride;\npr3 = (int8)src[-1];\nreturn satd + satd_8x4_intra_lr( src_l + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8c_v( const local pixel *src, int src_stride )\n{\nint8 pred = convert_int8( vload8( 0, &src[-src_stride] ));\nreturn satd_8x4_intra_lr( src, src_stride, pred, pred, pred, pred ) +\nsatd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pred, pred, pred, pred );\n}\nint x264_predict_8x8c_p( const local pixel *src, int src_stride )\n{\nint H = 0, V = 0;\nfor( int i = 0; i < 4; i++ )\n{\nH += (i + 1) * (src[4 + i - src_stride] - src[2 - i - src_stride]);\nV += (i + 1) * (src[-1 + (i + 4) * src_stride] - src[-1 + (2 - i) * src_stride]);\n}\nint a = 16 * (src[-1 + 7 * src_stride] + src[7 - src_stride]);\nint b = (17 * H + 16) >> 5;\nint c = (17 * V + 16) >> 5;\nint i00 = a - 3 * b - 3 * c + 16;\nint pix = i00;\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr1.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr2.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr3.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npix = i00;\npr0.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr1.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr2.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr3.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8c_dc( const local pixel *src, int src_stride )\n{\nint s0 = 0, s1 = 0, s2 = 0, s3 = 0;\nfor( int i = 0; i < 4; i++ )\n{\ns0 += src[i - src_stride];\ns1 += src[i + 4 - src_stride];\ns2 += src[-1 + i * src_stride];\ns3 += src[-1 + (i+4)*src_stride];\n}\nint8 dc0;\ndc0.lo = (int4)( (s0 + s2 + 4) >> 3 );\ndc0.hi = (int4)( (s1 + 2) >> 2 );\nint satd = satd_8x4_intra_lr( src, src_stride, dc0, dc0, dc0, dc0 );\ndc0.lo = (int4)( (s3 + 2) >> 2 );\ndc0.hi = (int4)( (s1 + s3 + 4) >> 3 );\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, dc0, dc0, dc0, dc0 );\n}\n#else  /* not vectorized: private is cheap registers are scarce */\nint x264_predict_8x8_ddl( const local pixel *src, int src_stride, const local pixel *top )\n{\nprivate pixel pred[32];\nfor( int y = 0; y < 4; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\npixel x_plus_y = (pixel) clamp_int( x + y, 0, 13 );\npred[x + y*8] = ( 2 + top[x_plus_y] + 2*top[x_plus_y + 1] + top[x_plus_y + 2] ) >> 2;\n}\n}\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\nfor( int y = 4; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\npixel x_plus_y = (pixel) clamp_int( x + y, 0, 13 );\npred[x + ( y - 4 )*8] = ( 2 + top[x_plus_y] + 2*top[x_plus_y + 1] + top[x_plus_y + 2] ) >> 2;\n}\n}\npred[31] = ( 2 + top[14] + 3*top[15] ) >> 2;\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8_ddr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nprivate pixel pred[32];\n#define PRED( x, y ) pred[(x) + (y)*8]\nPRED( 0, 3 ) = F2( left[1], left[2], left[3] );\nPRED( 0, 2 ) = PRED( 1, 3 ) = F2( left[0], left[1], left[2] );\nPRED( 0, 1 ) = PRED( 1, 2 ) = PRED( 2, 3 ) = F2( left[1], left[0], left_top );\nPRED( 0, 0 ) = PRED( 1, 1 ) = PRED( 2, 2 ) = PRED( 3, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 1, 0 ) = PRED( 2, 1 ) = PRED( 3, 2 ) = PRED( 4, 3 ) = F2( left_top, top[0], top[1] );\nPRED( 2, 0 ) = PRED( 3, 1 ) = PRED( 4, 2 ) = PRED( 5, 3 ) = F2( top[0], top[1], top[2] );\nPRED( 3, 0 ) = PRED( 4, 1 ) = PRED( 5, 2 ) = PRED( 6, 3 ) = F2( top[1], top[2], top[3] );\nPRED( 4, 0 ) = PRED( 5, 1 ) = PRED( 6, 2 ) = PRED( 7, 3 ) = F2( top[2], top[3], top[4] );\nPRED( 5, 0 ) = PRED( 6, 1 ) = PRED( 7, 2 ) = F2( top[3], top[4], top[5] );\nPRED( 6, 0 ) = PRED( 7, 1 ) = F2( top[4], top[5], top[6] );\nPRED( 7, 0 ) = F2( top[5], top[6], top[7] );\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\nPRED( 0, 3 ) = F2( left[5], left[6], left[7] );\nPRED( 0, 2 ) = PRED( 1, 3 ) = F2( left[4], left[5], left[6] );\nPRED( 0, 1 ) = PRED( 1, 2 ) = PRED( 2, 3 ) = F2( left[3], left[4], left[5] );\nPRED( 0, 0 ) = PRED( 1, 1 ) = PRED( 2, 2 ) = PRED( 3, 3 ) = F2( left[2], left[3], left[4] );\nPRED( 1, 0 ) = PRED( 2, 1 ) = PRED( 3, 2 ) = PRED( 4, 3 ) = F2( left[1], left[2], left[3] );\nPRED( 2, 0 ) = PRED( 3, 1 ) = PRED( 4, 2 ) = PRED( 5, 3 ) = F2( left[0], left[1], left[2] );\nPRED( 3, 0 ) = PRED( 4, 1 ) = PRED( 5, 2 ) = PRED( 6, 3 ) = F2( left[1], left[0], left_top );\nPRED( 4, 0 ) = PRED( 5, 1 ) = PRED( 6, 2 ) = PRED( 7, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 5, 0 ) = PRED( 6, 1 ) = PRED( 7, 2 ) = F2( left_top, top[0], top[1] );\nPRED( 6, 0 ) = PRED( 7, 1 ) = F2( top[0], top[1], top[2] );\nPRED( 7, 0 ) = F2( top[1], top[2], top[3] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n#undef PRED\n}\nint x264_predict_8x8_vr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nprivate pixel pred[32];\n#define PRED( x, y ) pred[(x) + (y)*8]\nPRED( 0, 2 ) = F2( left[1], left[0], left_top );\nPRED( 0, 3 ) = F2( left[2], left[1], left[0] );\nPRED( 0, 1 ) = PRED( 1, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 0, 0 ) = PRED( 1, 2 ) = F1( left_top, top[0] );\nPRED( 1, 1 ) = PRED( 2, 3 ) = F2( left_top, top[0], top[1] );\nPRED( 1, 0 ) = PRED( 2, 2 ) = F1( top[0], top[1] );\nPRED( 2, 1 ) = PRED( 3, 3 ) = F2( top[0], top[1], top[2] );\nPRED( 2, 0 ) = PRED( 3, 2 ) = F1( top[1], top[2] );\nPRED( 3, 1 ) = PRED( 4, 3 ) = F2( top[1], top[2], top[3] );\nPRED( 3, 0 ) = PRED( 4, 2 ) = F1( top[2], top[3] );\nPRED( 4, 1 ) = PRED( 5, 3 ) = F2( top[2], top[3], top[4] );\nPRED( 4, 0 ) = PRED( 5, 2 ) = F1( top[3], top[4] );\nPRED( 5, 1 ) = PRED( 6, 3 ) = F2( top[3], top[4], top[5] );\nPRED( 5, 0 ) = PRED( 6, 2 ) = F1( top[4], top[5] );\nPRED( 6, 1 ) = PRED( 7, 3 ) = F2( top[4], top[5], top[6] );\nPRED( 6, 0 ) = PRED( 7, 2 ) = F1( top[5], top[6] );\nPRED( 7, 1 ) = F2( top[5], top[6], top[7] );\nPRED( 7, 0 ) = F1( top[6], top[7] );\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\nPRED( 0, 2 ) = F2( left[5], left[4], left[3] );\nPRED( 0, 3 ) = F2( left[6], left[5], left[4] );\nPRED( 0, 0 ) = PRED( 1, 2 ) = F2( left[3], left[2], left[1] );\nPRED( 0, 1 ) = PRED( 1, 3 ) = F2( left[4], left[3], left[2] );\nPRED( 1, 0 ) = PRED( 2, 2 ) = F2( left[1], left[0], left_top );\nPRED( 1, 1 ) = PRED( 2, 3 ) = F2( left[2], left[1], left[0] );\nPRED( 2, 1 ) = PRED( 3, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 2, 0 ) = PRED( 3, 2 ) = F1( left_top, top[0] );\nPRED( 3, 1 ) = PRED( 4, 3 ) = F2( left_top, top[0], top[1] );\nPRED( 3, 0 ) = PRED( 4, 2 ) = F1( top[0], top[1] );\nPRED( 4, 1 ) = PRED( 5, 3 ) = F2( top[0], top[1], top[2] );\nPRED( 4, 0 ) = PRED( 5, 2 ) = F1( top[1], top[2] );\nPRED( 5, 1 ) = PRED( 6, 3 ) = F2( top[1], top[2], top[3] );\nPRED( 5, 0 ) = PRED( 6, 2 ) = F1( top[2], top[3] );\nPRED( 6, 1 ) = PRED( 7, 3 ) = F2( top[2], top[3], top[4] );\nPRED( 6, 0 ) = PRED( 7, 2 ) = F1( top[3], top[4] );\nPRED( 7, 1 ) = F2( top[3], top[4], top[5] );\nPRED( 7, 0 ) = F1( top[4], top[5] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n#undef PRED\n}\ninline uint32_t pack16to32( uint32_t a, uint32_t b )\n{\nreturn a + (b << 16);\n}\ninline uint32_t pack8to16( uint32_t a, uint32_t b )\n{\nreturn a + (b << 8);\n}\nint x264_predict_8x8_hd( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nprivate pixel pred[32];\nint satd;\nint p1 =  pack8to16( (F1( left[6], left[7] )), ((left[5] + 2 * left[6] + left[7] + 2) >> 2) );\nint p2 =  pack8to16( (F1( left[5], left[6] )), ((left[4] + 2 * left[5] + left[6] + 2) >> 2) );\nint p3 =  pack8to16( (F1( left[4], left[5] )), ((left[3] + 2 * left[4] + left[5] + 2) >> 2) );\nint p4 =  pack8to16( (F1( left[3], left[4] )), ((left[2] + 2 * left[3] + left[4] + 2) >> 2) );\nint p5 =  pack8to16( (F1( left[2], left[3] )), ((left[1] + 2 * left[2] + left[3] + 2) >> 2) );\nint p6 =  pack8to16( (F1( left[1], left[2] )), ((left[0] + 2 * left[1] + left[2] + 2) >> 2) );\nint p7 =  pack8to16( (F1( left[0], left[1] )), ((left_top + 2 * left[0] + left[1] + 2) >> 2) );\nint p8 =  pack8to16( (F1( left_top, left[0] )), ((left[0] + 2 * left_top + top[0] + 2) >> 2) );\nint p9 =  pack8to16( (F2( top[1], top[0], left_top )), (F2( top[2], top[1], top[0] )) );\nint p10 =  pack8to16( (F2( top[3], top[2], top[1] )), (F2( top[4], top[3], top[2] )) );\nint p11 =  pack8to16( (F2( top[5], top[4], top[3] )), (F2( top[6], top[5], top[4] )) );\nvstore4( as_uchar4( pack16to32( p8, p9 ) ), 0, &pred[0 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p10, p11 ) ), 0, &pred[4 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[0 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p9, p10 ) ), 0, &pred[4 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[0 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p8, p9 ) ), 0, &pred[4 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[0 + 3 * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[4 + 3 * 8] );\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[0 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[4 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[0 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[4 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p2, p3 ) ), 0, &pred[0 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[4 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p1, p2 ) ), 0, &pred[0 + 3 * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[4 + 3 * 8] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8_vl( const local pixel *src, int src_stride, const local pixel *top )\n{\nprivate pixel pred[32];\nint satd;\n#define PRED( x, y ) pred[(x) + (y)*8]\nPRED( 0, 0 ) = F1( top[0], top[1] );\nPRED( 0, 1 ) = F2( top[0], top[1], top[2] );\nPRED( 0, 2 ) = PRED( 1, 0 ) = F1( top[1], top[2] );\nPRED( 0, 3 ) = PRED( 1, 1 ) = F2( top[1], top[2], top[3] );\nPRED( 1, 2 ) = PRED( 2, 0 ) = F1( top[2], top[3] );\nPRED( 1, 3 ) = PRED( 2, 1 ) = F2( top[2], top[3], top[4] );\nPRED( 2, 2 ) = PRED( 3, 0 ) = F1( top[3], top[4] );\nPRED( 2, 3 ) = PRED( 3, 1 ) = F2( top[3], top[4], top[5] );\nPRED( 3, 2 ) = PRED( 4, 0 ) = F1( top[4], top[5] );\nPRED( 3, 3 ) = PRED( 4, 1 ) = F2( top[4], top[5], top[6] );\nPRED( 4, 2 ) = PRED( 5, 0 ) = F1( top[5], top[6] );\nPRED( 4, 3 ) = PRED( 5, 1 ) = F2( top[5], top[6], top[7] );\nPRED( 5, 2 ) = PRED( 6, 0 ) = F1( top[6], top[7] );\nPRED( 5, 3 ) = PRED( 6, 1 ) = F2( top[6], top[7], top[8] );\nPRED( 6, 2 ) = PRED( 7, 0 ) = F1( top[7], top[8] );\nPRED( 6, 3 ) = PRED( 7, 1 ) = F2( top[7], top[8], top[9] );\nPRED( 7, 2 ) = F1( top[8], top[9] );\nPRED( 7, 3 ) = F2( top[8], top[9], top[10] );\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nPRED( 0, 0 ) = F1( top[2], top[3] );\nPRED( 0, 1 ) = F2( top[2], top[3], top[4] );\nPRED( 0, 2 ) = PRED( 1, 0 ) = F1( top[3], top[4] );\nPRED( 0, 3 ) = PRED( 1, 1 ) = F2( top[3], top[4], top[5] );\nPRED( 1, 2 ) = PRED( 2, 0 ) = F1( top[4], top[5] );\nPRED( 1, 3 ) = PRED( 2, 1 ) = F2( top[4], top[5], top[6] );\nPRED( 2, 2 ) = PRED( 3, 0 ) = F1( top[5], top[6] );\nPRED( 2, 3 ) = PRED( 3, 1 ) = F2( top[5], top[6], top[7] );\nPRED( 3, 2 ) = PRED( 4, 0 ) = F1( top[6], top[7] );\nPRED( 3, 3 ) = PRED( 4, 1 ) = F2( top[6], top[7], top[8] );\nPRED( 4, 2 ) = PRED( 5, 0 ) = F1( top[7], top[8] );\nPRED( 4, 3 ) = PRED( 5, 1 ) = F2( top[7], top[8], top[9] );\nPRED( 5, 2 ) = PRED( 6, 0 ) = F1( top[8], top[9] );\nPRED( 5, 3 ) = PRED( 6, 1 ) = F2( top[8], top[9], top[10] );\nPRED( 6, 2 ) = PRED( 7, 0 ) = F1( top[9], top[10] );\nPRED( 6, 3 ) = PRED( 7, 1 ) = F2( top[9], top[10], top[11] );\nPRED( 7, 2 ) = F1( top[10], top[11] );\nPRED( 7, 3 ) = F2( top[10], top[11], top[12] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n#undef PRED\n}\nint x264_predict_8x8_hu( const local pixel *src, int src_stride, const local pixel *left )\n{\nprivate pixel pred[32];\nint satd;\nint p1 = pack8to16( (F1( left[0], left[1] )), ((left[0] + 2 * left[1] + left[2] + 2) >> 2) );\nint p2 = pack8to16( (F1( left[1], left[2] )), ((left[1] + 2 * left[2] + left[3] + 2) >> 2) );\nint p3 = pack8to16( (F1( left[2], left[3] )), ((left[2] + 2 * left[3] + left[4] + 2) >> 2) );\nint p4 = pack8to16( (F1( left[3], left[4] )), ((left[3] + 2 * left[4] + left[5] + 2) >> 2) );\nint p5 = pack8to16( (F1( left[4], left[5] )), ((left[4] + 2 * left[5] + left[6] + 2) >> 2) );\nint p6 = pack8to16( (F1( left[5], left[6] )), ((left[5] + 2 * left[6] + left[7] + 2) >> 2) );\nint p7 = pack8to16( (F1( left[6], left[7] )), ((left[6] + 2 * left[7] + left[7] + 2) >> 2) );\nint p8 = pack8to16( left[7], left[7] );\nvstore4( as_uchar4( pack16to32( p1, p2 ) ), 0, &pred[( 0 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[( 4 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p2, p3 ) ), 0, &pred[( 0 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[( 4 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[( 0 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[( 4 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[( 0 ) + ( 3 ) * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[( 4 ) + ( 3 ) * 8] );\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[( 0 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[( 4 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[( 0 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 4 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[( 0 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 4 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 0 ) + ( 3 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 4 ) + ( 3 ) * 8] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8c_h( const local pixel *src, int src_stride )\n{\nprivate pixel pred[32];\nconst local pixel *src_l = src;\nvstore8( (uchar8)(src[-1]), 0, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 1, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 2, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 3, pred ); src += src_stride;\nint satd = satd_8x4_lp( src_l, src_stride, pred, 8 );\nvstore8( (uchar8)(src[-1]), 0, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 1, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 2, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 3, pred );\nreturn satd + satd_8x4_lp( src_l + ( src_stride << 2 ), src_stride, pred, 8 );\n}\nint x264_predict_8x8c_v( const local pixel *src, int src_stride )\n{\nprivate pixel pred[32];\nuchar16 v16;\nv16.lo = vload8( 0, &src[-src_stride] );\nv16.hi = vload8( 0, &src[-src_stride] );\nvstore16( v16, 0, pred );\nvstore16( v16, 1, pred );\nreturn satd_8x4_lp( src, src_stride, pred, 8 ) +\nsatd_8x4_lp( src + (src_stride << 2), src_stride, pred, 8 );\n}\nint x264_predict_8x8c_p( const local pixel *src, int src_stride )\n{\nint H = 0, V = 0;\nprivate pixel pred[32];\nint satd;\nfor( int i = 0; i < 4; i++ )\n{\nH += (i + 1) * (src[4 + i - src_stride] - src[2 - i - src_stride]);\nV += (i + 1) * (src[-1 + (i + 4) * src_stride] - src[-1 + (2 - i) * src_stride]);\n}\nint a = 16 * (src[-1 + 7 * src_stride] + src[7 - src_stride]);\nint b = (17 * H + 16) >> 5;\nint c = (17 * V + 16) >> 5;\nint i00 = a - 3 * b - 3 * c + 16;\nfor( int y = 0; y < 4; y++ )\n{\nint pix = i00;\nfor( int x = 0; x < 8; x++ )\n{\npred[x + y*8] = x264_clip_pixel( pix >> 5 );\npix += b;\n}\ni00 += c;\n}\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nfor( int y = 0; y < 4; y++ )\n{\nint pix = i00;\nfor( int x = 0; x < 8; x++ )\n{\npred[x + y*8] = x264_clip_pixel( pix >> 5 );\npix += b;\n}\ni00 += c;\n}\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8c_dc( const local pixel *src, int src_stride )\n{\nprivate pixel pred[32];\nint s0 = 0, s1 = 0, s2 = 0, s3 = 0;\nfor( int i = 0; i < 4; i++ )\n{\ns0 += src[i - src_stride];\ns1 += src[i + 4 - src_stride];\ns2 += src[-1 + i * src_stride];\ns3 += src[-1 + (i+4)*src_stride];\n}\nuchar8 dc0;\ndc0.lo = (uchar4)( (s0 + s2 + 4) >> 3 );\ndc0.hi = (uchar4)( (s1 + 2) >> 2 );\nvstore8( dc0, 0, pred );\nvstore8( dc0, 1, pred );\nvstore8( dc0, 2, pred );\nvstore8( dc0, 3, pred );\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\ndc0.lo = (uchar4)( (s3 + 2) >> 2 );\ndc0.hi = (uchar4)( (s1 + s3 + 4) >> 3 );\nvstore8( dc0, 0, pred );\nvstore8( dc0, 1, pred );\nvstore8( dc0, 2, pred );\nvstore8( dc0, 3, pred );\nreturn satd + satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\n}\n#endif\n/* Find the least cost intra mode for 32 8x8 macroblocks per workgroup\n*\n* Loads 33 macroblocks plus the pixels directly above them into local memory,\n* padding where necessary with edge pixels.  It then cooperatively calculates\n* smoothed top and left pixels for use in some of the analysis.\n*\n* Then groups of 32 threads each calculate a single intra mode for each 8x8\n* block.  Since consecutive threads are calculating the same intra mode there\n* is no code-path divergence.  8 intra costs are calculated simultaneously.  If\n* the \"slow\" argument is not zero, the final two (least likely) intra modes are\n* tested in a second pass.  The slow mode is only enabled for presets slow,\n* slower, and placebo.\n*\n* This allows all of the pixels functions to read pixels from local memory, and\n* avoids re-fetching edge pixels from global memory.  And it allows us to\n* calculate all of the intra mode costs simultaneously without branch divergence.\n*\n* Local dimension:    [ 32, 8 ]\n* Global dimensions:  [ paddedWidth, height ] */\nkernel void mb_intra_cost_satd_8x8( read_only image2d_t  fenc,\nglobal uint16_t     *fenc_intra_cost,\nglobal int          *frame_stats,\nint                  lambda,\nint                  mb_width,\nint                  slow )\n{\n#define CACHE_STRIDE 265\n#define BLOCK_OFFSET 266\nlocal pixel cache[2385];\nlocal int cost_buf[32];\nlocal pixel top[32 * 16];\nlocal pixel left[32 * 8];\nlocal pixel left_top[32];\nint lx = get_local_id( 0 );\nint ly = get_local_id( 1 );\nint gx = get_global_id( 0 );\nint gy = get_global_id( 1 );\nint gidx = get_group_id( 0 );\nint gidy = get_group_id( 1 );\nint linear_id = ly * get_local_size( 0 ) + lx;\nint satd = COST_MAX;\nint basex = gidx << 8;\nint basey = (gidy << 3) - 1;\n/* Load 33 8x8 macroblocks and the pixels above them into local cache */\nfor( int y = 0; y < 9 && linear_id < (33<<3)>>2; y++ )\n{\nint x = linear_id << 2;\nuint4 data = read_imageui( fenc, sampler, (int2)(x + basex, y + basey) );\ncache[y * CACHE_STRIDE + 1 + x] = data.s0;\ncache[y * CACHE_STRIDE + 1 + x + 1] = data.s1;\ncache[y * CACHE_STRIDE + 1 + x + 2] = data.s2;\ncache[y * CACHE_STRIDE + 1 + x + 3] = data.s3;\n}\n/* load pixels on left edge */\nif( linear_id < 9 )\ncache[linear_id * CACHE_STRIDE] = read_imageui( fenc, sampler, (int2)( basex - 1, linear_id + basey) ).s0;\nbarrier( CLK_LOCAL_MEM_FENCE );\nint j = ly;\ntop[lx*16 + j] = ( cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j - 1, -1, 15 )] +\n2*cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j, 0, 15 )] +\ncache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j + 1, 0, 15 )] + 2 ) >> 2;\nj += 8;\ntop[lx*16 + j] = ( cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j - 1, -1, 15 )] +\n2*cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j, 0, 15 )] +\ncache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j + 1, 0, 15 )] + 2 ) >> 2;\nleft[lx*8 + ly] = ( cache[BLOCK_OFFSET + 8*lx - 1 + CACHE_STRIDE*(ly - 1)] +\n2*cache[BLOCK_OFFSET + 8*lx - 1 + CACHE_STRIDE*ly] +\ncache[BLOCK_OFFSET + 8*lx - 1 + CACHE_STRIDE*clamp((ly + 1), 0, 7 )] + 2 ) >> 2;\nif( 0 == ly )\n{\nleft_top[lx] = ( cache[BLOCK_OFFSET + 8*lx - 1] + 2*cache[BLOCK_OFFSET + 8*lx - 1 - CACHE_STRIDE] +\ncache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE] + 2 ) >> 2;\ncost_buf[lx] = COST_MAX;\n}\nbarrier( CLK_LOCAL_MEM_FENCE );\nswitch( ly )\n{\ncase 0:\nsatd = x264_predict_8x8c_h( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 1:\nsatd = x264_predict_8x8c_v( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 2:\nsatd = x264_predict_8x8c_dc( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 3:\nsatd = x264_predict_8x8c_p( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 4:\nsatd = x264_predict_8x8_ddr( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx], &left[8*lx], left_top[lx] );\nbreak;\ncase 5:\nsatd = x264_predict_8x8_vr( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx], &left[8*lx], left_top[lx] );\nbreak;\ncase 6:\nsatd = x264_predict_8x8_hd( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx], &left[8*lx], left_top[lx] );\nbreak;\ncase 7:\nsatd = x264_predict_8x8_hu( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &left[8*lx] );\nbreak;\ndefault:\nbreak;\n}\natom_min( &cost_buf[lx], satd );\nif( slow )\n{\nswitch( ly )\n{\ncase 0: // DDL\nsatd = x264_predict_8x8_ddl( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx] );\natom_min( &cost_buf[lx], satd );\nbreak;\ncase 1: // VL\nsatd = x264_predict_8x8_vl( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx] );\natom_min( &cost_buf[lx], satd );\nbreak;\ndefault:\nbreak;\n}\n}\nbarrier( CLK_LOCAL_MEM_FENCE );\nif( (0 == ly) && (gx < mb_width) )\nfenc_intra_cost[gidy * mb_width + gx] = cost_buf[lx]+ 5*lambda;\nif( gx < 2 && gy == 0 )\nframe_stats[gx] = 0;\n#undef CACHE_STRIDE\n#undef BLOCK_OFFSET\n}\n/*\n* parallel sum intra costs\n*\n* global launch dimensions: [256, mb_height]\n*/\nkernel void sum_intra_cost( const global uint16_t *fenc_intra_cost,\nconst global uint16_t *inv_qscale_factor,\nglobal int           *fenc_row_satds,\nglobal int           *frame_stats,\nint                   mb_width )\n{\nint y = get_global_id( 1 );\nint mb_height = get_global_size( 1 );\nint row_satds = 0;\nint cost_est = 0;\nint cost_est_aq = 0;\nfor( int x = get_global_id( 0 ); x < mb_width; x += get_global_size( 0 ))\n{\nint mb_xy = x + y * mb_width;\nint cost = fenc_intra_cost[mb_xy];\nint cost_aq = (cost * inv_qscale_factor[mb_xy] + 128) >> 8;\nint b_frame_score_mb = (x > 0 && x < mb_width - 1 && y > 0 && y < mb_height - 1) || mb_width <= 2 || mb_height <= 2;\nrow_satds += cost_aq;\nif( b_frame_score_mb )\n{\ncost_est += cost;\ncost_est_aq += cost_aq;\n}\n}\nlocal int buffer[256];\nint x = get_global_id( 0 );\nrow_satds   = parallel_sum( row_satds, x, buffer );\ncost_est    = parallel_sum( cost_est, x, buffer );\ncost_est_aq = parallel_sum( cost_est_aq, x, buffer );\nif( get_global_id( 0 ) == 0 )\n{\nfenc_row_satds[y] = row_satds;\natomic_add( frame_stats + COST_EST,    cost_est );\natomic_add( frame_stats + COST_EST_AQ, cost_est_aq );\n}\n}\n/* Hierarchical (iterative) OpenCL lowres motion search */\ninline int find_downscale_mb_xy( int x, int y, int mb_width, int mb_height )\n{\n/* edge macroblocks might not have a direct descendant, use nearest */\nx = select( x >> 1, (x - (mb_width&1)) >> 1, x == mb_width-1 );\ny = select( y >> 1, (y - (mb_height&1)) >> 1, y == mb_height-1 );\nreturn (mb_width>>1) * y + x;\n}\n/* Four threads calculate an 8x8 SAD.  Each does two rows */\nint sad_8x8_ii_coop4( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref, int2 frefpos, int idx, local int16_t *costs )\n{\nfrefpos.y += idx << 1;\nfencpos.y += idx << 1;\nint cost = 0;\nif( frefpos.x < 0 )\n{\n/* slow path when MV goes past left edge.  The GPU clamps reads from\n* (-1, 0) to (0,0), so you get pixels [0, 1, 2, 3] when what you really\n* want are [0, 0, 1, 2]\n*/\nfor( int y = 0; y < 2; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\npixel enc = read_imageui( fenc, sampler, fencpos + (int2)(x, y) ).s0;\npixel ref = read_imageui( fref, sampler, frefpos + (int2)(x, y) ).s0;\ncost += abs_diff( enc, ref );\n}\n}\n}\nelse\n{\nuint4 enc, ref, costs = 0;\nenc = read_imageui( fenc, sampler, fencpos );\nref = read_imageui( fref, sampler, frefpos );\ncosts += abs_diff( enc, ref );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(4, 0) );\nref = read_imageui( fref, sampler, frefpos + (int2)(4, 0) );\ncosts += abs_diff( enc, ref );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(0, 1) );\nref = read_imageui( fref, sampler, frefpos + (int2)(0, 1) );\ncosts += abs_diff( enc, ref );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(4, 1) );\nref = read_imageui( fref, sampler, frefpos + (int2)(4, 1) );\ncosts += abs_diff( enc, ref );\ncost = costs.s0 + costs.s1 + costs.s2 + costs.s3;\n}\ncosts[idx] = cost;\nreturn costs[0] + costs[1] + costs[2] + costs[3];\n}\n/* One thread performs 8x8 SAD */\nint sad_8x8_ii( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref, int2 frefpos )\n{\nif( frefpos.x < 0 )\n{\n/* slow path when MV goes past left edge */\nint cost = 0;\nfor( int y = 0; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\nuint enc = read_imageui( fenc, sampler, fencpos + (int2)(x, y) ).s0;\nuint ref = read_imageui( fref, sampler, frefpos + (int2)(x, y) ).s0;\ncost += abs_diff( enc, ref );\n}\n}\nreturn cost;\n}\nelse\n{\nuint4 enc, ref, cost = 0;\nfor( int y = 0; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x += 4 )\n{\nenc = read_imageui( fenc, sampler, fencpos + (int2)(x, y) );\nref = read_imageui( fref, sampler, frefpos + (int2)(x, y) );\ncost += abs_diff( enc, ref );\n}\n}\nreturn cost.s0 + cost.s1 + cost.s2 + cost.s3;\n}\n}\n/*\n* hierarchical motion estimation\n*\n* Each kernel launch is a single iteration\n*\n* MB per work group is determined by lclx / 4 * lcly\n*\n* global launch dimensions:  [mb_width * 4, mb_height]\n*/\nkernel void hierarchical_motion( read_only image2d_t  fenc,\nread_only image2d_t  fref,\nconst global short2 *in_mvs,\nglobal short2       *out_mvs,\nglobal int16_t      *out_mv_costs,\nglobal short2       *mvp_buffer,\nlocal int16_t       *cost_local,\nlocal short2        *mvc_local,\nint                  mb_width,\nint                  lambda,\nint                  me_range,\nint                  scale,\nint                  b_shift_index,\nint                  b_first_iteration,\nint                  b_reverse_references )\n{\nint mb_x = get_global_id( 0 ) >> 2;\nif( mb_x >= mb_width )\nreturn;\nint mb_height = get_global_size( 1 );\nint mb_i = get_global_id( 0 ) & 3;\nint mb_y = get_global_id( 1 );\nint mb_xy = mb_y * mb_width + mb_x;\nconst int mb_size = 8;\nint2 coord = (int2)(mb_x, mb_y) * mb_size;\nconst int mb_in_group = get_local_id( 1 ) * (get_local_size( 0 ) >> 2) + (get_local_id( 0 ) >> 2);\ncost_local += 4 * mb_in_group;\nint i_mvc = 0;\nmvc_local += 4 * mb_in_group;\nmvc_local[mb_i] = 0;\nint2 mvp =0;\nif( !b_first_iteration )\n{\n#define MVC( DX, DY )\\\n{\\\nint px = mb_x + DX;\\\nint py = mb_y + DY;\\\nmvc_local[i_mvc] = b_shift_index ? in_mvs[find_downscale_mb_xy( px, py, mb_width, mb_height )] : \\\nin_mvs[mb_width * py + px];\\\nmvc_local[i_mvc] >>= (short) scale;\\\ni_mvc++;\\\n}\n/* Find MVP from median of MVCs */\nif( b_reverse_references )\n{\n/* odd iterations: derive MVP from down and right */\nif( mb_x < mb_width - 1 )\nMVC( 1, 0 );\nif( mb_y < mb_height - 1 )\n{\nMVC( 0, 1 );\nif( mb_x > b_shift_index )\nMVC( -1, 1 );\nif( mb_x < mb_width - 1 )\nMVC( 1, 1 );\n}\n}\nelse\n{\n/* even iterations: derive MVP from up and left */\nif( mb_x > 0 )\nMVC( -1, 0 );\nif( mb_y > 0 )\n{\nMVC( 0, -1 );\nif( mb_x < mb_width - 1 )\nMVC( 1, -1 );\nif( mb_x > b_shift_index )\nMVC( -1, -1 );\n}\n}\n#undef MVC\nmvp = (i_mvc <= 1) ? convert_int2_sat(mvc_local[0]) : x264_median_mv( mvc_local[0], mvc_local[1], mvc_local[2] );\n}\n/* current mvp matches the previous mvp and we have not changed scale.  We know\n* we're going to arrive at the same MV again, so just copy the previous\n* result to our output. */\nif( !b_shift_index && mvp.x == mvp_buffer[mb_xy].x && mvp.y == mvp_buffer[mb_xy].y )\n{\nout_mvs[mb_xy] = in_mvs[mb_xy];\nreturn;\n}\nmvp_buffer[mb_xy] = convert_short2_sat(mvp);\nint2 mv_min = -mb_size * (int2)(mb_x, mb_y) - 4;\nint2 mv_max = mb_size * ((int2)(mb_width, mb_height) - (int2)(mb_x, mb_y) - 1) + 4;\nint2 bestmv = clamp(mvp, mv_min, mv_max);\nint2 refcrd = coord + bestmv;\n/* measure cost at bestmv */\nint bcost = sad_8x8_ii_coop4( fenc, coord, fref, refcrd, mb_i, cost_local ) +\nlambda * mv_cost( abs_diff( bestmv, mvp ) << (2 + scale) );\ndo\n{\n/* measure costs at offsets from bestmv */\nrefcrd = coord + bestmv + dia_offs[mb_i];\nint2 trymv = bestmv + dia_offs[mb_i];\nint cost = sad_8x8_ii( fenc, coord, fref, refcrd ) +\nlambda * mv_cost( abs_diff( trymv, mvp ) << (2 + scale) );\ncost_local[mb_i] = (cost<<2) | mb_i;\ncost = min( cost_local[0], min( cost_local[1], min( cost_local[2], cost_local[3] ) ) );\nif( (cost >> 2) >= bcost )\nbreak;\nbestmv += dia_offs[cost&3];\nbcost = cost>>2;\nif( bestmv.x >= mv_max.x || bestmv.x <= mv_min.x || bestmv.y >= mv_max.y || bestmv.y <= mv_min.y )\nbreak;\n}\nwhile( --me_range > 0 );\nint2 trymv = 0, diff = 0;\n#define COST_MV_NO_PAD( L )\\\ntrymv = clamp( trymv, mv_min, mv_max );\\\ndiff = convert_int2_sat(abs_diff( mvp, trymv ));\\\nif( diff.x > 1 || diff.y > 1 ) {\\\nint2 refcrd = coord + trymv;\\\nint cost = sad_8x8_ii_coop4( fenc, coord, fref, refcrd, mb_i, cost_local ) +\\\nL * mv_cost( abs_diff( trymv, mvp ) << (2 + scale) );\\\nif( cost < bcost ) { bcost = cost; bestmv = trymv; } }\nCOST_MV_NO_PAD( 0 );\nif( !b_first_iteration )\n{\n/* try cost at previous iteration's MV, if MVP was too far away */\nint2 prevmv = b_shift_index ? convert_int2_sat(in_mvs[find_downscale_mb_xy( mb_x, mb_y, mb_width, mb_height )]) : convert_int2_sat(in_mvs[mb_xy]);\nprevmv >>= scale;\ntrymv = prevmv;\nCOST_MV_NO_PAD( lambda );\n}\nfor( int i = 0; i < i_mvc; i++ )\n{\n/* try cost at each candidate MV, if MVP was too far away */\ntrymv = convert_int2_sat( mvc_local[i] );\nCOST_MV_NO_PAD( lambda );\n}\nif( mb_i == 0 )\n{\nbestmv <<= scale;\nout_mvs[mb_xy] = convert_short2_sat(bestmv);\nout_mv_costs[mb_xy] = min( bcost, LOWRES_COST_MASK );\n}\n}\n/* OpenCL lowres subpel Refine */\n/* Each thread performs 8x8 SAD.  4 threads per MB, so the 4 DIA HPEL offsets are\n* calculated simultaneously */\nint sad_8x8_ii_hpel( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref_planes, int2 qpos )\n{\nint2 frefpos = qpos >> 2;\nint hpel_idx = ((qpos.x & 2) >> 1) + (qpos.y & 2);\nuint mask_shift = 8 * hpel_idx;\nuint4 cost4 = 0;\nfor( int y = 0; y < 8; y++ )\n{\nuint4 enc, val4;\nenc = read_imageui( fenc, sampler, fencpos + (int2)(0, y));\nval4.s0 = (read_imageui( fref_planes, sampler, frefpos + (int2)(0, y)).s0 >> mask_shift) & 0xFF;\nval4.s1 = (read_imageui( fref_planes, sampler, frefpos + (int2)(1, y)).s0 >> mask_shift) & 0xFF;\nval4.s2 = (read_imageui( fref_planes, sampler, frefpos + (int2)(2, y)).s0 >> mask_shift) & 0xFF;\nval4.s3 = (read_imageui( fref_planes, sampler, frefpos + (int2)(3, y)).s0 >> mask_shift) & 0xFF;\ncost4 += abs_diff( enc, val4 );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(4, y));\nval4.s0 = (read_imageui( fref_planes, sampler, frefpos + (int2)(4, y)).s0 >> mask_shift) & 0xFF;\nval4.s1 = (read_imageui( fref_planes, sampler, frefpos + (int2)(5, y)).s0 >> mask_shift) & 0xFF;\nval4.s2 = (read_imageui( fref_planes, sampler, frefpos + (int2)(6, y)).s0 >> mask_shift) & 0xFF;\nval4.s3 = (read_imageui( fref_planes, sampler, frefpos + (int2)(7, y)).s0 >> mask_shift) & 0xFF;\ncost4 += abs_diff( enc, val4 );\n}\nreturn cost4.s0 + cost4.s1 + cost4.s2 + cost4.s3;\n}\n/* One thread measures 8x8 SAD cost at a QPEL offset into an HPEL plane */\nint sad_8x8_ii_qpel( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref_planes, int2 qpos )\n{\nint2 frefApos = qpos >> 2;\nint hpelA = ((qpos.x & 2) >> 1) + (qpos.y & 2);\nint2 qposB = qpos + ((qpos & 1) << 1);\nint2 frefBpos = qposB >> 2;\nint hpelB = ((qposB.x & 2) >> 1) + (qposB.y & 2);\nuint mask_shift0 = 8 * hpelA, mask_shift1 = 8 * hpelB;\nint cost = 0;\nfor( int y = 0; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\nuint enc = read_imageui( fenc, sampler, fencpos + (int2)(x, y)).s0;\nuint vA = (read_imageui( fref_planes, sampler, frefApos + (int2)(x, y)).s0 >> mask_shift0) & 0xFF;\nuint vB = (read_imageui( fref_planes, sampler, frefBpos + (int2)(x, y)).s0 >> mask_shift1) & 0xFF;\ncost += abs_diff( enc, rhadd( vA, vB ) );\n}\n}\nreturn cost;\n}\n/* Four threads measure 8x8 SATD cost at a QPEL offset into an HPEL plane\n*\n* Each thread collects 1/4 of the rows of diffs and processes one quarter of\n* the transforms\n*/\nint satd_8x8_ii_qpel_coop4( read_only image2d_t fenc,\nint2 fencpos,\nread_only image2d_t fref_planes,\nint2 qpos,\nlocal sum2_t *tmpp,\nint idx )\n{\nvolatile local sum2_t( *tmp )[4] = (volatile local sum2_t( * )[4])tmpp;\nsum2_t b0, b1, b2, b3;\nint2 frefApos = qpos >> 2;\nint hpelA = ((qpos.x&2)>>1) + (qpos.y&2);\nint2 qposB = qpos + (int2)(((qpos.x&1)<<1), ((qpos.y&1)<<1));\nint2 frefBpos = qposB >> 2;\nint hpelB = ((qposB.x&2)>>1) + (qposB.y&2);\nuint mask_shift0 = 8 * hpelA, mask_shift1 = 8 * hpelB;\nuint vA, vB;\nuint a0, a1;\nuint enc;\nsum2_t sum = 0;\n#define READ_DIFF( OUT, X )\\\nenc = read_imageui( fenc, sampler, fencpos + (int2)(X, idx) ).s0;\\\nvA = (read_imageui( fref_planes, sampler, frefApos + (int2)(X, idx) ).s0 >> mask_shift0) & 0xFF;\\\nvB = (read_imageui( fref_planes, sampler, frefBpos + (int2)(X, idx) ).s0 >> mask_shift1) & 0xFF;\\\nOUT = enc - rhadd( vA, vB );\n#define READ_DIFF_EX( OUT, a, b )\\\n{\\\nREAD_DIFF( a0, a );\\\nREAD_DIFF( a1, b );\\\nOUT = a0 + (a1<<BITS_PER_SUM);\\\n}\n#define ROW_8x4_SATD( a, b )\\\n{\\\nfencpos.y += a;\\\nfrefApos.y += b;\\\nfrefBpos.y += b;\\\nREAD_DIFF_EX( b0, 0, 4 );\\\nREAD_DIFF_EX( b1, 1, 5 );\\\nREAD_DIFF_EX( b2, 2, 6 );\\\nREAD_DIFF_EX( b3, 3, 7 );\\\nHADAMARD4( tmp[idx][0], tmp[idx][1], tmp[idx][2], tmp[idx][3], b0, b1, b2, b3 );\\\nHADAMARD4( b0, b1, b2, b3, tmp[0][idx], tmp[1][idx], tmp[2][idx], tmp[3][idx] );\\\nsum += abs2( b0 ) + abs2( b1 ) + abs2( b2 ) + abs2( b3 );\\\n}\nROW_8x4_SATD( 0, 0 );\nROW_8x4_SATD( 4, 4 );\n#undef READ_DIFF\n#undef READ_DIFF_EX\n#undef ROW_8x4_SATD\nreturn (((sum_t)sum) + (sum>>BITS_PER_SUM)) >> 1;\n}\nconstant int2 hpoffs[4] =\n{\n{0, -2}, {-2, 0}, {2, 0}, {0, 2}\n};\n/* sub pixel refinement of motion vectors, output MVs and costs are moved from\n* temporary buffers into final per-frame buffer\n*\n* global launch dimensions:  [mb_width * 4, mb_height]\n*\n* With X being the source 16x16 pixels, F is the lowres pixel used by the\n* motion search.  We will now utilize the H V and C pixels (stored in separate\n* planes) to search at half-pel increments.\n*\n* X X X X X X\n*  F H F H F\n* X X X X X X\n*  V C V C V\n* X X X X X X\n*  F H F H F\n* X X X X X X\n*\n* The YX HPEL bits of the motion vector selects the plane we search in.  The\n* four planes are packed in the fref_planes 2D image buffer.  Each sample\n* returns:  s0 = F, s1 = H, s2 = V, s3 = C */\nkernel void subpel_refine( read_only image2d_t   fenc,\nread_only image2d_t   fref_planes,\nconst global short2  *in_mvs,\nconst global int16_t *in_sad_mv_costs,\nlocal int16_t        *cost_local,\nlocal sum2_t         *satd_local,\nlocal short2         *mvc_local,\nglobal short2        *fenc_lowres_mv,\nglobal int16_t       *fenc_lowres_mv_costs,\nint                   mb_width,\nint                   lambda,\nint                   b,\nint                   ref,\nint                   b_islist1 )\n{\nint mb_x = get_global_id( 0 ) >> 2;\nif( mb_x >= mb_width )\nreturn;\nint mb_height = get_global_size( 1 );\nint mb_i = get_global_id( 0 ) & 3;\nint mb_y = get_global_id( 1 );\nint mb_xy = mb_y * mb_width + mb_x;\n/* fenc_lowres_mv and fenc_lowres_mv_costs are large buffers that\n* hold many frames worth of motion vectors.  We must offset into the correct\n* location for this frame's vectors.  The kernel will be passed the correct\n* directional buffer for the direction of the search: list1 or list0\n*\n*   CPU equivalent: fenc->lowres_mvs[0][b - p0 - 1]\n*   GPU equivalent: fenc_lowres_mvs[(b - p0 - 1) * mb_count] */\nfenc_lowres_mv +=       (b_islist1 ? (ref-b-1) : (b-ref-1)) * mb_width * mb_height;\nfenc_lowres_mv_costs += (b_islist1 ? (ref-b-1) : (b-ref-1)) * mb_width * mb_height;\n/* Adjust pointers into local memory buffers for this thread's data */\nint mb_in_group = get_local_id( 1 ) * (get_local_size( 0 ) >> 2) + (get_local_id( 0 ) >> 2);\ncost_local += mb_in_group * 4;\nsatd_local += mb_in_group * 16;\nmvc_local += mb_in_group * 4;\nint i_mvc = 0;\nmvc_local[0] = mvc_local[1] = mvc_local[2] = mvc_local[3] = 0;\n#define MVC( DX, DY ) mvc_local[i_mvc++] = in_mvs[mb_width * (mb_y + DY) + (mb_x + DX)];\nif( mb_x > 0 )\nMVC( -1, 0 );\nif( mb_y > 0 )\n{\nMVC( 0, -1 );\nif( mb_x < mb_width - 1 )\nMVC( 1, -1 );\nif( mb_x > 0 )\nMVC( -1, -1 );\n}\n#undef MVC\nint2 mvp = (i_mvc <= 1) ? convert_int2_sat(mvc_local[0]) : x264_median_mv( mvc_local[0], mvc_local[1], mvc_local[2] );\nint bcost =  in_sad_mv_costs[mb_xy];\nint2 coord = (int2)(mb_x, mb_y) << 3;\nint2 bmv = convert_int2_sat( in_mvs[mb_xy] );\n/* Make mvp and bmv QPEL MV */\nmvp <<= 2; bmv <<= 2;\n#define HPEL_QPEL( ARR, FUNC )\\\n{\\\nint2 trymv = bmv + ARR[mb_i];\\\nint2 qpos = (coord << 2) + trymv;\\\nint cost = FUNC( fenc, coord, fref_planes, qpos ) + lambda * mv_cost( abs_diff( trymv, mvp ) );\\\ncost_local[mb_i] = (cost<<2) + mb_i;\\\ncost = min( cost_local[0], min( cost_local[1], min( cost_local[2], cost_local[3] ) ) );\\\nif( (cost>>2) < bcost )\\\n{\\\nbmv += ARR[cost&3];\\\nbcost = cost>>2;\\\n}\\\n}\nHPEL_QPEL( hpoffs, sad_8x8_ii_hpel );\nHPEL_QPEL( dia_offs, sad_8x8_ii_qpel );\nfenc_lowres_mv[mb_xy] = convert_short2_sat( bmv );\n/* remeasure cost of bmv using SATD */\nint2 qpos = (coord << 2) + bmv;\ncost_local[mb_i] = satd_8x8_ii_qpel_coop4( fenc, coord, fref_planes, qpos, satd_local, mb_i );\nbcost = cost_local[0] + cost_local[1] + cost_local[2] + cost_local[3];\nbcost += lambda * mv_cost( abs_diff( bmv, mvp ) );\nfenc_lowres_mv_costs[mb_xy] = min( bcost, LOWRES_COST_MASK );\n}\n/* Weightp filter a downscaled image into a temporary output buffer.\n* This kernel is launched once for each scale.\n*\n* Launch dimensions: width x height (in pixels)\n*/\nkernel void weightp_scaled_images( read_only image2d_t in_plane,\nwrite_only image2d_t out_plane,\nuint offset,\nuint scale,\nuint denom )\n{\nint gx = get_global_id( 0 );\nint gy = get_global_id( 1 );\nuint4 input_val;\nuint4 output_val;\ninput_val = read_imageui( in_plane, sampler, (int2)(gx, gy));\noutput_val = (uint4)(offset) + ( ( ((uint4)(scale)) * input_val ) >> ((uint4)(denom)) );\nwrite_imageui( out_plane, (int2)(gx, gy), output_val );\n}\n/* Weightp filter for the half-pel interpolated image\n*\n* Launch dimensions: width x height (in pixels)\n*/\nkernel void weightp_hpel( read_only image2d_t in_plane,\nwrite_only image2d_t out_plane,\nuint offset,\nuint scale,\nuint denom )\n{\nint gx = get_global_id( 0 );\nint gy = get_global_id( 1 );\nuint input_val;\nuint output_val;\ninput_val = read_imageui( in_plane, sampler, (int2)(gx, gy)).s0;\nuint4 temp;\ntemp.s0 = input_val & 0x00ff; temp.s1 = (input_val >> 8) & 0x00ff;\ntemp.s2 = (input_val >> 16) & 0x00ff; temp.s3 = (input_val >> 24) & 0x00ff;\ntemp = (uint4)(offset) + ( ( ((uint4)(scale)) * temp ) >> ((uint4)(denom)) );\noutput_val = temp.s0 | (temp.s1 << 8) | (temp.s2 << 16) | (temp.s3 << 24);\nwrite_imageui( out_plane, (int2)(gx, gy), output_val );\n}\n", "OpenCL: %s\n", "OpenCL: fatal error, aborting encode\n", "libOpenCL.so", "clBuildProgram", "clCreateBuffer", "clCreateCommandQueue", "clCreateContext", "clCreateImage2D", "clCreateKernel", "clCreateProgramWithBinary", "clCreateProgramWithSource", "clEnqueueCopyBuffer", "clEnqueueMapBuffer", "clEnqueueNDRangeKernel", "clEnqueueReadBuffer", "clEnqueueWriteBuffer", "clFinish", "clGetCommandQueueInfo", "clGetDeviceIDs", "clGetDeviceInfo", "clGetKernelWorkGroupInfo", "clGetPlatformIDs", "clGetProgramBuildInfo", "clGetProgramInfo", "clGetSupportedImageFormats", "clReleaseCommandQueue", "clReleaseContext", "clReleaseKernel", "clReleaseMemObject", "clReleaseProgram", "clSetKernelArg", "(SI)", "-DVECTORIZE=1", "OpenCL: Unable to query installed platforms\n", "OpenCL: malloc of installed platforms buffer failed\n", "OpenCL: %s does not support required image formats\n", "x264_lookahead.clbin", "OpenCL: Unable to find a compatible device\n", "Advanced Micro Devices, Inc.", "libatiadlxx.so", "ADL_Main_Control_Create", "ADL_Main_Control_Destroy", "ADL_Adapter_NumberOfAdapters_Get", "ADL_PowerXpress_Scheme_Get", "OpenCL acceleration disabled, switchable graphics detected\n", "OpenCL acceleration enabled with %s %s %s\n", "Compiling OpenCL kernels...\n", "OpenCL: unable to create program\n", "OpenCL: unable to open clbin file for write\n", "OpenCL: Unable to query program binary size, no cache file generated\n", "OpenCL: Unable to query program binary, no cache file generated\n", "OpenCL: Compilation failed, unable to query build log\n", "OpenCL: Compilation failed, unable to alloc build log\n", "OpenCL: Compilation failed, unable to get build log\n", "x264_kernel_build_log.txt", "OpenCL: Compilation failed, unable to create file x264_kernel_build_log.txt\n", "OpenCL: kernel build errors written to x264_kernel_build_log.txt\n", "OpenCL: Unable to compile kernel '%s' (%d)\n", "OpenCL: Unable to allocate page-locked buffer, error '%d'\n", "OpenCL: Unable to map page-locked buffer, error '%d'\n", "mb_intra_cost_satd_8x8", "sum_intra_cost", "downscale_hpel", "downscale1", "downscale2", "memset_int16", "weightp_scaled_images", "weightp_hpel", "hierarchical_motion", "subpel_refine", "mode_selection", "sum_inter_cost", "Invalid input colorspace\n", "This build of x264 requires 8-bit input. Rebuild to support high depth input.\n", "v210 input is only compatible with bit-depth of 10 bits\n", "forced frame type (%d) at %d is unknown\n", "Input picture width (%d) is greater than stride (%d)\n", "ARMv6", "NEON", "FastNeonMRC", "can't open file '%s'\n", "INTRA4X4_LUMA", "bad coefficient in list '%s'\n", " \t\n,", "not enough coefficients in list '%s'\n", "0123456789", "INTER4X4_LUMA", "INTRA4X4_CHROMA", "INTER4X4_CHROMA", "INTRA8X8_LUMA", "INTER8X8_LUMA", "INTRA8X8_CHROMA", "INTER8X8_CHROMA", "internal error P_L0 and partition=%d\n", "internal error\n", "internal error (invalid MB type)\n", "internal error (!8x8 && !4x4)\n", "scene cut at %d Icost:%d Pcost:%d ratio:%.4f bias:%.4f gop:%d (imb:%d pmb:%d)\n", "forced frame type (%d) at %d was changed to frame type (%d)\n", "B-ref at frame %d incompatible with B-pyramid %s \n", "B-ref at frame %d incompatible with B-pyramid %s and %d reference frames\n", "specified frame type (%d) at %d is not compatible with keyframe interval\n", "specified frame type is not compatible with max B-frames\n", "infinite ", "init_pass2", "x264_ratecontrol_start", "slice=%c but 2pass stats say %c\n", "MB-tree frametype %d doesn't match actual frametype %d.\n", "Incomplete MB-tree stats file.\n", "VBV buffer size cannot be smaller than one frame, using %d kbit\n", "VBV parameters cannot be changed when NAL HRD is in use\n", "CRF max must be greater than CRF\n", "constant rate-factor is incompatible with 2pass.\n", "HRD with very large timescale and bufsize not supported\n", "bitrate tolerance too small, using .01\n", "%d,%d,q=%d%n", "%d,%d,b=%f%n", "%d,%d%n", "invalid zone: \"%s\"\n", "invalid zone param: %s = %s\n", "invalid zone: start=%d end=%d\n", "invalid zone: bitrate_factor=%f\n", "encoder/ratecontrol.c", "h->param.rc.psz_stat_in", "ratecontrol_init: can't open stats file\n", ".mbtree", "ratecontrol_init: can't open mbtree stats file\n", "#options:", "options list in stats file not valid\n", "#options: %dx%d", "resolution specified in stats file not valid\n", "timebase=", "timebase specified in stats file not valid\n", "timebase=%u/%u", "timebase mismatch with 1st pass (%u/%u vs %u/%u)\n", "bitdepth=", "bitdepth=%d", "different bitdepth setting than first pass (%d vs %d)\n", "weightp=", "weightp=%d", "different weightp setting than first pass (%d vs %d)\n", "bframes=", "bframes=%d", "different bframes setting than first pass (%d vs %d)\n", "b_pyramid=", "b_pyramid=%d", "different b_pyramid setting than first pass (%d vs %d)\n", "intra_refresh=", "intra_refresh=%d", "different intra_refresh setting than first pass (%d vs %d)\n", "open_gop=", "different open_gop setting than first pass (%d vs %d)\n", "bluray_compat=", "bluray_compat=%d", "different bluray_compat setting than first pass (%d vs %d)\n", "interlaced=", "interlaced=%4s", "different interlaced setting than first pass (%s vs %s)\n", "keyint=", "different keyint setting than first pass (%.*s vs %.*s)\n", "qp=0", "1st pass was lossless, bitrate prediction will be inaccurate\n", "direct=3", "direct=auto not used on the first pass\n", "b_adapt=", "b_adapt=%d", "b_adapt method specified in stats file not valid\n", "rc_lookahead=", "rc_lookahead=%d", "empty stats file\n", "2nd pass has fewer frames than 1st pass (%d vs %d)\n", "2nd pass has more frames than 1st pass (%d vs %d)\n", " in:%d out:%d ", "bad frame number (%d) at stats line %d\n", "bad frame output number (%d) at stats line %d\n", " in:%*d out:%*d type:%c dur:%lld cpbdur:%lld q:%f aq:%f tex:%d mv:%d misc:%d imb:%d pmb:%d smb:%d d:%c", "w:%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd", "statistics are damaged at line %d, parser out=%d\n", "requested bitrate is too low. estimated minimum is %d kbps\n", "qscale[i] >= 0", "rce->new_qscale >= 0", "vbv-maxrate issue, qpmax or vbv-maxrate too low\n", "Error: 2pass curve failed to converge\n", "target: %.2f kbit/s, expected: %.2f kbit/s, avg QP: %.4f\n", "try reducing target bitrate or reducing qp_min (currently %d)\n", "try reducing target bitrate\n", "try increasing target bitrate or increasing qp_max (currently %d)\n", "try increasing target bitrate\n", ".temp", "#options: %s\n", ".mbtree.temp", "failed to parse zones\n", "final ratefactor: %.2f\n", "failed to rename \"%s\" to \"%s\"\n", "frame >= 0 && frame < rc->num_entries", "2nd pass has more frames than 1st pass (%d)\n", "continuing anyway, at constant QP=%d\n", "disabling adaptive B-frames\n", "in:%d out:%d type:%c dur:%lld cpbdur:%lld q:%.2f aq:%.2f tex:%d mv:%d misc:%d imb:%d pmb:%d smb:%d d:%c ref:", "w:%d,%d,%d", ",%d,%d,%d,%d,%d ", "VBV underflow due to CRF-max (frame %d, %.0f bits)\n", "VBV underflow (frame %d, %.0f bits)\n", "ratecontrol_end: stats file could not be written to\n", "underflow", "overflow", "CPB %s: %.0f bits in a %.0f-bit buffer\n", "clCreateImage2D error '%d'\n", "clCreateBuffer error '%d'\n", "clEnqueueWriteBuffer error '%d'\n", "clSetKernelArg error '%d'\n", "clEnqueueNDRangeKernel error '%d'\n", "clEnqueueReadBuffer error '%d'\n", "clEnqueueCopyBuffer error '%d'\n", "Oct 19 2016", "21:38:35", "AAC Encoder", "%d.%d.%d", "%d.%d.%d", "Oct 19 2016", "21:38:38", "MPEG Transport", "%d.%d.%d", "Oct 19 2016", "21:38:43", "SBR Encoder", "@33#", "Oct 19 2016", "21:38:45", "FDK Tools", "This program is protected by copyright law and international treaties.\nAny reproduction or distribution of this program, or any portion\nof it, may result in severe civil and criminal penalties, and will be\nprosecuted to the maximum extent possible under law.\n\n", "q=\n'", "_{fI", "{NFE", "RIFF", "WEBPVP8L", "{NFE", "getauxval", "/sys/devices/system/cpu/present", "/sys/devices/system/cpu/possible", "CPU architecture", "(v6l)", "vfpv3d16", "vfpv4", "idiva", "idivt", "idiv", "iwmmxt", "Hardware", "Goldfish", "Processor", "CPU implementer", "CPU variant", "CPU part", "CPU revision"], "stringidentifiers": ["write_id3v2", "write_apetag", "APETAGEX", "Author", "Description", "comment", "encoded_by", "genre", "language", "disc", "publisher", "service_provider", "service_name", "asf_parse_packet", "asf_read_packet", "asf_st", "AspectRatioX", "AspectRatioY", "author", "copyright", "ASF_Protection_Type", "ASF_Key_ID", "ASF_License_URL", "encryption", "no_resync_search", "export_xmp", "async", "Async", "NULL", "subfile", "URLContext", "AVIOContext", "h264_mp4toannexb", "NOPTS", "inpoint", "outpoint", "file_packet_metadata", "exact_stream_id", "ffconcat", "auto_convert", "base64", "unknown", "dump_separator", "effects", "dialogue", "comentary", "emergency", "karaoke", "Output", "Input", "truncate", "WAVEFORMATEXTENSIBLE_CHANNEL_MASK", "fLaC", "flac", "true", "false", "times", "filepositions", "videodatarate", "audiodatarate", "datastream", "videocodecid", "audiocodecid", "audiosamplerate", "audiosamplesize", "filesize", "onTextData", "onCaption", "onCaptionInfo", "onMetaData", "onCuePoint", "live_flv", "live_flvdec", "flv_metadata", "image2", "ssegment", "image2pipe", "mime_type", "final_delay", "min_delay", "max_gif_delay", "default_delay", "ignore_loop", "h261", "h263", "hevc", "cookies", "headers", "seekable", "end_offset", "EVENT", "PRIV", "APIC", "variant_bitrate", "user_agent", "live_start_index", "Blues", "Country", "Dance", "Disco", "Grunge", "Oldies", "Other", "Reggae", "Alternative", "Pranks", "Soundtrack", "Ambient", "Vocal", "Trance", "Classical", "Instrumental", "Acid", "Game", "Gospel", "Noise", "AlternRock", "Space", "Meditative", "Ethnic", "Gothic", "Darkwave", "Electronic", "Eurodance", "Dream", "Comedy", "Cult", "Jungle", "Cabaret", "Psychadelic", "Rave", "Showtunes", "Trailer", "Tribal", "Polka", "Retro", "Musical", "Swing", "Bebob", "Latin", "Revival", "Celtic", "Bluegrass", "Avantgarde", "Chorus", "Acoustic", "Humour", "Speech", "Chanson", "Opera", "Sonata", "Symphony", "Primus", "Satire", "Club", "Tango", "Samba", "Folklore", "Freestyle", "Duet", "Hardcore", "Terror", "Indie", "BritPop", "Negerpunk", "Beat", "Crossover", "Merengue", "Salsa", "Anime", "JPop", "SynthPop", "TDATTIMETORYTRDATSIZTYER", "TDENTDORTDRCTDRLTDTGTIPLTMCLTMOOTPROTSOATSOPTSOTTSST", "TALBTBPMTCOMTCONTCOPTDLYTENCTEXTTFLTTIT1TIT2TIT3TKEYTLANTLENTMEDTOALTOFNTOLYTOPETOWNTPE1TPE2TPE3TPE4TPOSTPUBTRCKTRSNTRSOTSRCTSSE", "TCON", "TXXX", "GEOB", "encrypted", "compression", "USLT", "TYER", "TDAT", "Conductor", "Illustration", "TCMP", "compilation", "TDRC", "TDRL", "TDEN", "creation_time", "TSOA", "TSOP", "TSOT", "TALB", "TCOM", "TCOP", "TENC", "TIT2", "TLAN", "TPE1", "TPE2", "TPE3", "TPOS", "TPUB", "TRCK", "TSSE", "lyrics", "CHAP", "ljpg", "pgmyuv", "pict", "im24", "im32", "sunras", "yuv10", "xface", "SDPX", "XPDS", "Exif", "webp_pipe", "tiff_pipe", "sunrast_pipe", "sgi_pipe", "qdraw_pipe", "png_pipe", "pictor_pipe", "jpegls_pipe", "jpeg_pipe", "j2k_pipe", "exr_pipe", "dpx_pipe", "dds_pipe", "bmp_pipe", "pattern_type", "glob_sequence", "glob", "pixel_format", "start_number", "start_number_range", "video_size", "frame_size", "ts_from_file", "ts_type", "UVAx", "updatefirst", "update", "strftime", "tx3g806cc608", "sac3", "alac", "twos", "lpcm", "WMA2cvessevcvmssssmv", "cvid1", "mp2vY", "tiffb", "avs2u", "dracd", "AVupf", "ap4x3", "HapY", "loas", "binary", "ATAD", "A_AAC", "A_AC3", "A_ALAC", "A_DTS", "A_EAC3", "A_FLAC", "A_MLP", "A_OPUS", "A_TRUEHD", "A_TTA1", "A_VORBIS", "A_WAVPACK4", "S_DVBSUB", "V_DIRAC", "V_MJPEG", "V_MPEG1", "V_MPEG2", "V_PRORES", "V_SNOW", "WONSV_THEORA", "V_UNCOMPRESSED", "V_VP8", "V_VP9", "background", "left_right", "bottom_top", "top_bottom", "checkerboard_rl", "checkerboard_lr", "row_interleaved_rl", "row_interleaved_lr", "col_interleaved_rl", "col_interleaved_lr", "anaglyph_cyan_red", "right_left", "anaglyph_green_magenta", "block_lr", "block_rl", "LEAD_PERFORMER", "PART_NUMBER", "enc_key_id", "A_QUICKTIME", "V_QUICKTIME", "alac", "TTA1", "stereo_mode", "alpha_mode", "mimetype", "webm_dash_manifest_duration", "webm_dash_manifest_initialization_range", "webm_dash_manifest_file_name", "webm_dash_manifest_track_number", "webm_dash_manifest_cues_start", "webm_dash_manifest_cues_end", "webm_dash_manifest_bandwidth", "webm_dash_manifest_cluster_keyframe", "webm_dash_manifest_cue_timestamps", "webm_dash_manifest", "MAIN", "iTunSMPB", "cdec", "handler_name", "major_brand", "minor_version", "compatible_brands", "tmcd", "timecode", "rotate", "nclx", "nclc", "premiere_version", "quicktime_version", "account_type", "account_id", "category", "description", "episode_uid", "hd_video", "keywords", "synopsis", "podcast", "gapless_playback", "purchase_date", "rating", "sort_album_artist", "sort_album", "sort_artist", "sort_composer", "sort_name", "sort_show", "media_type", "episode_id", "episode_sort", "network", "season_number", "producer", "chapter", "director", "disclaimer", "edit_date", "original_format", "grouping", "host_computer", "make", "original_artist", "performers", "playback_requirements", "original_source", "warning", "stsd", "avc1", "hvc1", "hev1", "mp4s", "reel_name", "use_absolute_path", "seek_streams_individually", "ignore_editlist", "use_mfra_for", "export_all", "activation_bytes", "audible_fixed_key", "enable_drefs", "text", "mp4a", "tx3g", "avc1k", "VP6F", "yuv2", "yuvs", "b48r0", "stps", "mhlr", "VideoHandler", "soun", "SoundHandler", "subp", "SubtitleHandler", "HintHandler", "TimeCodeHandler", "DataHandler", "clcp", "ClosedCaptionHandler", "sbtl", "dhlr", "handler", "yrrc", "albm", "XDCAM", "DpxE", "lpcm", "disk", "trkn", "perf", "titl", "auth", "gnre", "dscp", "cprt", "aART", "encoding_tool", "ldes", "tvsh", "tven", "tvnn", "tves", "tvsn", "stik", "hdvd", "pgap", "cpil", "tmpo", "CodecPrivateData", "wide", "free", "ipod", "systemBitrate", "trackID", "FourCC", "WVC1", "MaxWidth", "MaxHeight", "DisplayWidth", "DisplayHeight", "AACL", "WMAP", "AudioTag", "Channels", "SamplingRate", "BitsPerSample", "PacketSize", "movflags", "rtphint", "moov_size", "empty_moov", "frag_keyframe", "separate_moof", "frag_custom", "isml", "faststart", "omit_tfhd_offset", "disable_chpl", "default_base_moof", "dash", "frag_discont", "delay_moov", "global_sidx", "write_colr", "write_gama", "rtpflags", "rfc2190", "skip_rtcp", "h264_mode0", "send_bye", "skip_iods", "iods_audio_profile", "iods_video_profile", "min_frag_duration", "frag_size", "ism_lookahead", "video_track_timescale", "use_editlist", "fragment_index", "mov_gamma", "frag_interleave", "rtpo", "usetoc", "IMKH", "Sofdec", "XTDB", "drac", "HEVC", "SUPO", "HDMV", "HDPR", "mpegtsraw", "mpegts", "resync_size", "compute_pcr", "ts_packetsize", "fix_teletext_pts", "scan_all_pmts", "skip_changes", "skip_clear", "mpegvideo", "OggS", "BBCD", "OpusTags", "OpusHead", "Opus", "fishead", "fisbone", "METADATA_BLOCK_PICTURE", "NAME", "OVP80", "AVFormatContext", "avioflags", "direct", "formatprobesize", "flush_packets", "ignidx", "genpts", "nofillin", "noparse", "igndts", "discardcorrupt", "sortdts", "keepside", "fastseek", "nobuffer", "seek2any", "bitexact", "analyzeduration", "cryptokey", "indexmem", "rtbufsize", "fdebug", "max_delay", "start_time_realtime", "fpsprobesize", "audio_preload", "chunk_duration", "f_err_detect", "crccheck", "explode", "ignore_err", "careful", "compliant", "aggressive", "use_wallclock_as_timestamps", "skip_initial_bytes", "correct_ts_overflow", "metadata_header_padding", "output_ts_offset", "max_interleave_delta", "f_strict", "normal", "unofficial", "experimental", "max_ts_probe", "avoid_negative_ts", "disabled", "make_non_negative", "make_zero", "codec_whitelist", "REPLAYGAIN_TRACK_GAIN", "REPLAYGAIN_TRACK_PEAK", "REPLAYGAIN_ALBUM_GAIN", "REPLAYGAIN_ALBUM_PEAK", "HFYUD", "IV32p", "IV41q", "VP62k", "Xxanr", "cvid4", "DUCK4", "PVEZ6", "MSZH7", "S263W", "svq19", "WMVPG", "WVC1G", "WVP2I", "LOCOJ", "WNV1J", "YUV8K", "AAS4K", "AASCL", "RT21M", "theoN", "TM20P", "CSCDR", "ZMBVV", "KMVCX", "CAVSY", "mjp2Y", "MJ2CY", "LJ2CY", "LJ2KY", "IPJ2Z", "CLJRu", "LAGSl", "ZECOP14YY41P3", "SVQ3V210012vV210a12vM2G", "G2M2M2G", "G2M3M2G", "G2M4M2G", "CUVC", "IART", "ICMT", "ICOP", "ICRD", "IGNR", "ILNG", "INAM", "IPRD", "IPRT", "ITRK", "ISFT", "ISMP", "ITCH", "IARL", "IART", "ICMS", "ICMT", "ICOP", "ICRD", "ICRP", "IDIM", "IDPI", "IENG", "IGNR", "IKEY", "ILGT", "ILNG", "IMED", "INAM", "IPLT", "IPRD", "IPRT", "ITRK", "ISBJ", "ISFT", "ISHP", "ISMP", "ISRC", "ISRF", "ITCH", "BottomUp", "RVTRE", "RV30F", "dnet", "PCMU", "G723", "DVI4", "DVI4", "PCMA", "G722", "QCELP", "G728", "DVI4", "DVI4", "G729", "CelB", "JPEG", "H261", "MP2T", "H263", "mp4v", "dvbsub", "eac3", "vc1test", "ALBUMARTIST", "TRACKNUMBER", "DISCNUMBER", "DESCRIPTION", "originator", "originator_reference", "origination_date", "origination_time", "time_reference", "umid", "coding_history", "WAVE", "RIFF", "RIFX", "RF64", "ds64", "ignore_length", "levl", "JUNK", "fact", "write_bext", "write_peak", "rf64", "always", "never", "peak_block_size", "peak_format", "peak_ppv", "RIFF", "WEBP", "VP8X", "ANIM", "ANMF", "xobX", "aeval", "same", "aevalsrc", "nb_in_channels", "nb_out_channels", "default", "exprs", "nb_samples", "adelay", "aecho", "in_gain", "out_gain", "acrossfade", "afade", "crossfade0", "crossfade1", "curve1", "esin", "ipar", "quadratic", "exponential", "iqsin", "ihsin", "dese", "desi", "curve2", "start_sample", "start_time", "curve", "aformat", "sample_fmts", "sample_rates", "channel_layouts", "amix", "longest", "shortest", "dropout_transition", "anull", "apad", "packet_size", "pad_len", "whole_len", "aphaser", "triangular", "sinusoidal", "aresample", "asetnsamples", "nb_out_samples", "asetrate", "Effects", "Dialogue", "Commentary", "Emergency", "Karaoke", "ashowinfo", "Crest_factor", "astats", "astreamsync", "out1", "out2", "atempo", "biquad", "allpass", "highpass", "lowpass", "bandreject", "bandpass", "treble", "bass", "equalizer", "width_type", "octave", "channelmap", "channelsplit", "chorus", "compand", "attacks", "limitergain", "dynaudnorm", "regen", "itype", "join", "args", "replaygain", "sidechaincompress", "sidechain", "makeup", "link", "average", "maximum", "silencedetect", "start_periods", "start_duration", "start_threshold", "stop_periods", "stop_duration", "stop_threshold", "leave_silence", "nb_channels", "nb_consumed_samples", "startpts", "startt", "fixed", "float", "double", "drop", "ignore", "replaygain_preamp", "replaygain_noclip", "volumedetect", "anullsink", "anullsrc", "beep_factor", "samples_per_frame", "aphasemeter", "lissajous", "lissajous_xy", "polar", "unsafe", "showcqt", "a_weighting", "b_weighting", "c_weighting", "midi", "tlength", "gamma2", "fullhd", "fontfile", "fontcolor", "showfreqs", "ascale", "cbrt", "fscale", "rlog", "w128", "w256", "w512", "w1024", "w2048", "w4096", "w8192", "w16384", "w32768", "w65536", "win_func", "Rectangular", "bartlett", "Bartlett", "hanning", "Hanning", "hamming", "Hamming", "blackman", "Blackman", "welch", "Welch", "flattop", "bharris", "bnuttall", "bhann", "Sine", "showspectrum", "slide", "replace", "fullframe", "combined", "separate", "saturation", "VOLUME", "CHANNEL", "showwavespic", "showwaves", "split_channels", "cline", "enable", "noformat", "frei0r", "frei0r_src", "AVFilter", "thread_type", "slice", "afifo", "AVFilterGraph", "scale_sws_opts", "aresample_swr_opts", "all_channel_counts", "pix_fmts", "ffbuffersink", "ffabuffersink", "abuffer", "time_base", "pix_fmt", "time_base_num", "time_base_den", "sar_num", "sar_den", "pixel_aspect", "frame_rate", "sws_param", "pix_desc", "mainpic", "adrawgraph", "white", "rscroll", "out0", "in_channel_layout", "in_sample_fmt", "out_channel_layout", "out_sample_rate", "out_sample_fmt", "ebur128", "framelog", "verbose", "ainterleave", "aperms", "toggle", "areverse", "scene", "aselect", "start_pts", "prev_pts", "prev_selected_pts", "start_t", "prev_t", "prev_selected_t", "PICT_TYPE_I", "PICT_TYPE_P", "PICT_TYPE_B", "PICT_TYPE_S", "PICT_TYPE_SI", "PICT_TYPE_SP", "PICT_TYPE_BI", "interlace_type", "PROGRESSIVE", "TOPFIRST", "BOTTOMFIRST", "consumed_samples_n", "prev_selected_n", "asendcmd", "framesync", "asetpts", "FRAME_RATE", "INTERLACED", "NB_CONSUMED_SAMPLES", "NB_SAMPLES", "PREV_INPTS", "PREV_INT", "PREV_OUTPTS", "PREV_OUTT", "SAMPLE_RATE", "STARTPTS", "STARTT", "RTCTIME", "RTCSTART", "asettb", "AVTB", "intb", "asplit", "amovie", "format_name", "stream_index", "seek_point", "atrim", "starti", "endi", "end_pts", "durationi", "end_sample", "start_frame", "alphamerge", "setsar", "setdar", "dar_den", "bbox", "min_val", "blackdetect", "black_min_duration", "picture_black_ratio_th", "pic_th", "pixel_black_th", "pix_th", "blackframe", "tblend", "BOTTOM", "c0_mode", "c1_mode", "c2_mode", "c3_mode", "all_mode", "addition", "burn", "darken", "difference128", "divide", "dodge", "exclusion", "glow", "hardlight", "hardmix", "lighten", "linearlight", "multiply", "negation", "overlay", "phoenix", "pinlight", "reflect", "screen", "softlight", "subtract", "vividlight", "c0_expr", "c1_expr", "c2_expr", "c3_expr", "all_expr", "c0_opacity", "c1_opacity", "c2_opacity", "c3_opacity", "all_opacity", "repeatlast", "boxblur", "luma_radius", "luma_power", "chroma_radius", "chroma_power", "alpha_radius", "alpha_power", "similarity", "rimin", "gimin", "bimin", "aimin", "rimax", "gimax", "bimax", "aimax", "romin", "gomin", "bomin", "aomin", "romax", "gomax", "bomax", "aomax", "colormatrix", "bt709", "bt601", "smpte240m", "color_mode", "bt470", "bt470bg", "smpte170m", "copy", "cover_rect", "cover", "out_w", "out_h", "keep_aspect", "cropdetect", "limit", "reset_count", "max_outliers", "curves", "preset_name", "color_negative", "cross_process", "darker", "increase_contrast", "lighter", "linear_contrast", "medium_contrast", "strong_contrast", "vintage", "master", "psfile", "dctdnoiz", "sigma", "clean_src", "cycle", "dupthresh", "scthresh", "blockx", "blocky", "ppsrc", "dejudder", "delogo", "deshake", "blank", "smode", "exhaustive", "opencl", "detelecine", "first_field", "invert", "drawgrid", "drawbox", "edgedetect", "wires", "colormix", "elbg", "codebook_length", "nb_steps", "pal8", "brightness", "gamma_r", "gamma_g", "gamma_b", "gamma_weight", "init", "alphaextract", "extractplanes", "nb_frames", "weight_Y", "weight_U", "weight_V", "dc_Y", "dc_U", "dc_V", "field_type", "fieldmatch", "pc_n", "pc_u", "pc_n_ub", "pcn_ub", "mchroma", "combmatch", "combdbg", "dbglvl", "pcnub", "combpel", "down", "fieldorder", "find_rect", "object", "xmin", "ymin", "xmax", "ymax", "framepack", "frameseq", "interp_start", "interp_end", "scene_change_detect", "framestep", "fspp", "use_bframe_qp", "lum_expr", "cb_expr", "cr_expr", "alpha_expr", "red_expr", "green_expr", "blue_expr", "gradfun", "hflip", "histeq", "weak", "strong", "waveform", "color2", "level_height", "scale_height", "waveform_mode", "column", "waveform_mirror", "display_mode", "parade", "levels_mode", "hqdn3d", "luma_spatial", "chroma_spatial", "luma_tmp", "chroma_tmp", "idet", "intl_thres", "prog_thres", "rep_thres", "half_life", "analyze_interlaced_flag", "luma_mode", "deinterleave", "chroma_mode", "luma_swap", "chroma_swap", "alpha_swap", "without", "negval", "negate", "lutrgb", "lutyuv", "minval", "clipval", "gammaval", "gammaval709", "negate_alpha", "DOMAIN_", "values", "haldclut", "lut3d", "interp_mode", "trilinear", "tetrahedral", "memc_only", "no_bitstream", "mcdeint", "medium", "extra_slow", "mergeplanes", "mpdecimate", "frac", "dilation", "deflate", "inflate", "threshold0", "threshold1", "threshold2", "threshold3", "all_seed", "all_strength", "alls", "all_flags", "allf", "c0_seed", "c0_strength", "c0_flags", "c1_seed", "c1_strength", "c1_flags", "c2_seed", "c2_strength", "c2_flags", "c3_seed", "c3_strength", "c3_flags", "repeat", "endall", "main_w", "main_h", "overlay_w", "overlay_h", "eof_action", "yuv420", "yuv422", "yuv444", "luma_strength", "chroma_strength", "palettegen", "max_colors", "reserve_transparent", "stats_mode", "paletteuse", "dithering_mode", "bayer", "heckbert", "floyd_steinberg", "sierra2", "sierra2_4a", "bayer_scale", "diff_mode", "debug_kdtree", "color_search", "nns_iterative", "nns_recursive", "bruteforce", "mean_err", "debug_accuracy", "perspective", "sense", "pixdesctest", "hard", "soft", "psnr", "stats_file", "pullup", "removelogo", "repeatfields", "rotw", "roth", "fillcolor", "luma_pre_filter_radius", "lpfr", "chroma_pre_filter_radius", "cpfr", "srcw", "srch", "src_format", "dstw", "dsth", "dst_format", "sws_flags", "param0", "param1", "src_range", "dst_range", "src_h_chr_pos", "src_v_chr_pos", "dst_h_chr_pos", "dst_v_chr_pos", "scale2ref", "ohsub", "interl", "in_color_matrix", "out_color_matrix", "in_range", "out_range", "in_v_chr_pos", "in_h_chr_pos", "out_v_chr_pos", "out_h_chr_pos", "force_original_aspect_ratio", "force_oar", "disable", "decrease", "increase", "separatefields", "setfield", "prog", "shuffleplanes", "map0", "map1", "map2", "map3", "signalstats", "TOUT", "VREP", "BRNG", "stat", "tout", "vrep", "brng", "yellow", "smartblur", "luma_threshold", "chroma_threshold", "ssim", "vstack", "hstack", "stereo3d", "ab2l", "ab2r", "sbs2l", "sbs2r", "sbsl", "sbsr", "agmc", "agmd", "agmg", "agmh", "arbg", "arcc", "arcd", "arcg", "argg", "aybc", "aybd", "aybg", "aybh", "swapuv", "thumbnail", "tile", "margin", "tinterlace", "drop_even", "drop_odd", "interleave_top", "interleave_bottom", "interlacex2", "low_pass_filter", "vlpf", "exact_tb", "counterclockwise", "transpose", "cclock_flip", "cclock", "passthrough", "portrait", "landscape", "unsharp", "luma_msize_x", "luma_msize_y", "luma_amount", "chroma_msize_x", "chroma_msize_y", "chroma_amount", "uspp", "color3", "color4", "vflip", "vignette", "forward", "backward", "simple", "complex", "aflat", "achroma", "yadif", "send_frame", "send_field", "send_frame_nospatial", "send_field_nospatial", "pduration", "pzoom", "hd720", "cellauto", "random_fill_ratio", "random_seed", "start_full", "stitch", "bBsS", "mold", "life_color", "death_color", "mold_color", "mandelbrot", "maxiter", "start_x", "start_y", "start_scale", "end_scale", "bailout", "morphxf", "morphyf", "morphamp", "outer", "normalized_iteration_count", "outz", "inner", "mincol", "mptestsrc", "dc_luma", "dc_chroma", "freq_luma", "freq_chroma", "amp_luma", "amp_chroma", "ring1", "ring2", "allrgb", "allyuv", "smptehdbars", "smptebars", "rgbtestsrc", "haldclutsrc", "decimals", "aac_adtstoasc", "aac_latm", "Main", "dual_mono_mode", "autoselection", "both", "ms_off", "ms_force", "aac_coder", "faac", "anmr", "twoloop", "aac_pns", "aac_is", "intensity_stereo", "aac_tns", "aac_pred", "amrnb", "amrwb", "AVDCT", "fastint", "altivec", "faan", "simplemmx", "simplearm", "simplearmv5te", "simplearmv6", "simpleneon", "simplealpha", "xvid", "xvidmmx", "faani", "simpleauto", "Palette", "mpeg1video", "mpeg2video", "mpegvideo_xvmc", "rv10", "rv20", "mjpegb", "rawvideo", "msmpeg4v1", "msmpeg4v2", "msmpeg4v3", "wmv1", "wmv2", "h263p", "h263i", "flv1", "svq1", "svq3", "dvvideo", "huffyuv", "cyuv", "indeo3", "asv1", "asv2", "ffv1", "vcr1", "cljr", "mdec", "interplayvideo", "xan_wc3", "xan_wc4", "rpza", "cinepak", "ws_vqa", "msrle", "msvideo1", "idcin", "flic", "truemotion1", "vmdvideo", "mszh", "zlib", "qtrle", "snow", "tscc", "qdraw", "vixl", "qpeg", "ffvhuff", "rv30", "rv40", "loco", "wnv1", "aasc", "indeo2", "fraps", "truemotion2", "cscd", "mmvideo", "zmbv", "smackvideo", "kmvc", "flashsv", "cavs", "jpeg2000", "vmnc", "vp6f", "dsicinvideo", "tiertexseqvideo", "dnxhd", "bethsoftvid", "vp6a", "indeo4", "indeo5", "mimic", "escape124", "dirac", "motionpixels", "aura", "aura2", "v210x", "v210", "frwu", "flashsv2", "cdgraphics", "r210", "binkvideo", "iff_ilbm", "iff_byterun1", "kgv1", "pictor", "a64_multi", "a64_multi5", "r10k", "mvc1", "mvc2", "mxpeg", "lagarith", "prores", "utvideo", "bmv_video", "vble", "dxtory", "v410", "cdxl", "zerocodec", "mss1", "msa1", "tscc2", "mts2", "cllc", "mss2", "y41p", "escape130", "avrp", "avui", "ayuv", "targa_y216", "v308", "v408", "yuv4", "avrn", "cpia", "smvjpeg", "hnm4video", "paf_video", "sanm", "sgirle", "hq_hqa", "alias_pix", "ansi", "brender_pix", "jpegls", "ljpeg", "sp5x", "sunrast", "tdsc", "vc1image", "wmv3image", "apng", "pcm_s16le", "pcm_s16be", "pcm_u16le", "pcm_u16be", "pcm_s8", "pcm_u8", "pcm_mulaw", "pcm_alaw", "pcm_s32le", "pcm_s32be", "pcm_u32le", "pcm_u32be", "pcm_s24le", "pcm_s24be", "pcm_u24le", "pcm_u24be", "pcm_s24daud", "pcm_zork", "pcm_s16be_planar", "pcm_s16le_planar", "pcm_s24le_planar", "pcm_s32le_planar", "pcm_dvd", "pcm_f32be", "pcm_f32le", "pcm_f64be", "pcm_f64le", "pcm_bluray", "pcm_lxf", "s302m", "pcm_s8_planar", "adpcm_ima_qt", "adpcm_ima_wav", "adpcm_ima_dk3", "adpcm_ima_dk4", "adpcm_ima_ws", "adpcm_ima_smjpeg", "adpcm_ms", "adpcm_4xm", "adpcm_xa", "adpcm_adx", "adpcm_ea", "adpcm_g726", "adpcm_ct", "adpcm_swf", "adpcm_yamaha", "adpcm_sbpro_4", "adpcm_sbpro_3", "adpcm_sbpro_2", "adpcm_thp", "adpcm_thp_le", "adpcm_ima_amv", "adpcm_ea_r1", "adpcm_ea_r3", "adpcm_ea_r2", "adpcm_ima_ea_sead", "adpcm_ima_ea_eacs", "adpcm_ea_xas", "adpcm_ea_maxis_xa", "adpcm_ima_iss", "adpcm_g722", "adpcm_ima_apc", "adpcm_afc", "adpcm_ima_oki", "adpcm_dtk", "adpcm_ima_rad", "adpcm_g726le", "adpcm_vima", "amr_nb", "amr_wb", "ra_144", "ra_288", "roq_dpcm", "interplay_dpcm", "xan_dpcm", "sol_dpcm", "dvaudio", "wmav1", "wmav2", "mace3", "mace6", "vmdaudio", "mp3adu", "mp3on4", "shorten", "westwood_snd1", "qdm2", "cook", "truespeech", "smackaudio", "qcelp", "wavpack", "dsicinaudio", "musepack7", "gsm_ms", "atrac3", "voxware", "nellymoser", "musepack8", "speex", "wmavoice", "wmapro", "wmalossless", "atrac3p", "sipr", "twinvq", "truehd", "mp4als", "atrac1", "binkaudio_rdft", "binkaudio_dct", "qdmc", "celt", "g723_1", "dss_sp", "g729", "bmv_audio", "ralf", "ilbc", "wavesynth", "sonic", "sonicls", "opus", "comfortnoise", "metasound", "paf_audio", "evrc", "dsd_lsbf", "dsd_msbf", "dsd_lsbf_planar", "dsd_msbf_planar", "dvd_subtitle", "dvb_subtitle", "xsub", "mov_text", "hdmv_pgs_subtitle", "dvb_teletext", "subrip", "microdvd", "mpl2", "eia_608", "jacosub", "sami", "realtext", "subviewer1", "subviewer", "vplayer", "webvtt", "hdmv_text_subtitle", "bintext", "xbin", "dvd_nav_packet", "timed_id3", "bin_data", "brender_pix_deprecated", "escape130_deprecated", "exr_deprecated", "g2m_deprecated", "hevc_deprecated", "paf_video_deprecated", "sanm_deprecated", "vp7_deprecated", "webp_deprecated", "adpcm_vima_deprecated", "opus_deprecated", "paf_audio_deprecated", "pcm_s24le_planar_deprecated", "pcm_s32le_planar_deprecated", "pcm_s16be_planar_deprecated", "tak_deprecated", "dump_extra", "GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "ImageWidth", "non_deterministic", "gifflags", "transdiff", "trans_color", "GEOV", "GEOX", "L263", "S263", "Q264", "is_avc", "nal_length_size", "enable_er", "Gray", "CABAC", "CAVLC", "LPAR", "CONSTR", "REDU", "TEMP", "SPAT", "apply_defdispwin", "hevc_mp4toannexb", "TRAIL_N", "TRAIL_R", "STSA_N", "STSA_R", "RADL_N", "RADL_R", "RASL_N", "RASL_R", "BLA_W_LP", "BLA_W_RADL", "BLA_N_LP", "IDR_W_RADL", "IDR_N_LP", "CRA_NUT", "EOS_NUT", "EOB_NUT", "FD_NUT", "SEI_PREFIX", "SEI_SUFFIX", "imxdump", "SEPB1", "SEPB2", "ZYGO", "libfdk_aac", "afterburner", "eld_sbr", "implicit", "explicit_sbr", "explicit_hierarchical", "header_period", "libwebp", "compression_level", "global_quality", "photo", "drawing", "cr_threshold", "cr_size", "Quality", "Lossy", "weightp", "deblock", "partitions", "baseline", "high10", "high422", "high444", "libx264rgb", "libx264", "ultrafast", "superfast", "veryfast", "faster", "slower", "veryslow", "placebo", "animation", "stillimage", "fastdecode", "zerolatency", "flags2", "i_qfactor", "b_qfactor", "qmin", "qdiff", "qblur", "qcomp", "sc_threshold", "trellis", "me_range", "me_method", "subq", "b_strategy", "keyint_min", "rc_init_occupancy", "tune", "fastfirstpass", "passlogfile", "wpredp", "x264opts", "crf_max", "aq_mode", "autovariance", "weightb", "smart", "b_pyramid", "mbtree", "cplxblur", "temporal", "tesa", "AVI1", "mjpeg2jpeg", "mjpg", "mjpegadump", "MJPG", "PRCT", "CJPG", "JFIF", "Adob", "LJIF", "xfrm", "_JPS", "AVID", "extern_huff", "mov2textsub", "text2movsub", "mp3decomp", "mpeg4_unpack_bframes", "ffmpeg", "XVID", "XVIX", "RMP4", "ZMP4", "SIPP", "DIVX", "UMP4", "WV1F", "QMP4", "Reserved", "MP4S", "divx_packed", "mpv_flags", "skip_rd", "strict_gop", "qp_rd", "cbp_rd", "luma_elim_threshold", "chroma_elim_threshold", "quantizer_noise_shaping", "error_rate", "qsquish", "rc_qmod_amp", "rc_qmod_freq", "rc_eq", "rc_init_cplx", "rc_buf_aggressivity", "border_mask", "ibias", "pbias", "rc_strategy", "motion_est", "epzs", "xone", "obmc", "structured_slices", "mb_info", "AVCodecContext", "AVFrame", "AVSubtitleRect", "unaligned", "input_preserved", "pass1", "pass2", "emu_edge", "truncated", "ildct", "low_delay", "global_header", "ilme", "output_corrupt", "noout", "ignorecrop", "local_header", "showall", "export_mvs", "skip_manual", "phods", "frame_number", "mv_bits", "header_bits", "i_tex_bits", "p_tex_bits", "i_count", "skip_count", "misc_bits", "frame_bits", "autodetect", "old_msmpeg4", "xvid_ilace", "ump4", "no_padding", "ac_vlc", "qpel_chroma", "std_qpel", "qpel_chroma2", "direct_blocksize", "hpel_chroma", "dc_clip", "trunc", "very", "b_qoffset", "has_b_frames", "block_align", "mpeg_quant", "rc_override_count", "maxrate", "minrate", "i_qoffset", "lumi_mask", "tcplx_mask", "scplx_mask", "p_mask", "dark_mask", "slice_count", "guess_mvs", "favor_inter", "bits_per_coded_sample", "median", "dct_coeff", "green_metadata", "startcode", "mmco", "vis_qp", "vis_mb_type", "buffers", "thread_ops", "nomc", "vismv", "debug_mv", "cmp_func", "subcmp", "mbcmp", "ildctcmp", "last_pred", "preme", "precmp", "satd", "vsad", "vsse", "nsse", "dctmax", "pre_dia_size", "dtg_active_format", "context", "slice_flags", "xvmc_acceleration", "stream_codec_tag", "me_threshold", "mb_threshold", "intra_dc_precision", "nssew", "skip_top", "skip_bottom", "aac_main", "aac_ssr", "aac_ltp", "aac_he_v2", "aac_ld", "aac_eld", "mpeg2_aac_low", "mpeg2_aac_he", "dts_es", "dts_96_24", "dts_hd_hra", "dts_hd_ma", "mpeg4_sp", "mpeg4_core", "mpeg4_main", "mpeg4_asp", "lowres", "skip_threshold", "skip_factor", "skip_exp", "skipcmp", "mblmin", "mblmax", "mepc", "skip_loop_filter", "avdiscard", "skip_idct", "skip_frame", "noref", "bidir", "nokey", "nointra", "bidir_refine", "brd_scale", "chromaoffset", "sc_factor", "mv0_threshold", "b_sensitivity", "min_prediction_order", "max_prediction_order", "timecode_frame_start", "request_channels", "bits_per_raw_sample", "request_channel_layout", "rc_max_vbv_use", "rc_min_vbv_use", "color_primaries", "color_primaries_type", "unspecified", "Unspecified", "bt470m", "Film", "bt2020", "color_trc", "color_trc_type", "gamma22", "gamma28", "Linear", "log_sqrt", "iec61966_2_4", "bt1361", "iec61966_2_1", "bt2020_10bit", "bt2020_12bit", "colorspace_type", "ycocg", "YCOCG", "bt2020_ncl", "bt2020_cl", "color_range", "color_range_type", "chroma_sample_location", "chroma_sample_location_type", "Left", "Center", "topleft", "bottomleft", "Bottom", "log_level_offset", "audio_service_type", "request_sample_fmt", "pkt_timebase", "sub_charenc", "sub_charenc_mode", "do_nothing", "pre_decoder", "refcounted_frames", "side_data_only_packets", "skip_alpha", "field_order", "best_effort_timestamp", "pkt_pos", "pkt_size", "sample_aspect_ratio", "forced", "MPNG", "WIDTH", "HEIGHT", "DEPTH", "MAXVAL", "TUPLTYPE", "TUPLETYPE", "ENDHDR", "iTex", "pTex", "fCode", "iCount", "mcVar", "avgQP", "avgIITex", "avgPITex", "avgPPTex", "avgBPTex", "avgTex", "bits2qp", "qp2bits", "I420", "IYUV", "YUNVw", "BGR0C", "remove_extra", "audioresample", "ReSampleContext", "unknown_codec", "swscaler", "SWScaler", "fast_bilinear", "bicubic", "bicublin", "gauss", "gaussian", "sinc", "lanczos", "print_info", "accurate_rnd", "full_chroma_int", "full_chroma_inp", "error_diffusion", "sws_dither", "a_dither", "x_dither", "alphablend", "uniform_color", "Gaussian", "Lanczos", "SWResampler", "in_channel_count", "out_channel_count", "used_channel_count", "internal_sample_fmt", "clev", "center_mix_level", "slev", "surround_mix_level", "lfe_mix_level", "rmvol", "rematrix_volume", "rematrix_maxval", "swr_flags", "dither_scale", "dither_method", "rectangular", "triangular_hp", "lipshitz", "low_shibata", "high_shibata", "f_weighted", "modified_e_weighted", "improved_e_weighted", "phase_shift", "linear_interp", "resample_cutoff", "resampler", "soxr", "cheby", "min_comp", "min_hard_comp", "comp_duration", "max_soft_comp", "first_pts", "matrix_encoding", "dolby", "dplii", "filter_type", "blackman_nuttall", "kaiser", "kaiser_beta", "output_sample_bits", "Features", "hexagonal", "octagonal", "hexadecagonal", "downmix", "LFE2", "cpuflags", "armv6t2", "vfpv3", "setend", "BSF_NOT_FOUND", "BUG2", "BUFFER_TOO_SMALL", "DECODER_NOT_FOUND", "DEMUXER_NOT_FOUND", "ENCODER_NOT_FOUND", "EXIT", "EXTERNAL", "FILTER_NOT_FOUND", "INPUT_CHANGED", "INVALIDDATA", "OPTION_NOT_FOUND", "PATCHWELCOME", "PROTOCOL_NOT_FOUND", "STREAM_NOT_FOUND", "UNKNOWN", "EXPERIMENTAL", "INPUT_AND_OUTPUT_CHANGED", "HTTP_BAD_REQUEST", "HTTP_UNAUTHORIZED", "HTTP_FORBIDDEN", "HTTP_NOT_FOUND", "HTTP_OTHER_4XX", "HTTP_SERVER_ERROR", "sinh", "cosh", "tanh", "atan", "acos", "isnan", "isinf", "while", "taylor", "floor", "ceil", "print", "hypot", "ifnot", "bitand", "bitor", "between", "Eval", "QP2LAMBDA", "FILE", "AVPanScan", "AVMatrixEncoding", "AVReplayGain", "YCgCo", "murmur3", "RIPEMD128", "RIPEMD160", "RIPEMD256", "RIPEMD320", "SHA160", "SHA224", "SHA256", "SHA384", "SHA512", "CRC32", "adler32", "IMGUTILS", "quiet", "fatal", "panic", "TERM", "NO_COLOR", "AV_LOG_FORCE_NOCOLOR", "AV_LOG_FORCE_COLOR", "AV_LOG_FORCE_256COLOR", "INT_MAX", "INT_MIN", "UINT32_MAX", "I64_MAX", "I64_MIN", "pixel", "bikeshed", "qntsc", "qpal", "sntsc", "spal", "sqcif", "qqvga", "svga", "qxga", "wvga", "wxga", "wsxga", "wuxga", "woxga", "wqsxga", "wquxga", "whsxga", "whuxga", "hd480", "hd1080", "hqvga", "fwqvga", "hvga", "uhd2160", "uhd4320", "AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "BlueViolet", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "CornflowerBlue", "Cornsilk", "Crimson", "DarkBlue", "DarkCyan", "DarkGoldenRod", "DarkGray", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "Darkorange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenRodYellow", "LightGreen", "LightGrey", "LightPink", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Maroon", "MediumAquaMarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "PaleGoldenRod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Plum", "PowderBlue", "RosyBrown", "RoyalBlue", "SaddleBrown", "SandyBrown", "SeaShell", "Sienna", "Silver", "Snow", "Teal", "Thistle", "Tomato", "Wheat", "WhiteSmoke", "YellowGreen", "yuvj", "bgra", "rgba", "rgb32", "bgr32", "bayer_", "yuv420p", "yuyv422", "rgb24", "bgr24", "yuv422p", "yuv444p", "yuv410p", "yuv411p", "monow", "monob", "yuvj420p", "yuvj422p", "yuvj444p", "xvmcmc", "xvmcidct", "uyvy422", "uyyvyy411", "bgr8", "bgr4", "bgr4_byte", "rgb8", "rgb4", "rgb4_byte", "nv12", "nv21", "argb", "abgr", "gray16be", "gray16le", "yuv440p", "yuvj440p", "yuva420p", "vdpau_h264", "vdpau_mpeg1", "vdpau_mpeg2", "vdpau_wmv3", "vdpau_vc1", "rgb48be", "rgb48le", "rgb565be", "rgb565le", "rgb555be", "rgb555le", "bgr565be", "bgr565le", "bgr555be", "bgr555le", "vaapi_moco", "vaapi_idct", "vaapi_vld", "yuv420p16le", "yuv420p16be", "yuv422p16le", "yuv422p16be", "yuv444p16le", "yuv444p16be", "vdpau_mpeg4", "dxva2_vld", "rgb444le", "rgb444be", "bgr444le", "bgr444be", "gray8a", "bgr48be", "bgr48le", "yuv420p9be", "yuv420p9le", "yuv420p10be", "yuv420p10le", "yuv422p10be", "yuv422p10le", "yuv444p9be", "yuv444p9le", "yuv444p10be", "yuv444p10le", "yuv422p9be", "yuv422p9le", "vda_vld", "gbrp", "gbrp9be", "gbrp9le", "gbrp10be", "gbrp10le", "gbrp16be", "gbrp16le", "yuva420p9be", "yuva420p9le", "yuva422p9be", "yuva422p9le", "yuva444p9be", "yuva444p9le", "yuva420p10be", "yuva420p10le", "yuva422p10be", "yuva422p10le", "yuva444p10be", "yuva444p10le", "yuva420p16be", "yuva420p16le", "yuva422p16be", "yuva422p16le", "yuva444p16be", "yuva444p16le", "vdpau", "xyz12le", "xyz12be", "nv16", "nv20le", "nv20be", "yvyu422", "ya16be", "ya16le", "mmal", "d3d11va_vld", "rgba64be", "rgba64le", "bgra64be", "bgra64le", "rgb0", "bgr0", "yuva444p", "yuva422p", "yuv420p12be", "yuv420p12le", "yuv420p14be", "yuv420p14le", "yuv422p12be", "yuv422p12le", "yuv422p14be", "yuv422p14le", "yuv444p12be", "yuv444p12le", "yuv444p14be", "yuv444p14le", "gbrp12be", "gbrp12le", "gbrp14be", "gbrp14le", "gbrap", "gbrap16be", "gbrap16le", "yuvj411p", "bayer_bggr8", "bayer_rggb8", "bayer_gbrg8", "bayer_grbg8", "bayer_bggr16le", "bayer_bggr16be", "bayer_rggb16le", "bayer_rggb16be", "bayer_gbrg16le", "bayer_gbrg16be", "bayer_grbg16le", "bayer_grbg16be", "yuv440p10le", "yuv440p10be", "yuv440p12le", "yuv440p12be", "ayuv64le", "ayuv64be", "videotoolbox_vld", "log100", "log316", "bt1361e", "ycgco", "bt2020nc", "bt2020c", "s16p", "s32p", "fltp", "dblp", "IPBSipb", "attachment", "fffffff", "x00000x", "p000x", "p00000x", "p000x", "p000x", "p000x", "error", "warning", "info", "debug", "unknown", "true", "false", "auto", "threads", "deterministic", "level", "overscan", "videoformat", "fullrange", "colorprim", "transfer", "colormatrix", "chromaloc", "frameref", "scenecut", "bframes", "filter", "deblock", "slices", "cabac", "interlaced", "flat", "cqmfile", "cqm4", "cqm8", "cqm4i", "cqm4p", "cqm4iy", "cqm4ic", "cqm4py", "cqm4pc", "cqm8i", "cqm8p", "analyse", "partitions", "i4x4", "i8x8", "p8x8", "p4x4", "b8x8", "weightb", "weightp", "direct", "merange", "mvrange", "subme", "subq", "trellis", "bitrate", "qp_constant", "qpmin", "qpmax", "qpstep", "ratetol", "ipratio", "pbratio", "pass", "stats", "qcomp", "mbtree", "qblur", "cplxblur", "zones", "psnr", "ssim", "annexb", "filler", "stitchable", "opencl", "baseline", "main", "high", "high10", "high422", "high444", "ultrafast", "superfast", "veryfast", "faster", "medium", "slower", "veryslow", "placebo", "film", "animation", "grain", "stillimage", "fastdecode", "zerolatency", "touhou", "fake", "none", "bt709", "undef", "bt470bg", "smpte170m", "smpte240m", "YCgCo", "bt2020nc", "bt2020c", "smpte2085", "bt470m", "linear", "log100", "log316", "bt1361e", "smpte2084", "smpte428", "bt2020", "smpte431", "smpte432", "component", "ntsc", "secam", "show", "crop", "strict", "normal", "tesa", "spatial", "temporal", "left", "Main", "High", "SSE2", "SSE3", "BMI1", "uvDC", "uvAC", "f4b6c29ca248858bb7177e64694e42a8", "clBuildProgram", "clCreateBuffer", "clCreateCommandQueue", "clCreateContext", "clCreateImage2D", "clCreateKernel", "clCreateProgramWithBinary", "clCreateProgramWithSource", "clEnqueueCopyBuffer", "clEnqueueMapBuffer", "clEnqueueNDRangeKernel", "clEnqueueReadBuffer", "clEnqueueWriteBuffer", "clFinish", "clGetCommandQueueInfo", "clGetDeviceIDs", "clGetDeviceInfo", "clGetKernelWorkGroupInfo", "clGetPlatformIDs", "clGetProgramBuildInfo", "clGetProgramInfo", "clGetSupportedImageFormats", "clReleaseCommandQueue", "clReleaseContext", "clReleaseKernel", "clReleaseMemObject", "clReleaseProgram", "clSetKernelArg", "ADL_Main_Control_Create", "ADL_Main_Control_Destroy", "ADL_Adapter_NumberOfAdapters_Get", "ADL_PowerXpress_Scheme_Get", "mb_intra_cost_satd_8x8", "sum_intra_cost", "downscale_hpel", "downscale1", "downscale2", "memset_int16", "weightp_scaled_images", "weightp_hpel", "hierarchical_motion", "subpel_refine", "mode_selection", "sum_inter_cost", "ARMv6", "NEON", "FastNeonMRC", "INTRA4X4_LUMA", "INTER4X4_LUMA", "INTRA4X4_CHROMA", "INTER4X4_CHROMA", "INTRA8X8_LUMA", "INTER8X8_LUMA", "INTRA8X8_CHROMA", "INTER8X8_CHROMA", "init_pass2", "x264_ratecontrol_start", "underflow", "overflow", "RIFF", "WEBPVP8L", "getauxval", "vfpv3d16", "vfpv4", "idiva", "idivt", "idiv", "iwmmxt", "Hardware", "Goldfish", "Processor"], "debugstrings": ["Unsupported file version - %d.%02d\n", "Unsupported tag version. (>=%d)\n", "ffconcat version 1.0", "Line %d: invalid version\n", "configurationVersion:                %u\n", "EBML header using unsupported features\n(EBML version %llu, doctype %s, doc version %llu)\n", "sidx version %u", "minor_version", "Version %d", "premiere_version", "quicktime_version", "version =%d, isom =%d\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n", "sid=0x%x sec_num=%d/%d version=%d\n", "ogg page, unsupported version\n", "Unknown skeleton version %d.%d\n", "Unknown OggVP8 version %d.%d\n", "Unsupported version\n", "Unsupported Name value property version\n", "Unknown SMV version found\n", "Uncommon version %u", "FFmpeg version 2.8.7", "Color conversion not implemented for %s\n", "Impossible to create scale context for the conversion fmt:%s s:%dx%d -> fmt:%s s:%dx%d\n", "error calculating conversion coefficients\n", "Timebase conversion is not exact\n", "GPSVersionID", "Using libwebp for RGB-to-YUV conversion. You may want to consider passing in YUV instead for lossy encoding.\n", "Using libwebp for YUV-to-RGB conversion. You may want to consider passing in RGB instead for lossless encoding.\n", "mjpeg: JFIF header found (version: %x.%x) SAR=%d/%d\n", "Intel(R) JPEG Library, version 1", "range <= 16 || !s->msmpeg4_version", "bugs: %X lavc_build:%d xvid_build:%d divx_version:%d divx_build:%d %s\n", "old standard qpel (autodetected per FOURCC/version)", "direct-qpel-blocksize bug (autodetected per FOURCC/version)", "edge padding bug (autodetected per FOURCC/version)", "strictly conform to a older more strict version of the spec or reference software", "Extradata version %d", "Audio sample format conversion failed\n", "FFmpeg version 2.8.7", "Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\n", "Old WMV3 version detected, some frames may be decoded incorrectly\n", "unsupported conversion to planar RGB %s -> %s\n", "unsupported bayer conversion\n", "No accelerated colorspace conversion found from %s to %s.\n", "FFmpeg version 2.8.7", "FFmpeg version 2.8.7", "GCC: (GNU) 4.6 20120106 (prerelease)", "GCC: (GNU) 4.8", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3", "GCC: (GNU) 4.4.3"], "localsymbols": [""], "dependencies": ["libstdc++.so", "liblog.so", "libdl.so", "libm.so", "libc.so", "libz.so"], "elfname": "libffmpeg.so"}