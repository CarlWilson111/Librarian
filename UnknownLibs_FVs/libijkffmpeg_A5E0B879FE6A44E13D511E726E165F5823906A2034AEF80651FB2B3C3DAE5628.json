{"globalvars": ["x264_hpel_ref0", "ff_vf_deband", "ff_mba_max", "ff_vf_decimate", "ff_vf_framestep", "rgb15to16", "avpriv_cga_font", "av_reverse", "ff_flv_demuxer", "ff_mpeg12_vlc_dc_lum_bits", "ff_af_asetpts", "ff_vf_transpose", "ff_mpeg4_decoder", "ff_vf_reverse", "ff_dither4", "av_sha512_size", "uyvytoyuv420", "ff_avio_class", "ff_h263_parser", "av_md5_size", "ff_af_aselect", "ff_cos_1024", "rgb16to15", "ff_pw_1023", "ff_vsrc_smptehdbars", "ff_mp3_muxer", "ff_crop_tab", "ff_vf_fifo", "ff_cos_256_fixed", "ff_image_sgi_pipe_demuxer", "ff_M24C", "ff_wmv1_encoder", "ff_dither_8x8_32", "av_util_ffversion", "ff_aac_pow2sf_tab", "ff_hls_protocol", "ff_pw_20", "ff_avf_aphasemeter", "ff_interleaved_ue_golomb_vlc_code", "ff_vf_fps", "ff_pw_9", "ff_swb_offset_512", "ff_tns_max_bands_1024", "ff_vf_setdar", "ff_vf_qp", "ff_sine_512", "ff_aac_eld_window_512_fixed", "x264_cache_mv_func_table", "ff_af_aperms", "ff_vf_hqdn3d", "ff_pw_5", "ff_dither_4x4_16", "rgb24tobgr24", "ff_pb_FC", "ff_af_biquad", "ff_pw_42", "ff_pw_1024", "ff_af_ashowinfo", "ff_af_join", "ff_id3v2_3_tags", "ff_af_atrim", "ff_vf_drawgraph", "ff_asrc_anullsrc", "ff_vf_hflip", "ff_rl_mpeg1", "ff_pw_8192", "rgb16to32", "ff_vf_pad", "ff_vsink_nullsink", "ff_sine_2048", "ff_vf_repeatfields", "planar2x", "ff_mpeg1_default_non_intra_matrix", "x264_total_zeros_2x2_dc", "ff_vf_hqx", "ff_vf_lut3d", "ff_vf_framepack", "yuyvtoyuv422", "ff_vf_drawgrid", "x264_bit_depth", "ff_sin_512", "ff_vf_framerate", "ff_msmpeg4v2_encoder", "ff_image2_muxer", "ff_log2_run", "ff_ipod_muxer", "ff_sine_64", "ff_h263_loop_filter_strength", "ff_flv_muxer", "ff_h263_hwaccel_pixfmt_list_420", "ff_cos_2048", "ff_mpegts_muxer", "ff_ac3_bitrate_tab", "ff_sine_8192_fixed", "ff_h264_decoder", "ff_vf_deshake", "ff_vf_dejudder", "ff_sin_4096", "ff_cos_256", "ff_latm_demuxer", "ff_cos_2048_fixed", "ff_sine_32", "ff_vsrc_nullsrc", "ff_pw_2", "ff_swb_offset_1024", "avpriv_mjpeg_val_ac_chrominance", "ff_h263p_decoder", "ff_vsink_buffer", "ff_aac_kbd_long_1024", "ff_sin_2048", "ff_mpeg12_mbPatTable", "ff_vf_edgedetect", "ff_asrc_sine", "ff_dc_lum_vlc", "shuffle_bytes_2103", "rgb32tobgr24", "ff_af_volumedetect", "ff_ac3_sample_rate_tab", "ff_file_protocol", "ff_sine_256_fixed", "ff_interleaved_dirac_golomb_vlc_code", "ff_mba_length", "ff_libx264rgb_encoder", "ff_interleaved_se_golomb_vlc_code", "av_tea_size", "avpriv_ac3_channel_layout_tab", "ff_mpeg4audio_channels", "ff_eac3_default_cpl_band_struct", "swr_ffversion", "ff_pb_15", "ff_dither_8x8_73", "ff_M24B", "x264_hpel_ref1", "ff_vf_uspp", "ff_vf_drawbox", "ff_rtmpe_protocol", "ff_mpa_synth_window_float", "ff_vf_negate", "ff_sine_128_fixed", "ff_png_encoder", "ff_vf_perms", "ff_vf_find_rect", "ff_vf_settb", "ff_vf_super2xsai", "av_aes_size", "ff_af_ebur128", "ff_mbincr_vlc", "deinterleaveBytes", "ff_h264_parser", "ff_vsrc_allrgb", "avpriv_mjpeg_val_ac_luminance", "av_sha_size", "ff_aac_codebook_vectors", "ff_aac_kbd_short_128_fixed", "ff_avf_adrawgraph", "ff_aac_kbd_long_1024_fixed", "ff_vf_signalstats", "ff_h263_intra_MCBPC_bits", "ff_vf_dctdnoiz", "ff_mpegtsraw_demuxer", "ff_af_amix", "ff_image_jpegls_pipe_demuxer", "ff_af_apad", "ff_dither_2x2_8", "ff_mp4_muxer", "ff_dither_8x8_128", "ff_image_webp_pipe_demuxer", "rgb24tobgr32", "ff_vf_spp", "shuffle_bytes_0321", "ff_vf_kerndeint", "ff_codec_movvideo_tags", "ff_id3v2_34_metadata_conv", "ff_mpeg1_dc_scale_table", "ff_inter_level", "ff_adts_muxer", "ff_fft_offsets_lut", "ff_vf_colorkey", "ff_aac_codebook_vector_idx", "ff_af_silenceremove", "ff_pb_0", "ff_codec_bmp_tags", "ff_reverse", "ff_sprite_trajectory_tab", "rgb24tobgr16", "ff_af_lowpass", "ff_mpegvideo_parser", "ff_mpeg2_aspect", "ff_mp4_obj_type", "ff_rl_mpeg2", "interleaveBytes", "av_pix_fmt_descriptors", "ff_bgr2YOffset", "ff_af_highpass", "ff_vf_split", "ff_mjpeg_demuxer", "ff_cos_64", "ff_vf_psnr", "ff_swb_offset_128", "x264_log2_lut", "ff_vf_mergeplanes", "ff_vf_overlay", "ff_h263_inter_MCBPC_code", "ff_af_bass", "ff_id3v2_4_metadata_conv", "ff_vf_sendcmd", "ff_ac3_rematrix_band_tab", "ff_vf_vignette", "ff_aac_num_swb_480", "ff_vf_extractplanes", "ff_tns_max_bands_512", "av_cast5_size", "ff_rtmpte_protocol", "ff_add_pixels_clamped", "ff_codec_movsubtitle_tags", "ff_vf_owdenoise", "ff_pw_64", "ff_avf_showwaves", "ff_vf_rotate", "ff_cos_65536", "x264_last_coeff_flag_offset_8x8", "ff_sine_2048_fixed", "avpriv_mjpeg_bits_dc_chrominance", "ff_cos_64_fixed", "ff_vf_telecine", "ff_af_asyncts", "ff_ac3_enc_channel_map", "ff_h264_demuxer", "ff_pb_FE", "avpriv_mjpeg_bits_ac_chrominance", "x264_decimate_table4", "ff_sin_65536", "ff_pw_1019", "ff_pw_8", "ff_aac_latm_parser", "avpriv_vga16_font", "yv12touyvy", "ff_mpeg4_intra_run", "ff_mpeg4_dc_threshold", "ff_vsrc_cellauto", "x264_total_zeros", "ff_aac_swb_size_128", "ff_af_afade", "ff_hls_demuxer", "ff_sine_windows", "ff_mp3_decoder", "ff_mpeg4_default_non_intra_matrix", "ff_put_pixels_clamped", "ff_aac_spectral_sizes", "rgb24to15", "ff_vsrc_testsrc", "ff_vf_cover_rect", "ff_png_pass_ymask", "ff_vf_random", "ff_sbr_noise_table", "ff_vf_geq", "ff_bgr2UVOffset", "ff_mdct_win_float", "ff_msmpeg4v3_encoder", "x264_count_cat_m1", "x264_weight_none", "ff_vf_showpalette", "ff_aac_adtstoasc_bsf", "ff_image_qdraw_pipe_demuxer", "ff_image_dpx_pipe_demuxer", "ff_wav_muxer", "ff_sine_4096", "yuyvtoyuv420", "ff_mjpeg_muxer", "ff_mpeg12_vlc_dc_lum_code", "ff_vf_blackframe", "rgb24to16", "yuv422ptoyuy2", "ff_vf_codecview", "ff_mpeg12_static_rl_table_store", "ff_cos_4096_fixed", "ff_wav_demuxer", "ff_vf_deflate", "ff_mpegts_demuxer", "ff_aac_spectral_codes", "ff_vf_pixdesctest", "ff_aac_scalefactor_bits", "ff_af_sidechaincompress", "ff_aac_pow34sf_tab", "ff_vf_tblend", "ff_cos_128_fixed", "avfilter_all_channel_layouts", "ff_vf_lut", "x264_dct4_weight_tab", "ff_dither8", "ff_aac_swb_size_128_len", "x264_iter_kludge", "postproc_ffversion", "rgb16tobgr24", "ff_af_bandpass", "ff_ac3_log_add_tab", "ff_id3v2_4_tags", "ff_mpeg4video_parser", "ff_vf_sab", "ff_vf_vectorscope", "ff_af_acrossfade", "ff_vf_colorbalance", "ff_af_areverse", "ff_aac_scalefactor_code", "ff_m4v_demuxer", "ff_golomb_vlc_len", "ff_af_volume", "ff_ac3_dec_channel_map", "ff_af_resample", "ff_cos_16", "ff_af_pan", "ff_pd_1", "ff_h263_cbpy_vlc", "ff_codec_movaudio_tags", "avpriv_mpa_freq_tab", "avpriv_pix_fmt_bps_avi", "rgb32tobgr15", "ff_sin_256", "ff_pw_128", "av_camellia_size", "ff_af_channelsplit", "ff_h263_rl_inter", "ff_vf_colormatrix", "x264_dct8_weight2_tab", "ff_ac3_slow_gain_tab", "ff_latm_muxer", "ff_aac_latm_decoder", "ff_flv_encoder", "ff_vf_setsar", "ff_vf_boxblur", "ff_af_equalizer", "yv12toyuy2", "ff_ac3_bap_tab", "ff_cos_tabs_fixed", "ff_yuv2rgb_coeffs", "ff_log2_tab", "ff_sin_32", "ff_ue_golomb_vlc_code", "ff_vf_format", "ff_ac3_fast_decay_tab", "avpriv_mjpeg_bits_ac_luminance", "x264_cache_mvd_func_table", "ff_swb_offset_480", "ff_vf_elbg", "ff_af_aresample", "ff_w_tab_sr", "ff_image_dds_pipe_demuxer", "pp_help", "ff_vf_shuffleplanes", "x264_lambda2_tab", "ff_asink_ffabuffersink", "ff_af_dcshift", "x264_log2_lz_lut", "ff_vf_stereo3d", "ff_dither_2x2_4", "ff_vf_removegrain", "ff_vf_xbr", "ff_h263_intra_MCBPC_vlc", "ff_h263_inter_MCBPC_vlc", "ff_mpegvideo_demuxer", "ff_cos_8192_fixed", "ff_af_ainterleave", "ff_vf_mpdecimate", "ff_aac_codebook_vector_vals", "ff_alternate_horizontal_scan", "ff_vf_smartblur", "ff_mpeg4_rl_intra", "ff_vf_removelogo", "ff_vsink_ffbuffersink", "ff_aac_kbd_short_128", "ff_aac_demuxer", "ff_cos_16384", "ff_vf_lutrgb", "ff_image_pictor_pipe_demuxer", "ff_image2_demuxer", "ff_h263_inter_MCBPC_bits", "ff_mov_muxer", "ff_af_asetrate", "ff_mpeg12_vlc_dc_chroma_bits", "ff_pb_3", "ff_cos_512", "ff_vsrc_buffer", "ff_pw_17", "ff_vf_select", "ff_cos_1024_fixed", "rgb15tobgr24", "ff_avf_showvolume", "x264_coeff_abs_level_m1_offset", "ff_aac_swb_size_1024_len", "ff_vf_erosion", "ff_vf_inflate", "ff_sine_8192", "ff_aanscales", "x264_dct4_weight2_tab", "ff_ac3_hearing_threshold_tab", "ff_vf_tinterlace", "x264_run_before", "ff_rgb24toyv12", "ff_pw_96", "ff_vf_idet", "ff_cos_32768", "x264_cabac_range_lps", "ff_avf_concat", "ff_ac3_fast_gain_tab", "ff_inter_run", "ff_tns_max_bands_480", "uyvytoyuv422", "x264_lambda_tab", "ff_vf_alphamerge", "x264_coeff_flag_offset_chroma_422_dc", "ff_af_replaygain", "ff_libx264_encoder", "ff_sine_256", "ff_ac3_window", "av_tree_node_size", "ff_vf_mcdeint", "ff_mpv_generic_options", "ff_mpeg4_default_intra_matrix", "x264_levels", "ff_af_aecho", "ff_pw_18", "ff_vf_trim", "ff_vf_palettegen", "ff_vf_showinfo", "ff_vf_atadenoise", "ff_vf_histogram", "ff_vf_interlace", "ff_ac3_floor_tab", "ff_sine_64_fixed", "ff_mpegaudio_parser", "ff_mpa_sblimit_table", "av_format_ffversion", "avpriv_mjpeg_bits_dc_luminance", "ff_h264_cabac_tables", "ff_asrc_aevalsrc", "ff_mb_btype_vlc", "ff_aac_parser", "ff_af_silencedetect", "ff_af_chorus", "ff_h263_intra_MCBPC_code", "ff_vf_cropdetect", "ff_mpa_quant_bits", "ff_default_chroma_qscale_table", "ff_image_bmp_pipe_demuxer", "ff_af_astreamsync", "ff_sin_16384", "ff_af_dynaudnorm", "ff_af_amerge", "ff_aac_eld_window_480_fixed", "ff_vf_colorlevels", "ff_sine_windows_fixed", "ff_h263i_decoder", "ff_sin_16", "ff_mvtab", "ff_vf_histeq", "ff_riff_info_conv", "ff_mpeg4_intra_level", "ffurl_context_class", "ff_vf_scale", "rgb32to16", "ff_mp3_demuxer", "ff_pw_255", "ff_h264_muxer", "ff_vsrc_life", "ff_pcm_s16le_decoder", "ff_mpa_alloc_tables", "ff_aac_eld_window_512", "ff_vsrc_mptestsrc", "ff_mpeg4_c_dc_scale_table", "ff_vf_interleave", "ff_af_afifo", "ff_vf_fftfilt", "ff_mpa_enwindow", "ff_mov_demuxer", "ff_dc_chroma_vlc", "yuv422ptouyvy", "x264_cabac_transition", "ff_af_asendcmd", "ff_h263_static_rl_table_store", "ff_h263_encoder", "ff_http_protocol", "ff_sqrt_tab", "ff_img_options", "ff_ue_golomb_len", "ff_vf_crop", "ff_w1111", "ff_codec_wav_guids", "ff_avf_showcqt", "x264_level_token", "ff_pw_4096", "ff_vf_ssim", "swri_resampler", "ff_vf_haldclut", "ff_ps_neg", "ff_sin_1024", "ff_aac_num_swb_128", "ff_aac_swb_size_1024", "ff_af_treble", "ff_tns_max_bands_128", "ff_flv_decoder", "ff_mpeg12_mbAddrIncrTable", "ff_af_bandreject", "ff_se_golomb_vlc_code", "ff_pw_32", "ff_vf_fspp", "ff_ac3_frame_size_tab", "ff_cbpc_b_tab", "ff_af_channelmap", "ff_rtmp_protocol", "ff_af_asettb", "ff_concat_protocol", "ff_af_flanger", "ff_ac3_db_per_bit_tab", "ff_pw_m1", "x264_cabac_transition_unary", "x264_total_zeros_2x4_dc", "ff_zigzag_direct", "ff_af_aformat", "avpriv_pix_fmt_bps_mov", "ff_image_tiff_pipe_demuxer", "ff_mpa_synth_window_fixed", "ff_id3v2_mime_tags", "ff_mpa_quant_steps", "ff_dither_8x8_220", "ff_cos_16384_fixed", "ff_vf_separatefields", "ff_af_earwax", "avpriv_mpa_bitrate_tab", "ff_aac_encoder", "ff_vf_fade", "ff_mb_pat_vlc", "ff_mb_ptype_vlc", "av_ripemd_size", "x264_exp2_lut", "ff_mpeg1_aspect", "ff_vf_il", "ff_h263_format", "ff_ac3_channels_tab", "ff_h263_mbtype_b_tab", "ff_avf_showwavespic", "ff_h263p_encoder", "ff_vsrc_smptebars", "ff_vf_w3fdif", "ff_sine_512_fixed", "ff_vf_fieldmatch", "ff_aac_psy_model", "ff_aic_dc_scale_table", "ff_vsrc_haldclutsrc", "ff_h264_mp4toannexb_bsf", "av_twofish_size", "ff_aac_coders", "ff_vf_blackdetect", "ff_pw_16", "ff_mpeg4_resync_prefix", "ff_vf_eq", "ff_pw_2048", "ff_sine_4096_fixed", "ff_cos_65536_fixed", "ff_cos_4096", "ff_vf_phase", "avpriv_mpeg4audio_sample_rates", "ff_codec_wav_tags", "rgb24tobgr15", "ff_af_aeval", "ff_vsrc_color", "ff_cos_16_fixed", "x264_significant_coeff_flag_offset_8x8", "av_filter_ffversion", "ff_aac_spectral_bits", "ff_id3v1_genre_str", "ff_rl_intra_aic", "ff_af_asplit", "ff_vf_perspective", "ff_mpeg4_y_dc_scale_table", "x264_decimate_table8", "ff_live_flv_demuxer", "ff_vf_field", "ff_asink_anullsink", "yvu9_to_yuy2", "ff_vf_delogo", "ff_inter_vlc", "ff_mjpeg_encoder", "ff_mpeg12_vlc_dc_chroma_code", "ff_vf_setfield", "ff_mjpeg_decoder", "ff_pw_1", "ff_image_sunrast_pipe_demuxer", "ff_pw_15", "ff_vf_swapuv", "ff_aac_decoder", "ff_cos_32768_fixed", "ff_vf_pullup", "ff_sin_64", "rgb32tobgr16", "ff_pw_256", "ff_vf_waveform", "ff_mpeg4_static_rl_table_store", "ff_aac_pred_sfb_max", "ff_avf_avectorscope", "x264_cabac_size_unary", "ff_vf_bbox", "ff_avsrc_movie", "x264_cpu_names", "ff_af_atempo", "ff_pw_3", "ff_vf_setpts", "ff_vf_gradfun", "ff_af_anull", "x264_cabac_entropy", "ff_apng_encoder", "rgb32to15", "ff_cos_8192", "x264_cabac_contexts", "ff_M24A", "ff_vf_hue", "x264_cache_ref_func_table", "ff_cos_tabs", "ff_sin_32768", "ff_vf_vstack", "ff_avf_showspectrum", "ff_vf_fieldorder", "ff_vf_vflip", "ff_image_jpeg_pipe_demuxer", "ff_vf_unsharp", "ff_sin_8192", "ff_mpeg4_DCtab_chrom", "ff_inverse", "ff_af_allpass", "ff_af_adelay", "ff_h264_chroma_qp", "x264_coeff0_token", "ff_vf_dilation", "ff_pb_2", "ff_cos_128", "ff_mb_type_b_tab", "ff_sin_128", "ff_rvlc_rl_intra", "ff_aac_num_swb_1024", "ff_raw_pix_fmt_tags", "ff_network_inited_globally", "ff_vf_lutyuv", "x264_cabac_renorm_shift", "ff_interleaved_golomb_vlc_len", "avpriv_mjpeg_val_dc", "ff_vf_copy", "ff_vf_detelecine", "ff_vf_blend", "ff_image_j2k_pipe_demuxer", "ff_id3v2_tags", "sws_context_class", "ff_vf_tile", "ff_h263_pixel_aspect", "ff_mpeg12_mbMotionVectorTable", "ff_pw_4", "ff_h263_decoder", "ff_square_tab", "rgb15to32", "ff_mpeg4_DCtab_lum", "ff_mpeg4_encoder", "ff_vf_hstack", "ff_pb_1", "ff_rvlc_rl_inter", "ff_sine_1024", "ff_avcodec_locked", "ff_alternate_vertical_scan", "x264_coeff_token", "ff_image_exr_pipe_demuxer", "x264_last_coeff_flag_offset", "ff_sine_1024_fixed", "yuy2toyv12", "ff_h263_chroma_qscale_table", "ff_pb_80", "ff_rtmpt_protocol", "ff_af_asetnsamples", "ff_vf_null", "ff_ac3_slow_decay_tab", "ff_pw_512", "ff_png_decoder", "ff_af_compand", "ff_vf_noformat", "x264_significant_coeff_flag_offset", "ff_mpeg4_intra_vlc", "ff_af_aphaser", "ff_vf_pp7", "ff_cos_32", "x264_dct8_weight_tab", "ff_rawvideo_options", "ff_vf_thumbnail", "ff_pw_53", "ff_rtmpts_protocol", "ff_mdct_win_fixed", "ff_cos_512_fixed", "ff_vf_lenscorrection", "x264_chroma_format", "ff_vf_noise", "ff_aac_num_swb_512", "ff_vf_zoompan", "ff_inv_aanscales", "ff_vf_scale2ref", "ff_cos_32_fixed", "ff_vsrc_mandelbrot", "ff_h264_mb_sizes", "av_codec_ffversion", "ff_asrc_abuffer", "ff_vf_colorchannelmixer", "ff_sine_128", "ff_concat_demuxer", "ff_aac_eld_window_480", "ff_avf_showfreqs", "ff_mv_vlc", "ff_vf_pp", "ff_mpeg12_frame_rate_tab", "ff_image_png_pipe_demuxer", "ff_mpeg2_frame_rate_tab", "ff_avsrc_amovie", "ff_eac3_default_chmap", "ff_vf_yadif", "ff_tcp_protocol", "ff_af_astats", "ff_sine_32_fixed", "ff_vf_paletteuse", "ff_id3v2_picture_types", "ff_rtmps_protocol", "ff_h263_cbpy_tab", "ff_vf_alphaextract", "ff_mpeg1_default_intra_matrix", "ff_vsrc_rgbtestsrc", "ff_mpeg2_dc_scale_table", "ff_asink_abuffer", "ff_vf_curves", "vu9_to_vu12", "ff_vsrc_allyuv", "ff_modified_quant_tab"], "importedglobals": ["__sF"], "importedfunctions": ["cbrt", "strtod", "strncpy", "fgets", "deflate", "setsockopt", "sscanf", "cosh", "read", "inflateInit_", "asin", "mktime", "mprotect", "rename", "strncasecmp", "deflateEnd", "deflateBound", "strcasecmp", "pthread_mutex_destroy", "atan2", "pthread_cond_wait", "memcmp", "fwrite", "fprintf", "vsnprintf", "madvise", "tanh", "strcpy", "time", "strftime", "__stack_chk_fail", "fputs", "floor", "opendir", "__assert2", "printf", "realloc", "uncompress", "strdup", "qsort", "readdir", "unlink", "fseeko", "__errno", "strchr", "munmap", "inflateInit2_", "gai_strerror", "sinf", "getaddrinfo", "pthread_create", "pow", "pthread_mutex_lock", "freeaddrinfo", "acos", "strtol", "stat", "recv", "strpbrk", "cbrtf", "atan2f", "inflateEnd", "fabs", "memchr", "cos", "strerror_r", "free", "frexp", "gettimeofday", "fcntl", "sprintf", "write", "pthread_cond_broadcast", "listen", "logf", "isatty", "pthread_cond_signal", "fputc", "log", "dlopen", "atanf", "socket", "strncmp", "round", "getsockopt", "clock", "bind", "tan", "strtoul", "strtok_r", "exp", "isnanf", "fclose", "__isinf", "zlibCompileFlags", "exp2f", "strlen", "deflateReset", "inflate", "pthread_mutex_unlock", "fread", "dlclose", "inet_ntop", "pthread_cond_init", "strcspn", "modf", "erf", "getenv", "sin", "closedir", "memcpy", "atoi", "memmove", "ftello", "sysconf", "abort", "deflateInit2_", "send", "open", "nice", "pthread_mutex_init", "rewind", "localtime_r", "access", "fopen", "exp2", "strrchr", "memalign", "atan", "pthread_cond_destroy", "close", "connect", "hypot", "fstat", "inet_aton", "shutdown", "dlsym", "pthread_join", "sinh", "ldexp", "nanosleep", "accept", "log10", "ceil", "expf", "mmap", "bsearch", "fdopen", "strstr", "snprintf", "strtok", "memset", "lseek64", "powf", "strspn", "clock_gettime", "vfprintf", "__isfinite", "lstat", "cosf", "poll", "mkstemp", "strcmp", "gmtime_r", "rmdir", "strtoll"], "exportedfunctions": ["avformat_alloc_output_context2", "ff_audio_convert_set_func", "avcodec_decode_audio3", "ff_h264_get_profile", "ff_codec_open2_recursive", "x264_predict_16x16_p_c", "avfilter_pad_count", "swri_rematrix_init", "ff_jpeg_fdct_islow_10", "ff_init_scantable_permutation", "ff_h264_hl_decode_mb", "ff_h264_reset_sei", "rgb64to48_nobswap", "av_opt_serialize", "x264_quant_4x4_trellis", "ff_dv_frame_profile", "ff_init_ff_cos_tabs_fixed_32", "ff_mov_add_hinted_packet", "x264_predict_8x8c_h_c", "ff_check_h264_startcode", "x264_sei_frame_packing_write", "av_image_fill_arrays", "ff_getSwsFunc", "av_codec_get_max_lowres", "ff_request_frame", "x264_ratecontrol_delete", "av_hmac_final", "av_tree_find", "x264_frame_expand_border_lowres", "x264_sei_dec_ref_pic_marking_write", "ff_amf_read_null", "av_channel_layout_extract_channel", "ff_put_h264_qpel16_mc32_10_mmxext", "x264_cabac_encode_terminal_c", "ff_make_absolute_url", "ff_draw_supported_pixel_formats", "av_opt_freep_ranges", "av_log", "x264_predict_8x8c_v_c", "x264_noise_reduction_update", "ff_put_qpel8_mc31_old_c", "avformat_open_input", "ff_pred_weight_table", "x264_macroblock_cache_free", "av_fifo_realloc2", "ff_audio_convert_alloc", "avfilter_transform", "avio_rb24", "ff_fdct_ifast", "ff_dct_encode_init", "ff_h263_show_pict_info", "ff_rtmp_packet_read", "av_isxdigit", "ff_h264_idct_add16intra_9_c", "av_image_fill_linesizes", "ff_iso8601_to_unix_time", "sws_cloneVec", "ff_audio_data_init", "av_vorbis_parse_frame", "avpriv_mpegts_parse_packet", "av_fifo_generic_peek", "ff_simple_idct84_add", "av_dct_calc", "ffurl_open", "av_register_output_format", "ff_avg_h264_qpel16_mc31_10_mmxext", "sws_convertPalette8ToPacked24", "ff_sws_init_swscale_x86", "ff_isom_write_hvcc", "avformat_match_stream_specifier", "ff_h264_idct8_add4_10_c", "ff_make_format_list", "sws_getCoefficients", "ff_h263_decode_init_vlc", "av_reduce", "av_crc_init", "ff_id3v1_read", "ff_aac_encode_tns_info", "x264_sei_avcintra_vanc_write", "av_bprint_init", "ff_mpeg4_get_video_packet_prefix_length", "ff_h264_idct_add8_422_10_c", "ff_set_ref_count", "ff_avfilter_default_free_buffer", "avresample_is_open", "av_realloc", "av_opt_free", "x264_sei_version_write", "av_samples_alloc", "ff_hqdn3d_init_x86", "ff_fdct248_islow_10", "ff_tdecode_header", "ff_match_2uint16", "ff_aac_search_for_pred", "avpicture_free", "av_rescale_delta", "x264_frame_pop_unused", "av_codec_get_codec_descriptor", "av_utf8_decode", "av_timegm", "ff_psy_end", "ff_pre_estimate_p_frame_motion", "av_hash_final_b64", "rgb15tobgr15", "av_md5_update", "av_dv_codec_profile", "ff_mov_iso639_to_lang", "ff_http_do_new_request", "ff_h263_encode_picture_header", "ff_h264_fill_mbaff_ref_list", "ff_h264qpel_init", "av_get_channel_layout_string", "ff_check_alignment", "ff_mpv_decode_init", "ff_yadif_init_x86", "avfilter_graph_get_filter", "ff_avg_qpel16_mc12_old_c", "ff_mdct_calc_c", "ff_amf_write_string2", "av_sha_final", "x264_lookahead_put_frame", "av_color_range_name", "av_opt_get_int", "ff_mdct_end_fixed", "ff_default_get_video_buffer", "av_version_info", "ff_h264_chroma_dc_dequant_idct_9_c", "av_get_token", "ff_simple_idct_add_12", "avfilter_insert_filter", "avio_alloc_context", "avresample_get_delay", "ff_h264_idct8_add_8_c", "av_probe_input_format3", "x264_macroblock_probe_skip", "ff_free_stream", "swri_noise_shaping_float", "avio_open_dir", "av_rdft_end", "rgb15tobgr16", "ff_png_pass_row_size", "av_format_set_subtitle_codec", "av_image_copy_plane", "ff_get_channel_layout", "ff_reduce_index", "av_frame_set_qp_table", "ff_frame_thread_encoder_init", "avcodec_close", "ff_thread_get_format", "ff_h263_decode_picture_header", "ff_qpeldsp_init", "ff_put_qpel8_mc12_old_c", "ff_interleave_add_packet", "swr_get_out_samples", "avcodec_align_dimensions2", "ff_h264_remove_all_refs", "ff_init_cabac_encoder", "av_camellia_crypt", "ff_gmc_c", "av_codec_get_pkt_timebase", "ff_query_formats_all", "ff_formats_changeref", "ff_h264_chroma_dc_dequant_idct_12_c", "ff_amf_match_string", "x264_me_search_ref", "av_opt_ptr", "rgb48tobgr48_bswap", "avpriv_toupper4", "av_free", "ff_dualinput_uninit", "x264_adaptive_quant_frame", "ff_psy_find_group", "avio_open2", "ff_mpa_synth_filter_float", "x264_hrd_fullness", "x264_macroblock_encode_p8x8", "av_hwaccel_next", "avcodec_descriptor_next", "ff_write_chained", "x264_deblock_init", "avpicture_layout", "ff_codec_get_id", "ff_avg_h264_qpel16_mc20_10_mmxext", "ff_h264_idct_add16intra_12_c", "av_register_input_format", "ff_get_pcm_codec_id", "avformat_network_init", "x264_ratecontrol_mb_qp", "ff_print_debug_info", "ff_h264_check_intra_pred_mode", "ff_simple_idct_add_10", "av_codec_is_decoder", "ff_slice_thread_init", "ff_avg_qpel16_mc33_old_c", "avformat_get_riff_video_tags", "audio_resample_close", "avfilter_graph_config", "av_guess_sample_aspect_ratio", "av_get_bits_per_pixel", "ff_fft_end_fixed", "ff_fspp_init_x86", "sws_convVec", "ff_avg_h264_qpel16_mc11_10_mmxext", "swri_rematrix_init_x86", "ff_ps_apply", "x264_intra_satd_x3_16x16", "ff_mpv_decode_defaults", "ff_png_zfree", "ff_set_common_samplerates", "ff_hyscale_fast_mmxext", "ff_id3v2_write_metadata", "avpriv_float_dsp_alloc", "av_frame_get_metadata", "ff_avg_pixels16_xy2_mmx", "ff_get_guid", "ffio_ensure_seekback", "swri_get_dither", "ff_h264_luma_dc_dequant_idct_14_c", "av_timecode_init_from_string", "ff_h264_idct_dc_add_8_c", "ff_amf_read_number", "avresample_get_out_samples", "avcodec_decode_audio4", "av_md5_final", "sws_convertPalette8ToPacked32", "ff_put_h264_qpel16_mc12_10_mmxext", "sws_allocVec", "x264_macroblock_thread_allocate", "ff_yuv2rgb_c_init_tables", "av_file_map", "ff_updateMMXDitherTables", "av_get_int", "av_buffersrc_get_nb_failed_requests", "avcodec_dct_alloc", "av_samples_fill_arrays", "avpriv_strtod", "av_frame_alloc", "ff_filter_graph_remove_filter", "ff_audio_resample_free", "ff_tis_ifd", "ff_faanidct", "sws_isSupportedEndiannessConversion", "x264_mc_init", "ff_h263_encode_gob_header", "ff_jref_idct_add", "av_bprint_clear", "av_buffersink_get_buffer_ref", "ff_rtmp_calc_digest", "x264_encoder_open_148", "ff_huffyuvencdsp_init", "ff_mjpeg_encode_dc", "ff_mpadsp_init", "ff_graph_thread_free", "ff_fdctdsp_init", "ff_h264_chroma_dc_dequant_idct_10_c", "ff_mpegvideodsp_init_x86", "ff_h264_chroma_dc_dequant_idct_14_c", "ffio_get_checksum", "avcodec_chroma_pos_to_enum", "avpriv_mpegts_parse_open", "ff_h264_flush_change", "av_xtea_init", "avio_wl32", "av_hash_final_bin", "x264_ratecontrol_set_weights", "ff_put_h264_qpel16_mc00_10_mmxext", "av_expr_free", "ff_psdsp_init", "ff_fdct_sse2", "ff_h264_init_dequant_tables", "av_dict_free", "ff_free_picture_tables", "ff_h264_chroma_dc_dequant_idct_8_c", "avio_put_str16be", "ff_h263_encode_init", "ff_audio_convert_init_x86", "av_frame_set_channel_layout", "ff_put_h264_qpel16_mc33_10_mmxext", "x264_quant_init", "ff_dct_encode_init_x86", "x264_frame_expand_border_mod16", "av_mdct_init", "ff_merge_samplerates", "av_mdct_end", "av_hmac_update", "av_picture_pad", "av_hex_dump", "sws_alloc_set_opts", "ff_null_get_audio_buffer", "av_crc", "x264_ratecontrol_start", "sws_alloc_context", "av_register_all", "x264_macroblock_bipred_init", "ff_set_qscale", "ff_sbrdsp_init", "avpriv_aac_parse_header", "ff_avg_h264_qpel16_mc21_10_mmxext", "ff_find_stream_index", "x264_intra_sad_x3_8x8", "ff_pcm_read_packet", "av_get_sample_fmt_name", "ff_put_qpel8_mc11_old_c", "ff_audio_data_combine", "ff_simple_idct_put_8", "ff_put_h264_qpel16_mc22_10_mmxext", "av_log_set_flags", "ff_mjpeg_encode_init", "av_opt_find", "ff_simple_idct_put_12", "av_buffer_default_free", "ff_h264_decode_init", "avio_wb32", "ff_h264_idct8_dc_add_14_c", "av_log2", "ff_init_desc_chscale", "x264_pps_init", "avfilter_graph_create_filter", "av_sha512_init", "ff_copy_rectangle", "avfilter_graph_alloc", "ff_fdctdsp_init_x86", "ff_audio_mix_free", "ff_mpeg_update_thread_context", "ff_draw_color", "x264_mb_predict_mv_16x16", "av_file_unmap", "ff_mjpeg_encode_picture_trailer", "x264_copy_column8", "avcodec_default_get_format", "ff_mpeg4_clean_buffers", "av_strcasecmp", "av_parse_time", "av_image_fill_max_pixsteps", "avformat_query_codec", "x264_macroblock_slice_init", "ff_estimate_b_frame_motion", "av_codec_set_pkt_timebase", "ff_mpv_common_init_x86", "ff_mov_close_hinting", "__divdi3", "ff_put_no_rnd_qpel16_mc11_old_c", "avpriv_new_chapter", "x264_predict_8x8c_p_c", "x264_nal_encode", "__powidf2", "av_div_q", "av_opt_get_video_rate", "av_buffer_allocz", "ff_pixblockdsp_init_x86", "ff_channel_layouts_changeref", "av_opt_get_double", "ff_dither_free", "ffurl_register_protocol", "ff_http_init_auth_state", "ff_mov_read_esds", "ff_framesync_process_frame", "x264_frame_expand_border", "ff_reget_buffer", "ff_mov_read_stsd_entries", "ff_rtmp_packet_read_internal", "ff_frame_thread_init", "av_get_default_channel_layout", "ff_init_mpadsp_tabs_fixed", "x264_predict_4x4_h_c", "av_adler32_update", "ff_put_no_rnd_qpel8_mc33_old_c", "x264_predict_lossless_16x16", "x264_opencl_lookahead_init", "ff_simple_idct48_add", "x264_frame_push_blank_unused", "ff_put_no_rnd_qpel8_mc12_old_c", "av_strerror", "av_sha512_alloc", "avfilter_get_by_name", "av_register_bitstream_filter", "ff_fix_long_p_mvs", "avresample_available", "av_expr_parse", "av_hmac_init", "ff_interlace_init_x86", "avcodec_configuration", "ff_audio_mix_alloc", "avpriv_frame_get_metadatap", "ff_data_to_hex", "av_opt_set_sample_fmt", "ffio_read_size", "avio_accept", "ff_amf_get_string", "ff_mjpeg_encode_stuffing", "x264_predict_8x8_dc_c", "av_twofish_crypt", "av_opt_set_bin", "avcodec_dct_get_class", "av_image_get_linesize", "ff_socket", "x264_sps_init", "av_murmur3_alloc", "sws_getDefaultFilter", "swr_get_class", "ff_tls_deinit", "x264_predict_lossless_chroma", "av_get_known_color_name", "av_opt_query_ranges_default", "avfilter_graph_set_auto_convert", "ff_h264_luma_dc_dequant_idct_12_c", "avfilter_init_filter", "ff_ape_parse_tag", "ff_command_queue_pop", "ff_h264_idct_dc_add_12_c", "av_strnstr", "av_fifo_generic_peek_at", "ff_kbd_window_init", "rgb64tobgr48_nobswap", "x264_opencl_precalculate_frame_cost", "x264_ratecontrol_new", "av_ripemd_init", "av_ripemd_alloc", "avfilter_get_video_buffer_ref_from_frame", "x264_intra_satd_x3_4x4", "ff_h264_idct_add16intra_10_c", "av_get_channel_layout_nb_channels", "av_buffer_create", "av_register_codec_parser", "av_strncasecmp", "av_bprintf", "av_opt_eval_flags", "ff_spp_init_x86", "ff_aac_apply_tns", "av_opt_eval_q", "ff_stream_new_side_data", "ff_audio_resample", "ff_h264_idct_add8_422_12_c", "ff_amf_write_field_name", "x264_frame_shift", "ff_h263_aspect_to_info", "av_escape", "avfilter_get_video_buffer_ref_from_arrays", "avfilter_version", "av_dict_get_string", "avfilter_graph_alloc_filter", "ff_parse_pixel_format", "x264_frame_push_unused", "ff_h264_get_slice_type", "avpriv_exif_decode_ifd", "ff_sws_init_output_funcs", "ff_get_bmp_header", "x264_rd_cost_part", "av_twofish_init", "av_frame_ref", "swr_alloc", "av_bitstream_filter_filter", "av_opt_set_q", "ff_avc_write_annexb_extradata", "ff_mpa_l2_select_table", "ff_init_buffer_info", "pp_free_context", "ff_line_noise_avg_c", "av_set_q", "av_frame_set_channels", "x264_sei_buffering_period_write", "ff_mpv_common_end", "ff_framesync_drop", "av_guess_format", "avio_handshake", "av_packet_from_data", "swresample_version", "avpriv_vorbis_parse_reset", "av_add_q", "av_aes_init", "av_samples_set_silence", "ff_pullup_init_x86", "ff_mpv_encode_init", "ff_gradfun_init_x86", "ff_put_qpel16_mc33_old_c", "av_buffer_alloc", "x264_frame_pop", "ff_put_guid", "sws_shiftVec", "x264_intra_sad_x3_8x16c", "ff_mpeg4videodec_static_init", "av_expr_eval", "av_frame_get_colorspace", "av_opt_show2", "avio_read", "ff_h263_resync", "av_xtea_alloc", "ff_insert_pad", "ff_read_packet", "ff_formats_ref", "avpriv_mpa_decode_header", "ff_mjpeg_decode_init", "ff_h264_unref_picture", "avpriv_h264_has_num_reorder_frames", "ff_copy_rectangle2", "ff_all_channel_counts", "ff_id3v2_match", "ff_xvid_idct", "av_usleep", "av_rescale_q", "ff_init_ff_sine_windows", "x264_validate_levels", "ff_unlock_avcodec", "avcodec_encode_audio", "av_hmac_alloc", "ff_pngdsp_init_x86", "av_strstart", "ff_h264_idct_add8_422_14_c", "av_get_frame_filename", "av_pkt_dump2", "ff_mp4_read_dec_config_descr", "ff_kbd_window_init_fixed", "av_copy_packet_side_data", "ff_get_video_buffer", "avpriv_split_xiph_headers", "avformat_queue_attached_pictures", "av_timecode_make_smpte_tc_string", "x264_macroblock_encode_p4x4", "ff_put_h264_qpel16_mc13_10_mmxext", "av_gcd", "swr_close", "pp_get_context", "avio_close_dyn_buf", "avio_w8", "ff_default_query_formats", "ff_amf_write_string", "ff_fill_rectangle", "av_fifo_alloc_array", "x264_free", "x264_macroblock_cache_allocate", "avpriv_set_pts_info", "x264_macroblock_cache_load_progressive", "av_resample_close", "av_hash_names", "swri_realloc_audio", "av_sha_update", "av_tree_node_alloc", "ffio_init_context", "x264_cabac_block_residual_c", "ff_put_qpel16_mc12_old_c", "ff_h264_idct_add_12_c", "avfilter_get_class", "av_vbprintf", "ff_sws_init_input_funcs", "ff_mdct_end_fixed_32", "ff_rtmp_packet_write", "ff_calculate_bounding_box", "ff_h264_decode_nal", "avformat_get_mov_audio_tags", "ff_h264_decode_picture_parameter_set", "av_packet_side_data_name", "ff_mpeg4_workaround_bugs", "ff_put_qpel16_mc13_old_c", "ff_put_no_rnd_qpel8_mc13_old_c", "av_get_double", "ff_mpeg_unref_picture", "av_new_program", "av_md5_init", "x264_predict_8x16c_v_c", "avcodec_default_reget_buffer", "ff_check_interrupt", "av_iformat_next", "av_read_frame", "avformat_seek_file", "swri_noise_shaping_int16", "ff_socket_nonblock", "av_samples_get_buffer_size", "x264_opencl_lowres_init", "ffurl_handshake", "av_buffer_get_ref_count", "ff_avg_h264_qpel16_mc01_10_mmxext", "av_display_rotation_set", "ff_videodsp_init", "av_opt_get_channel_layout", "x264_plane_copy_c", "ff_h263_decode_frame", "av_audio_fifo_size", "av_frame_get_best_effort_timestamp", "av_murmur3_init", "x264_encoder_invalidate_reference", "x264_param_default", "av_fifo_generic_read", "swri_audio_convert", "x264_plane_copy_swap_c", "ff_avc_find_startcode", "ff_mpv_common_defaults", "av_get_exact_bits_per_sample", "avpicture_alloc", "av_hash_update", "av_stereo3d_create_side_data", "av_packet_ref", "ff_find_unused_picture", "av_thread_message_queue_recv", "x264_me_refine_qpel_rd", "av_xtea_crypt", "ffio_free_dyn_buf", "ff_thread_report_progress", "ff_h263_decode_mba", "x264_macroblock_analyse", "ff_imdct_calc_c_fixed", "ff_set_dimensions", "avcodec_alloc_frame", "ff_mpv_encode_picture", "av_probe_input_buffer2", "av_packet_get_side_data", "avresample_config", "avfilter_graph_send_command", "ffurl_connect", "ff_init_gamma_convert", "ff_dither_alloc", "avio_rb16", "ff_float_dsp_init_x86", "ff_generate_wave_table", "ff_init_slice_from_src", "av_buffer_ref", "avpriv_scalarproduct_float_c", "avfilter_get_audio_buffer_ref_from_frame", "ffurl_accept", "ff_mdct_init", "ff_mjpeg_decode_dht", "ff_set_mpeg4_time", "ff_h264dsp_init", "av_get_pix_fmt", "ff_program_add_stream_index", "swr_set_compensation", "av_blowfish_crypt", "ff_start_tag", "ff_h264_chroma422_dc_dequant_idct_12_c", "av_stream_set_r_frame_rate", "ff_raw_data_read_header", "avfilter_inout_alloc", "sws_scale", "avio_check", "avpriv_unlock_avformat", "avcodec_descriptor_get", "avio_rl24", "ff_h264_init_cabac_states", "sws_isSupportedOutput", "ff_startcode_find_candidate_c", "av_resample", "swscale_version", "ff_h264_idct_add8_10_c", "ff_tadd_shorts_metadata", "avcodec_string", "av_cast5_crypt2", "x264_ratecontrol_slice_type", "av_image_get_buffer_size", "av_free_packet", "ff_aac_search_for_tns", "ff_mov_init_hinting", "avcodec_dct_init", "av_blowfish_crypt_ecb", "av_gettime_relative_is_monotonic", "x264_predict_16x16_v_c", "ff_mdct_calcw_c", "ff_idctdsp_init_x86", "ff_add_channel_layout", "avio_open", "av_compare_ts", "av_tempfile", "av_rdft_init", "av_format_get_audio_codec", "ff_simple_idct44_add", "av_fifo_freep", "ff_audio_data_add_to_fifo", "x264_cqm_init", "ff_tinterlace_init_x86", "ff_mpeg4_decode_picture_header", "avresample_set_matrix", "x264_macroblock_tree_read", "ff_aac_is_encoding_err", "av_buffersrc_add_frame_flags", "ffio_read_partial", "x264_frame_deblock_row", "ff_rdft_end", "ff_put_h264_qpel16_mc21_10_mmxext", "avpriv_dv_frame_profile2", "av_url_split", "avcodec_free_frame", "av_frame_new_side_data", "ff_side_data_update_matrix_encoding", "av_stream_get_end_pts", "sws_normalizeVec", "ff_dualinput_request_frame", "av_opt_get_sample_fmt", "avpriv_lock_avformat", "av_format_get_probe_score", "avcodec_find_encoder", "av_stristr", "ff_init_qscale_tab", "av_audio_fifo_realloc", "ff_put_qpel16_mc11_old_c", "av_buffersink_read", "av_timecode_adjust_ntsc_framenum2", "sws_printVec2", "x264_cabac_context_init", "ff_h264_decode_extradata", "ff_mpv_frame_start", "av_buffersink_set_frame_size", "ff_write_quant_matrix", "ff_init_desc_fmt_convert", "ffio_limit", "rgb12to15", "ff_h264_idct_add8_422_9_c", "ff_er_add_slice", "av_parser_change", "av_append_packet", "swri_rematrix", "avfilter_add_matrix", "ff_h264_chroma422_dc_dequant_idct_14_c", "av_get_codec_tag_string", "avio_feof", "x264_threads_distribute_ratecontrol", "ff_rfps_calculate", "av_get_standard_channel_layout", "av_codec_set_seek_preroll", "av_mul_q", "av_base64_decode", "swr_next_pts", "avcodec_encode_subtitle", "ff_h264_idct_add_10_c", "avio_wb16", "ff_line_noise_c", "av_image_check_sar", "x264_mb_mc", "ff_h263_decode_end", "av_parse_cpu_caps", "ff_put_no_rnd_qpel16_mc32_old_c", "rgb64to48_bswap", "x264_predict_lossless_4x4", "av_log_missing_feature", "ff_add_index_entry", "ff_h264_execute_decode_slices", "avfilter_inout_free", "av_parser_parse2", "ff_avg_h264_qpel16_mc22_10_mmxext", "av_dv_frame_profile", "rgb2rgb_init_x86", "av_get_pcm_codec", "ffurl_closep", "avresample_free", "av_strndup", "swr_convert_frame", "avio_read_to_bprint", "ffio_set_buf_size", "x264_analyse_init_costs", "av_tree_insert", "ff_h264_idct_add8_9_c", "x264_sps_write", "ff_hpeldsp_init_x86", "ff_find_last_ts", "av_fft_end", "ff_mpeg4_encode_picture_header", "x264_macroblock_deblock", "x264_me_refine_bidir_satd", "av_hash_alloc", "av_format_set_data_codec", "ff_put_qpel8_mc13_old_c", "av_codec_set_codec_descriptor", "ff_urldecode", "ff_h264chroma_init", "ff_codec_get_tag", "av_basename", "av_expr_parse_and_eval", "x264_ratecontrol_mb", "av_pix_fmt_desc_next", "swr_free", "av_set_double", "ff_avg_qpel8_mc11_old_c", "av_log_set_level", "ff_rl_init_vlc", "ff_mpegvideoencdsp_init_x86", "av_image_copy", "av_imdct_calc", "av_dv_codec_profile2", "ff_prores_idct", "x264_predict_8x8_init", "avutil_license", "av_sha_init", "av_get_time_base_q", "x264_predict_4x4_v_c", "ff_fdct_mmx", "avio_read_dir", "ff_mpeg1_find_frame_end", "ff_parse_specific_params", "ff_h264_draw_horiz_band", "ff_id3v2_write_apic", "x264_threads_merge_ratecontrol", "ff_update_duplicate_context", "ff_put_h264_qpel16_mc11_10_mmxext", "ff_h263_decode_motion", "ff_put_qpel8_mc32_old_c", "ff_check_pixfmt_descriptors", "av_fopen_utf8", "ff_metadata_conv_ctx", "avcodec_find_decoder", "av_packet_unpack_dictionary", "avfilter_mul_matrix", "ff_init_lls_x86", "ff_rtp_enc_name", "avformat_get_riff_audio_tags", "av_new_packet", "ff_channel_layouts_ref", "ff_thread_get_buffer", "ff_crc04C11DB7_update", "ff_h264_idct_add_9_c", "av_blowfish_init", "ff_mjpeg_build_huffman_codes", "av_get_profile_name", "x264_cabac_encode_bypass_c", "x264_macroblock_encode", "av_frame_side_data_name", "ff_network_wait_fd", "x264_threadslice_cond_broadcast", "x264_pixel_ssim_wxh", "ff_h264_chroma422_dc_dequant_idct_8_c", "av_frame_remove_side_data", "ff_mpeg_er_frame_start", "av_timecode_get_smpte_from_framenum", "x264_reduce_fraction64", "x264_sync_frame_list_pop", "sws_getConstVec", "av_frame_set_best_effort_timestamp", "x264_cabac_encode_init", "av_timecode_make_string", "ff_configure_buffers_for_index", "av_imdct_half", "ff_aac_tableinit", "ff_clean_intra_table_entries", "avpriv_find_start_code", "ff_init_vlc_sparse", "ff_thread_finish_setup", "av_isgraph", "ff_update_cur_dts", "sws_freeVec", "x264_picture_alloc", "av_read_pause", "av_mdct_calc", "av_packet_copy_props", "ff_blend_rectangle", "x264_quant_8x8_trellis", "x264_quant_luma_dc_trellis", "ff_get_audio_buffer", "ff_h263_encode_mba", "ff_id3v2_free_extra_meta", "ff_mpeg4_init_partitions", "ff_h263_update_motion_val", "av_opt_get_image_size", "ff_imdct_half_c_fixed", "avfilter_open", "av_opt_set_video_rate", "ff_thread_init", "x264_cabac_encode_ue_bypass", "ff_put_h264_qpel16_mc23_10_mmxext", "ff_set_cmp", "ff_set_common_channel_layouts", "ff_mpv_frame_end", "ff_alloc_packet2", "av_ripemd_final", "av_parse_color", "avresample_convert", "avfilter_graph_parse2", "ff_aac_ac3_parse", "av_buffer_is_writable", "ff_isom_write_avcc", "ff_mov_write_chan", "x264_prefetch_fenc", "av_picture_crop", "ff_dct_end", "av_aes_alloc", "swresample_license", "av_camellia_alloc", "av_pix_fmt_desc_get", "av_frame_get_pkt_pos", "ff_h264_idct_dc_add_9_c", "avfilter_free", "ff_mpeg4video_split", "avformat_version", "ff_imdct15_init", "ff_dualinput_init", "av_thread_message_queue_set_err_recv", "ff_network_init", "ff_mjpeg_escape_FF", "ff_aac_sbr_ctx_close", "av_crc_get_table", "ff_draw_round_to_sub", "ff_h264_idct_add16_8_c", "avfilter_graph_add_filter", "ff_h264_direct_dist_scale_factor", "avfilter_config_links", "ff_set_sar", "swr_inject_silence", "ff_psy_preprocess_init", "ff_get_v_length", "ff_avg_h264_qpel16_mc33_10_mmxext", "x264_thread_sync_ratecontrol", "ff_convert_matrix", "ff_hevc_annexb2mp4", "avfilter_pad_get_type", "avfilter_sub_matrix", "av_format_set_audio_codec", "av_tree_enumerate", "av_packet_free_side_data", "avcodec_find_decoder_by_name", "ff_avg_h264_qpel16_mc12_10_mmxext", "ff_h264_idct_add8_8_c", "x264_opencl_load_library", "x264_log", "rgb15to24", "av_fast_padded_mallocz", "ff_avg_h264_qpel16_mc23_10_mmxext", "ff_idet_filter_line_c", "ffio_init_checksum", "av_lfg_init", "ff_simple_idct_12", "av_thread_message_queue_alloc", "x264_sei_write", "ff_mpeg4_stuffing", "x264_intra_sad_x3_16x16", "x264_predict_8x8c_dc_c", "av_nearer_q", "ff_h263_decode_mb", "av_frame_get_side_data", "avpriv_report_missing_feature", "avformat_license", "pp_get_mode_by_name_and_quality", "av_codec_next", "ff_h264_idct_add16_12_c", "av_opt_get_dict_val", "av_log_get_level", "av_memdup", "x264_frame_expand_border_filtered", "av_opt_next", "ff_thread_flush", "ff_mpv_decode_mb", "ff_put_bmp_header", "avcodec_default_get_buffer", "ff_raw_video_read_header", "avcodec_fill_audio_frame", "ff_aac_adjust_common_prediction", "av_stream_get_side_data", "x264_cabac_encode_decision_c", "ff_lpc_end", "ff_h264_idct_add16intra_14_c", "av_dict_parse_string", "avutil_configuration", "rgb16tobgr15", "av_mallocz", "ff_amf_get_field_value", "av_codec_set_chroma_intra_matrix", "av_format_set_control_message_cb", "av_get_audio_frame_duration", "ff_fdct_mmxext", "ff_raw_write_packet", "av_audio_convert", "ff_rate_estimate_qscale", "ff_h264qpel_init_x86", "ff_simple_idct_10", "ff_rtmp_calc_digest_pos", "av_frame_get_decode_error_flags", "av_display_matrix_flip", "ff_put_no_rnd_qpel8_mc11_old_c", "postproc_version", "av_packet_split_side_data", "ff_sws_alphablendaway", "ff_thread_video_encode_frame", "av_set_options_string", "avutil_version", "ff_brktimegm", "ff_init_mpadsp_tabs_float", "av_realloc_array", "ff_dither_init_x86", "ff_tadd_string_metadata", "ff_null_get_video_buffer", "ff_audio_data_copy", "avpriv_mpa_decode_header2", "ff_h264_idct_add16_10_c", "av_add_index_entry", "av_opt_query_ranges", "av_frame_get_buffer", "ff_h264_fill_default_ref_list", "av_opt_set_dict_val", "ff_id3v2_write_simple", "x264_macroblock_thread_free", "ff_fdct248_islow_8", "x264_macroblock_deblock_strength", "x264_predict_16x16_dc_c", "ff_mpeg_er_init", "ff_mpa_synth_init_float", "av_fft_calc", "av_frame_copy", "ffurl_get_file_handle", "ff_update_picture_tables", "x264_encoder_delayed_frames", "av_hash_get_size", "ff_put_h264_qpel16_mc02_10_mmxext", "ff_dct_init_x86", "ff_h263_pred_dc", "av_tea_crypt", "ff_sample_fmt_is_planar", "av_format_get_opaque", "ff_fix_long_mvs", "av_get_bits_per_sample", "av_log_format_line", "av_buffersink_poll_frame", "av_get_channel_layout_channel_index", "av_buffer_pool_init", "avfilter_copy_buffer_ref_props", "ffio_open_dyn_packet_buf", "ff_interleave_packet_per_dts", "avpriv_vorbis_parse_frame_flags", "x264_intra_sa8d_x3_8x8", "x264_threadslice_cond_wait", "avpriv_mpeg4audio_get_config", "ff_put_h264_qpel16_mc03_10_mmxext", "x264_malloc", "ff_mdct_init_fixed_32", "ff_mpeg4_decode_video_packet_header", "av_opt_set_from_string", "avcodec_find_best_pix_fmt_of_2", "avfilter_copy_frame_props", "av_fifo_grow", "x264_param_apply_fastfirstpass", "ff_framesync_next", "av_cpu_count", "x264_frame_cond_wait", "__umoddi3", "ff_scale_image", "ff_h264_idct8_add4_9_c", "ff_h264_chroma422_dc_dequant_idct_10_c", "ff_intel_h263_decode_picture_header", "avio_pause", "ff_init_cabac_states", "av_color_transfer_name", "x264_encoder_reconfig", "av_index_search_timestamp", "av_get_random_seed", "ff_mjpeg_decode_end", "av_opt_set_defaults", "ff_fft_end", "ff_avg_h264_qpel16_mc13_10_mmxext", "ff_put_no_rnd_qpel8_mc31_old_c", "avio_rl32", "ff_framesync_request_frame", "x264_param_parse", "av_xiphlacing", "av_vorbis_parse_init", "av_match_ext", "ff_h264_decode_sei", "ff_amf_write_number", "av_get_pix_fmt_string", "ff_ps_init", "ff_img_read_packet", "ff_free_vlc", "av_strtod", "av_pix_fmt_count_planes", "ff_shrink88", "ff_merge_formats", "av_d2str", "avfilter_init_dict", "av_tea_init", "ff_init_hscaler_mmxext", "ff_imdct36_blocks_float", "av_pkt_dump_log2", "ff_metadata_conv", "av_opt_set_dict", "avio_open_dyn_buf", "x264_cabac_mb_skip", "ff_h264dsp_init_x86", "ff_flv_encode_picture_header", "av_strdup", "ff_rate_control_uninit", "x264_opencl_flush", "ff_inet_aton", "swri_rematrix_free", "av_rc4_init", "ff_put_v", "ff_mpeg4_find_frame_end", "ff_sine_window_init_fixed", "ff_frame_thread_encoder_free", "ff_tadd_doubles_metadata", "swri_audio_convert_init_x86", "x264_ratecontrol_qp", "ff_h264_idct_add16_14_c", "x264_slicetype_analyse", "ff_thread_decode_frame", "avcodec_get_edge_width", "ff_framesync_uninit", "av_find_best_pix_fmt_of_2", "av_fifo_alloc", "av_get_planar_sample_fmt", "av_dct_init", "av_codec_is_encoder", "ff_mpeg4_encode_video_packet_header", "avpriv_get_raw_pix_fmt_tags", "ff_hyscale_fast_c", "av_buffersrc_buffer", "av_set_string3", "avfilter_graph_dump", "x264_cavlc_init", "ff_listen_connect", "av_fifo_drain", "av_opt_get", "av_packet_merge_side_data", "ff_h264_idct_add8_14_c", "av_audio_fifo_alloc", "ff_get_2pass_fcode", "av_murmur3_update", "ff_init_desc_no_chr", "ff_yuv2rgb_get_func_ptr", "ff_h264_decode_ref_pic_marking", "avio_close", "av_shrink_packet", "avfilter_graph_parse", "av_demuxer_open", "ff_h264_idct8_add4_12_c", "ff_ape_write_tag", "x264_param_apply_profile", "av_timecode_make_mpeg_tc_string", "x264_sync_frame_list_init", "av_frame_clone", "ff_yuv2rgb_init_x86", "av_packet_pack_dictionary", "ff_init_poc", "av_base64_encode", "av_fifo_reset", "av_append_path_component", "ff_sdp_write_media", "av_fft_permute", "av_vorbis_parse_free", "av_des_mac", "ff_audio_mix", "av_log2_16bit", "x264_intra_satd_x3_8x8c", "x264_predict_lossless_8x8", "avpriv_put_string", "swr_drop_output", "ff_fft_lut_init", "ff_gradfun_blur_line_c", "ff_network_wait_fd_timeout", "ff_free_filters", "ff_me_cmp_init_x86", "ff_tget", "av_dup_packet", "ff_removegrain_init_x86", "ff_merge_channel_layouts", "ff_h264_idct_add_8_c", "ff_put_no_rnd_qpel16_mc33_old_c", "ff_mjpeg_decode_dqt", "ff_emulated_edge_mc_8", "av_frame_get_color_range", "ff_audio_mix_set_func", "av_image_fill_pointers", "av_frame_set_colorspace", "av_asprintf", "x264_lookahead_is_empty", "ff_mpeg4_frame_end", "avformat_close_input", "av_opt_eval_int64", "__moddi3", "ff_h264_decode_init_vlc", "ff_dct32_fixed", "x264_cqm_delete", "av_vorbis_parse_reset", "ff_pngdsp_init", "av_opt_is_set_to_default_by_name", "ff_pixblockdsp_init", "avpriv_mpegaudio_decode_header", "avformat_flush", "ff_h264_check_intra4x4_pred_mode", "avio_r8", "avcodec_decode_video2", "ff_faanidct_add", "x264_frame_push", "x264_frame_delete_list", "avpriv_open", "ff_thread_await_progress2", "av_q2intfloat", "ff_h264_idct_dc_add_14_c", "ff_mpegvideoencdsp_init", "x264_macroblock_cache_save", "ff_psy_preprocess_end", "ff_tget_long", "x264_frame_copy_picture", "avpriv_mpegts_parse_close", "avfilter_pad_get_name", "ff_flv_decode_picture_header", "av_buffer_pool_get", "ff_formats_unref", "av_gettime", "ff_get_cpu_flags_x86", "av_downmix_info_update_side_data", "av_filename_number_test", "x264_predict_8x16c_dc_c", "av_get_sample_fmt", "avformat_network_deinit", "ff_mpeg1_clean_buffers", "audio_resample", "ff_lpc_calc_ref_coefs", "ffurl_write", "rgb32to24", "swscale_configuration", "avpriv_io_move", "ff_decode_frame_props", "av_opt_get_q", "ff_h264_luma_dc_dequant_idct_8_c", "ff_sbrdsp_init_x86", "av_codec_get_id", "rgb24to32", "av_get_channel_name", "swresample_configuration", "ff_get_extradata", "x264_cpu_detect", "ff_copy_whitelists", "ff_audio_data_set_channels", "av_pix_fmt_get_chroma_sub_sample", "ff_h264_idct8_add_9_c", "ff_shrink44", "avcodec_get_context_defaults3", "sws_getIdentityVec", "av_stream_get_r_frame_rate", "ff_pixelutils_sad_init_x86", "x264_pixel_ssd_wxh", "swr_is_initialized", "ff_thread_free", "avfilter_register_all", "avio_rb64", "x264_bitstream_init", "ff_rtp_get_codec_info", "av_opt_set_dict2", "x264_rdo_init", "ff_h264_idct8_add4_14_c", "ff_get_unscaled_swscale", "x264_field_vsad", "av_frame_get_pkt_duration", "avfilter_get_audio_buffer_ref_from_arrays_channels", "av_format_get_subtitle_codec", "ff_h263_loop_filter", "av_log_get_flags", "av_opt_eval_int", "x264_cqm_parse_file", "ff_put_no_rnd_qpel16_mc13_old_c", "avresample_license", "ff_http_averror", "ff_parse_sample_rate", "ff_noise_init_x86", "av_get_packet", "ff_avg_pixels16x16_c", "swr_config_frame", "ff_init_block_index", "swri_audio_convert_free", "swr_convert", "av_get_channel_description", "avformat_free_context", "sws_rgb2rgb_init", "ff_is_multicast_address", "av_chroma_location_name", "av_fft_init", "av_bitstream_filter_next", "x264_me_refine_qpel", "av_opt_flag_is_set", "x264_analyse_weight_frame", "ff_lpc_init_x86", "ff_h264_idct_add_14_c", "ff_put_pixels16x16_c", "ff_wav_codec_get_id", "av_dynarray2_add", "ff_blockdsp_init", "av_destruct_packet", "av_get_cpu_flags", "ff_mjpeg_decode_sof", "av_stristart", "ff_h263_encode_mb", "av_dirname", "ff_clean_mpeg4_qscales", "av_get_colorspace_name", "ff_init_vscale", "ff_emulated_edge_mc_16", "av_probe_input_buffer", "ff_avg_h264_qpel16_mc03_10_mmxext", "avpriv_init_elbg", "av_strtok", "ff_draw_init", "ff_mov_get_channel_layout", "avfilter_get_buffer_ref_from_frame", "avio_write", "av_oformat_next", "ff_pcm_read_seek", "av_hash_get_name", "av_dynarray_add_nofree", "av_murmur3_init_seeded", "x264_mb_predict_mv", "ff_rtmp_packet_create", "ff_mov_get_channel_layout_tag", "ff_af_queue_init", "ff_aac_sbr_ctx_init", "av_get_alt_sample_fmt", "av_buffer_get_opaque", "avcodec_encode_video2", "x264_lookahead_delete", "ff_put_h264_qpel16_mc10_10_mmxext", "swr_set_channel_mapping", "ff_get_wav_header", "ff_af_queue_add", "ff_audio_data_drain", "avio_put_str16le", "av_camellia_init", "ff_h264_decode_mb_cavlc", "ff_tadd_long_metadata", "ff_rotate_slice", "avcodec_flush_buffers", "x264_pps_write", "ff_simple_idct_add_8", "av_opt_child_class_next", "av_bmg_get", "avcodec_set_dimensions", "avio_rl16", "av_qsv_alloc_context", "x264_ratecontrol_init_reconfigurable", "ff_init_me", "ff_avg_qpel16_mc32_old_c", "x264_dct_init", "avpriv_find_pix_fmt", "swri_noise_shaping_int32", "swri_resample_dsp_init", "av_fifo_generic_write", "x264_pixel_init", "avcodec_descriptor_get_by_name", "x264_macroblock_thread_init", "av_bprint_finalize", "ffio_fill", "av_strlcpy", "av_rescale_q_rnd", "av_packet_move_ref", "ff_rtmp_check_alloc_array", "ff_h264_field_end", "avpriv_float_dsp_init", "ff_h263dsp_init", "ff_get_codec_guid", "av_opt_eval_double", "ff_thread_can_start_frame", "av_stream_get_parser", "av_display_rotation_get", "ff_audio_data_alloc", "av_format_get_open_cb", "ff_listen", "av_aes_crypt", "ff_filter_alloc", "av_format_get_control_message_cb", "ff_mp4_read_descr_len", "avfilter_ref_buffer", "ff_parse_time_base", "avio_get_str16le", "ff_framesync_init", "ff_init_desc_cfmt_convert", "av_set_int", "ff_imdct_half_c", "ff_h264_pred_init", "av_frame_move_ref", "av_d2q", "ffurl_get_multi_file_handle", "avio_wb64", "ff_add_format", "ff_mdct_init_fixed", "avfilter_copy_buf_props", "av_bitstream_filter_init", "x264_predict_8x8_h_c", "ff_mpeg_framesize_alloc", "avpriv_vorbis_parse_frame", "avfilter_make_format64_list", "ff_lpc_calc_coefs", "av_color_primaries_name", "swscale_license", "av_get_padded_bits_per_pixel", "ff_h263_pred_motion", "ff_png_get_nb_channels", "ff_avg_qpel8_mc31_old_c", "ff_put_pixels8_l2_8", "ff_tget_double", "ff_frame_thread_free", "ff_iir_filter_init_state", "ff_er_frame_end", "sws_getContext", "x264_weight_scale_plane", "ff_write_pass1_stats", "ff_h264_idct8_dc_add_12_c", "ff_faanidct_put", "ff_audio_data_realloc", "ff_avg_qpel16_mc31_old_c", "ff_put_h264_qpel16_mc01_10_mmxext", "ff_h264_update_thread_context", "ff_mdct_calc_c_fixed_32", "ff_sbr_apply", "ff_mpeg4_init_direct_mv", "swri_resample_dsp_x86_init", "av_fifo_free", "av_opt_set_double", "av_dict_count", "ff_http_match_no_proxy", "ff_fft_init_fixed", "ff_shrink22", "av_rdft_calc", "ff_mpa_synth_filter_fixed", "ff_amf_write_object_end", "ff_audio_resample_init", "x264_opencl_frame_delete", "av_vorbis_parse_frame_flags", "x264_expand_border_mbpair", "ff_fdct_ifast248", "avio_get_str", "ff_h264_luma_dc_dequant_idct_9_c", "ff_rtmp_packet_destroy", "avfilter_graph_request_oldest", "av_hash_final_hex", "x264_mb_mc_8x8", "av_codec_get_tag", "ff_me_cmp_init", "av_parser_close", "ff_fill_line_with_color", "ff_tadd_bytes_metadata", "av_frame_get_qp_table", "x264_encoder_headers", "ff_mjpeg_encode_close", "avcodec_get_pix_fmt_loss", "av_codec_get_seek_preroll", "ff_amf_tag_size", "ff_add_param_change", "ff_tread_tag", "av_frame_set_pkt_duration", "avcodec_default_get_buffer2", "avfilter_graph_free", "ff_h264_luma_dc_dequant_idct_10_c", "ffio_read_varlen", "ff_rtp_chain_mux_open", "av_opt_find2", "ff_url_join", "ff_dct_quantize_c", "ff_jref_idct_put", "ff_h264_chroma422_dc_dequant_idct_9_c", "avio_size", "ff_convert_dither", "ff_mpeg4_set_direct_mv", "avio_close_dir", "ff_h264_decode_seq_parameter_set", "ff_mpeg12_common_init", "av_find_program_from_stream", "av_buffersrc_add_frame", "av_add_stable", "av_parse_video_rate", "rgb16tobgr32", "ff_h264_set_erpic", "ff_print_debug_info2", "avfilter_get_audio_buffer_ref_from_arrays", "ff_png_zalloc", "pp_free_mode", "av_resample_compensate", "x264_encoder_intra_refresh", "avio_wl16", "avcodec_alloc_context3", "avresample_set_compensation", "ff_set_common_formats", "av_bprint_append_data", "swr_init", "ffio_open_null_buf", "x264_intra_sad_x3_4x4", "avcodec_get_class", "ff_lpc_init", "av_frame_unref", "av_opt_set_channel_layout", "av_thread_message_queue_send", "ff_mpv_reallocate_putbitbuffer", "av_dict_copy", "av_get_picture_type_char", "ff_h264_filter_mb_fast", "ff_mdct_end", "av_opt_get_key_value", "av_audio_fifo_free", "av_parse_ratio", "av_packet_new_side_data", "ff_id3v2_finish", "ff_h264_direct_ref_list_init", "ff_lock_avcodec", "ff_network_close", "avfilter_link_free", "ff_mjpeg_find_marker", "ff_tlog_link", "sws_getGaussianVec", "avfilter_get_matrix", "ff_amf_read_bool", "av_write_frame", "ff_avg_qpel8_mc33_old_c", "ff_add_png_paeth_prediction", "avcodec_encode_video", "avpriv_copy_bits", "av_cast5_alloc", "ff_imdct_calc_c", "ff_huffyuvencdsp_init_x86", "avresample_configuration", "x264_analyse_free_costs", "ff_mpeg_flush", "ff_rgb24toyv12_c", "ff_audio_mix_set_matrix", "x264_cpu_num_processors", "x264_mb_predict_mv_direct16x16", "av_read_play", "avresample_convert_frame", "ff_iir_filter_init", "ff_mov_lang_to_iso639", "avfilter_unref_bufferp", "ff_h264_idct_dc_add_10_c", "av_bprint_chars", "avresample_version", "x264_ratecontrol_summary", "ff_rl_init", "ff_alloc_packet", "av_fast_malloc", "av_match_list", "avfilter_configuration", "ff_epzs_motion_search", "av_find_best_stream", "avpriv_get_gamma_from_trc", "ff_vbv_update", "av_pixelutils_get_sad_fn", "ff_mpv_idct_init", "ff_h264_decode_ref_pic_list_reordering", "x264_sei_recovery_point_write", "avio_free_directory_entry", "ff_mpv_export_qp_table", "x264_threadpool_wait", "ff_put_h264_qpel16_mc30_10_mmxext", "av_abuffersink_params_alloc", "ffurl_seek", "ff_framesync_filter_frame", "avpriv_vorbis_parse_extradata", "ff_mjpeg_encode_picture_header", "ff_xvid_idct_init", "avio_closep", "ff_read_riff_info", "ff_put_qpel16_mc32_old_c", "av_lockmgr_register", "av_hmac_free", "x264_predict_16x16_init", "x264_param_default_preset", "av_timecode_init", "av_get_media_type_string", "ff_guess_image2_codec", "x264_cabac_encode_flush", "ff_amf_read_string", "av_opt_get_pixel_fmt", "ff_fetch_timestamp", "av_cast5_init", "av_register_hwaccel", "ff_ps_read_data", "ff_h264_slice_context_init", "x264_frame_cond_broadcast", "x264_me_refine_qpel_refdupe", "av_get_pix_fmt_name", "av_isdigit", "ff_rfps_add_frame", "ff_thread_release_buffer", "ff_seek_frame_binary", "av_codec_get_codec_properties", "av_image_alloc", "av_dict_set_int", "avresample_alloc_context", "sws_freeFilter", "avio_wb24", "ff_hcscale_fast_mmxext", "pp_postprocess", "ff_crcA001_update", "av_buffersink_get_frame_flags", "av_thread_message_queue_set_err_send", "ff_img_read_header", "ff_faandct248", "ff_side_data_set_encoder_stats", "av_codec_set_lowres", "avcodec_get_chroma_sub_sample", "shuffle_bytes_1230", "ff_thread_await_progress", "avpriv_do_elbg", "ff_hex_to_data", "ff_h264_idct_add8_12_c", "avpriv_request_sample", "ff_thread_report_progress2", "av_fifo_size", "x264_predict_4x4_dc_c", "ff_choose_chroma_location", "avcodec_get_frame_defaults", "ff_avg_qpel16_mc13_old_c", "ff_mpeg4_encode_mb", "ff_default_get_audio_buffer", "ffurl_size", "avcodec_encode_audio2", "ff_idet_init_x86", "avio_find_protocol_name", "av_format_get_video_codec", "av_opt_child_next", "avpicture_get_size", "avformat_alloc_context", "ff_generate_avci_extradata", "x264_mb_predict_mv_ref16x16", "x264_mb_predict_mv_pskip", "avformat_write_header", "x264_opencl_finalize_cost", "ff_all_channel_layouts", "x264_opencl_slicetype_end", "avfilter_link", "ff_mpv_motion", "avfilter_unref_buffer", "ff_blend_mask", "av_codec_get_chroma_intra_matrix", "ff_reset_entries", "shuffle_bytes_3012", "postproc_configuration", "av_opt_copy", "avresample_close", "ff_mpv_encode_end", "ff_parse_channel_layout", "rgb12tobgr12", "ff_h264_idct8_add_14_c", "avpriv_bprint_to_extradata", "avpriv_color_frame", "ff_h264_decode_mb_cabac", "avio_wl24", "av_audio_fifo_drain", "rgb15tobgr32", "ff_tadd_rational_metadata", "avcodec_pix_fmt_to_codec_tag", "av_rc4_crypt", "av_frame_set_sample_rate", "ff_h264_free_context", "ff_amf_write_bool", "ff_h264_idct8_dc_add_10_c", "__udivdi3", "avformat_get_mov_video_tags", "ff_h264_pred_direct_motion", "av_frame_get_plane_buffer", "avcodec_enum_to_chroma_pos", "ff_psy_init", "avcodec_get_subtitle_rect_class", "av_write_trailer", "av_strlcatf", "ffurl_shutdown", "av_read_image_line", "sws_isSupportedInput", "av_samples_copy", "av_hash_freep", "x264_mb_encode_chroma", "avcodec_decode_subtitle2", "av_next_option", "av_small_strptime", "av_audio_fifo_reset", "x264_sei_pic_timing_write", "ff_er_frame_start", "av_find_nearest_q_idx", "ff_raw_read_partial_packet", "x264_predict_8x16c_p_c", "ff_mpeg_draw_horiz_band", "ff_dct_init", "x264_plane_copy_interleave_c", "av_dict_set", "av_probe_input_format2", "ff_poll_frame", "ff_mjpeg_decode_frame", "ff_http_auth_create_response", "ff_lpc_calc_ref_coefs_f", "ff_id3v2_parse_apic", "av_format_set_open_cb", "av_audio_fifo_peek", "av_format_get_data_codec", "ff_imdct36_blocks_fixed", "ff_tls_init", "av_sha_alloc", "ff_h264_sei_stereo_mode", "av_isspace", "avio_skip", "ff_fmt_is_in", "ff_h264_idct_add8_422_8_c", "x264_filler_write", "avpicture_fill", "ff_hevc_annexb2mp4_buf", "ff_mpv_common_frame_size_change", "ff_videodsp_init_x86", "avfilter_init_str", "av_fmt_ctx_get_duration_estimation_method", "ff_j_rev_dct", "av_resample_init", "av_packet_unref", "avformat_get_class", "ff_clean_h263_qscales", "x264_predict_8x16c_h_c", "av_get_sample_fmt_string", "ff_audio_convert_free", "av_ripemd_update", "ff_update_link_current_pts", "ff_hcscale_fast_c", "avpriv_set_systematic_pal2", "av_fast_realloc", "ff_h264_idct8_dc_add_9_c", "avfilter_graph_parse_ptr", "ff_fill_rgba_map", "av_frame_get_sample_rate", "av_tree_destroy", "av_frame_set_decode_error_flags", "av_opt_eval_float", "url_feof", "av_format_set_opaque", "ff_faandct", "ff_draw_horiz_band", "ff_mov_get_lpcm_codec_id", "av_vlog", "x264_macroblock_write_cavlc", "av_calloc", "ff_me_cmp_init_static", "ff_iir_filter_init_coeffs", "av_cast5_crypt", "ff_mpadsp_apply_window_float", "ff_avc_parse_nal_units", "ff_fft_end_fixed_32", "avfilter_link_set_closed", "x264_lookahead_get_frames", "av_audio_convert_free", "x264_opencl_lookahead_delete", "ff_choose_timebase", "ff_estimate_p_frame_motion", "ff_init_filters", "av_force_cpu_flags", "av_find_info_tag", "x264_encoder_parameters", "avcodec_copy_context", "av_match_name", "av_frame_get_pkt_size", "ff_put_wav_header", "av_opt_set_pixel_fmt", "ff_psnr_init_x86", "ff_http_auth_handle_header", "ff_ssim_init_x86", "x264_frame_new_slice", "ff_framesync_get_frame", "x264_opencl_motionsearch", "ff_mov_read_chan", "av_sub_q", "av_dict_get", "avpriv_alloc_fixed_dsp", "ff_put_no_rnd_qpel16_mc12_old_c", "av_frame_set_pkt_size", "avpriv_init_lls", "ff_h264_idct8_add4_8_c", "ff_init_scantable_permutation_x86", "ff_id3v2_read_dict", "av_write_uncoded_frame", "ff_generate_sliding_window_mmcos", "av_buffer_pool_uninit", "ff_filter_frame", "sws_addVec", "ff_end_tag", "av_frame_copy_props", "ff_fft_init", "x264_cabac_block_residual_rd_c", "ff_amf_write_null", "x264_quant_chroma_dc_trellis", "av_parser_next", "ff_h264_free_tables", "av_audio_resample_init", "ff_iir_filter_free_statep", "x264_predict_8x8c_init", "ff_replaygain_export", "ff_combine_frame", "av_bprint_strftime", "swr_alloc_set_opts", "x264_predict_8x8_v_c", "av_copy_packet", "avcodec_get_type", "avio_seek_time", "ff_audio_convert", "x264_weighted_reference_duplicate", "x264_sync_frame_list_delete", "av_malloc", "ff_h264_idct_add16intra_8_c", "avfilter_graph_queue_command", "avcodec_is_open", "av_parse_cpu_flags", "ffio_close_null_buf", "av_tea_alloc", "ff_mpv_common_init", "ffio_read_indirect", "avcodec_open2", "av_memcpy_backptr", "postproc_license", "av_buffersrc_write_frame", "av_parse_video_size", "x264_pixel_ssd_nv12", "ff_h264_decode_slice_header", "avcodec_find_best_pix_fmt2", "swri_noise_shaping_double", "ff_init_cabac_decoder", "av_reallocp_array", "ff_mpeg4_decode_partitions", "av_buffersink_get_frame", "ff_h264_filter_mb", "av_md5_sum", "x264_frame_filter", "avfilter_link_get_channels", "ff_framesync_add_frame", "ff_id3v2_start", "ff_ps_ctx_init", "avformat_configuration", "av_fast_padded_malloc", "ff_slice_thread_free", "av_des_alloc", "ffio_fdopen", "av_sha512_update", "ff_avg_h264_qpel16_mc32_10_mmxext", "avresample_get_class", "av_int_list_length_for_size", "av_frame_set_metadata", "ffurl_close", "av_frame_set_color_range", "ff_audio_mix_init_x86", "ff_avg_qpel8_mc32_old_c", "avpriv_io_delete", "avcodec_default_execute2", "av_buffersink_read_samples", "av_image_check_size", "av_filter_next", "ff_j_rev_dct2", "ff_mpadsp_apply_window_fixed", "ff_j_rev_dct4", "av_gettime_relative", "ff_avg_h264_qpel16_mc00_10_mmxext", "av_codec_get_lowres", "avresample_set_channel_mapping", "x264_predict_4x4_init", "x264_frame_init_lowres", "ff_audio_data_read_from_fifo", "av_write_image_line", "av_strlcat", "ff_audio_data_free", "x264_plane_copy_deinterleave_v210_c", "ff_avg_h264_qpel16_mc02_10_mmxext", "ff_mdct_calc_c_fixed", "av_md5_alloc", "av_log_ask_for_sample", "av_buffer_unref", "ff_audio_mix_get_matrix", "ff_h263dsp_init_x86", "avpriv_copy_pce_data", "ff_xvid_idct_init_x86", "ffio_rewind_with_probe_data", "rgb16tobgr16", "ff_h264_alloc_tables", "ff_alloc_dir_entry", "av_set_cpu_flags_mask", "sws_subVec", "ff_draw_rectangle", "ff_sine_window_init", "swri_audio_convert_alloc", "x264_sei_avcintra_umid_write", "av_frame_get_channel_layout", "ff_decode_sbr_extension", "ff_get_format", "ff_avc_parse_nal_units_buf", "av_format_get_metadata_header_padding", "x264_threadpool_init", "ff_accept", "x264_intra_sad_x3_8x8c", "x264_cabac_encode_init_core", "ff_id3v2_read", "ff_avc_mp4_find_startcode", "av_audio_convert_alloc", "ff_h264_execute_ref_pic_marking", "av_fifo_space", "ff_fft_init_x86", "ff_h263_decode_init", "ff_tlog_ref", "av_picture_copy", "avformat_find_stream_info", "ff_avg_pixels8_xy2_mmx", "av_max_alloc", "ff_mjpeg_encode_mb", "ff_raw_audio_read_header", "avresample_read", "av_des_crypt", "x264_predict_16x16_h_c", "ff_put_no_rnd_qpel16_mc31_old_c", "ff_rtp_codec_id", "av_ctz", "x264_zigzag_init", "ff_simple_idct248_put", "ff_opencl_register_filter_kernel_code_all", "ff_replaygain_export_raw", "av_format_set_video_codec", "ff_mpa_synth_init_fixed", "av_format_inject_global_side_data", "sws_getCachedContext", "ff_j_rev_dct1", "av_hex_dump_log", "avio_enum_protocols", "av_pix_fmt_swap_endianness", "x264_encoder_maximum_delayed_frames", "av_get_bytes_per_sample", "x264_lookahead_init", "x264_encoder_encode", "ff_amf_write_object_start", "av_hash_init", "av_find_default_stream_index", "av_hmac_calc", "x264_picture_init", "ff_channel_layouts_unref", "ff_h263_find_frame_end", "avio_seek", "ff_put_h264_qpel16_mc20_10_mmxext", "ff_ntp_time", "ff_put_qpel16_mc31_old_c", "av_audio_fifo_read", "avsubtitle_free", "av_twofish_alloc", "shuffle_bytes_3210", "ff_put_pixels8x8_c", "avresample_get_matrix", "ff_init_scantable", "avpriv_solve_lls", "ff_mpeg4_pred_ac", "ff_put_h264_qpel16_mc31_10_mmxext", "av_realloc_f", "av_frame_set_pkt_pos", "ff_mpadsp_init_x86", "av_default_item_name", "ff_h264_idct8_add_10_c", "sws_freeContext", "ff_fft_init_fixed_32", "av_stream_get_recommended_encoder_configuration", "ff_mpegvideodsp_init", "ff_af_queue_remove", "av_log_default_callback", "av_buffersrc_add_ref", "ff_simple_idct_8", "av_opt_set", "ff_index_search_timestamp", "avcodec_get_name", "avio_wl64", "ff_imdct_half_c_fixed_32", "ff_avg_h264_qpel16_mc30_10_mmxext", "x264_macroblock_cache_load_interlaced", "x264_me_refine_bidir_rd", "ff_riff_write_info", "av_frame_free", "ff_af_queue_close", "ff_all_formats", "ff_init_ff_cos_tabs", "ff_rate_control_init", "avfilter_uninit", "rgb64tobgr48_bswap", "avfilter_process_command", "av_default_get_category", "sws_init_context", "av_find_input_format", "ff_aac_search_for_is", "av_bprint_get_buffer", "ff_tget_short", "av_buffersink_get_samples", "rgb16to24", "ff_gen_search", "avcodec_register", "av_pix_fmt_desc_get_id", "x264_slurp_file", "ff_avg_qpel8_mc13_old_c", "rgb48tobgr48_nobswap", "av_grow_packet", "av_stereo3d_alloc", "avfilter_ref_get_channels", "av_get_output_timestamp", "av_interleaved_write_uncoded_frame", "ff_compute_frame_duration", "avcodec_default_execute", "x264_encoder_reconfig_apply", "av_frame_get_channels", "ff_mpeg_ref_picture", "av_get_string", "av_stream_set_recommended_encoder_configuration", "ff_simple_idct_put_10", "x264_cabac_block_residual_8x8_rd_c", "x264_frame_expand_border_chroma", "ff_get_line", "ff_h264_idct8_add_12_c", "av_opt_set_defaults2", "ff_put_no_rnd_qpel8_mc32_old_c", "ff_mp4_parse_es_descr", "ff_aac_encode_main_pred", "av_opt_set_image_size", "av_guess_codec", "x264_intra_satd_x3_8x16c", "ff_idctdsp_init", "av_compare_mod", "ffurl_protocol_next", "av_timecode_check_frame_rate", "av_bitstream_filter_close", "av_blowfish_alloc", "avcodec_register_all", "av_packet_shrink_side_data", "av_format_set_metadata_header_padding", "ffurl_read_complete", "sws_scaleVec", "x264_frame_unshift", "ff_psdsp_init_x86", "av_buffer_make_writable", "ff_parse_close", "x264_frame_pop_blank_unused", "avfilter_register", "ff_get_best_fcode", "ff_put_pixels16_xy2_mmx", "avcodec_find_encoder_by_name", "av_audio_fifo_space", "x264_opencl_slicetype_prep", "ff_graph_thread_init", "av_murmur3_final", "ff_all_samplerates", "avresample_open", "ff_put_pixels8_xy2_mmx", "av_sha512_final", "swr_set_matrix", "x264_sync_frame_list_push", "av_buffersink_get_frame_rate", "av_audio_fifo_write", "av_rescale_rnd", "ff_init_ff_sine_windows_fixed", "av_rescale", "ff_simple_idct_mmx", "av_dynarray_add", "av_get_packed_sample_fmt", "avio_rl64", "av_log_set_callback", "ff_imdct15_uninit", "ff_init_ff_cos_tabs_fixed", "sws_getColorspaceDetails", "av_frame_is_writable", "av_guess_frame_rate", "ff_avg_qpel16_mc11_old_c", "ff_avfilter_graph_update_heap", "ffurl_alloc", "ff_thread_ref_frame", "av_get_pix_fmt_loss", "av_bprint_escape", "sws_get_class", "ff_rtmp_packet_dump", "ff_get_mb_score", "avfilter_license", "x264_macroblock_write_cabac", "avio_rb32", "avio_put_str", "avio_printf", "av_init_packet", "ff_alloc_entries", "ff_init_desc_hscale", "ff_aac_sbr_init", "ff_jpeg_fdct_islow_8", "ff_parse_key_value", "av_color_space_name", "ff_iir_filter", "ff_eq_init_x86", "av_samples_alloc_array_and_samples", "x264_slicetype_decide", "ff_init_vscale_pfn", "av_opt_is_set_to_default", "ffurl_read", "ff_alloc_picture", "ff_dualinput_filter_frame", "avcodec_align_dimensions", "av_get_q", "ff_simple_idct_add_mmx", "ff_rdft_init", "ff_h264_idct8_dc_add_8_c", "x264_threadpool_run", "av_opt_set_int", "avformat_new_stream", "av_frame_make_writable", "av_freep", "ff_imdct_calc_c_fixed_32", "ff_mp4_read_descr", "ff_codec_guid_get_id", "avcodec_find_best_pix_fmt_of_list", "ff_h264_ref_picture", "ff_dct32_float", "ff_aac_apply_main_pred", "av_sdp_create", "av_dump_format", "ff_parse_sample_format", "x264_cabac_init", "x264_frame_delete", "ff_h264chroma_init_x86", "ff_flv2_encode_ac_esc", "av_rc4_alloc", "avpriv_align_put_bits", "ff_idet_filter_line_c_16bit", "ff_read_frame_flush", "ff_mpeg12_init_vlcs", "avresample_build_matrix", "avcodec_get_frame_class", "ff_mpv_report_decode_progress", "ff_volume_init_x86", "ff_sws_init_range_convert", "ff_load_image", "swri_dither_init", "av_seek_frame", "av_get_channel_layout", "ff_h263_encode_motion", "av_packet_rescale_ts", "swr_get_delay", "ff_get_buffer", "ff_h263_pred_acdc", "x264_opencl_close_library", "ff_rtp_get_payload_type", "ff_blockdsp_init_x86", "avcodec_version", "av_bprint_channel_layout", "ff_avg_pixels8x8_c", "ff_framesync_configure", "ff_mpeg4_merge_partitions", "ffio_open2_wrapper", "ff_riff_write_info_tag", "av_des_init", "x264_threadpool_delete", "ff_mjpeg_init_hvsample", "av_dct_end", "ff_psy_preprocess", "x264_encoder_close", "avfilter_next", "ff_h264_idct_add16_9_c", "ff_id3v2_tag_len", "av_interleaved_write_frame", "x264_reduce_fraction", "ff_avg_h264_qpel16_mc10_10_mmxext", "ff_hpeldsp_init", "ff_parse_mpeg2_descriptor", "ff_rl_free", "ff_simple_idct_put_mmx", "sws_setColorspaceDetails", "av_bprint_init_for_buffer", "x264_picture_clean", "ff_mjpeg_decode_sos", "avio_get_str16be", "ff_alloc_extradata", "ff_pp7_init_x86", "av_sample_fmt_is_planar", "x264_predict_8x16c_init", "x264_ratecontrol_end", "av_buffersink_params_alloc", "avpicture_deinterlace", "ff_mov_write_packet", "ff_iir_filter_flt", "x264_rc_analyse_slice", "ff_listen_bind", "ff_avg_qpel8_mc12_old_c", "av_hash_final", "ff_gradfun_filter_line_c", "av_probe_input_format", "x264_reference_build_list_optimal", "av_image_copy_to_buffer", "ff_put_qpel8_mc33_old_c", "avcodec_default_release_buffer", "av_reallocp", "av_codec_get_tag2", "x264_weights_analyse", "avcodec_license", "av_parser_init", "avcodec_free_context", "ff_qpeldsp_init_x86", "avio_flush", "ff_h264_pred_init_x86", "ff_planar_sample_fmts", "x264_param2string", "av_write_uncoded_frame_query", "ff_iir_filter_free_coeffsp", "av_buffer_realloc", "av_thread_message_queue_free"], "allstrings": ["infinity", "+infinity", "+inf", "-infinity", "-inf", "+nan", "-nan", "aac_adtstoasc", "Assertion %s failed at %s:%d\n", "Too many channels\n", "Reserved bit set.\n", "invalid band type\n", "ms_present = 3 is reserved.\n", "mono with CPE\n", "stereo with SCE\n", "SBR+", "960/120 MDCT window", "epConfig %d", "Low Delay SBR", "Audio object type %s%d", "audio config changed\n", "initializing latmctx\n", "Elem type:%x id:%x\n", "extension type: %d len:%d\n", "FILL:%s\n", "libfaac %d.%d", "no frame data found\n", "Multiple programs", "Multiple layers", "no decoder config found\n", "incomplete frame\n", "aac_latm", "AAC (Advanced Audio Coding)", "Main", "HE-AAC", "HE-AACv2", "AAC decoder", "dual_mono_mode", "auto", "autoselection", "main", "Select Main/Left channel", "Select Sub/Right channel", "both", "Select both channels", "Unsupported sample rate %d\n", "Unsupported profile %d\n", "Cannot allocate memory.\n", "Input contains NaN\n", "Lavc56.60.100", "libavcodec/aacenc.c", "diff >= 0 && diff <= 120", "AAC encoder", "stereo_mode", "Stereo coding method", "Selected by the Encoder", "ms_off", "Disable Mid/Side coding", "ms_force", "aac_coder", "Coding algorithm", "faac", "FAAC-inspired method", "anmr", "ANMR method", "twoloop", "Two loop searching method", "fast", "Constant quantizer", "aac_pns", "Perceptual Noise Substitution", "disable", "enable", "aac_is", "Intensity stereo coding", "intensity_stereo", "aac_tns", "Temporal noise shaping", "Enable temporal noise shaping", "aac_pred", "AAC-Main prediction", "Disable AAC-Main prediction", "Enable AAC-Main prediction", "iid_mode %d is reserved.\n", "icc_mode %d is reserved.\n", "illegal iid\n", "illegal icc\n", "ps extension overflow %d\n", "iid_par invalid\n", "icc_par invalid\n", "3GPP TS 26.403-inspired model", "libavcodec/aacsbr_template.c", "bs_pointer >= 0", "Non monotone time borders\n", "Invalid bs_stop_freq: %d\n", "Invalid n_master: %d\n", "Invalid num_bands_0: %d\n", "Invalid vDk0[%d]: %d\n", "Invalid vDk1[%d]: %d\n", "patch construction failed\n", "Too many patches: %d\n", "Reserved SBR extensions", "SBR Extension over read.\n", "sbr->data[ch].bs_num_env > 0", "!afq->frame_count", "AVDCT", "DCT algorithm", "fastint", "accurate integer", "experimental / for debugging", "altivec", "faan", "idct", "select IDCT implementation", "simple", "simplemmx", "simplearm", "simplearmv5te", "simplearmv6", "simpleneon", "simplealpha", "xvid", "xvidmmx", "faani", "simpleauto", "bits_per_sample", "libavcodec/avpacket.c", "Palette", "New Extradata", "Param Change", "H263 MB Info", "Replay Gain", "Display Matrix", "Stereo 3D", "Audio Service Type", "Skip Samples", "JP Dual Mono", "Strings Metadata", "Subtitle Position", "Matroska BlockAdditional", "WebVTT ID", "WebVTT Settings", "Metadata Update", "p-pkt->data == pkt->size", "incorrect codes\n", "libavcodec/bitstream.c", "length <= put_bits_left(pb)", "libavcodec/put_bits.h", "n <= s->buf_end - s->buf_ptr", "symbols_size <= 2 || !symbols", "Invalid code in init_vlc\n", "needed %d had %d\n", "ret >= 0", "mpeg1video", "MPEG-1 video", "mpeg2video", "MPEG-2 video", "mpegvideo_xvmc", "h261", "H.261", "h263", "rv10", "RealVideo 1.0", "rv20", "RealVideo 2.0", "mjpeg", "Motion JPEG", "mjpegb", "Apple MJPEG-B", "mpeg4", "MPEG-4 part 2", "rawvideo", "raw video", "msmpeg4v1", "msmpeg4v2", "msmpeg4v3", "wmv1", "Windows Media Video 7", "wmv2", "Windows Media Video 8", "h263p", "h263i", "Intel H.263", "flv1", "svq1", "svq3", "dvvideo", "DV (Digital Video)", "huffyuv", "HuffYUV", "cyuv", "Creative YUV (CYUV)", "h264", "indeo3", "Intel Indeo 3", "On2 VP3", "theora", "Theora", "asv1", "ASUS V1", "asv2", "ASUS V2", "ffv1", "FFmpeg video codec #1", "4X Movie", "vcr1", "ATI VCR1", "cljr", "Cirrus Logic AccuPak", "mdec", "id RoQ video", "interplayvideo", "Interplay MVE video", "xan_wc3", "Wing Commander III / Xan", "xan_wc4", "Wing Commander IV / Xxan", "rpza", "QuickTime video (RPZA)", "cinepak", "Cinepak", "ws_vqa", "msrle", "Microsoft RLE", "msvideo1", "Microsoft Video 1", "idcin", "id Quake II CIN video", "8bps", "QuickTime 8BPS video", "QuickTime Graphics (SMC)", "flic", "Autodesk Animator Flic video", "truemotion1", "Duck TrueMotion 1.0", "vmdvideo", "Sierra VMD video", "mszh", "zlib", "qtrle", "snow", "Snow", "tscc", "ulti", "IBM UltiMotion", "qdraw", "Apple QuickDraw", "vixl", "Miro VideoXL", "qpeg", "Q-team QPEG", "ffvhuff", "Huffyuv FFmpeg variant", "rv30", "RealVideo 3.0", "rv40", "RealVideo 4.0", "SMPTE VC-1", "wmv3", "Windows Media Video 9", "loco", "LOCO", "wnv1", "Winnov WNV1", "aasc", "Autodesk RLE", "indeo2", "Intel Indeo 2", "fraps", "Fraps", "truemotion2", "Duck TrueMotion 2.0", "BMP (Windows and OS/2 bitmap)", "cscd", "CamStudio", "mmvideo", "American Laser Games MM Video", "zmbv", "Zip Motion Blocks Video", "smackvideo", "Smacker video", "NuppelVideo/RTJPEG", "kmvc", "Karl Morton's video codec", "flashsv", "Flash Screen Video v1", "cavs", "jpeg2000", "JPEG 2000", "vmnc", "On2 VP5", "On2 VP6", "vp6f", "On2 VP6 (Flash version)", "dsicinvideo", "tiertexseqvideo", "Tiertex Limited SEQ video", "Feeble Files/ScummVM DXA", "dnxhd", "VC3/DNxHD", "Nintendo Gamecube THP video", "Interplay C93", "bethsoftvid", "Bethesda VID video", "vp6a", "AMV Video", "Beam Software VB", "indeo4", "indeo5", "mimic", "Mimic", "RL2 video", "escape124", "Escape 124", "dirac", "Dirac", "Brute Force & Ignorance", "Electronic Arts CMV video", "motionpixels", "Motion Pixels video", "Electronic Arts TGV video", "Electronic Arts TGQ video", "Electronic Arts TQI video", "aura", "Auravision AURA", "aura2", "Auravision Aura 2", "v210x", "Uncompressed 4:2:2 10-bit", "8088flex TMV", "v210", "Electronic Arts Madcow Video", "frwu", "Forward Uncompressed", "flashsv2", "Flash Screen Video v2", "cdgraphics", "CD Graphics video", "r210", "Uncompressed RGB 10-bit", "Deluxe Paint Animation", "binkvideo", "Bink video", "iff_ilbm", "IFF ILBM", "iff_byterun1", "IFF ByteRun1", "kgv1", "Kega Game Video", "Psygnosis YOP Video", "On2 VP8", "Google VP9", "pictor", "Pictor/PC Paint", "a64_multi", "a64_multi5", "r10k", "AJA Kona 10-bit RGB Codec", "mvc1", "mvc2", "mxpeg", "Mobotix MxPEG video", "lagarith", "Lagarith lossless", "prores", "Apple ProRes (iCodec Pro)", "Bitmap Brothers JV video", "Chronomaster DFA", "utvideo", "Ut Video", "bmv_video", "Discworld II BMV video", "vble", "VBLE Lossless Codec", "dxtory", "Dxtory", "v410", "Uncompressed 4:4:4 10-bit", "cdxl", "Commodore CDXL video", "zerocodec", "ZeroCodec Lossless Video", "mss1", "MS Screen 1", "msa1", "MS ATC Screen", "tscc2", "TechSmith Screen Codec 2", "mts2", "MS Expression Encoder Screen", "cllc", "Canopus Lossless Codec", "mss2", "Apple Intermediate Codec", "y41p", "Uncompressed YUV 4:1:1 12-bit", "escape130", "Escape 130", "avrp", "Avid 1:1 10-bit RGB Packer", "012v", "avui", "Avid Meridien Uncompressed", "ayuv", "targa_y216", "Pinnacle TARGA CineWave YUV16", "v308", "Uncompressed packed 4:4:4", "v408", "yuv4", "Uncompressed packed 4:2:0", "avrn", "Avid AVI Codec", "cpia", "CPiA video format", "xface", "X-face image", "smvjpeg", "Sigmatel Motion Video", "Go2Meeting", "hnm4video", "HNM 4 video", "hevc", "Mirillis FIC", "paf_video", "On2 VP7", "sanm", "LucasArts SANM/SMUSH video", "sgirle", "SGI RLE 8-bit", "Canopus HQX", "hq_hqa", "Canopus HQ/HQA", "Vidvox Hap decoder", "alias_pix", "Alias/Wavefront PIX image", "ansi", "ASCII/ANSI art", "brender_pix", "BRender PIX image", "OpenEXR image", "jpegls", "JPEG-LS", "ljpeg", "Lossless JPEG", "PAM (Portable AnyMap) image", "PBM (Portable BitMap) image", "PC Paintbrush PCX image", "PGM (Portable GrayMap) image", "pgmyuv", "PPM (Portable PixelMap) image", "V.Flash PTX image", "SGI image", "sp5x", "Sunplus JPEG (SP5X)", "sunrast", "Sun Rasterfile image", "targa", "Truevision Targa image", "tdsc", "TDSC", "tiff", "TIFF image", "vc1image", "webp", "WebP", "wmv3image", "Windows Media Video 9 Image", "XBM (X BitMap) image", "XWD (X Window Dump) image", "apng", "pcm_s16le", "pcm_s16be", "PCM signed 16-bit big-endian", "pcm_u16le", "pcm_u16be", "pcm_s8", "PCM signed 8-bit", "pcm_u8", "PCM unsigned 8-bit", "pcm_mulaw", "PCM mu-law / G.711 mu-law", "pcm_alaw", "PCM A-law / G.711 A-law", "pcm_s32le", "pcm_s32be", "PCM signed 32-bit big-endian", "pcm_u32le", "pcm_u32be", "pcm_s24le", "pcm_s24be", "PCM signed 24-bit big-endian", "pcm_u24le", "pcm_u24be", "pcm_s24daud", "pcm_zork", "PCM Zork", "pcm_s16be_planar", "pcm_s16le_planar", "pcm_s24le_planar", "pcm_s32le_planar", "pcm_dvd", "pcm_f32be", "pcm_f32le", "pcm_f64be", "pcm_f64le", "pcm_bluray", "pcm_lxf", "s302m", "SMPTE 302M", "pcm_s8_planar", "PCM signed 8-bit planar", "adpcm_ima_qt", "ADPCM IMA QuickTime", "adpcm_ima_wav", "ADPCM IMA WAV", "adpcm_ima_dk3", "ADPCM IMA Duck DK3", "adpcm_ima_dk4", "ADPCM IMA Duck DK4", "adpcm_ima_ws", "ADPCM IMA Westwood", "adpcm_ima_smjpeg", "ADPCM IMA Loki SDL MJPEG", "adpcm_ms", "ADPCM Microsoft", "adpcm_4xm", "ADPCM 4X Movie", "adpcm_xa", "ADPCM CDROM XA", "adpcm_adx", "SEGA CRI ADX ADPCM", "adpcm_ea", "ADPCM Electronic Arts", "adpcm_g726", "G.726 ADPCM", "adpcm_ct", "ADPCM Creative Technology", "adpcm_swf", "ADPCM Shockwave Flash", "adpcm_yamaha", "ADPCM Yamaha", "adpcm_sbpro_4", "ADPCM Sound Blaster Pro 4-bit", "adpcm_sbpro_3", "adpcm_sbpro_2", "ADPCM Sound Blaster Pro 2-bit", "adpcm_thp", "ADPCM Nintendo THP", "adpcm_thp_le", "adpcm_ima_amv", "ADPCM IMA AMV", "adpcm_ea_r1", "ADPCM Electronic Arts R1", "adpcm_ea_r3", "ADPCM Electronic Arts R3", "adpcm_ea_r2", "ADPCM Electronic Arts R2", "adpcm_ima_ea_sead", "adpcm_ima_ea_eacs", "adpcm_ea_xas", "ADPCM Electronic Arts XAS", "adpcm_ea_maxis_xa", "adpcm_ima_iss", "ADPCM IMA Funcom ISS", "adpcm_g722", "G.722 ADPCM", "adpcm_ima_apc", "ADPCM IMA CRYO APC", "adpcm_afc", "ADPCM Nintendo Gamecube AFC", "adpcm_ima_oki", "ADPCM IMA Dialogic OKI", "adpcm_dtk", "ADPCM Nintendo Gamecube DTK", "adpcm_ima_rad", "ADPCM IMA Radical", "adpcm_g726le", "G.726 ADPCM little-endian", "adpcm_vima", "LucasArts VIMA audio", "amr_nb", "amr_wb", "ra_144", "RealAudio 1.0 (14.4K)", "ra_288", "RealAudio 2.0 (28.8K)", "roq_dpcm", "DPCM id RoQ", "interplay_dpcm", "DPCM Interplay", "xan_dpcm", "DPCM Xan", "sol_dpcm", "DPCM Sol", "MP2 (MPEG audio layer 2)", "MP3 (MPEG audio layer 3)", "ATSC A/52A (AC-3)", "DCA (DTS Coherent Acoustics)", "vorbis", "Vorbis", "dvaudio", "DV audio", "wmav1", "Windows Media Audio 1", "wmav2", "Windows Media Audio 2", "mace3", "mace6", "vmdaudio", "Sierra VMD audio", "flac", "mp3adu", "mp3on4", "MP3onMP4", "shorten", "Shorten", "alac", "westwood_snd1", "Westwood Audio (SND1)", "qdm2", "QDesign Music Codec 2", "cook", "truespeech", "DSP Group TrueSpeech", "TTA (True Audio)", "smackaudio", "Smacker audio", "qcelp", "QCELP / PureVoice", "wavpack", "WavPack", "dsicinaudio", "IMC (Intel Music Coder)", "musepack7", "Musepack SV7", "gsm_ms", "GSM Microsoft variant", "atrac3", "voxware", "Voxware RT29 Metasound", "Monkey's Audio", "nellymoser", "Nellymoser Asao", "musepack8", "Musepack SV8", "speex", "Speex", "wmavoice", "Windows Media Audio Voice", "wmapro", "wmalossless", "Windows Media Audio Lossless", "atrac3p", "eac3", "ATSC A/52B (AC-3, E-AC-3)", "sipr", "RealAudio SIPR / ACELP.NET", "MP1 (MPEG audio layer 1)", "twinvq", "VQF TwinVQ", "truehd", "TrueHD", "mp4als", "atrac1", "binkaudio_rdft", "Bink Audio (RDFT)", "binkaudio_dct", "Bink Audio (DCT)", "qdmc", "QDesign Music", "celt", "g723_1", "G.723.1", "dss_sp", "g729", "G.729", "8svx_exp", "8SVX exponential", "8svx_fib", "8SVX fibonacci", "bmv_audio", "Discworld II BMV audio", "ralf", "RealAudio Lossless", "IAC (Indeo Audio Coder)", "ilbc", "wavesynth", "Wave synthesis pseudo-codec", "sonic", "Sonic", "sonicls", "Sonic lossless", "opus", "comfortnoise", "RFC 3389 Comfort Noise", "metasound", "Voxware MetaSound", "paf_audio", "On2 Audio for Video Codec", "evrc", "SMV (Selectable Mode Vocoder)", "dsd_lsbf", "dsd_msbf", "dsd_lsbf_planar", "dsd_msbf_planar", "dvd_subtitle", "DVD subtitles", "dvb_subtitle", "DVB subtitles", "text", "raw UTF-8 text", "xsub", "XSUB", "ASS (Advanced SSA) subtitle", "mov_text", "MOV text", "hdmv_pgs_subtitle", "dvb_teletext", "DVB teletext", "subrip", "SubRip subtitle", "microdvd", "MicroDVD subtitle", "mpl2", "MPL2 subtitle", "eia_608", "EIA-608 closed captions", "jacosub", "JACOsub subtitle", "sami", "SAMI subtitle", "realtext", "RealText subtitle", "Spruce subtitle format", "subviewer1", "SubViewer v1 subtitle", "subviewer", "SubViewer subtitle", "vplayer", "VPlayer subtitle", "webvtt", "WebVTT subtitle", "hdmv_text_subtitle", "HDMV Text subtitle", "TrueType font", "bintext", "Binary text", "xbin", "eXtended BINary text", "iCEDraw text", "OpenType font", "dvd_nav_packet", "DVD Nav packet", "timed_id3", "timed ID3 metadata", "bin_data", "binary data", "brender_pix_deprecated", "escape130_deprecated", "Escape 130 (deprecated id)", "exr_deprecated", "OpenEXR image (deprecated id)", "g2m_deprecated", "Go2Meeting (deprecated id)", "hevc_deprecated", "paf_video_deprecated", "sanm_deprecated", "vp7_deprecated", "On2 VP7 (deprecated id)", "webp_deprecated", "WebP (deprecated id)", "vima", "adpcm_vima_deprecated", "opus_deprecated", "paf_audio_deprecated", "pcm_s24le_planar_deprecated", "pcm_s32le_planar_deprecated", "pcm_s16be_planar_deprecated", "tak_deprecated", "application/octet-stream", "application/vnd.ms-opentype", "application/x-truetype-font", "application/x-font", "image/png", "image/x-xwindowdump", "image/webp", "image/tiff", "image/x-targa", "image/x-tga", "image/x-pcx", "image/x-portable-pixmap", "image/gif", "image/jp2", "image/x-ms-bmp", "image/jpeg", "guess_dc() is out of memory\n", "libavcodec/error_resilience.c", "s->quarter_sample", "ignoring last missing slice\n", "Warning MVs not available\n", "%2X ", "0x%04X", "TIFF tag type (%u)", "Bad picture start code\n", "Bad picture format\n", "%c esc_type:%d, qp:%d num:%d\n", "flv encoder", "non_deterministic", "threads", "Unsupported codec %d\n", "L263", "S263", "Slice mismatch at MB: %d\n", "Error at MB: %d\n", "overreading %d bits\n", "header damaged\n", "format change not supported\n", "GEOV", "GEOX", "Reference invalid\n", "Invalid POC %d<%d\n", "libavcodec/h264.c", "pics <= 16", "no picture %s\n", "AVC: nal size %d\n", "NAL %d/%d at %d/%d length %d\n", "Invalid inter IDR frame\n", "data partitioning", "decode_slice_header error\n", "avcC %d too short\n", "buf_index <= buf_size", "Q264", "no frame!\n", "pict->buf[0] || !*got_frame", "Baseline", "Constrained Baseline", "Extended", "High", "High 10", "High 10 Intra", "High 4:2:2", "High 4:2:2 Intra", "High 4:4:4", "High 4:4:4 Predictive", "High 4:4:4 Intra", "CAVLC 4:4:4", "H264 Decoder", "is_avc", "is avc", "nal_length_size", "enable_er", "Reference %d >= %d\n", "gray chroma\n", "Invalid level prefix\n", "libavcodec/h264_cavlc.c", "ref %u overflow\n", "cbp too large (%u) at %d %d\n", "private_spspps_buf", "h264_mp4toannexb", "pps_id %u out of range\n", "reference count %d overflow\n", "libavcodec/h264_picture.c", "!dst->f->buf[0]", "src->f->buf[0]", "sl == h->slice_ctx", "cpb_count %d invalid\n", "PIC-AFF", "MB-AFF", "sps_id %u out of range\n", "chroma_format_idc %u", "poc_cycle_length overflow %d\n", "illegal POC type %d\n", "too many reference frames %d\n", "mb_width/height overflow\n", "illegal aspect ratio\n", "Truncated VUI\n", "Overread %s by %d bits\n", "8x8DCT", "REDU", "CONSTR", "LPAR", "weighted", "CABAC", "CAVLC", "Invalid luma bit depth=%d\n", "FMO not supported\n", "reference overflow (pps)\n", "remove short %d count %d\n", "%d %d %p\n", "libavcodec/h264_refs.c", "index < def_len", "len <= 32", "short term list:\n", "%u fn:%d poc:%d %p\n", "long term list:\n", "reference count overflow\n", "abs_diff_pic_num overflow\n", "long_term_pic_idx overflow\n", "no mmco here\n", "mmco:%d %d %d\n", "mmco: unref short failure\n", "mmco: unref long failure\n", "!h->cur_pic_ptr->long_ref", "x264 - core %d", "x264 - core 0000", "user data:\"%s\"\n", "SEI %d len:%d\n", "ct_type:%X pic_struct:%d\n", "sei_recovery_frame_cnt: %d\n", "SEI FPA %d %d %d %d %d %d\n", "unknown SEI type %d\n", "checkerboard_rl", "checkerboard_lr", "col_interleaved_rl", "col_interleaved_lr", "row_interleaved_rl", "row_interleaved_lr", "right_left", "left_right", "bottom_top", "top_bottom", "block_rl", "block_lr", "mono", "Could not allocate memory\n", "Unsupported bit depth %d\n", "context_init() failed.\n", "libavcodec/h264_slice.c", "!pic->f->data[0]", "!pic->hwaccel_picture_private", "no frame buffer available\n", "bytestream overread %td\n", "TEMP", "SPAT", " IDR", " fix", "!h->setup_finished", "Too many fields\n", "Broken frame packetizing\n", "PPS changed between slices\n", "h->cur_pic_ptr", "h->cur_pic_ptr->f->buf[0]", "Frame num gap %d %d\n", "first_mb_in_slice overflow\n", "cabac_init_idc %u overflow\n", "QP %u out of range\n", "libavcodec/h264dsp.c", "bit_depth<=8", "libavcodec/h264pred.c", "libavcodec/imgconvert.c", "desc", "after picture_number", "Bad H263 id\n", "SAC not supported\n", "Wrong Intel H263 format\n", "Bad value for reserved field\n", "Invalid marker\n", "in dimensions", "Invalid aspect ratio.\n", "illegal dc %d at %d %d\n", "illegal ac vlc code at %dx%d\n", "run overflow at %dx%d i:%d\n", " LOOP", " AIV", " AIC", " LONG", " UMV", "before MBA", "after MBA", "after SQUANT", "cbpc damaged at %d %d\n", "b mb_type damaged at %d %d\n", "b cbpy damaged at %d %d\n", "I cbpc damaged at %d %d\n", "I cbpy damaged at %d %d\n", "in PTYPE", "H263 SAC not supported\n", "Bad UFEP type (%d)\n", "zero framerate\n", "SEPB1", "SEPB2", " %5d", "ZYGO", "libavcodec/kbdwin.c", "n <= 1024", "Possible presets:", "Possible tunes:", "weightp", "bad option '%s': '%s'\n", "bad value for '%s': '%s'\n", "level", "Failed to parse level\n", "psy-rd", "deblock", "partitions", "stats", "baseline", "high", "high10", "high422", "high444", "Error setting profile %s.\n", "Possible profiles:", "%255[^:=]=%255[^:]", "libx264rgb", "libx264", "flags2", "i_qfactor", "b_qfactor", "qmin", "qmax", "qdiff", "qblur", "qcomp", "refs", "sc_threshold", "trellis", "me_range", "me_method", "subq", "b_strategy", "keyint_min", "coder", "thread_type", "flags", "+cgop", "rc_init_occupancy", "preset", "medium", "tune", "profile", "fastfirstpass", "passlogfile", "Filename for 2 pass stats", "wpredp", "x264opts", "x264 options", "crf_max", "aq-mode", "AQ method", "aq_mode", "none", "variance", "Variance AQ (complexity mask)", "autovariance", "Auto-variance AQ", "autovariance-biased", "aq-strength", "rc-lookahead", "weightb", "smart", "ssim", "intra-refresh", "bluray-compat", "b-bias", "b-pyramid", "b_pyramid", "strict", "Strictly hierarchical pyramid", "normal", "mixed-refs", "8x8dct", "High profile 8x8 transform.", "fast-pskip", "Use access unit delimiters.", "mbtree", "cplxblur", "direct-pred", "Direct MV prediction mode", "spatial", "temporal", "slice-max-size", "nal-hrd", "avcintra-class", "AVC-Intra class 50/100/200", "motion-est", "Set motion estimation method", "tesa", "forced-idr", "x264-params", "film", "animation", "grain", "stillimage", "psnr", "fastdecode", "zerolatency", "ultrafast", "superfast", "veryfast", "faster", "slow", "slower", "veryslow", "placebo", "libavcodec/lpc.c", "Single field\n", "libavcodec/mjpegdec.c", "nb_codes <= 256", "dqt: len %d is too large\n", "dqt: invalid precision\n", "index=%d\n", "qscale[%d]: %d\n", "dht: len %d is too large\n", "using external huffman table\n", "bottom field first\n", "AVID: len:%d %d\n", "MJPG", "bits %d is invalid\n", "sof0: picture: %dx%d\n", "quant_index is invalid\n", "Subsampling in JPEG-LS", "pix fmt id %x\n", "s->nb_components == 3", "s->nb_components == 4", "PRCT", "lossless", "sequential DCT", "s->picture_ptr->data[0]", "decode_sos: invalid len (%d)\n", "component: %d\n", "s->picture_ptr == s->picture", "ss>=0 && Ah>=0 && Al>=0", "SS/SE %d/%d is invalid\n", "error count: %d\n", "ZRL overflow: %d\n", "error y=%d x=%d\n", "mb_bitmask_size mismatches\n", "overread %d\n", "error dc\n", "CJPG", "escaping removed %td bytes\n", "Invalid escape sequence\n", "startcode: %X\n", "restart marker: %d\n", "APPx (%s / %8X) len=%d\n", "polarity %d\n", "unknown colorspace %d\n", "Mismatching LJIF tag\n", "COLR %d\n", "XFRM %d\n", "_JPSJPS_\n", "libavcodec/bytestream.h", "buf_size >= 0", "comment: '%s'\n", "AVID", "CS=ITU601", "Metasoft MJPEG Codec", "MULTISCOPE II", "JPEG-LS support not enabled.\n", "huffman table decode error\n", "QP: %d\n", "restart interval: %d\n", "EOI missing, emulating\n", "No JPEG data found in image\n", "w > 0", "invalid buffer\n", "AVI1", "JFIF", "Adob", "LJIF", "colr", "xfrm", "_JPS", "Exif", "mjpg", "MJPEG (Motion JPEG)", "MJPEG decoder", "extern_huff", "Use external huffman table.", "mjpeg encoder", "libavcodec/mjpegenc_common.c", "Buffer reallocation failed\n", "libavcodec/motion_est.c", "s->linesize == c->stride", "s->uvlinesize == c->uvstride", "libavcodec/mpeg12.c", "Failed to parse extradata\n", "dc<0 at %dx%d\n", "dc overflow at %dx%d\n", "DivX%dBuild%d%c", "DivX%db%d%c", "FFmpe%*[^b]b%d", "Lavc%d.%d.%d", "ffmpeg", "XviD%d", "before sprite_trajectory", "after sprite_trajectory", "after new_pred", " VOLC", "before time_increment", "before vop_coded", "vop not coded\n", "after width", "after height", "after hor_spat_ref", "Header truncated\n", "static sprite not supported\n", "illegal dc vlc\n", "dc marker bit missing\n", "reverse esc missing\n", "ac-tex damaged at %d %d\n", "mcbpc damaged at %d %d\n", "P cbpy damaged at %d %d\n", "illegal MB_type\n", "marker does not match f_code\n", "untested\n", "mcbpc corrupted at %d %d\n", "DC corrupted at %d %d\n", "slice below monitor ...\n", "cbpy corrupted at %d %d\n", "I cbpy corrupted at %d %d\n", "P cbpy corrupted at %d %d\n", "XVIX", "UMP4", "XVID", "RMP4", "ZMP4", "SIPP", "DIVX", "rvlc ", "partition ", "qpel ", "scalability ", "frame skip %d\n", "startcode: %3X ", "Video Object Start", "Video Object Layer Start", "Reserved", "FGS bp start", "Visual Object Seq Start", "Visual Object Seq End", "User Data", "Group of VOP start", "Video Session Error", "Visual Object Start", "Video Object Plane start", "slice start", "extension start", "fgs start", "FBA Object start", "FBA Object Plane start", "Mesh Object start", "Mesh Object Plane start", "Still Texture Object start", "Texture Spatial Layer start", "Texture SNR Layer start", "Texture Tile start", "Texture Shape Layer start", "stuffing start", "reserved", "System start", " at %d\n", "illegal chroma format\n", "after first_half_bitrate", "after latter_half_bitrate", "Gray shape not supported\n", "framerate==0\n", "before fixed_vop_rate", "before width", "before height", "Static Sprites not supported\n", "after sprite_width", "after sprite_height", "after sprite_left", "after sprite_top", "%d sprite_warping_points\n", "N-bit not supported\n", "quant precision %d\n", "VOL Header truncated\n", "new pred not supported\n", "scalability not supported\n", "GOP header invalid\n", "in gop_header", "WV1F", "QMP4", "MP4S", "MPEG4 Video Decoder", "quarter_sample", "1/4 subpel MC", "divx_packed", "divx style packed b frames", "Simple Profile", "Simple Scalable Profile", "Core Profile", "Main Profile", "N-bit Profile", "Scalable Texture Profile", "Simple Face Animation Profile", "Hybrid Profile", "Code Scalable Profile", "Advanced Coding Profile", "Advanced Core Profile", "Simple Studio Profile", "Advanced Simple Profile", "size <= 2147483647/8 - 32", "libavcodec/mpeg4videoenc.c", "time_incr >= 0", "MPEG4 encoder", "data_partitioning", "Use data partitioning.", "alternate_scan", "Enable alternate scantable.", "mpv_flags", "skip_rd", "strict_gop", "Strictly enforce gop size", "qp_rd", "cbp_rd", "always try a mb with mv=<0,0>", "luma_elim_threshold", "chroma_elim_threshold", "quantizer_noise_shaping", "error_rate", "qsquish", "rc_qmod_amp", "rc_qmod_freq", "rc_eq", "rc_init_cplx", "rc_buf_aggressivity", "currently useless", "border_mask", "lmin", "minimum Lagrange factor (VBR)", "lmax", "maximum Lagrange factor (VBR)", "ibias", "intra quant bias", "pbias", "inter quant bias", "rc_strategy", "ratecontrol method", "motion_est", "motion estimation algorithm", "zero", "epzs", "xone", "MP3ADU full parser", "big_values too big\n", "invalid block type\n", "switch point in 8khz", "bits_left=%d\n", "discarding ID3 tag\n", "invalid old backstep %d\n", "invalid new backstep %d\n", "s->frame", "Header missing\n", "libavcodec/mpegpicture.c", "pic->f->data[0]", "!pic->f->buf[0]", "get_buffer() failed (%d %p)\n", "Error allocating a picture.\n", "VCR2", "libavcodec/mpegvideo.c", "s != s1", "releasing zombie picture\n", "New frame, type: %c\n", "DCT coeffs of MB at %dx%d:\n", "libavcodec/mpegvideo_enc.c", "s->linesize >= 32", "scale >= 0 && scale <= 3", "illegal b frame strategy\n", "reencoding frame due to VBV\n", "s->avctx->rc_max_rate", "stuffing too large\n", "vbv buffer overflow\n", "vbv_delay < 0xFFFF", "only YUV420 is supported\n", "intra dc precision too large\n", "bitrate below min bitrate\n", "bitrate above max bitrate\n", "4MV not supported by codec\n", "qpel not supported by codec\n", "w/h must be a multiple of 4\n", "width must be multiple of 2\n", "CBP RD needs trellis quant\n", "QP RD needs mbd=2\n", "framerate not set\n", "encoded frame too large\n", "illegal MB type\n", "wmv1 encoder", "msmpeg4", "msmpeg4v3 encoder", "msmpeg4v2 encoder", "H.263p encoder", "Use unlimited motion vectors.", "Use alternative inter VLC.", "obmc", "structured_slices", "H.263 / H.263-1996", "H.263 encoder", "mb_info", "Failed to set dimensions\n", "NULL", "libavcodec/options.c", "AVSubtitleRect", "type", "forced", "AVFrame", "best_effort_timestamp", "pkt_pos", "pkt_size", "sample_aspect_ratio", "width", "height", "format", "channel_layout", "sample_rate", "AVCodecContext", "set bitrate (in bits/s)", "unaligned", "qpel", "loop", "use loop filter", "qscale", "use fixed qscale", "use gmc", "input_preserved", "pass1", "pass2", "gray", "only decode/encode grayscale", "emu_edge", "do not draw edges", "truncated", "ildct", "use interlaced DCT", "low_delay", "force low delay", "global_header", "bitexact", "ilme", "interlaced motion estimation", "cgop", "closed GOP", "output_corrupt", "noout", "skip bitstream encoding", "ignorecrop", "local_header", "chunks", "showall", "export_mvs", "skip_manual", "set motion estimation method", "full", "tesa motion estimation", "log motion estimation", "phods", "phods motion estimation", "X1 motion estimation", "hex motion estimation", "umh motion estimation", "iter", "iter motion estimation", "time_base", "set number of audio channels", "cutoff", "set cutoff bandwidth", "frame_size", "frame_number", "delay", "RTP payload size in bytes", "mv_bits", "header_bits", "i_tex_bits", "p_tex_bits", "i_count", "p_count", "skip_count", "misc_bits", "frame_bits", "codec_tag", "autodetect", "old_msmpeg4", "xvid_ilace", "ump4", "no_padding", "padding bug (autodetected)", "ac_vlc", "qpel_chroma", "std_qpel", "qpel_chroma2", "direct_blocksize", "edge", "hpel_chroma", "dc_clip", "trunc", "truncated frames", "very", "unofficial", "allow unofficial extensions", "experimental", "b_qoffset", "err_detect", "set error detection flags", "crccheck", "verify embedded CRCs", "bitstream", "buffer", "explode", "ignore_err", "ignore errors", "careful", "compliant", "aggressive", "has_b_frames", "block_align", "mpeg_quant", "rc_override_count", "maxrate", "minrate", "bufsize", "i_qoffset", "fast integer", "floating point AAN DCT", "lumi_mask", "tcplx_mask", "temporal complexity masking", "scplx_mask", "spatial complexity masking", "p_mask", "inter masking", "dark_mask", "floating point AAN IDCT", "slice_count", "guess_mvs", "favor_inter", "bits_per_coded_sample", "pred", "prediction method", "left", "plane", "median", "aspect", "sample aspect ratio", "debug", "print specific debug info", "pict", "picture info", "rate control", "mb_type", "macroblock (MB) type", "motion vector", "dct_coeff", "green_metadata", "skip", "startcode", "error recognition", "mmco", "bugs", "vis_qp", "vis_mb_type", "visualize block types", "buffers", "picture buffer allocations", "thread_ops", "threading operations", "nomc", "skip motion compensation", "vismv", "debug_mv", "full-pel ME compare function", "cmp_func", "subcmp", "sub-pel ME compare function", "mbcmp", "macroblock compare function", "ildctcmp", "dia_size", "last_pred", "preme", "pre motion estimation", "precmp", "sum of squared errors", "satd", "rate distortion optimal, slow", "vsad", "vsse", "nsse", "dctmax", "chroma", "pre_dia_size", "dtg_active_format", "global_quality", "arithmetic coder", "raw (no encoding)", "run-length coder", "deflate", "deflate-based coder", "context", "context model", "slice_flags", "xvmc_acceleration", "use mbcmp (default)", "bits", "use fewest bits", "use best rate distortion", "stream_codec_tag", "scene change threshold", "noise reduction", "error", "me_threshold", "motion estimation threshold", "mb_threshold", "macroblock threshold", "intra_dc_precision", "nssew", "nsse weight", "skip_top", "skip_bottom", "unknown", "aac_main", "aac_low", "aac_ssr", "aac_ltp", "aac_he", "aac_he_v2", "aac_ld", "aac_eld", "mpeg2_aac_low", "mpeg2_aac_he", "dts_es", "dts_96_24", "dts_hd_hra", "dts_hd_ma", "mpeg4_sp", "mpeg4_core", "mpeg4_main", "mpeg4_asp", "lowres", "skip_threshold", "frame skip threshold", "skip_factor", "frame skip factor", "skip_exp", "frame skip exponent", "skipcmp", "frame skip compare function", "mblmin", "mblmax", "mepc", "skip_loop_filter", "avdiscard", "skip_idct", "skip_frame", "discard no frame", "default", "discard useless frames", "noref", "bidir", "nokey", "nointra", "discard all frames", "bidir_refine", "brd_scale", "chromaoffset", "chroma QP offset from luma", "sc_factor", "mv0_threshold", "b_sensitivity", "compression_level", "min_prediction_order", "max_prediction_order", "timecode_frame_start", "request_channels", "bits_per_raw_sample", "request_channel_layout", "rc_max_vbv_use", "rc_min_vbv_use", "ticks_per_frame", "color_primaries", "color primaries", "color_primaries_type", "bt709", "BT.709", "unspecified", "Unspecified", "bt470m", "BT.470 M", "bt470bg", "BT.470 BG", "smpte170m", "SMPTE 170 M", "smpte240m", "SMPTE 240 M", "Film", "bt2020", "BT.2020", "color_trc", "color_trc_type", "gamma22", "gamma28", "linear", "Linear", "log_sqrt", "Log square root", "iec61966_2_4", "IEC 61966-2-4", "bt1361", "BT.1361", "iec61966_2_1", "IEC 61966-2-1", "bt2020_10bit", "BT.2020 - 10 bit", "bt2020_12bit", "BT.2020 - 12 bit", "colorspace", "color space", "colorspace_type", "ycocg", "YCOCG", "bt2020_ncl", "BT.2020 NCL", "bt2020_cl", "BT.2020 CL", "color_range", "color range", "color_range_type", "mpeg", "MPEG (219*2^(n-8))", "jpeg", "JPEG (2^n-1)", "chroma_sample_location", "chroma sample location", "chroma_sample_location_type", "Left", "center", "Center", "topleft", "Top-left", "bottomleft", "Bottom-left", "bottom", "Bottom", "log_level_offset", "set the log level offset", "slices", "select multithreading type", "slice", "frame", "audio_service_type", "audio service type", "Main Audio Service", "Effects", "Visually Impaired", "Hearing Impaired", "Dialogue", "Commentary", "Emergency", "Voice Over", "Karaoke", "request_sample_fmt", "pkt_timebase", "sub_charenc", "sub_charenc_mode", "do_nothing", "pre_decoder", "refcounted_frames", "side_data_only_packets", "skip_alpha", "Skip processing alpha", "field_order", "Field order", "progressive", "dump_separator", "codec_whitelist", "pixel_format", "set pixel format", "video_size", "set video size", "libavcodec/parser.c", "index > -0x20000000", "PCM channels out of bounds\n", "Invalid sample_size\n", "Invalid number of channels\n", "codec ids mismatch\n", "1.2.3", "%d bytes left\n", "chunk too big\n", "png: tag=%c%c%c%c length=%u\n", "IHDR after IDAT\n", "Multiple IHDR\n", "Invalid image size\n", "pHYs after IDAT\n", "IDAT without IHDR\n", "libavcodec/pngdec.c", "inflate returned error %d\n", "Broken tEXt chunk\n", "Broken zTXt chunk\n", "IEND without all image\n", "MPNG", "libavcodec/pngenc.c", "bpp || !pred", "APNG encoder", "PNG encoder", "libavcodec/pthread_frame.c", "%p finished %d field %d\n", "Final thread update failed\n", "thread_get_buffer() failed\n", "bits<0.9\n", "qp<=0.0\n", "libavcodec/ratecontrol.c", "qmin <= qmax", "limiting QP %f -> %f\n", "rc buffer underflow\n", "stuffing %d bytes\n", "tex^qComp", "Error parsing rc_eq \"%s\"\n", " in:%d ", "picture_number >= 0", "requested bitrate is too low\n", "filter_size % 2 == 1", "toobig <= 40", "qblur too large\n", "q > 0.0", "bits2qp", "qp2bits", "iTex", "pTex", "fCode", "iCount", "mcVar", "avgQP", "qComp", "avgIITex", "avgPITex", "avgPPTex", "avgBPTex", "avgTex", "audioresample", "Could not allocate buffer\n", "ReSampleContext", "libavcodec/rl.c", "%s%7i:%-7i", "%s%7i", "%s%.15g", "%s%5i", "%s%3i", "./libavutil/mem_internal.h", "val || !min_size", "libavcodec/utils.c", "Invalid channel count", "Invalid sample rate", "ignoring invalid SAR: %d/%d\n", "desc->flags & (1 << 4)", "frame->nb_extended_buf == 0", "ignoring invalid SAR: %u/%u\n", "Too many channels: %d.\n", "get_buffer() failed\n", "reget_buffer() failed\n", "extended_data is not set.\n", "avctx->codec->encode2", "AVFrame.format is not set\n", "ret <= 0", "Invalid media type for video\n", "Invalid media type for audio\n", "ret <= tmp.size", "skip %d/%d samples\n", "discard %d/%d samples\n", "unknown_codec", "[%d]", "%s: %s", " (%s)", ", %d reference frame%s", " (%s / 0x%04X)", "%d bpc, ", "%s, ", "%s/%s/%s, ", "%dx%d", " (%dx%d)", " [SAR %d:%d DAR %d:%d]", ", %d/%d", ", q=%d-%d", ", Closed Captions", ", lossless", "%d Hz, ", ", %s", " (%d bit)", ", %dx%d", ", pass 1", ", pass 2", ", %d kb/s", ", max. %d kb/s", "n >= 1", "choices[n] != AV_PIX_FMT_NONE", "ff_avcodec_locked", "!ff_avcodec_locked", "!dst->progress", "encoder", "decoder", "Codec (%s) not on whitelist\n", "Codec type or id mismatches\n", "Channel layout not specified\n", "dimensions not set\n", "p <= end", "Extradata corrupt.\n", "Id header is too short\n", "Setup header is too short\n", "Out of memory\n", "Invalid Setup header\n", "Unsupported mode count: %d\n", "Invalid packet\n", "Invalid mode in packet\n", "Vorbis parser", "aeval", "same", "exprs", "set channel layout", "aevalsrc", "nb_samples", "set the sample rate", "44100", "duration", "set audio duration", "nb_in_channels", "nb_out_channels", "adelay", "delays", "nb_echoes:%d\n", "aecho", "Add echoing to the audio.", "in_gain", "set signal input gain", "out_gain", "set signal output gain", "set list of signal delays", "1000", "decays", "set list of signal decays", "acrossfade", "crossfade0", "crossfade1", "set cross fade duration", "overlap", "curve1", "linear slope", "qsin", "quarter of sine wave", "esin", "exponential sine wave", "hsin", "half of sine wave", "logarithmic", "ipar", "inverted parabola", "quadratic", "cubic", "square root", "cubic root", "parabola", "exponential", "iqsin", "inverted quarter of sine wave", "ihsin", "inverted half of sine wave", "dese", "double-exponential seat", "desi", "double-exponential sigmoid", "curve2", "afade", "Fade in/out input audio.", "set the fade direction", "fade-in", "fade-out", "start_sample", "start_time", "set time to start fading", "set fade duration", "curve", "set fade curve type", "sample format", "sample rate", "channel layout", "aformat", "sample_fmts", "sample_rates", "channel_layouts", "Using \"%s\" for input %d\n", "Too many channels (max %d)\n", "in%d", " -> out:", "%sin%d:", "libavfilter/bufferqueue.h", "queue->available", "amerge", "inputs", "specify the number of inputs", "unknown input link\n", "libavfilter/af_amix.c", "frame_list->end", "input%d", "s->nb_inputs > 1", "s->frame_list->nb_frames > 0", "info", "amix", "Audio mixing.", "Number of inputs.", "longest", "Duration of longest input.", "shortest", "Duration of shortest input.", "first", "Duration of first input.", "dropout_transition", "anull", "libavfilter/af_apad.c", "n_out:%d whole_len_left:%lld\n", "apad", "Pad audio with silence.", "packet_size", "set silence packet size", "pad_len", "whole_len", "libavfilter/af_aphaser.c", "channels > 0", "delay is too small\n", "in_gain may cause clipping\n", "out_gain may cause clipping\n", "aphaser", "set input gain", "set output gain", "set delay in milliseconds", "decay", "set decay", "speed", "set modulation speed", "set modulation type", "triangular", "sinusoidal", "libavfilter/af_aresample.c", "outlink->format == out_format", "aresample", "Resample audio data.", "nb_out_samples:%d pad:%d\n", "asetnsamples", "nb_out_samples", "pad last frame with zeros", "Time base is inaccurate\n", "asetrate", "%.6g", "%lld", "plane_checksums: [ ", "%08X ", "  side data - ", "matrix encoding: ", "invalid data", "Dolby Surround", "Dolby Pro Logic II", "Dolby Pro Logic IIx", "Dolby Pro Logic IIz", "Dolby EX", "Dolby Headphone", "downmix: ", "preferred downmix type - ", "Lo/Ro", "Lt/Rt", "replaygain: ", "track gain", "%s - ", "track peak", "album gain", "album peak", "audio service type: ", "ashowinfo", "Channel: %d\n", "DC offset: %f\n", "Min level: %f\n", "Max level: %f\n", "Min difference: %f\n", "Max difference: %f\n", "Mean difference: %f\n", "Peak level dB: %f\n", "RMS level dB: %f\n", "RMS peak dB: %f\n", "RMS trough dB: %f\n", "Crest factor: %f\n", "Flat factor: %f\n", "Peak count: %lld\n", "Bit depth: %u\n", "Overall\n", "Peak count: %f\n", "Number of samples: %lld\n", "DC_offset", "lavfi.astats.%d.%s", "Min_level", "Max_level", "Min_difference", "Max_difference", "Mean_difference", "Peak_level", "RMS_level", "RMS_peak", "RMS_trough", "Crest_factor", "Flat_factor", "Peak_count", "Bit_depth", "Overall.DC_offset", "lavfi.astats.%s", "Overall.Min_level", "Overall.Max_level", "Overall.Min_difference", "Overall.Max_difference", "Overall.Mean_difference", "Overall.Peak_level", "Overall.RMS_level", "Overall.RMS_peak", "Overall.RMS_trough", "Overall.Flat_factor", "Overall.Peak_count", "Overall.Bit_depth", "Overall.Number_of_samples", "astats", "length", "set the window length", "metadata", "reset", "Error in expression \"%s\"\n", "astreamsync", "out1", "out2", "expr", "t1-t2", "in_channel_layout", "out_channel_layout", "in_sample_fmt", "out_sample_fmt", "in_sample_rate", "out_sample_rate", "force_resampling", "asyncts", "Sync audio data to timestamps", "compensate", "min_delta", "max_comp", "first_pts", "tempo", "Invalid tempo value '%s'\n", "libavfilter/af_atempo.c", "read_size <= atempo->ring", "zeros != nsamples", "nsamples <= zeros + na + nb", "pot <= atempo->window", "atempo", "Adjust audio tempo.", "set tempo scale factor", "clipping\n", "libavfilter/af_biquads.c", "biquad", "allpass", "frequency", "set central frequency", "width_type", "set filter-width type", "Q-Factor", "octave", "slope", "set filter-width", "highpass", "set frequency", "set width", "poles", "set number of poles", "lowpass", "bandreject", "set band-width", "bandpass", "use constant skirt gain", "treble", "set shelf transition steep", "gain", "set gain", "bass", "equalizer", "%d%n", "channelmap", "Remap audio channels.", "Output channel layout.", "channelsplit", "Input channel layout.", "stereo", "chorus", "set delays", "set decays", "speeds", "set speeds", "depths", "set depths", "%lf/%lf", "%d: x=%f y=%f\n", "libavfilter/af_compand.c", "compand", "attacks", "points", "-70/-70|-60/-20", "soft-knee", "set soft-knee", "volume", "set initial volume", "dcshift", "shift", "set DC shift", "limitergain", "set limiter gain", "libavfilter/af_dynaudnorm.c", "./libavfilter/bufferqueue.h", "frame len %d\n", "dynaudnorm", "Dynamic Audio Normalizer.", "set the frame length in msec", "set the filter size", "set the peak value", "set the max amplification", "set the target RMS", "enable channel coupling", "enable DC correction", "set the compress factor", "earwax", "Widen the stereo image.", "flanger", "base delay in milliseconds", "depth", "regen", "sweeps per second (Hz)", "shape", "swept wave shape", "phase", "interp", "delay-line interpolation", "itype", "Invalid output channel: %s.\n", "Invalid input channel: %s.\n", "mappings: ", "%d.%s => %s ", "libavfilter/af_join.c", "i < ctx->nb_inputs", "!s->input_frames[i]", "join", "Number of input streams.", "%7[A-Z]%n", "c%d%n", "%lf%n *%n", "Syntax error near \"%.8s\"\n", "%s%.3g i%d", "o%d = %s\n", "args", "track_gain = %+.2f dB\n", "track_peak = %.6f\n", "libavfilter/af_replaygain.c", "replaygain", "ReplayGain scanner.", "lavr option: %s=%s\n", "libavfilter/af_resample.c", "!avresample_available(s->avr)", "resample", "i < 2 && !s->input_frame[i]", "sidechaincompress", "Sidechain compressor.", "sidechain", "threshold", "set threshold", "ratio", "set ratio", "attack", "set attack", "release", "set release", "makeup", "set make up gain", "knee", "set knee", "link", "set link type", "average", "maximum", "detection", "set detection", "peak", "lavfi.silence_start", "silence_start: %s\n", "lavfi.silence_end", "lavfi.silence_duration", "silencedetect", "Detect silence.", "set noise tolerance", "noise", "silenceremove", "Remove silence.", "start_periods", "start_duration", "start_threshold", "stop_periods", "stop_duration", "stop_threshold", "leave_silence", "volume_i:%d/255 ", "volume:%f volume_dB:%f\n", "Change input volume.", "precision", "select mathematical precision", "fixed", "select 8-bit fixed-point", "float", "select 32-bit floating-point", "double", "select 64-bit floating-point", "eval", "once", "eval volume expression once", "drop", "ignore", "track", "track gain is preferred", "album", "album gain is preferred", "replaygain_preamp", "replaygain_noclip", "nb_channels", "nb_consumed_samples", "startpts", "startt", "n_samples: %lld\n", "libavfilter/af_volumedetect.c", "power <= 0x8000 * 0x8000", "mean_volume: %.1f dB\n", "max_volume: %.1f dB\n", "histogram_%ddb: %lld\n", "volumedetect", "Detect audio volume.", "anullsink", "anullsrc", "set channel_layout", "set sample rate", "sine", "set the sine frequency", "beep_factor", "set the beep fequency factor", "set the audio duration", "samples_per_frame", "libavfilter/audio.c", "channels", "libavfilter/avcodec.c", "src->video", "src->audio", "lavfi.aphasemeter.phase", "aphasemeter", "rate", "set video rate", "size", "800x400", "set red contrast", "set green contrast", "set blue contrast", "set median phase color", "avectorscope", "mode", "set mode", "lissajous", "lissajous_xy", "polar", "400x400", "set alpha contrast", "set red fade", "set green fade", "set blue fade", "set alpha fade", "zoom", "set zoom factor", "in%d:%c%d", "out:%c%d", "Segment finished at pts=%lld\n", "Frame after EOF on input %s\n", "concat", "unsafe", "enable unsafe mode", "midi", "a_weighting", "b_weighting", "c_weighting", "timeclamp", "freq", "showcqt", "set volume", "tlength", "set transform length", "384/f*tc/(384/f+tc)", "set timeclamp", "coeffclamp", "set coeffclamp", "gamma", "set gamma", "gamma2", "set gamma of bargraph", "fullhd", "set full HD resolution", "set video fps", "count", "fontfile", "set font file", "fontcolor", "set font color", "libavfilter/avf_showfreqs.c", "overlap %f too big\n", "showfreqs", "1024x512", "set display mode", "line", "show lines", "show bars", "show dots", "ascale", "set amplitude scale", "sqrt", "cbrt", "fscale", "set frequency scale", "rlog", "reverse logarithmic", "win_size", "set window size", "w128", "w256", "w512", "w1024", "w2048", "w4096", "w8192", "w16384", "w32768", "w65536", "win_func", "set window function", "rect", "Rectangular", "bartlett", "Bartlett", "hanning", "Hanning", "hamming", "Hamming", "blackman", "Blackman", "welch", "Welch", "flattop", "Flat-top", "bharris", "Blackman-Harris", "bnuttall", "Blackman-Nuttall", "bhann", "Bartlett-Hann", "Sine", "nuttall", "Nuttall", "set window overlap", "averaging", "set time averaging", "colors", "set channels colors", "s:%dx%d RDFT window size:%d\n", "showspectrum", "640x512", "slide", "set sliding mode", "replace", "replace old columns with new", "scroll", "scroll from right to left", "fullframe", "return full frames", "set channel display mode", "combined", "combined mode", "separate", "separate mode", "color", "set channel coloring", "channel", "intensity", "intensity based coloring", "scale", "set display scale", "saturation", "color saturation multiplier", "hann", "Hann window", "Hamming window", "Blackman window", "showvolume", "VOLUME", "CHANNEL", "set border width", "set channel width", "set channel height", "set fade", "set volume color expression", "display channel names", "showwavespic", "s:%dx%d r:%f n:%d\n", "Too few samples\n", "libavfilter/avf_showwaves.c", "col < outlink->w", "600x240", "split_channels", "draw channels separately", "showwaves", "select display mode", "point", "draw a point for each sample", "draw a line for each sample", "draw a line between samples", "cline", "No option name near '%s'\n", "Unable to parse '%s': %s\n", "Setting '%s' to value '%s'\n", "Option '%s' not found\n", "ping", "pong from:%s %s\n", "Copying data in avfilter.\n", "libavfilter/avfilter.c", "!link->frame_requested", "noformat", "frei0r", "frei0r_src", "No such option: %s.\n", "AVFilter", "Allowed thread types", "set enable expression", "libavfilter/avfiltergraph.c", "index >= 0", "auto-inserted scaler %d", "auto-inserted resampler %d", "%s%s", "fifo", "afifo", "auto-inserted fifo %d", "query_formats not finished\n", "best_idx >= 0", "picking %s out of %d ref:%s\n", "n == sink_links_count", "EOF on sink link %s:%s.\n", "AVFilterGraph", "Maximum number of threads", "scale_sws_opts", "default scale filter options", "aresample_swr_opts", "Failed to allocate qp_table\n", "libavfilter/buffer.c", "ref->buf->refcount > 0", "Failed to allocate fifo\n", "pix_fmts", "channel_counts", "all_channel_counts", "buffersink", "abuffersink", "ffbuffersink", "ffabuffersink", "libavfilter/buffersink.c", "accept all channel counts", "Invalid parameters provided.\n", "Invalid channel layout %s.\n", "abuffer", "sample_fmt", "pix_fmt", "time_base_num", "deprecated, do not use", "time_base_den", "sar_num", "sar_den", "pixel_aspect", "frame_rate", "sws_param", "libavfilter/drawutils.c", "pix_desc", "libavfilter/dualinput.c", "mainpic", "adrawgraph", "drawgraph", "set 1st metadata key", "0xffff0000", "set 2nd metadata key", "0xff00ff00", "set 3rd metadata key", "0xffff00ff", "set 4th metadata key", "0xffffff00", "set background color", "white", "set minimal value", "set maximal value", "set graph mode", "draw bars", "draw dots", "draw lines", "set slide mode", "draw new frames", "rscroll", "scroll from left to right", "set graph size", "900x256", "out0", "out%d", "EBU +%d scale\n", "%c%d", "%.3f", "lavfi.r128.M", "lavfi.r128.S", "lavfi.r128.I", "lavfi.r128.LRA", "lavfi.r128.LRA.low", "lavfi.r128.LRA.high", "lavfi.r128.sample_peaks_ch%d", "lavfi.r128.true_peaks_ch%d", "  SPK:", " dBFS", " %5.1f", "  FTPK:", "  TPK:", "ebur128", "EBU R128 scanner.", "video", "set video output", "640x480", "meter", "set scale meter (+9 to +18)", "framelog", "force frame logging level", "information logging level", "verbose", "verbose logging level", "set peak mode", "disable any peak mode", "sample", "enable peak-sample mode", "true", "enable true-peak mode", "libavfilter/f_interleave.c", "queue:%d -> frame time:%f\n", "ainterleave", "nb_inputs", "set number of inputs", "interleave", "random seed: 0x%08x\n", " (no-op)", "%s -> %s%s\n", "perms", "aperms", "select permissions mode", "do nothing", "toggle", "switch permissions", "random", "set permissions randomly", "seed", "areverse", "Reverse an audio clip.", "reverse", "Reverse a clip.", "scene", "output%d", "lavfi.scene_score", "n:%f pts:%f t:%f key:%d", " -> select:%f select_out:%d\n", "select", "outputs", "set the number of outputs", "aselect", "start_pts", "prev_pts", "prev_selected_pts", "start_t", "prev_t", "prev_selected_t", "pict_type", "PICT_TYPE_I", "PICT_TYPE_P", "PICT_TYPE_B", "PICT_TYPE_S", "PICT_TYPE_SI", "PICT_TYPE_SP", "PICT_TYPE_BI", "interlace_type", "PROGRESSIVE", "TOPFIRST", "BOTTOMFIRST", "consumed_samples_n", "samples_n", "selected_n", "prev_selected_n", "enter", "leave", " \f\t\n\r", " \f\t\n\r,;", "No commands were specified\n", "Parsed commands:\n", "asendcmd", "Send commands to filters.", "sendcmd", "commands", "set commands", "filename", "set commands file", "libavfilter/fifo.c", "frame->nb_samples > offset", "s->root.next", "fifo->root.next", "Invalid pixel format '%s'\n", "Invalid sample format '%s'\n", "Invalid time base '%s'\n", "Invalid sample rate '%s'\n", "Invalid channel layout '%s'\n", "framesync", "libavfilter/framesync.c", "level <= fs->sync_level", "Impossible to set time base\n", "Selected %d/%d time base\n", "Sync level %u\n", "!fs->frame_ready", "fs->on_event", "[%dx%d %d:%d %s]", "[%dHz %s:%s]", "%s:%s", "%*s%-*s", "%*s(%s)%*s", "=,;[\n", "[],;\n", "Parsed_%s_%d", "No such filter: '%s'\n", "Error creating filter '%s'\n", " with args '%s'", "sws_flags=", "[in]", "[out]", "image2", "Find stream info failed\n", "Failed to find codec\n", "Failed to open codec\n", "Failed to alloc frame\n", "N:%lld PTS:%s T:%f POS:%s", " INTERLACED:%lld", " -> PTS:%s T:%f\n", "asetpts", "setpts", "FRAME_RATE", "INTERLACED", "NB_CONSUMED_SAMPLES", "NB_SAMPLES", "PREV_INPTS", "PREV_INT", "PREV_OUTPTS", "PREV_OUTT", "SAMPLE_RATE", "STARTPTS", "STARTT", "RTCTIME", "RTCSTART", "tb:%d/%d -> tb:%d/%d\n", "asettb", "intb", "settb", "AVTB", "asplit", "split", "set number of outputs", "Stream finished, looping.\n", "Unable to loop: %s\n", "Decode error: %s\n", "did not match any stream", "No filename provided!\n", "amovie", "d%c%d", "Failed to find stream info\n", "d%1[av]%d%c", "Stream specifier \"%s\" %s\n", "Failed to find any codec\n", "movie", "Read from a movie source.", "format_name", "set format name", "stream_index", "set stream index", "seek_point", "set seekpoint (seconds)", "streams", "set streams", "set loop count", "libavfilter/trim.c", "atrim", "starti", "endi", "end_pts", "durationi", "end_sample", "start", "trim", "start_frame", "end_frame", "alphamerge", "alpha", "setsar", "setdar", "set display aspect ratio", "dar_den", "hsub", "vsub", "atadenoise", "set threshold A for 1st plane", "set threshold B for 1st plane", "set threshold A for 2nd plane", "set threshold B for 2nd plane", "set threshold A for 3rd plane", "set threshold B for 3rd plane", "set how many frames to use", "n:%lld pts:%s pts_time:%s", "lavfi.bbox.x1", "lavfi.bbox.x2", "lavfi.bbox.y1", "lavfi.bbox.y2", "lavfi.bbox.w", "lavfi.bbox.h", "bbox", "min_val", "lavfi.black_start", "lavfi.black_end", "blackdetect", "black_min_duration", "picture_black_ratio_th", "pic_th", "pixel_black_th", "set the pixel black threshold", "pix_th", "lavfi.blackframe.pblack", "blackframe", "amount", "thresh", "tblend", "Blend successive frames.", "c0_mode", "set component #0 blend mode", "c1_mode", "set component #1 blend mode", "c2_mode", "set component #2 blend mode", "c3_mode", "set component #3 blend mode", "all_mode", "addition", "burn", "darken", "difference", "difference128", "divide", "dodge", "exclusion", "glow", "hardlight", "hardmix", "lighten", "linearlight", "multiply", "negation", "overlay", "phoenix", "pinlight", "reflect", "screen", "softlight", "subtract", "vividlight", "c0_expr", "c1_expr", "c2_expr", "c3_expr", "all_expr", "c0_opacity", "c1_opacity", "c2_opacity", "c3_opacity", "all_opacity", "blend", "repeatlast", "repeat last bottom frame", "BOTTOM", "boxblur", "Blur the input.", "luma_radius", "luma_power", "chroma_radius", "chroma_power", "alpha_radius", "alpha_power", "codecview", "colorbalance", "Adjust the color balance.", "set red shadows", "set green shadows", "set blue shadows", "set red midtones", "set green midtones", "set blue midtones", "set red highlights", "set green highlights", "set blue highlights", "colorchannelmixer", "colorkey", "colorkey filter", "set the colorkey key color", "black", "similarity", "colorlevels", "Adjust the color levels.", "rimin", "set input red black point", "gimin", "set input green black point", "bimin", "set input blue black point", "aimin", "set input alpha black point", "rimax", "set input red white point", "gimax", "set input green white point", "bimax", "set input blue white point", "aimax", "set input alpha white point", "romin", "set output red black point", "gomin", "set output green black point", "bomin", "set output blue black point", "aomin", "set output alpha black point", "romax", "set output red white point", "gomax", "set output green white point", "bomax", "set output blue white point", "aomax", "set output alpha white point", "%s -> %s\n", "colormatrix", "Convert color matrix.", "bt601", "set source color matrix", "color_mode", "set destination color matrix", "set BT.709 colorspace", "set FCC colorspace   ", "set BT.601 colorspace", "bt470", "set BT.470 colorspace", "set SMTPE-170M colorspace", "set SMPTE-240M colorspace", "copy", "cover filename not set\n", "lavfi.rect.x", "lavfi.rect.y", "lavfi.rect.w", "lavfi.rect.h", "cover_rect", "cover", "cover bitmap filename", "set removal mode", "cover area with bitmap", "blur", "blur area", "out_w", "out_h", "crop", "Crop the input video.", "(in_w-out_w)/2", "(in_h-out_h)/2", "keep_aspect", "keep aspect ratio", "in_w", "in_h", "total:%d\n", "lavfi.cropdetect.x1", "lavfi.cropdetect.x2", "lavfi.cropdetect.y1", "lavfi.cropdetect.y2", "lavfi.cropdetect.w", "lavfi.cropdetect.h", "lavfi.cropdetect.x", "lavfi.cropdetect.y", "cropdetect", "Auto-detect crop size.", "limit", "round", "reset_count", "max_outliers", "Threshold count of outliers", "%f/%f ", "libavfilter/vf_curves.c", "last", "point->next", "f(%f)=%f -> y[%d]=%d\n", "#%d points:", " (%f;%f)", "#%d values:", " %02X", "curves", "Adjust components curves.", "0.231/0.094 0.709/0.874", "0.5/0.4", "0.4/0.5", "0.305/0.286 0.694/0.713", "0.286/0.219 0.639/0.643", "0/1 1/0", "0/0.11 0.42/0.51 1/0.95", "0.50/0.48", "0/0.22 0.49/0.44 1/0.8", "select a color curves preset", "preset_name", "color_negative", "cross_process", "darker", "increase_contrast", "lighter", "linear_contrast", "medium_contrast", "negative", "strong_contrast", "vintage", "master", "set master points coordinates", "set red points coordinates", "green", "set green points coordinates", "blue", "set blue points coordinates", "psfile", "libavfilter/vf_dctdnoiz.c", "dctdnoiz", "Denoise frames using 2D DCT.", "sigma", "set noise sigma constant", "deband", "Debands video.", "1thr", "set 1st plane threshold", "2thr", "set 2nd plane threshold", "3thr", "set 3rd plane threshold", "4thr", "set 4th plane threshold", "range", "set range", "direction", "set direction", "enable blur", " [DROP]", " lowest", " dup", "1/%d frame drop:\n", "clean_src", "FPS: %d/%d -> %d/%d\n", "decimate", "cycle", "dupthresh", "set duplicate threshold", "scthresh", "set scene change threshold", "blockx", "blocky", "ppsrc", "cycle:%d\n", "%lld\t", "next=%lld, new=%lld\n", "dejudder", "Option %s was not set.\n", "delogo", "Remove logo from input video.", "set logo x position", "set logo y position", "set logo width", "set logo height", "band", "set delogo area band size", "show", "show delogo area", "rx must be a multiple of 16\n", "deshake", "Stabilize shaky video.", "set edge mode", "blank", "original", "clamp", "mirror", "blocksize", "set motion search blocksize", "contrast", "search", "set search strategy", "smode", "exhaustive", "exhaustive search", "less", "less exhaustive search", "opencl", "No pattern provided.\n", "TB: %d/%d -> %d/%d\n", "detelecine", "first_field", "select first field", "field", "select top field first", "select bottom field first", "pattern", "invert", "drawgrid", "set horizontal offset", "set vertical offset", "set width of grid cell", "set height of grid cell", "set color of the grid", "thickness", "set grid line thickness", "drawbox", "set width of the box", "set height of the box", "set color of the box", "set the box thickness", "libavfilter/vf_edgedetect.c", "edgedetect", "Detect and draw edge.", "set high threshold", "set low threshold", "wires", "white/gray wires on black", "colormix", "mix colors", "elbg", "codebook_length", "set codebook length", "nb_steps", "set the random seed", "pal8", "set the pal8 output", "brightness", "gamma_r", "gamma_g", "gamma_b", "gamma_weight", "set the brightness adjustment", "set the saturation adjustment", "set the initial gamma value", "gamma value for red", "gamma value for green", "gamma value for blue", "init", "eval expressions per-frame", "alphaextract", "extractplanes", "planes", "set planes", "set luma plane", "set u plane", "set v plane", "set red plane", "set green plane", "set blue plane", "set alpha plane", "libavfilter/vf_fade.c", "fade", "Fade in/out input video.", "nb_frames", "set color", "weight_Y", "weight_U", "weight_V", "fftfilt", "dc_Y", "adjust gain in Y plane", "dc_U", "adjust gain in U plane", "dc_V", "adjust gain in V plane", "field_type", "select top field", "select bottom field", "libavfilter/vf_fieldmatch.c", "fm->prv && fm->src && fm->nxt", "COMBS: %3d %3d %3d %3d %3d\n", "fieldmatch", "order", "auto detect parity", "assume bottom field first", "assume top field first", "2-way match (p/c)", "pc_n", "pc_u", "pc_n_ub", "3-way match (p/c/n)", "pcn_ub", "set the field to match from", "bottom field", "top field", "mchroma", "combmatch", "set combmatching mode", "combmatching", "disable combmatching", "combdbg", "enable comb debug", "dbglvl", "no forced calculation", "calculate p/c/n", "pcnub", "calculate p/c/n/u/b", "cthresh", "combpel", "frame with same field order", "progressive frame", "down", "Skipping %s.\n", "fieldorder", "Set the field order.", "output field order", "bottom field first", "top field first", "object filename not set\n", "libavfilter/vf_find_rect.c", "score != 0", "Found at %d %d score %f\n", "find_rect", "Find a user specified object", "object", "object bitmap filename", "mipmaps", "set mipmaps", "xmin", "ymin", "xmax", "ymax", "Empty output format string.\n", "fps=%d/%d\n", "Dropping %d frame(s).\n", "Duplicating frame.\n", "Force constant framerate.", "round towards 0", "round away from 0", "round towards -infty", "round towards +infty", "near", "round to nearest", "Unknown packing mode.", "framepack", "packed", "right", "Frame pack output format", "frameseq", "Views are one after the other", "lines", "columns", "config_output()\n", "set_srce_frame_output_pts()\n", "set_work_frame_pts()\n", "libavfilter/vf_framerate.c", "s->srce[s->next]", "s->srce[s->crnt]", "process_work_frame()\n", "next_source()\n", "next_source() unlink %d\n", "next_source() copy %d to %d\n", "next_source() make %d null\n", "get_scene_score()\n", "get_scene_score() process\n", "request_frame()\n", "request_frame() FLUSH\n", "framerate", "interp_start", "interp_end", "scene change level", "set flags", "scene_change_detect", "enable scene change detection", "framestep", "step", "set frame step", "fspp", "quality", "set quality", "strength", "set filter strength", "use_bframe_qp", "use B-frames' QP", "g(X,Y)", "b(X,Y)", "r(X,Y)", "libavfilter/vf_geq.c", "lum_expr", "set luminance expression", "cb_expr", "set chroma blue expression", "cr_expr", "set chroma red expression", "alpha_expr", "set alpha expression", "red_expr", "set red expression", "green_expr", "set green expression", "blue_expr", "set blue expression", "threshold:%.2f radius:%d\n", "gradfun", "radius", "hflip", "histeq", "set the strength", "set the intensity", "antibanding", "set the antibanding level", "apply no antibanding", "weak", "apply weak antibanding", "strong", "apply strong antibanding", "libavfilter/vf_histogram.c", "histogram", "Compute and draw a histogram.", "set histogram mode", "levels", "standard histogram", "waveform", "chroma values in vectorscope", "color2", "level_height", "set level height", "scale_height", "set scale height", "set waveform step value", "waveform_mode", "set waveform mode", "column", "waveform_mirror", "set waveform mirroring", "display_mode", "parade", "levels_mode", "set levels mode", "components", "ls:%f cs:%f lt:%f ct:%f\n", "hqdn3d", "luma_spatial", "spatial luma strength", "chroma_spatial", "spatial chroma strength", "luma_tmp", "temporal luma strength", "chroma_tmp", "temporal chroma strength", "set scale factor", "set the saturation expression", "set the brightness expression", "auto-inserted", "undetermined", "neither", "%lld.%0*lld", "lavfi.idet.repeated.neither", "lavfi.idet.repeated.top", "lavfi.idet.repeated.bottom", "lavfi.idet.single.tff", "lavfi.idet.single.bff", "lavfi.idet.single.progressive", "lavfi.idet.multiple.tff", "lavfi.idet.multiple.bff", "Final flag accuracy %d\n", "idet", "Interlace detect Filter.", "intl_thres", "set interlacing threshold", "prog_thres", "set progressive threshold", "rep_thres", "set repeat threshold", "half_life", "analyze_interlaced_flag", "luma_mode", "select luma mode", "deinterleave", "chroma_mode", "select chroma mode", "alpha_mode", "select alpha mode", "luma_swap", "swap luma fields", "chroma_swap", "swap chroma fields", "alpha_swap", "swap alpha fields", "with", "without", "libavfilter/vf_interlace.c", "cols >= 0 || lines >= 0", "interlace", "scan", "scanning mode", "kerndeint", "set the threshold", "set the map", "set the order", "sharp", "enable sharpening", "twoway", "enable twoway", "lenscorrection", "set relative center x", "set relative center y", "val[%d][%d] = %d\n", "negval", "negate_alpha:%d\n", "negate", "Negate input video.", "negate_alpha", "lutrgb", "lutyuv", "clip", "gammaval", "gammaval709", "set component #0 expression", "set component #1 expression", "set component #2 expression", "set component #3 expression", "set Y expression", "set U expression", "set V expression", "set R expression", "set G expression", "set B expression", "set A expression", "maxval", "minval", "clipval", "libavfilter/vf_lut3d.c", "%s: %s\n", "Unexpected EOF\n", "3DLUTSIZE ", "%f %f %f", "%d %d %d", "cube", "LUT_3D_SIZE ", "DOMAIN_", "MIN ", "MAX ", "values", "in and out must be defined\n", "invalid in (%d) or out (%d)\n", "Unrecognized '.%s' file type\n", "3D LUT is empty\n", "haldclut", "clut", "select interpolation mode", "interp_mode", "nearest", "trilinear", "tetrahedral", "lut3d", "Adjust colors using a 3D LUT.", "file", "set 3D LUT file name", "memc_only", "no_bitstream", "mcdeint", "extra_slow", "parity", "set qp", "libavfilter/vf_mergeplanes.c", "mergeplanes", "Merge planes.", "mapping", "set output pixel format", "keep", "%d>=hi ", "lo:%d>=%d ", "lo:%d<%d ", "mpdecimate", "Remove near-duplicate frames.", "set high dropping threshold", "set low dropping threshold", "frac", "erosion", "dilation", "inflate", "Apply inflate effect", "threshold0", "set threshold for 1st plane", "threshold1", "set threshold for 2nd plane", "threshold2", "set threshold for 3rd plane", "threshold3", "set threshold for 4th plane", "Apply deflate effect", "Apply dilation effect", "coordinates", "set coordinates", "Apply erosion effect", "Add noise.", "all_seed", "set component #0 noise seed", "all_strength", "set component #0 strength", "alls", "all_flags", "set component #0 flags", "allf", "averaged noise", "(semi)regular pattern", "temporal noise", "uniform noise", "c0_seed", "c0_strength", "c0_flags", "c1_seed", "set component #1 noise seed", "c1_strength", "set component #1 strength", "c1_flags", "set component #1 flags", "c2_seed", "set component #2 noise seed", "c2_strength", "set component #2 strength", "c2_flags", "set component #2 flags", "c3_seed", "set component #3 noise seed", "c3_strength", "set component #3 strength", "c3_flags", "set component #3 flags", "null", "libavfilter/vf_overlay.c", "x:%f xi:%d y:%f yi:%d\n", "set the x expression", "set the y expression", "eof_action", "repeat", "Repeat the previous frame.", "endall", "End both streams.", "pass", "Pass through the main input.", "set output format", "yuv420", "yuv422", "yuv444", "main_w", "main_h", "overlay_w", "overlay_h", "owdenoise", "Denoise using wavelets.", "set depth", "luma_strength", "set luma strength", "chroma_strength", "set chroma strength", "Pad the input video.", "(+1)", "libavfilter/vf_palettegen.c", "box->len >= 1", "new_box->len >= 1", "lavfi.color_quant_ratio", "Dupped color: %08X\n", "s->nb_boxes < 256", "palettegen", "max_colors", "reserve_transparent", "stats_mode", "set statistics mode", "compute full frame histograms", "diff", "%*cnode%d -> node%d\n", "digraph {\n", "Accuracy check passed\n", "MEP:%.3f TotalMEP:%.3f\n", "paletteuse", "palette", "dither", "select dithering mode", "dithering_mode", "bayer", "heckbert", "floyd_steinberg", "sierra2", "sierra2_4a", "bayer_scale", "set scale for bayer dithering", "diff_mode", "set frame difference mode", "rectangle", "debug_kdtree", "color_search", "nns_iterative", "iterative search", "nns_recursive", "recursive search", "bruteforce", "brute-force into the palette", "mean_err", "compute and print mean error", "debug_accuracy", "test color search accuracy", "libavfilter/vf_perspective.c", "perspective", "set top left x coordinate", "set top left y coordinate", "set top right x coordinate", "set top right y coordinate", "set bottom left x coordinate", "set bottom left y coordinate", "set bottom right x coordinate", "set bottom right y coordinate", "interpolation", "set interpolation", "sense", "source", "destination", "libavfilter/vf_phase.c", "Phase shift fields.", "set phase mode", "top first", "bottom first", "top first analyze", "bottom first analyze", "analyze", "full analyze", "auto analyze", "pixdesctest", "libavfilter/vf_pp.c", "subfilters", "set postprocess subfilters", "set thresholding mode", "hard", "hard thresholding", "soft", "soft thresholding", "medium thresholding", " %c:%0.2f", "%0.2f", "lavfi.psnr.mse_avg", "lavfi.psnr.psnr_avg", "lavfi.psnr.mse.", "%s%c", "lavfi.psnr.psnr.", "n:%lld mse_avg:%0.2f ", "psnr_avg:%0.2f ", "mse_%c:%0.2f ", "psnr_%c:%0.2f ", "reference", "stats_file", "w: %d h: %d\n", "offset: %d length: %d\n", "Could not get buffer!\n", "pullup", "set left junk size", "set right junk size", "set top junk size", "set bottom junk size", "set strict breaks", "set metric plane", "luma", "chroma blue", "chroma red", "known", "set qp expression", "Return random frames.", "frames", "set number of frames in cache", "set the seed", "removegrain", "Remove grain.", "set mode for 1st plane", "set mode for 2nd plane", "set mode for 3rd plane", "set mode for 4th plane", "removelogo", "set bitmap filename", "repeatfields", "angle", "n:%f time:%f angle:%f/PI\n", "rotate", "Rotate the input image.", "rotw", "roth", "set angle (in radians)", "set output width expression", "set output height expression", "fillcolor", "set background fill color", "bilinear", "use bilinear interpolation", "Apply shape adaptive blur.", "set luma radius", "luma_pre_filter_radius", "set luma pre-filter radius", "lpfr", "set chroma radius", "chroma_pre_filter_radius", "set chroma pre-filter radius", "cpfr", "srcw", "srch", "src_format", "dstw", "dsth", "dst_format", "sws_flags", "param0", "param1", "src_range", "dst_range", "src_h_chr_pos", "src_v_chr_pos", "dst_h_chr_pos", "dst_v_chr_pos", "Invalid size '%s'\n", "scale2ref", "Output video width", "Output video height", "Flags to pass to libswscale", "interl", "set interlacing", "in_color_matrix", "set input YCbCr type", "out_color_matrix", "set output YCbCr type", "in_range", "set input color range", "out_range", "set output color range", "in_v_chr_pos", "in_h_chr_pos", "out_v_chr_pos", "out_h_chr_pos", "force_original_aspect_ratio", "force_oar", "decrease", "increase", "Scaler param 0", "Scaler param 1", "ohsub", "ovsub", "height must be even\n", "separatefields", "setfield", "select interlace mode", "keep the same input field", "mark as bottom-field-first", "mark as top-field-first", "prog", "mark as progressive", " %08X", "] mean:[", "%lld ", "%3.1f ", "pan/scan", "stereoscopic information: ", "type - ", "side by side", "top and bottom", "frame alternate", "checkerboard", "interleaved lines", "interleaved columns", " (inverted)", "afd: value of %u", "showinfo", "showpalette", "Display frame palette", "set pixel box size", "shuffleplanes", "Shuffle video planes", "map0", "map1", "map2", "map3", "lavfi.signalstats.YMIN", "lavfi.signalstats.YLOW", "lavfi.signalstats.YAVG", "lavfi.signalstats.YHIGH", "lavfi.signalstats.YMAX", "lavfi.signalstats.UMIN", "lavfi.signalstats.ULOW", "lavfi.signalstats.UAVG", "lavfi.signalstats.UHIGH", "lavfi.signalstats.UMAX", "lavfi.signalstats.VMIN", "lavfi.signalstats.VLOW", "lavfi.signalstats.VAVG", "lavfi.signalstats.VHIGH", "lavfi.signalstats.VMAX", "lavfi.signalstats.SATMIN", "lavfi.signalstats.SATLOW", "lavfi.signalstats.SATAVG", "lavfi.signalstats.SATHIGH", "lavfi.signalstats.SATMAX", "lavfi.signalstats.HUEMED", "lavfi.signalstats.HUEAVG", "lavfi.signalstats.YDIF", "lavfi.signalstats.UDIF", "lavfi.signalstats.VDIF", "TOUT", "lavfi.signalstats.%s", "VREP", "BRNG", "signalstats", "stat", "set statistics filters", "filters", "tout", "vrep", "brng", "set video filter", "set highlight color", "yellow", "smartblur", "luma_threshold", "set luma threshold", "chroma_threshold", "set chroma threshold", "lavfi.ssim.", "lavfi.ssim.All", "lavfi.ssim.dB", "n:%lld ", "All:%f (%f)\n", "%c:%f ", " %c:%f", "SSIM%s All:%f (%f)\n", "vstack", "hstack", "width must be even\n", "height must be multiple of 4\n", "libavfilter/vf_stereo3d.c", "stereo3d", "set input format", "ab2l", "ab2r", "above below left first", "above below right first", "alternating frames left first", "sbs2l", "sbs2r", "sbsl", "side by side left first", "sbsr", "side by side right first", "agmc", "anaglyph green magenta color", "agmd", "anaglyph green magenta dubois", "agmg", "anaglyph green magenta gray", "agmh", "arbg", "anaglyph red blue gray", "arcc", "anaglyph red cyan color", "arcd", "anaglyph red cyan dubois", "arcg", "anaglyph red cyan gray", "arch", "anaglyph red cyan half color", "argg", "anaglyph red green gray", "aybc", "anaglyph yellow blue color", "aybd", "anaglyph yellow blue dubois", "aybg", "anaglyph yellow blue gray", "aybh", "interleave rows left first", "interleave rows right first", "mono left", "mono right", "super2xsai", "swapuv", "Swap U and V components.", "telecine", "Apply a telecine pattern.", "batch size: %d frames\n", "thumbnail", "set the frames batch size", "Tile size %ux%u is insane.\n", "tile", "layout", "set grid size", "margin", "padding", "libavfilter/vf_tinterlace.c", "tinterlace", "merge", "merge fields", "drop_even", "drop even fields", "drop_odd", "drop odd fields", "interleave_top", "interleave_bottom", "interlacex2", "low_pass_filter", "vlpf", "exact_tb", "clockwise", "counterclockwise", "transpose", "Transpose input video.", "set transpose direction", "cclock_flip", "clock", "rotate clockwise", "cclock", "rotate counter-clockwise", "clock_flip", "passthrough", "always apply transposition", "portrait", "preserve portrait geometry", "landscape", "preserve landscape geometry", "sharpen", "unsharp", "luma_msize_x", "luma_msize_y", "set luma matrix vertical size", "luma_amount", "set luma effect strength", "chroma_msize_x", "chroma_msize_y", "chroma_amount", "set chroma effect strength", "SNOW encoder not found.\n", "libavfilter/vf_uspp.c", "avctx_enc->codec", "uspp", "libavfilter/vf_vectorscope.c", "vectorscope", "Video vectorscope.", "set vectorscope mode", "color3", "color4", "set color component on X axis", "set color component on Y axis", "set intensity", "envelope", "set envelope", "instant", "peak+instant", "vflip", "xscale=%f yscale=%f dmax=%f\n", "vignette", "set lens angle", "PI/5", "set forward/backward mode", "forward", "backward", "set dithering", "set aspect ratio", "w3fdif", "filter", "specify the filter", "complex", "deint", "deinterlace all frames", "interlaced", "Video waveform monitor.", "set mirroring", "display", "set components to display", "set envelope to display", "set filter", "flat", "aflat", "achroma", "libavfilter/vf_yadif.c", "Failed to reallocate frame\n", "yadif", "Deinterlace the input image.", "specify the interlacing mode", "send_frame", "send one frame for each frame", "send_field", "send one frame for each field", "send_frame_nospatial", "send_field_nospatial", "zoompan", "Apply Zoom & Pan effect.", "set the zoom expression", "set the duration expression", "set the output image size", "hd720", "pduration", "time", "pzoom", "nullsink", "w:%d\n", "%d %c\n", "320x518", "cellauto", "set initial pattern", "rule", "set rule", "random_fill_ratio", "random_seed", "scroll pattern downward", "start_full", "start filling the whole video", "stitch", "stitch boundaries", "320x240", "bBsS", "h:%d max_w:%d\n", "%d:%d %c\n", "life", "Create life.", "set source file", "B3/S23", "mold", "set mold speed for dead cells", "life_color", "set life color", "death_color", "set death color", "mold_color", "set mold color", "mandelbrot", "Render a Mandelbrot fractal.", "set frame size", "set frame rate", "maxiter", "set max iterations number", "start_x", "set the initial x position", "start_y", "set the initial y position", "start_scale", "set the initial scale value", "end_scale", "set the terminal scale value", "set the terminal pts value", "bailout", "set the bailout value", "morphxf", "set morph x frequency", "morphyf", "set morph y frequency", "morphamp", "set morph amplitude", "outer", "set outer coloring mode", "iteration_count", "set iteration count mode", "normalized_iteration_count", "set white mode", "outz", "set outz mode", "inner", "set inner coloring mode", "set black mode", "period", "set period mode", "convergence", "show time until convergence", "mincol", "rate:%d/%d duration:%f\n", "mptestsrc", "set video duration", "test", "set test to perform", "dc_luma", "dc_chroma", "freq_luma", "freq_chroma", "amp_luma", "amp_chroma", "ring1", "ring2", "libavfilter/vsrc_testsrc.c", "x + w <= test->w", "y + h <= test->h", "allrgb", "Generate all RGB colors.", "set video sample aspect ratio", "allyuv", "Generate all yuv colors.", "smptehdbars", "Generate SMPTE HD color bars.", "smptebars", "Generate SMPTE color bars.", "rgbtestsrc", "Generate RGB test pattern.", "testsrc", "Generate test pattern.", "decimals", "nullsrc", "haldclutsrc", "set level", "adts", "audio/aac", "aac,adts", "ADTS muxer", "write_id3v2", "Enable ID3v2 tag writing", "write_apetag", "Enable APE tag writing", "Invalid APE tag key '%s'.\n", "APE tag size too large.\n", "Skipping binary tag '%s'.\n", "Error reading cover art.\n", "APETAGEX", "Tag size is way too big\n", "Invalid tag size %u.\n", "Too many tag fields (%u)\n", "APE Tag is a header\n", "libavformat/avio.c", "Key '%s' not found.\n", "https:", "URLContext", "libavformat/aviobuf.c", "!s->write_flag", "len >= s->orig_buffer_size", "AVIOContext", "concat:", "ffconcat version 1.0", "Impossible to open '%s'\n", "open_next_file() failed (%d)\n", "libavformat/concatdec.c", "pkt2.buf", " \t\r\n", "Line %d: filename required\n", "inpoint", "outpoint", "Line %d: %s without file\n", "Line %d: invalid %s '%s'\n", "file_packet_metadata", "stream", "exact_stream_id", "ffconcat", "version", "Line %d: invalid version\n", "Unsafe file name '%s'\n", "Virtual concatenation script", "concat demuxer", "safe", "enable safe mode", "auto_convert", "%sMetadata:\n", "language", "%s  %-16s: ", "\n%s  %-16s: ", "fps, ", "tbr, ", "tbn, ", "    Stream #%d:%d", "[0x%x]", "(%s)", ", %d, %d/%d", ": %s", ", SAR %d:%d DAR %d:%d", "%1.4f %s", "%3.2f %s", "%1.0f %s", "%1.0fk %s", " (default)", " (dub)", " (original)", " (comment)", " (lyrics)", " (karaoke)", " (forced)", " (hearing impaired)", " (visual impaired)", " (clean effects)", "    ", "%sSide data:\n", "%s  ", "new extradata", "paramchange: ", "channel count %u, ", "channel layout: %s, ", "sample_rate %u, ", "width %u height %u", "unknown param", "h263 macroblock info", "stereo3d: ", "effects", "visually impaired", "hearing impaired", "dialogue", "comentary", "emergency", "voice over", "karaoke", "%08x ", " %02x", "stream #%d:\n", "  keyframe=%d\n", "  duration=%0.3f\n", "  dts=", "%0.3f", "  pts=", "  size=%d\n", "Output", "from", "Input", "%s #%d, %s, %s '%s':\n", "  Duration: ", "%02d:%02d:%02d.%02d", ", start: ", "%d.%06d", ", bitrate: ", "%d kb/s", "    Chapter #%d:%d: ", "start %f, ", "end %f\n", "name", "  Program %d %s\n", "  No Program\n", "file:", "truncate", "NGINX RTMP", "false", "keyframes", "Skipping duplicate index\n", "times", "filepositions", "unsupported amf type %d\n", "videodatarate", "audiodatarate", "datastream", "videocodecid", "Video codec (%x)", "audiocodecid", "Audio codec (%x)", "audiosamplerate", "audiosamplesize", "filesize", "onTextData", "onCaption", "onCaptionInfo", "onMetaData", "onCuePoint", "Unknown type %s\n", "%d %X %d \n", "invalid timestamps %lld %lld\n", "Omnia A/XE", "Encoder", "OnTextData packet", "live_flv", "live RTMP FLV (Flash Video)", "live_flvdec", "FLV (Flash Video)", "flvdec", "flv_metadata", "datasize", "lasttimestamp", "totalframes", "hasAudio", "hasVideo", "hasCuePoints", "hasMetadata", "hasKeyframes", "Ignoring metadata for %s\n", "Video", "Audio", "Data", "libavformat/flvenc.c", "aac bitstream error\n", "Text", "video/x-flv", "segment", "ssegment", "image2pipe", "Probing %s score:%d size:%d\n", "mime_type", "raw H.264 video", "h26l,h264,264,avc", "h264 demuxer", "TYPE=", "URI=", "GROUP-ID=", "LANGUAGE=", "ASSOC-LANGUAGE=", "NAME=", "DEFAULT=", "FORCED=", "CHARACTERISTICS=", "METHOD=", "BANDWIDTH=", "AUDIO=", "VIDEO=", "SUBTITLES=", "#EXTM3U", "#EXT-X-STREAM-INF:", "#EXT-X-TARGETDURATION:", "#EXT-X-MEDIA-SEQUENCE:", "comment", "user-agent", "cookies", "headers", "seekable", "offset", "end_offset", "Unable to read key file %s\n", "Unable to open key file %s\n", "crypto+%s", "crypto:%s", "location", "#EXT-X-KEY:", "AES-128", "SAMPLE-AES", "#EXT-X-MEDIA:", "AUDIO", "VIDEO", "#EXT-X-PLAYLIST-TYPE:", "EVENT", "#EXT-X-ENDLIST", "#EXT-X-DISCONTINUITY", "#EXTINF:", "#EXT-X-BYTERANGE:", "Failed to reload playlist %d\n", "Stripped %d HLS ID3 bytes\n", "PRIV", "HLS ID3 audio timestamp %lld\n", "APIC", "libavformat/hls.c", "!pls->id3_deferred_extra", "user_agent", "Empty playlist\n", "variant_bitrate", "hls,applehttp", "Apple HTTP Live Streaming", "live_start_index", "opening %s\n", "Unable to open %s\n", "hls+", "hls://", "Unsupported url %s\n", "%x\r\n", "Bad Request", "Forbidden", "Not Found", "Internal server error", "text/plain", "HTTP reply header: \n%s----\n", "libavformat/http.c", "sc->listen", "POST", "header='%s'\n", "Received method: %s\n", "Autodetected %s HTTP method\n", "Requested resource: %s\n", "HTTP/", "HTTP version string: %s\n", "http_code=%d\n", "HTTP error %d %s\n", "Location", "Content-Length", "Content-Range", "bytes ", "Accept-Ranges", "bytes", "Transfer-Encoding", "chunked", "WWW-Authenticate", "Authentication-Info", "Proxy-Authenticate", "Connection", "close", "Server", "AkamaiGHost", "MediaGateway", "Content-Type", "Set-Cookie", "Icy-MetaInt", "Icy-", "Content-Encoding", "gzip", "identity", "Unknown content coding: %s\n", "%s%s\n", "Unable to parse '%s'\n", "Proxy-", "Transfer-Encoding: chunked\r\n", "http_proxy", "no_proxy", "http://", "https", "\r\nUser-Agent: ", "\r\nAccept: ", "\r\nRange: ", "Range: bytes=%lld-", "\r\nExpect: ", "\r\nConnection: ", "Connection: keep-alive\r\n", "Connection: close\r\n", "\r\nHost: ", "\r\nContent-Length: ", "Content-Length: %d\r\n", "\r\nContent-Type: ", "Content-Type: %s\r\n", "\r\nCookie: ", "path=", "domain=", "%s; %s", "Cookie: %s\r\n", "\r\nIcy-MetaData: ", "Icy-MetaData: %d\r\n", "%s %s HTTP/1.1\r\n%s%s%s%s%s\r\n", "request: %s\n", "User-Agent: %s\r\n", "Accept: */*\r\n", "Expect: 100-continue\r\n", "Host: %s\r\n", "Lower protocol\n", "Read headers\n", "Reply code: %d\n", "listen", "inflate return value: %d, %s\n", "Will reconnect at %lld.\n", "Failed to reconnect at %lld.\n", "icy_metadata_packet", "http", "chunked_post", "content_type", "override User-Agent header", "Lavf/56.40.101", "multiple_requests", "use persistent connections", "post_data", "set custom HTTP post data", "export the MIME type", "request ICY metadata", "icy_metadata_headers", "return ICY metadata headers", "auth_type", "HTTP authentication type", "basic", "HTTP basic authentication", "send_expect_100", "initial byte offset", "method", "reconnect", "listen on HTTP", "resource", "reply_code", "http-tcp-hook", "hook protocol on tcp", "nextnonce=", "realm=", "nonce=", "opaque=", "algorithm=", "qop=", "stale=", "Basic ", "Digest ", "auth", "Authorization: Basic ", "%08x", "MD5-sess", "auth-int", "Authorization: Digest ", "username=\"%s\"", ",realm=\"%s\"", ",nonce=\"%s\"", ",uri=\"%s\"", ",response=\"%s\"", ",algorithm=\"%s\"", ",opaque=\"%s\"", ",qop=\"%s\"", ",cnonce=\"%s\"", ",nc=%s", "title", "artist", "date", "genre", "Blues", "Classic Rock", "Country", "Dance", "Disco", "Funk", "Grunge", "Hip-Hop", "Jazz", "Metal", "New Age", "Oldies", "Other", "Reggae", "Rock", "Techno", "Industrial", "Alternative", "Death Metal", "Pranks", "Soundtrack", "Euro-Techno", "Ambient", "Trip-Hop", "Vocal", "Jazz+Funk", "Fusion", "Trance", "Classical", "Instrumental", "Acid", "House", "Game", "Sound Clip", "Gospel", "Noise", "AlternRock", "Bass", "Soul", "Punk", "Space", "Meditative", "Instrumental Pop", "Instrumental Rock", "Ethnic", "Gothic", "Darkwave", "Techno-Industrial", "Electronic", "Pop-Folk", "Eurodance", "Dream", "Southern Rock", "Comedy", "Cult", "Gangsta", "Top 40", "Christian Rap", "Pop/Funk", "Jungle", "Native American", "Cabaret", "New Wave", "Psychadelic", "Rave", "Showtunes", "Trailer", "Lo-Fi", "Tribal", "Acid Punk", "Acid Jazz", "Polka", "Retro", "Musical", "Rock & Roll", "Hard Rock", "Folk", "Folk-Rock", "National Folk", "Swing", "Fast Fusion", "Bebob", "Latin", "Revival", "Celtic", "Bluegrass", "Avantgarde", "Gothic Rock", "Progressive Rock", "Psychedelic Rock", "Symphonic Rock", "Slow Rock", "Big Band", "Chorus", "Easy Listening", "Acoustic", "Humour", "Speech", "Chanson", "Opera", "Chamber Music", "Sonata", "Symphony", "Booty Bass", "Primus", "Porn Groove", "Satire", "Slow Jam", "Club", "Tango", "Samba", "Folklore", "Ballad", "Power Ballad", "Rhythmic Soul", "Freestyle", "Duet", "Punk Rock", "Drum Solo", "A capella", "Euro-House", "Dance Hall", "Drum & Bass", "Club-House", "Hardcore", "Terror", "Indie", "BritPop", "Negerpunk", "Polsk Punk", "Beat", "Christian Gangsta", "Heavy Metal", "Black Metal", "Crossover", "Contemporary Christian", "Christian Rock", "Merengue", "Salsa", "Thrash Metal", "Anime", "JPop", "SynthPop", "Error opening memory stream\n", "Incorrect BOM value\n", "Unknown encoding\n", "TCON", "(%d)", "TXXX", "encrypted", "encrypted and compressed", "extended header too long.", "compression", "Skipping %s ID3v2 frame %s.\n", "USLT", "CHAP", "Failed to alloc %d bytes\n", "Failed to alloc %ld bytes\n", "Failed to uncompress tag: %d\n", "lyrics-%s%s%s", "GEOB", "Failed to alloc %zu bytes\n", "TYER", "TDAT", "-%.2s-%.2s", "TIME", " %.2s:%.2s", "32x32 pixels 'file icon'", "Other file icon", "Cover (front)", "Cover (back)", "Leaflet page", "Media (e.g. label side of CD)", "Artist/performer", "Conductor", "Band/Orchestra", "Composer", "Lyricist/text writer", "Recording Location", "During recording", "During performance", "Movie/video screen capture", "A bright coloured fish", "Illustration", "Band/artist logotype", "Publisher/Studio logotype", "compilation", "encoded_by", "album_artist", "performer", "TCMP", "TDRC", "TDRL", "TDEN", "creation_time", "TSOA", "album-sort", "TSOP", "artist-sort", "TSOT", "title-sort", "TALB", "TCOM", "composer", "TCOP", "copyright", "TENC", "TIT2", "TLAN", "TPE1", "TPE2", "TPE3", "TPOS", "disc", "TPUB", "publisher", "TRCK", "TSSE", "lyrics", "%.2s%.2s", "ch%d", "ljpg", "mpg1-img", "mpg2-img", "mpg4-img", "ffv1-img", "im24", "im32", "sunras", "yuv10", "SDPX", "XPDS", "No such pixel format: %s.\n", "Could not open file : %s\n", "webp_pipe", "piped webp sequence", "webp demuxer", "tiff_pipe", "piped tiff sequence", "tiff demuxer", "sunrast_pipe", "piped sunrast sequence", "sunrast demuxer", "sgi_pipe", "piped sgi sequence", "sgi demuxer", "qdraw_pipe", "piped qdraw sequence", "qdraw demuxer", "png_pipe", "piped png sequence", "png demuxer", "pictor_pipe", "piped pictor sequence", "pictor demuxer", "jpegls_pipe", "piped jpegls sequence", "jpegls demuxer", "jpeg_pipe", "piped jpeg sequence", "jpeg demuxer", "j2k_pipe", "piped j2k sequence", "j2k demuxer", "exr_pipe", "piped exr sequence", "exr demuxer", "dpx_pipe", "piped dpx sequence", "dpx demuxer", "dds_pipe", "piped dds sequence", "dds demuxer", "bmp_pipe", "piped bmp sequence", "bmp demuxer", "image2 sequence", "image2 demuxer", "set the video framerate", "pattern_type", "set pattern type", "glob_sequence", "glob", "select glob pattern type", "sequence", "select sequence pattern type", "disable pattern matching", "set video pixel format", "start_number", "start_number_range", "force frame size in bytes", "ts_from_file", "ts_type", "second precision", "nano second precision", "UVAx", "image2 muxer", "updatefirst", "update", "strftime", "use strftime for filename", "esds object type id 0x%02x\n", "Specific MPEG4 header len=%d\n", "libavformat/latmenc.c", "latm", "LOAS/LATM", "audio/MP4A-LATM", "latm,loas", "LATM/LOAS muxer", "smc-interval", "StreamMuxConfig interval.", "raw MPEG-4 video", "m4v demuxer", "enda %d\n", "Duplicated STPS atom\n", "Atoms too deeply nested\n", "ignoring multiple glbl\n", "%d/%d", "qt  ", "major_brand", "minor_version", "compatible_brands", "systemBitrate=\"", "Duplicated SBGP atom\n", "frag flags 0x%x\n", "track[%i].stts.entries = %i\n", "Duplicated STTS atom\n", "Invalid sample_count=%d\n", "keyframe_count = %d\n", "Duplicated STSS atom\n", "track[%i].stsc.entries = %i\n", "Duplicated STSC atom\n", "ctype= %.4s (0x%08x)\n", "stype= %.4s\n", "handler_name", "Duplicated ELST atom\n", "track[%i].edit_count = %i\n", "Duplicated STCO atom\n", "get_wav_header failed\n", "track[%i].ctts.entries = %i\n", "count=%d, duration=%d\n", "CTTS invalid\n", "dts shift %d\n", "flags 0x%x entries %d\n", "first sample flags 0x%x\n", "calculated into dts %lld\n", "Failed to add index entry\n", "%Y-%m-%d %H:%M:%S", "time scale = %i\n", "stream has mfra\n", "found tfra\n", "moof offset %llx\n", "[aax] file checksum == ", "%02x", "[aax] mismatch in checksums!\n", "nclx", "nclc", "%s: pri %d trc %d matrix %d", " full %u", "type %.4s size %d\n", "volume %s, len %d\n", "filename %s, len %d\n", "nlvl from %d, nlvl to %d\n", "type %d, len %d\n", "path %s\n", "dir %s\n", "stream %d, found sample %d\n", "warning", "subtitle", "original_source", "playback_requirements", "performers", "producer", "original_artist", "model", "make", "host_computer", "grouping", "original_format", "edit_date", "disclaimer", "director", "chapter", "season_number", "network", "episode_sort", "episode_id", "media_type", "sort_show", "sort_name", "sort_composer", "sort_artist", "sort_album", "sort_album_artist", "rating", "purchase_date", "gapless_playback", "podcast", "synopsis", "keywords", "hd_video", "episode_uid", "description", "category", "account_id", "account_type", "quicktime_version", "premiere_version", "loci too short\n", "place name too long\n", "%+08.4f%+09.4f", "%s-%s", "Unknown cover type: 0x%x.\n", "%.4s", "lang \"%3s\" ", "Error parsing cover art.\n", "iTunSMPB", "%*X %X %X %X", "cdec", "truncated extradata\n", "size: %dx%d\n", "palette: ", "%06x%s", "stream %d, timescale not set\n", "wrong sample count\n", "error unaligned chunk\n", "chunk count %d\n", "wrong chunk count %d\n", "error reading header\n", "moov atom not found\n", "on_parse_exit_offset=%lld\n", "Chapter %d not found in file\n", "timecode", "root", "tmcd", "Invalid sample field size %d\n", "Duplicated STSZ atom\n", "Multiple mdhd?\n", "Version %d", "invalid size %lld in stsd\n", "Planar Y'CbCr 8-bit 4:2:0", "Sorenson H263", "depth %d, ctab id %d\n", "audio channels %d\n", "version =%d, isom =%d\n", "reel_name", "stsd", "avc1", "hvc1", "hev1", "mp4s", "mov,mp4,m4a,3gp,3g2,mj2", "QuickTime / MOV", "use_absolute_path", "seek_streams_individually", "ignore_editlist", "use_mfra_for", "export_all", "export_xmp", "Export full XMP metadata", "activation_bytes", "audible_fixed_key", "a=control:streamid=%d\r\n", "libavformat/movenc.c", "next_dts >= 0", "disk", "trkn", "stss", "stps", "mhlr", "vide", "VideoHandler", "soun", "SoundHandler", "subp", "SubtitleHandler", "hint", "HintHandler", "TimeCodeHandler", "url ", "DataHandler", "clcp", "ClosedCaptionHandler", "sbtl", "dhlr", "handler", "3gp6", "3gp4", "3g2b", "3g2a", "M4V ", "M4A ", "yrrc", "albm", "next_dts <= 2147483647", "Lucida Grande", "lpcm", "XDCAM", " HD422", " %d%c", "DpxE", "gamma value %g\n", "writing gama value %d\n", "track->mode == 0x02", "fps %d is too large\n", "2006/04/01 11:11:11", "perf", "titl", "author", "gnre", "dscp", "cprt", "aART", "encoding_tool", "Lavf56.40.101", "ldes", "tvsh", "tven", "tvnn", "tmpo", "pts has no value\n", "wide", "free", "audio", "ipod", "ismv", "palette:", "size:", "<head>\n", "</head>\n", "<body>\n", "<switch>\n", "<%s systemBitrate=\"%d\">\n", "systemBitrate", "trackID", "CodecPrivateData", "H264", "FourCC", "WVC1", "MaxWidth", "MaxHeight", "DisplayWidth", "DisplayHeight", "AACL", "WMAP", "AudioTag", "Channels", "SamplingRate", "BitsPerSample", "PacketSize", "</%s>\n", "</switch>\n", "</body>\n", "</smil>\n", "video/mp4", "m4v,m4a", "ipod muxer", "MP4 (MPEG-4 Part 14)", "mp4 muxer", "mov muxer", "movflags", "MOV muxer flags", "rtphint", "Add RTP hint tracks", "moov_size", "empty_moov", "frag_keyframe", "Fragment at video keyframes", "separate_moof", "frag_custom", "isml", "faststart", "omit_tfhd_offset", "disable_chpl", "Disable Nero chapter atom", "default_base_moof", "dash", "frag_discont", "delay_moov", "global_sidx", "write_colr", "write_gama", "Write deprecated gama atom", "rtpflags", "RTP muxer flags", "rfc2190", "skip_rtcp", "h264_mode0", "Use mode 0 for H264 in RTP", "send_bye", "skip_iods", "Skip writing iods atom.", "iods_audio_profile", "iods audio profile atom.", "iods_video_profile", "iods video profile atom.", "frag_duration", "Maximum fragment duration", "min_frag_duration", "Minimum fragment duration", "frag_size", "Maximum fragment size", "ism_lookahead", "video_track_timescale", "brand", "Override major brand", "use_editlist", "use edit list", "fragment_index", "mov_gamma", "gamma value for gama atom", "frag_interleave", "rtpo", "pad %d %d\n", "MP2/3 (MPEG audio layer 2/3)", "mp2,mp3,m2a,mpa", "usetoc", "use table of contents", "libavformat/mp3enc.c", "best_bitrate_idx >= 0", "Lavc libmp3lame", "No audio stream present.\n", "audio/mpeg", "MP3 muxer", "id3v2_version", "write_id3v1", "write_xing", "PES packet size mismatch\n", "changing packet size to %d\n", "timestamp_len > 64", "Predefined SLConfigDescriptor", "Filter: pid=0x%x\n", "libavformat/mpegts.c", "pos >= 188", "Skipping after seek\n", "SDT:\n", "tag: 0x%02x len=%d\n", "service_name", "service_provider", "HDMV", "HDPR", "pid=%x pes_code=%#x\n", "tuning done\n", "Found tag %x expected %x\n", "pid %x is not PES\n", "PAT:\n", "sid=0x%x pid=0x%x\n", "reg_desc=%.4s\n", "PMT: len %i\n", "pcr_pid=0x%x\n", "program tag: 0x%02x len=%d\n", "mpegtsraw", "mpegts", "mpegtsraw demuxer", "resync_size", "compute_pcr", "ts_packetsize", "mpegts demuxer", "fix_teletext_pts", "scan_all_pmts", "scan and combine all PMTs", "skip_changes", "skip_clear", "skip clearing programs", "Service01", "FFmpeg", "Duplicate stream id %d\n", "frame size not set\n", "muxrate VBR, ", "muxrate %d, ", "m2ts", "libavformat/mpegtsenc.c", "flag", "dts < pcr, TS is invalid\n", "pkt[3] & 0x20", " data %08X", "first pts value must be set\n", "nal %d\n", "AAC packet too short\n", "!ts_st->payload_size", "video/MP2T", "ts,m2t,m2ts,mts", "MPEGTS muxer", "mpegts_transport_stream_id", "mpegts_original_network_id", "mpegts_service_id", "Set service_id field.", "mpegts_service_type", "Set service_type field.", "digital_tv", "Digital Television.", "digital_radio", "Digital Radio.", "teletext", "Teletext.", "advanced_codec_digital_radio", "Advanced Codec Digital Radio.", "mpeg2_digital_hdtv", "MPEG2 Digital HDTV.", "advanced_codec_digital_sdtv", "Advanced Codec Digital SDTV.", "advanced_codec_digital_hdtv", "Advanced Codec Digital HDTV.", "mpegts_pmt_start_pid", "Set the first pid of the PMT.", "mpegts_start_pid", "Set the first pid.", "mpegts_m2ts_mode", "Enable m2ts mode.", "muxrate", "pes_payload_size", "mpegts_flags", "MPEG-TS muxing flags", "resend_headers", "pat_pmt_at_frames", "mpegts_copyts", "don't offset dts/pts", "tables_version", "set PAT, PMT and SDT version", "omit_video_pes_length", "pcr_period", "PCR retransmission time", "pat_period", "sdt_period", "mpegvideo", "raw MPEG video", "mpegvideo demuxer", "sample rate not set\n", "encoder-", "libavformat/mux.c", "((AVFrame *)pkt->data)->buf", "s->oformat", "Failed to set close on exec\n", "ff_socket_nonblock failed\n", "Connection to %s failed: %s\n", "AVFormatContext", "avioflags", "direct", "reduce buffering", "probesize", "set probing size", "formatprobesize", "packetsize", "set packet size", "fflags", "flush_packets", "ignidx", "ignore index", "genpts", "generate pts", "nofillin", "noparse", "igndts", "ignore dts", "discardcorrupt", "discard corrupted frames", "sortdts", "keepside", "don't merge side data", "fastseek", "fast but inaccurate seeks", "enable RTP MP4A-LATM payload", "nobuffer", "seek2any", "analyzeduration", "cryptokey", "decryption key", "indexmem", "rtbufsize", "fdebug", "max_delay", "start_time_realtime", "fpsprobesize", "audio_preload", "chunk_duration", "microseconds for each chunk", "chunk_size", "size in bytes for each chunk", "f_err_detect", "use_wallclock_as_timestamps", "use wallclock as timestamps", "skip_initial_bytes", "correct_ts_overflow", "metadata_header_padding", "output_ts_offset", "set output timestamp offset", "max_interleave_delta", "f_strict", "max_ts_probe", "avoid_negative_ts", "disabled", "do not change timestamps", "make_non_negative", "make_zero", "format_whitelist", "raw MJPEG video", "mjpg,mjpeg,mpo", "mjpeg demuxer", "raw LOAS/LATM", "video/x-mjpeg", "mjpg,mjpeg", "h264,264", "REPLAYGAIN_TRACK_GAIN", "REPLAYGAIN_TRACK_PEAK", "REPLAYGAIN_ALBUM_GAIN", "REPLAYGAIN_ALBUM_PEAK", "IART", "ICMT", "ICOP", "ICRD", "IGNR", "ILNG", "INAM", "IPRD", "IPRT", "ITRK", "ISFT", "ISMP", "ITCH", "wav header size < 14", "Invalid sample rate: %d\n", "INFO subchunk truncated\n", "too big INFO subchunk\n", "truncated file\n", "libavformat/riffenc.c", "(start&1) == 0", "BottomUp", "LIST", " number %g\n", " bool %d\n", " string '%s'\n", " NULL\n", "  %s: ", "chunk size", "bytes read", "server bandwidth", "client bandwidth", "audio packet", "video packet", "Flex shared stream", "Flex shared object", "Flex shared message", "notification", "shared object", "invoke", "Server BW = %d\n", "Client BW = %d\n", "Incorrect chunk size %d\n", "New incoming chunk size = %d\n", "./libavcodec/bytestream.h", "_result", "Server error: %s\n", "code", "NetStream.Play.Start", "NetStream.Play.Stop", "NetStream.Publish.Start", "NetStream.Seek.Notify", "onStatus", "status", "%s is now published", "details", "clientid", "Error in PT_INVOKE\n", "FCPublish", "publish", "onFCPublish", "play", "createStream", "@setDataFrame", "Too short ping packet (%d)\n", "_checkbw", "releaseStream", "FCSubscribe", "getStreamLength", "connect", "authmod=adobe", "authmod=llnw", "No credentials set\n", "?reason=authfailed", "Incorrect username/password\n", "?reason=nosuchuser", "Incorrect username\n", "Authentication failed\n", "code=403 need auth", "?authmod=%s&user=%s", "?reason=needauth", "No auth parameters found\n", "user", "salt", "opaque", "challenge", "nonce", "Ignoring unsupported var %s\n", "Variable %s has NULL value\n", "adobe", "&opaque=%s", "live", "/_definst_", "00000001", "llnw", "UnPublishing stream...\n", "FCUnpublish", "Deleting stream...\n", "deleteStream", "seek", "Pause at timestamp %d\n", "pause", "received bytes read report\n", "Sending SWF verification...\n", "Client bandwidth = %d\n", "Server bandwidth = %d\n", "_error", "Releasing stream...\n", "FCPublish stream...\n", "Creating stream...\n", "onBWDone", "|RtmpSampleAccess", "Sending bytes read report\n", "rtmp", "rtmpt", "rtmpts", "ffrtmphttp_tls", "ffrtmphttp", "rtmps", "rtmpe", "rtmpte", "ffrtmpcrypt_tunneling", "ffrtmpcrypt", "?listen&listen_timeout=%d", "Cannot open connection %s\n", "Cannot open connection %s.\n", "rtmp_swfhash", "Handshaking...\n", "Type answer %d\n", "Server version %d.%d.%d.%d\n", "Signature mismatch\n", "Unable to read handshake\n", "Unable to write answer\n", "RTMP Handshake S1 Error\n", "RTMP Handshake S2 Error\n", "slist=", "/ondemand/", ".f4v", ".mp4", ".flv", "%s %d,%d,%d,%d", "FMLE/3.0 (compatible; %s)", "nonprivate", "flashVer", "swfUrl", "tcUrl", "fpad", "capabilities", "audioCodecs", "videoCodecs", "videoFunction", "pageUrl", "Invalid AMF parameter: %s\n", "Expecting connect, got %s\n", "SeqNum not found\n", "fmsVer", "FMS/3,0,1,123", "NetConnection.Connect.Success", "Connection succeeded.", "objectEncoding", "RTMP Handshake C1 Error\n", "RTMP Handshake C2 Error\n", "rtmp_app", "rtmp_buffer", "rtmp_conn", "rtmp_flashver", "rtmp_flush_interval", "rtmp_live", "live stream", "recorded", "recorded stream", "rtmp_pageurl", "rtmp_playpath", "rtmp_subscribe", "rtmp_swfsize", "rtmp_swfurl", "rtmp_swfverify", "rtmp_tcurl", "rtmp_listen", "timeout", "payload_type", "Port missing in uri\n", "listen_timeout", "IP Address:%s\n", "libavformat/tcp.c", "send_buffer_size", "recv_buffer_size", "%s://", "libavformat/utils.c", "*pkt_buffer", "probing stream %d pp:%d\n", "probed stream %d\n", "probed stream %d failed\n", "Format not on whitelist\n", "st->codec->ticks_per_frame", "s->iformat", "DTS %lli < %lli out of order\n", "pipe", "cache", "tmp_pos > pos_max", "gen_seek: %d %s\n", "ts_min < ts_max", "pos_limit <= pos_max", "read_seek: %d %s\n", "index < st->nb_index_entries", "rfps: %f %f\n", "mp4v", "st->request_probe <= 0", "Invalid stream index %d\n", "st->index_entries", "unspecified frame size", "unspecified pixel format", "unspecified size", "no decodable DTS frames", "unspecified sample rate", "unspecified sample format", "unknown codec", "interrupted\n", "All info found\n", "s->nb_streams>0", "new_program: id=0x%04x\n", "stream index %d is not valid\n", "%0*d", "%Y - %m - %d %T", "%Y - %m - %dT%T", "dvbsub", "loas", "libavformat/wavdec.c", "length <= sizeof(temp)", "WAVE", "RIFF", "RIFX", "RF64", "ds64", "originator", "originator_reference", "origination_date", "origination_time", "%llu", "time_reference", "umid", "coding_history", "Unknown SMV version found\n", "Found SMV data\n", "too many frames per jpeg\n", "too short LIST tag\n", "no 'data' tag found\n", "Data size %lld is too large\n", "WAV / WAVE (Waveform Audio)", "WAV demuxer", "ignore_length", "Ignore length", "No memory for peak data\n", "wav_write_packet: NOPTS\n", "levl", "%Y:%m:%d:%H:%M:%S:", "%03d", "Failed to write timestamp\n", "JUNK", "NONE", "fmt ", "fact", "bext", "data", "audio/x-wav", "WAV muxer", "write_bext", "Write BEXT chunk.", "write_peak", "Write Peak Envelope chunk.", "Do not write peak chunk.", "only", "rf64", "always", "never", "peak_block_size", "peak_format", "peak_ppv", "libavutil/avstring.c", "tail_len <= 5", "'\\''", "%d channels", "3.0(back)", "quad", "quad(side)", "5.0(side)", "5.1(side)", "6.0(front)", "hexagonal", "6.1(front)", "7.0(front)", "7.1(wide)", "7.1(wide-side)", "octagonal", "hexadecagonal", "downmix", "front left", "front right", "front center", "low frequency", "back left", "back right", "front left-of-center", "front right-of-center", "back center", "side left", "side right", "top center", "top front left", "top front center", "top front right", "top back left", "top back center", "top back right", "downmix left", "downmix right", "wide left", "wide right", "surround direct left", "surround direct right", "LFE2", "low frequency 2", "detected %d logical cores\n", "mmx2", "mmxext", "sse2", "sse2slow", "sse3", "sse3slow", "ssse3", "atom", "sse4.1", "sse4.2", "avxslow", "fma3", "fma4", "avx2", "bmi1", "bmi2", "3dnow", "3dnowext", "cmov", "pentium2", "pentium3", "pentium4", "athlon", "athlonxp", "cpuflags", "Error number %d occurred", "BSF_NOT_FOUND", "Bitstream filter not found", "BUG2", "BUFFER_TOO_SMALL", "Buffer too small", "DECODER_NOT_FOUND", "Decoder not found", "DEMUXER_NOT_FOUND", "Demuxer not found", "ENCODER_NOT_FOUND", "Encoder not found", "End of file", "EXIT", "Immediate exit requested", "EXTERNAL", "FILTER_NOT_FOUND", "Filter not found", "INPUT_CHANGED", "Input changed", "INVALIDDATA", "MUXER_NOT_FOUND", "Muxer not found", "OPTION_NOT_FOUND", "Option not found", "OUTPUT_CHANGED", "Output changed", "PATCHWELCOME", "PROTOCOL_NOT_FOUND", "Protocol not found", "STREAM_NOT_FOUND", "Stream not found", "UNKNOWN", "Unknown error occurred", "EXPERIMENTAL", "Experimental feature", "INPUT_AND_OUTPUT_CHANGED", "Input and output changed", "HTTP_BAD_REQUEST", "HTTP_UNAUTHORIZED", "HTTP_FORBIDDEN", "HTTP_NOT_FOUND", "Server returned 404 Not Found", "HTTP_OTHER_4XX", "HTTP_SERVER_ERROR", "Missing ')' in '%s'\n", "sinh", "cosh", "tanh", "asin", "acos", "squish", "gauss", "isnan", "isinf", "while", "taylor", "floor", "ceil", "print", "hypot", "ifnot", "bitand", "bitor", "between", "Unknown function in '%s'\n", "atan", "QP2LAMBDA", "Eval", "Cannot read file '%s': %s\n", "Error occurred in mmap(): %s\n", "/tmp/%sXXXXXX", "FILE", "AVPanScan", "Stereoscopic 3d metadata", "AVMatrixEncoding", "AVReplayGain", "3x3 displaymatrix", "Motion vectors", "YCgCo", "murmur3", "RIPEMD128", "RIPEMD160", "RIPEMD256", "RIPEMD320", "SHA160", "SHA224", "SHA256", "SHA512/224", "SHA512/256", "SHA384", "SHA512", "CRC32", "adler32", "libavutil/imgutils.c", "av_image_get_linesize failed\n", "IMGUTILS", "TERM", "NO_COLOR", "AV_LOG_FORCE_NOCOLOR", "AV_LOG_FORCE_COLOR", "AV_LOG_FORCE_256COLOR", "256color", "quiet", "fatal", "panic", "[%s @ %p] ", "[%s] ", "%s%s%s%s", "libavutil/mathematics.c", "duration >= 0", "libavutil/mem_internal.h", "INT_MAX", "INT_MIN", "UINT32_MAX", "I64_MAX", "I64_MIN", "FLT_MAX", "FLT_MIN", "-FLT_MAX", "-FLT_MIN", "DBL_MAX", "DBL_MIN", "-DBL_MAX", "-DBL_MIN", "pixel", "0x%08X", "%02X", "%lli:%02d:%02d.%06d", "0x%02x%02x%02x%02x", "0x%llx", "%d%*1[:/]%d%c", "pixel format", "Invalid option type.\n", "  %s%-17s ", "<flags>", "%-12s ", "<int>", "<int64>", "<double>", "<float>", "<string>", "<rational>", "<binary>", "<image_size>", "<video_rate>", "<pix_fmt>", "<sample_fmt>", "<duration>", "<color>", "<channel_layout>", " (from ", " to ", " (default ", "%llX", "\"%s\"", "     %-15s ", "%s AVOptions:\n", "Invalid separator(s) found.", "%d:%d%c", "ntsc", "qntsc", "qpal", "sntsc", "spal", "ntsc-film", "bikeshed", "0123456789ABCDEFabcdef", "Cannot find color '%s'\n", "%H:%M:%S", "%Y-%m-%d", "%Y%m%d", "%H%M%S", "%J:%M:%S", "%M:%S", "AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "Blue", "BlueViolet", "Brown", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "Coral", "CornflowerBlue", "Cornsilk", "Crimson", "Cyan", "DarkBlue", "DarkCyan", "DarkGoldenRod", "DarkGray", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "Darkorange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "GoldenRod", "Gray", "Green", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Khaki", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenRodYellow", "LightGreen", "LightGrey", "LightPink", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Magenta", "Maroon", "MediumAquaMarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "Orchid", "PaleGoldenRod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Pink", "Plum", "PowderBlue", "Purple", "RosyBrown", "RoyalBlue", "SaddleBrown", "Salmon", "SandyBrown", "SeaGreen", "SeaShell", "Sienna", "Silver", "SkyBlue", "SlateBlue", "SlateGray", "SpringGreen", "SteelBlue", "Teal", "Thistle", "Tomato", "Turquoise", "Violet", "Wheat", "White", "WhiteSmoke", "Yellow", "YellowGreen", "sqcif", "qcif", "4cif", "16cif", "qqvga", "qvga", "svga", "uxga", "qxga", "sxga", "qsxga", "hsxga", "wvga", "wxga", "wsxga", "wuxga", "woxga", "wqsxga", "wquxga", "whsxga", "whuxga", "hd480", "hd1080", "2kdci", "2kflat", "2kscope", "4kdci", "4kflat", "4kscope", "hqvga", "wqvga", "fwqvga", "hvga", "uhd2160", "uhd4320", "bgra", "rgba", "rgb32", "bgr32", "name nb_components nb_bits", "%-11s %7d %10d", "yuvj", "libavutil/pixdesc.c", "d->log2_chroma_w <= 3", "d->log2_chroma_h <= 3", "d->nb_components <= 4", "d->name && d->name[0]", "bayer_", "tmp[0] == 0 && tmp[1] == 0", "ycgco", "bt2020nc", "bt2020c", "log100", "log316", "iec61966-2-4", "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-20", "yuv420p", "yuyv422", "rgb24", "bgr24", "yuv422p", "yuv444p", "yuv410p", "yuv411p", "gray8,y8", "monow", "monob", "yuvj420p", "yuvj422p", "yuvj444p", "xvmcmc", "xvmcidct", "uyvy422", "uyyvyy411", "bgr8", "bgr4", "bgr4_byte", "rgb8", "rgb4", "rgb4_byte", "nv12", "nv21", "argb", "abgr", "gray16be", "y16be", "gray16le", "y16le", "yuv440p", "yuvj440p", "yuva420p", "vdpau_h264", "vdpau_mpeg1", "vdpau_mpeg2", "vdpau_wmv3", "vdpau_vc1", "rgb48be", "rgb48le", "rgb565be", "rgb565le", "rgb555be", "rgb555le", "bgr565be", "bgr565le", "bgr555be", "bgr555le", "vaapi_moco", "vaapi_idct", "vaapi_vld", "yuv420p16le", "yuv420p16be", "yuv422p16le", "yuv422p16be", "yuv444p16le", "yuv444p16be", "vdpau_mpeg4", "dxva2_vld", "rgb444le", "rgb444be", "bgr444le", "bgr444be", "gray8a", "bgr48be", "bgr48le", "yuv420p9be", "yuv420p9le", "yuv420p10be", "yuv420p10le", "yuv422p10be", "yuv422p10le", "yuv444p9be", "yuv444p9le", "yuv444p10be", "yuv444p10le", "yuv422p9be", "yuv422p9le", "vda_vld", "gbrp", "gbrp9be", "gbrp9le", "gbrp10be", "gbrp10le", "gbrp16be", "gbrp16le", "yuva420p9be", "yuva420p9le", "yuva422p9be", "yuva422p9le", "yuva444p9be", "yuva444p9le", "yuva420p10be", "yuva420p10le", "yuva422p10be", "yuva422p10le", "yuva444p10be", "yuva444p10le", "yuva420p16be", "yuva420p16le", "yuva422p16be", "yuva422p16le", "yuva444p16be", "yuva444p16le", "vdpau", "xyz12le", "xyz12be", "nv16", "nv20le", "nv20be", "yvyu422", "ya16be", "ya16le", "mmal", "d3d11va_vld", "rgba64be", "rgba64le", "bgra64be", "bgra64le", "0rgb", "rgb0", "0bgr", "bgr0", "yuva444p", "yuva422p", "yuv420p12be", "yuv420p12le", "yuv420p14be", "yuv420p14le", "yuv422p12be", "yuv422p12le", "yuv422p14be", "yuv422p14le", "yuv444p12be", "yuv444p12le", "yuv444p14be", "yuv444p14le", "gbrp12be", "gbrp12le", "gbrp14be", "gbrp14le", "gbrap", "gbrap16be", "gbrap16le", "yuvj411p", "bayer_bggr8", "bayer_rggb8", "bayer_gbrg8", "bayer_grbg8", "bayer_bggr16le", "bayer_bggr16be", "bayer_rggb16le", "bayer_rggb16be", "bayer_gbrg16le", "bayer_gbrg16be", "bayer_grbg16le", "bayer_grbg16be", "yuv440p10le", "yuv440p10be", "yuv440p12le", "yuv440p12be", "ayuv64le", "ayuv64be", "videotoolbox_vld", "/dev/urandom", "/dev/random", "libavutil/random_seed.c", "sizeof(tmp) >= av_sha_size", "name   depth", "%-6s   %2d ", "%s%02d:%02d:%02d%c%02d", "%02u:%02u:%02u%c%02u", "%d:%d:%d%c%d", "attachment", "libavutil/utils.c", "!\"valid element size\"", "libswresample/audioconvert.c", "libswresample/dither.c", "!s->preout.count", "SWResampler", "set input channel count", "in_channel_count", "set output channel count", "out_channel_count", "set used channel count", "used_channel_count", "set input sample rate", "set output sample rate", "set input sample format", "set output sample format", "set internal sample format", "internal_sample_fmt", "set input channel layout", "set output channel layout", "clev", "set center mix level", "center_mix_level", "slev", "set surround mix level", "surround_mix_level", "set surround mix Level", "lfe_mix_level", "set LFE mix level", "rmvol", "set rematrix volume", "rematrix_volume", "rematrix_maxval", "set rematrix maxval", "swr_flags", "force resampling", "dither_scale", "set dither scale", "dither_method", "set dither method", "rectangular", "select rectangular dither", "select triangular dither", "triangular_hp", "lipshitz", "shibata", "low_shibata", "high_shibata", "f_weighted", "modified_e_weighted", "improved_e_weighted", "filter_size", "phase_shift", "linear_interp", "enable linear interpolation", "set cutoff frequency ratio", "resample_cutoff", "resampler", "set resampling Engine", "select SW Resampler", "soxr", "select SoX Resampler", "cheby", "min_comp", "min_hard_comp", "comp_duration", "max_soft_comp", "async", "matrix_encoding", "set matrixed stereo encoding", "select none", "dolby", "select Dolby", "dplii", "select Dolby Pro Logic II", "filter_type", "select swr filter type", "select cubic", "blackman_nuttall", "kaiser", "select Kaiser Windowed Sinc", "kaiser_beta", "set swr Kaiser Window Beta", "output_sample_bits", "Treating %s as mono\n", "libswresample/rematrix.c", "libswresample/resample.c", "a->planar", "Unsupported sample format\n", "Filter length too large\n", "libswresample/swresample.c", "out->planar == in->planar", "out->bps == in->bps", "out->ch_count == in->ch_count", "Failed to set option\n", "!s->in_ch_layout", "s->used_ch_count", "s->out.ch_count", "a->bps", "a->ch_count", "s->in.planar", "s->drop_output", "!s->resample", "discarding %d audio samples\n", "libswscale/alphablend.c", "libswscale/swscale_internal.h", "swscaler", "SWScaler", "scaler flags", "fast_bilinear", "fast bilinear", "bicubic", "neighbor", "nearest neighbor", "area", "averaging area", "bicublin", "luma bicubic, chroma bilinear", "gaussian", "sinc", "lanczos", "spline", "natural bicubic spline", "print_info", "print info", "accurate_rnd", "accurate rounding", "full_chroma_int", "full chroma interpolation", "full_chroma_inp", "full chroma input", "error_diffusion", "error diffusion dither", "source width", "source height", "destination width", "destination height", "source format", "destination format", "source range", "destination range", "scaler param 0", "scaler param 1", "sws_dither", "set dithering algorithm", "leave choice to sws", "bayer dither", "error diffusion", "a_dither", "arithmetic addition dither", "x_dither", "arithmetic xor dither", "gamma correct scaling", "alphablend", "mode for alpha -> non alpha", "ignore alpha", "uniform_color", "blend onto a uniform color", "blend onto a checkerboard", "libswscale/output.c", "libswscale/slice.c", "libswscale/swscale.c", "Slices start in the middle!\n", "bad src image pointers\n", "bad dst image pointers\n", "unsupported bayer conversion\n", "libswscale/swscale_unscaled.c", "libswscale/utils.c", "sizeFactor > 0", "filter2Size > 0", "minFilterSize > 0", "filterSize > 0", "(*filterPos)[i] >= 0", "(*filterPos)[i] < srcW", "sws: initFilter failed\n", "%1.3f ", "ehh flags invalid?!", "dithered ", "MMXEXT", "3DNOW", "c->dstBpc > 14", "c->chrDstH <= dstH", "%s scaler, from %s to %s%s ", "using %s\n", "%dx%d -> %dx%d\n", "area averaging", "Gaussian", "Lanczos", "nearest neighbor / point", "bicubic spline", "postproc", "pp: Missing argument\n", "help", "pp: %s\n", "pp: %s::%s\n", "pp: option: %s\n", "autoq", "nochrom", "chrom", "noluma", "fullyrange", "pp: lumMode=%X, chromMode=%X\n", "using npp filters 0x%X/0x%X\n", "Postproc", "hb:a,vb:a,dr:a", "h1:a,v1:a,dr:a", "ha:a:128:7,va:a,dr:a", "hdeblock", "vdeblock", "x1hdeblock", "x1vdeblock", "ahdeblock", "avdeblock", "dering", "autolevels", "linblenddeint", "linipoldeint", "cubicipoldeint", "mediandeint", "ffmpegdeint", "lowpass5", "tmpnoise", "forcequant", "visualize", "{no name}", "invalid channel count: %d\n", "invalid sample format\n", "sample format mismatch\n", "dst is read-only\n", "error reallocating dst\n", "AudioData", "[%d to %d] ", "[%d to any] ", "[any to %d] ", "Invalid channel counts\n", "matrix is not set\n", "Invalid mix coeff type\n", "  (ZERO)", "  (SKIP)", "  %0.3f ", "audio_mix: %s to %s\n", "matrix size: %d x %d\n", "error setting mix matrix\n", "dither s16 buffer", "dither flt buffer", "AVAudioResampleContext", "Input Channel Layout", "Input Sample Format", "Input Sample Rate", "Output Channel Layout", "Output Sample Format", "Output Sample Rate", "Internal Sample Format", "8-bit unsigned integer", "16-bit signed integer", "32-bit signed integer", "32-bit float", "64-bit double", "8-bit unsigned integer planar", "s16p", "16-bit signed integer planar", "s32p", "32-bit signed integer planar", "fltp", "32-bit float planar", "dblp", "64-bit double planar", "mix_coeff_type", "Mixing Coefficient Type", "16-bit 8.8 Fixed-Point", "32-bit 17.15 Fixed-Point", "Floating-Point", "Center Mix Level", "Surround Mix Level", "LFE Mix Level", "normalize_mix_level", "Normalize Mix Level", "Force Resampling", "Resampling Filter Size", "Resampling Phase Shift", "Use Linear Interpolation", "Cutoff Frequency Ratio", "Matrixed Stereo Encoding", "None", "Dolby", "Filter Type", "Cubic", "Kaiser Windowed Sinc", "Kaiser Window Beta", "Dither Method", "No Dithering", "Rectangular Dither", "Triangular Dither", "triangular_ns", "resample buffer", "error reallocating output\n", "error during resampling\n", "in_buffer", "resample_out_buffer", "out_buffer", "[start conversion]\n", "output", "input", "[copy] %s to output\n", "[copy] %s to out_buffer\n", "[convert] %s to in_buffer\n", "[copy] %s to in_buffer\n", "[downmix] in_buffer\n", "[end conversion]\n", "[resample] %s to %s\n", "[upmix] %s\n", "[convert] %s to output\n", "[convert] %s to out_buffer\n", "[FIFO] add %s to out_fifo\n", "Invalid channel layouts\n", "Invalid input channel layout\n", "Invalid channel map\n", "AuthenticAMD", "GenuineIntel", "libswscale/x86/swscale.c", "c->srcBpc == 16", "c->dstBpc>8", "SSE2", "SSE2SLOW", "SSSE3", "SSE4", "FMA4", "x264 [%s]: ", "x264_2pass.log", "lookahead-threads", "sliced-threads", "sync-lookahead", "deterministic", "n-deterministic", "cpu-independent", "level-idc", "%d:%d", "overscan", "videoformat", "fullrange", "colorprim", "transfer", "chromaloc", "%u/%u", "frameref", "dpb-size", "keyint", "infinite", "min-keyint", "keyint-min", "scenecut", "bframes", "b-adapt", "open-gop", "%d,%d", "slice-max-mbs", "slice-min-mbs", "slices-max", "cabac", "cabac-idc", "constrained-intra", "cqmfile", "cqm4", "cqm8", "cqm4i", "cqm4p", "cqm4iy", "cqm4ic", "cqm4py", "cqm4pc", "cqm8i", "cqm8p", "dump-yuv", "analyse", "i4x4", "i8x8", "p8x8", "p4x4", "b8x8", "weight-b", "chroma-qp-offset", "merange", "me-range", "mvrange", "mv-range", "mvrange-thread", "mv-range-thread", "subme", "%f:%f", "%f,%f", "%f|%f", "chroma-me", "dct-decimate", "deadzone-inter", "deadzone-intra", "bitrate", "qp_constant", "crf-max", "qpmin", "qp-min", "qpmax", "qp-max", "qpstep", "qp-step", "ratetol", "vbv-maxrate", "vbv-bufsize", "vbv-init", "ipratio", "ip-factor", "pbratio", "pb-factor", "cplx-blur", "zones", "crop-rect", "%u,%u,%u,%u", "sps-id", "global-header", "repeat-headers", "annexb", "force-cfr", "filler", "pic-struct", "fake-interlaced", "frame-packing", "stitchable", "opencl-clbin", "opencl-device", "invalid profile: %s\n", "malloc of size %d failed\n", "invalid preset '%s'\n", ",./-+", "touhou", "invalid tune '%s'\n", "fake", "2pass", "%dx%d ", "fps=%u/%u ", "timebase=%u/%u ", "bitdepth=%d ", "opencl=%d ", "cabac=%d", " ref=%d", " deblock=%d:%d:%d", " analyse=%#x:%#x", " me=%s", " subme=%d", " psy=%d", " psy_rd=%.2f:%.2f", " mixed_ref=%d", " me_range=%d", " chroma_me=%d", " trellis=%d", " 8x8dct=%d", " cqm=%d", " deadzone=%d,%d", " fast_pskip=%d", " chroma_qp_offset=%d", " threads=%d", " lookahead_threads=%d", " sliced_threads=%d", " slices=%d", " slices_max=%d", " slice_max_size=%d", " slice_max_mbs=%d", " slice_min_mbs=%d", " nr=%d", " decimate=%d", " interlaced=%s", " bluray_compat=%d", " stitchable=%d", " constrained_intra=%d", " bframes=%d", " weightp=%d", " keyint=%d", " rc_lookahead=%d", " rc=%s mbtree=%d", " crf=%.1f", " bitrate=%d ratetol=%.1f", " cplxblur=%.1f qblur=%.1f", " crf_max=%.1f", " qp=%d", " nal_hrd=%s filler=%d", " crop_rect=%u,%u,%u,%u", " frame-packing=%d", " ip_ratio=%.2f", " pb_ratio=%.2f", " aq=%d", ":%.2f", " zones=%s", "undef", "bt2020-12", "component", "secam", " r2 6c882b8", "bitrate not specified\n", "using mv_range_thread = %d\n", "invalid level_idc: %d\n", "using SAR=%d/%d\n", "(first_y&1) == 0", "encoder/encoder.c", " PSNR Y:%5.2f U:%5.2f V:%5.2f", " SSIM Y:%.5f", "using cpu capabilities:", "SSE3", "SSE4.1", "BMI1", "doesn't support it?\n", "failed to load OpenCL\n", "HRD bitrate: %i bits/sec\n", "CPB size: %i bits\n", "dump_yuv: can't write to %s\n", "%d.%d", "profile %s, level %s\n", "non-strictly-monotonic PTS\n", "uvAC", "uvDC", "consecutive B-frames:%s\n", " %4.1f%%", "mb I  %s\n", "mb B  %s\n", " inter:%.1f%%", " skip:%.1f%%", "field mbs: intra: %.1f%%%s\n", "8x8 transform intra:%.1f%%%s\n", " inter: %.1f%% %.1f%% %.1f%%", "ref %c L%d:%s\n", "SSIM Mean Y:%.7f (%6.3fdb)\n", "kb/s:%.2f\n", "..PCM", "4:0:0", "4:2:0", "4:2:2", "4:4:4", "dst->i_size < dst->i_max_size", "encoder/lookahead.c", "src->i_size", "OpenCL: %s\n", "libOpenCL.so", "clBuildProgram", "clCreateBuffer", "clCreateCommandQueue", "clCreateContext", "clCreateImage2D", "clCreateKernel", "clCreateProgramWithBinary", "clCreateProgramWithSource", "clEnqueueCopyBuffer", "clEnqueueMapBuffer", "clEnqueueNDRangeKernel", "clEnqueueReadBuffer", "clEnqueueWriteBuffer", "clFinish", "clGetCommandQueueInfo", "clGetDeviceIDs", "clGetDeviceInfo", "clGetKernelWorkGroupInfo", "clGetPlatformIDs", "clGetProgramBuildInfo", "clGetProgramInfo", "clGetSupportedImageFormats", "clReleaseCommandQueue", "clReleaseContext", "clReleaseKernel", "clReleaseMemObject", "clReleaseProgram", "clSetKernelArg", "(SI)", "-DVECTORIZE=1", "Advanced Micro Devices, Inc.", "libatiadlxx.so", "ADL_Main_Control_Create", "ADL_Main_Control_Destroy", "ADL_PowerXpress_Scheme_Get", "Compiling OpenCL kernels...\n", "x264_kernel_build_log.txt", "x264_lookahead.clbin", "mb_intra_cost_satd_8x8", "sum_intra_cost", "downscale_hpel", "downscale1", "downscale2", "memset_int16", "weightp_scaled_images", "weightp_hpel", "hierarchical_motion", "subpel_refine", "mode_selection", "sum_inter_cost", "common/macroblock.c", "Invalid input colorspace\n", "list[0]", "common/frame.c", "frame->i_reference_count > 0", "bad coefficient in list '%s'\n", " \t\n,", "0123456789", "can't open file '%s'\n", "INTRA4X4_LUMA", "INTER4X4_LUMA", "INTRA4X4_CHROMA", "INTER4X4_CHROMA", "INTRA8X8_LUMA", "INTER8X8_LUMA", "INTRA8X8_CHROMA", "INTER8X8_CHROMA", "internal error\n", "encoder/cabac.c", "mb type: %d \n", "mv: l%dr%d (%d,%d) \n", "limit: %d \n", "mb_xy: %d,%d \n", "completed: %d \n", "encoder/analyse.c", "h->frames.b_have_lowres", "encoder/slicetype.c", "cost >= 0", "%d,%d,q=%d%n", "%d,%d,b=%f%n", "%d,%d%n", "invalid zone: \"%s\"\n", "invalid zone param: %s = %s\n", "failed to parse zones\n", "h->param.rc.psz_stat_in", "encoder/ratecontrol.c", "#options:", "#options: %dx%d", "timebase=", "timebase=%u/%u", "bitdepth=", "bitdepth=%d", "weightp=", "weightp=%d", "bframes=", "bframes=%d", "b_pyramid=", "b_pyramid=%d", "intra_refresh=", "intra_refresh=%d", "open_gop=", "open_gop=%d", "bluray_compat=", "bluray_compat=%d", "interlaced=", "interlaced=%4s", "keyint=", "qp=0", "direct=3", "b_adapt=", "b_adapt=%d", "rc_lookahead=", "rc_lookahead=%d", "empty stats file\n", " in:%d out:%d ", "ref:", "qscale[i] >= 0", "rce->new_qscale >= 0", "try reducing target bitrate\n", "#options: %s\n", "final ratefactor: %.2f\n", "disabling adaptive B-frames\n", "w:%d,%d,%d", ",%d,%d,%d,%d,%d ", "underflow", "overflow", "clCreateImage2D error '%d'\n", "clCreateBuffer error '%d'\n", "bytes < PAGE_LOCKED_BUF_SIZE", "encoder/slicetype-cl.c", "clSetKernelArg error '%d'\n", "common/rectangle.h", "0@33333sU@", "Multiple RDBs per frame with CRC", "PCE-based channel configuration without PCE as first syntax element", "libavcodec/aacenc_quantization.h", "Dependent coupling is not supported together with LTP\n", "Sample rate index in program config element does not match the sample rate index configured by the container.\n", "decode_pce: Input buffer exhausted before END element found\n", "TNS filter order %d is greater than maximum %d.\n", "ChannelElement %d.%d missing \n", "AAC LD is only defined for ONLY_LONG_SEQUENCE but window sequence %d found.\n", "Invalid Predictor Reset Group.\n", "Prediction is not allowed in AAC-LC.\n", "LTP in ER AAC LD not yet implemented.\n", "Number of scalefactor bands in group (%d) exceeds limit (%d).\n", "decode_band_types: Input buffer exhausted before END element found\n", "Number of bands (%d) exceeds limit (%d).\n", "If you heard an audible artifact, there may be a bug in the decoder. Clipped intensity stereo position (%d -> %d)", "If you heard an audible artifact, there may be a bug in the decoder. Clipped noise gain (%d -> %d)", "Scalefactor (%d) out of range.\n", "Pulse tool not allowed in eight short sequence.\n", "error in spectral data, ESC overflow\n", "Pulse data corrupt or invalid.\n", "This stream seems to incorrectly report its last channel as %s[%d], mapping to LFE[0]\n", "This stream seems to incorrectly report its last channel as %s[%d], mapping to SCE[1]\n", "Unknown ER channel configuration %d", "channel element %d.%d is not allocated\n", "Audio specific config size is invalid\n", "invalid sampling rate index %d\n", "invalid low delay sampling rate index %d\n", "invalid default channel configuration (%d)\n", "Assuming an incorrectly encoded 7.1 channel layout instead of a spec-compliant 7.1(wide) layout, use -strict %d to decode according to the specification instead.\n", "AAC data resilience (flags %x)", "Input buffer exhausted before END element found\n", "Non-byte-aligned audio-specific config", "More than one AAC RDB per ADTS frame", "Error decoding AAC frame header.\n", "skip_data_stream_element: Input buffer exhausted before END element found\n", "Not evaluating a further program_config_element as this construct is dubious at best.\n", "TYPE_FIL: Input buffer exhausted before END element found\n", "SBR was found before the first channel element.\n", "SBR signaled to be not-present but was found in the bitstream.\n", "Implicit SBR was found with a first occurrence after the first frame.\n", "frame length mismatch %d << %d\n", "ADTS header detected, probably as result of configuration misparsing\n", "AAC LATM (Advanced Audio Coding LATM syntax)", "Select the channel to decode for dual mono", "Unsupported number of channels: %d\n", "Too many bits per frame requested, clamping to max\n", "Prediction requested, changing profile to AAC-Main\n", "Force Mid/Side for the whole frame if possible", "Disable perceptual noise substitution", "Enable perceptual noise substitution", "Disable intensity stereo coding", "Enable intensity stereo coding", "Disable temporal noise shaping", "Expected to read %d PS bits actually read %d.\n", "Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\n", "Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\n", "Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n", "Unsupported sample rate for SBR: %d\n", "Invalid bitstream, too many QMF subbands: %d\n", "Invalid bitstream, crossover band index beyond array bounds: %d\n", "Stop frequency border too high: %d\n", "Start frequency border too high: %d\n", "Too many noise floor scale factors: %d\n", "SBR reset failed. Switching SBR to pure upsampling mode.\n", "Invalid bitstream - cannot apply SBR to element type %d\n", "Parametric Stereo signaled to be not-present but was found in the bitstream.\n", "Expected to read %d SBR bytes actually read %d.\n", "element type mismatch %d != %d\n", "envelope scalefactor overflow in dequant\n", "ERROR : no subband found for frequency %d\n", "kx != f_table{high,low}[0]. Derived frequency tables were not regenerated.\n", "%d frames left in the queue on closing\n", "Queue input is backward in time\n", "Trying to remove %d samples, but the queue is empty\n", "libavcodec/audio_frame_queue.c", "afq->remaining_samples == afq->remaining_delay", "Trying to remove %d more samples than there are in the queue\n", "autoselect a good one (default)", "fast integer (experimental / for debugging)", "floating point AAN DCT (experimental / for debugging)", "floating point AAN IDCT (experimental / for debugging)", "(unsigned)pkt->size <= 2147483647 - 32", "size<=2147483647 && p - pkt->data >= size", "nb_codes + 1 <= (sizeof(localbuf) / sizeof((localbuf)[0]))", "Too long VLC (%d) in init_vlc\n", "MPEG-1/2 video XvMC (X-Video Motion Compensation)", "H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2", "MPEG-4 part 2 Microsoft variant version 1", "MPEG-4 part 2 Microsoft variant version 2", "MPEG-4 part 2 Microsoft variant version 3", "H.263+ / H.263-1998 / H.263 version 2", "FLV / Sorenson Spark / Sorenson H.263 (Flash Video)", "Sorenson Vector Quantizer 1 / Sorenson Video 1 / SVQ1", "Sorenson Vector Quantizer 3 / Sorenson Video 3 / SVQ3", "H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10", "Sony PlayStation MDEC (Motion DECoder)", "Westwood Studios VQA (Vector Quantized Animation) video", "LCL (LossLess Codec Library) MSZH", "LCL (LossLess Codec Library) ZLIB", "QuickTime Animation (RLE) video", "TechSmith Screen Capture Codec", "AVS (Audio Video Standard) video", "Chinese AVS (Audio Video Standard) (AVS1-P2, JiZhun profile)", "VMware Screen Codec / VMware Video", "Delphine Software International CIN video", "On2 VP6 (Flash version, with alpha channel)", "Intel Indeo Video Interactive 4", "Intel Indeo Video Interactive 5", "Multicolor charset for Commodore 64", "Multicolor charset for Commodore 64, extended with 5th color (colram)", "Silicon Graphics Motion Video Compressor 1", "Silicon Graphics Motion Video Compressor 2", "MS Windows Media Video V9 Screen", "Uncompressed packed MS 4:4:4:4", "Uncompressed packed QT 4:4:4:4", "H.265 / HEVC (High Efficiency Video Coding)", "Amazing Studio Packed Animation File Video", "DirectDraw Surface image decoder", "DPX (Digital Picture Exchange) image", "GIF (Graphics Interchange Format)", "PGMYUV (Portable GrayMap YUV) image", "PNG (Portable Network Graphics) image", "Renderware TXD (TeXture Dictionary) image", "Windows Media Video 9 Image v2", "APNG (Animated Portable Network Graphics) image", "PCM signed 16-bit little-endian", "PCM unsigned 16-bit little-endian", "PCM unsigned 16-bit big-endian", "PCM signed 32-bit little-endian", "PCM unsigned 32-bit little-endian", "PCM unsigned 32-bit big-endian", "PCM signed 24-bit little-endian", "PCM unsigned 24-bit little-endian", "PCM unsigned 24-bit big-endian", "PCM D-Cinema audio signed 24-bit", "PCM signed 16-bit big-endian planar", "PCM signed 16-bit little-endian planar", "PCM signed 24-bit little-endian planar", "PCM signed 32-bit little-endian planar", "PCM signed 20|24-bit big-endian", "PCM 32-bit floating point big-endian", "PCM 32-bit floating point little-endian", "PCM 64-bit floating point big-endian", "PCM 64-bit floating point little-endian", "PCM signed 16|20|24-bit big-endian for Blu-ray media", "PCM signed 20-bit little-endian planar", "ADPCM Sound Blaster Pro 2.6-bit", "ADPCM Nintendo THP (Little-Endian)", "ADPCM IMA Electronic Arts SEAD", "ADPCM IMA Electronic Arts EACS", "ADPCM Electronic Arts Maxis CDROM XA", "AMR-NB (Adaptive Multi-Rate NarrowBand)", "AMR-WB (Adaptive Multi-Rate WideBand)", "MACE (Macintosh Audio Compression/Expansion) 3:1", "MACE (Macintosh Audio Compression/Expansion) 6:1", "FLAC (Free Lossless Audio Codec)", "ADU (Application Data Unit) MP3 (MPEG audio layer 3)", "ALAC (Apple Lossless Audio Codec)", "Cook / Cooker / Gecko (RealAudio G2)", "Delphine Software International CIN audio", "MLP (Meridian Lossless Packing)", "ATRAC3 (Adaptive TRansform Acoustic Coding 3)", "Windows Media Audio 9 Professional", "ATRAC3+ (Adaptive TRansform Acoustic Coding 3+)", "MPEG-4 Audio Lossless Coding (ALS)", "ATRAC1 (Adaptive TRansform Acoustic Coding)", "Constrained Energy Lapped Transform (CELT)", "Digital Speech Standard - Standard Play mode (DSS SP)", "iLBC (Internet Low Bitrate Codec)", "Opus (Opus Interactive Audio Codec)", "TAK (Tom's lossless Audio Kompressor)", "Amazing Studio Packed Animation File Audio", "EVRC (Enhanced Variable Rate Codec)", "4GV (Fourth Generation Vocoder)", "DSD (Direct Stream Digital), least significant bit first", "DSD (Direct Stream Digital), most significant bit first", "DSD (Direct Stream Digital), least significant bit first, planar", "DSD (Direct Stream Digital), most significant bit first, planar", "SSA (SubStation Alpha) subtitle", "HDMV Presentation Graphic Stream subtitles", "SubRip subtitle with embedded timing", "PJS (Phoenix Japanimation Society) subtitle", "SMPTE 336M Key-Length-Value (KLV) metadata", "BRender PIX image (deprecated id)", "H.265 / HEVC (High Efficiency Video Coding) (deprecated id)", "Amazing Studio Packed Animation File Video (deprecated id)", "LucasArts SANM/SMUSH video (deprecated id)", "LucasArts VIMA audio (deprecated id)", "Opus (Opus Interactive Audio Codec) (deprecated id)", "Amazing Studio Packed Animation File Audio (deprecated id)", "PCM signed 24-bit little-endian planar (deprecated id)", "PCM signed 32-bit little-endian planar (deprecated id)", "PCM signed 16-bit big-endian planar (deprecated id)", "TAK (Tom's lossless Audio Kompressor) (deprecated id)", "internal error, slice end before start\n", "Cannot use previous picture in error concealment\n", "Cannot use next picture in error concealment\n", "concealing %d DC, %d AC, %d MV errors in %c frame\n", "s->avctx->codec_id != AV_CODEC_ID_H264", "Invalid TIFF tag type 0 found for %s with size %d\n", "Forcing thread count to 1 for MJPEG encoding, use -thread_type slice or a constant quantizer if you want to use multiple cpu cores\n", "MJPEG CBR encoding works badly with frame multi-threading, consider using -threads 1, -thread_type slice or a constant quantizer.\n", "libavcodec/frame_thread_encoder.c", "!avctx->internal->frame_thread_encoder", "!thread_avctx->internal->frame_thread_encoder", "ff_frame_thread_encoder_init failed\n", "Forcing thread count to 1 for huffyuv encoding with first pass or context 1\n", "discarding %d junk bits at end, next would be %X\n", "slice end not reached but screenspace end (%d left %06X, score= %d)\n", "this codec does not support truncated bitstreams\n", "Discarding excessive bitstream in packed xvid\n", "Reverting picture dimensions change due to header decoding failure\n", "Reference not available for error concealing\n", "Increasing reorder buffer to %d\n", "top block unavailable for requested intra4x4 mode %d at %d %d\n", "left block unavailable for requested intra4x4 mode %d at %d %d\n", "out of range intra chroma pred mode at %d %d\n", "top block unavailable for requested intra mode at %d %d\n", "left block unavailable for requested intra mode at %d %d\n", "AVC: Consumed only %d bytes instead of %d\n", "Ignoring NAL %d in global header/extradata\n", "invalid mixed IDR / non IDR frames cannot be decoded in slice multithreading mode\n", "SPS decoding failure, trying again with the complete NAL\n", "next_avc - buf_index + consumed == nalsize", "Unknown NAL code: %d (%d bits)\n", "Decoding sps %d from avcC failed\n", "Decoding pps %d from avcC failed\n", "Duplicating field %d to fill missing\n", "luma_log2_weight_denom %d is out of range\n", "chroma_log2_weight_denom %d is out of range\n", "reference overflow %u > %u or %u > %u\n", "Error resilience with slice threads is enabled. It is unsafe and unsupported and may crash. Use it at your own risk\n", "Enable error resilience on damaged frames (unsafe)", "overflow in decode_cabac_mb_mvd\n", "cabac decode of qscale diff failed at %d %d\n", "corrupted macroblock %d %d (total_coeff=%d)\n", "negative number of zero coeffs at %d %d\n", "offset == (sizeof(coeff_token_vlc_tables) / sizeof((coeff_token_vlc_tables)[0]))", "mb_type %d in %c slice too large at %d %d\n", "Not enough data for an intra PCM block.\n", "B sub_mb_type %u out of range at %d %d\n", "P sub_mb_type %u out of range at %d %d\n", "dquant out of range (%d) at %d %d\n", "Too big extradata size, corrupted stream or invalid MP4/AVCC bitstream\n", "Packet header is not contained in global extradata, corrupted stream or invalid MP4/AVCC bitstream\n", "Warning: SPS NALU missing or invalid. The resulting stream may not play.\n", "Warning: PPS NALU missing or invalid. The resulting stream may not play.\n", "SPS not present in the stream, nor in AVCC, stream may be unreadable\n", "PPS not present in the stream, nor in AVCC, stream may be unreadable\n", "AVC-parser: nal length size invalid\n", "AVC-parser: nal size %d remaining %d\n", "non-existing PPS %u referenced\n", "non-existing SPS %u referenced\n", "illegal reordering_of_pic_nums_idc %d\n", "illegal memory management control operation %d\n", "missing picture in access unit with size %d\n", "hardware accelerator failed to decode picture\n", "separate color planes are not supported\n", "Different chroma and luma bit depth", "illegal bit depth value (%d, %d)\n", "log2_max_frame_num_minus4 out of range (0-12): %d\n", "log2_max_poc_lsb (%d) is out of range\n", "discarding sps cropping, original values are l:%d r:%d t:%d b:%d\n", "Reducing left cropping to %d chroma samples to preserve alignment.\n", "crop values invalid %d %d %d %d / %d %d\n", "time_scale/num_units_in_tick invalid or unsupported (%u/%u)\n", "Clipping illegal num_reorder_frames %d\n", "sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %d/%d b%d reo:%d\n", "Unimplemented luma bit depth=%d\n", "Current profile doesn't provide more RBSP data in PPS, skipping\n", "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n", "Discarding mismatching reference\n", "illegal modification_of_pic_nums_idc %u\n", "Missing reference picture, default is %d\n", "av_buffer_get_ref_count(sl->ref_list[list][index].parent->f->buf[0]) > 0", "reference picture missing during reorder\n", "MMCO opcode [%d, %d] at %d mismatches between slices\n", "Inconsistent MMCO state between slices [%d, %d]\n", "mmco: unref short %d count %d\n", "mmco: cannot assign current picture to short and long at the same time\n", "mmco: cannot assign current picture to 2 long term references\n", "illegal short term reference assignment for second field in complementary field pair (first field is long term)\n", "illegal short term buffer state detected\n", "number of reference frames (%d+%d) exceeds max (%d; probably corrupt input), discarding one\n", "illegal long ref in memory management control operation %d\n", "SEI type %d size %d truncated at %d\n", "non-existing SPS %d referenced in buffering period\n", "Green Metadata Info SEI message\n", "green_metadata_type                            = %d\n", "green_metadata_period_type                     = %d\n", "green_metadata_num_seconds                     = %d\n", "green_metadata_num_pictures                    = %d\n", "SEI GREEN Complexity Metrics                   = %f %f %f %f\n", "xsd_metric_type                                = %d\n", "xsd_metric_value                               = %f\n", "VDPAU decoding does not support video colorspace.\n", "too many threads/slices %d, reducing to %d\n", "Attempt to start a frame outside SETUP state\n", "h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * sl->linesize * ((scan8[15] - scan8[0]) >> 3)", "Slice overlaps with next at %d\n", "error while decoding MB %d %d, bytestream %td\n", "error while decoding MB %d %d\n", "h264_slice_header_init() failed", "slice type %d too large at %d\n", "A non-intra slice in an IDR NAL unit.\n", "PPS change from %d to %d forbidden\n", "SPS changed in the middle of the frame\n", "Delayed frames seen. Reenabling low delay requires a codec flush.\n", "h->sps.crop_right + h->sps.crop_left < (unsigned)h->width", "h->sps.crop_top + h->sps.crop_bottom < (unsigned)h->height", "Invalid cropped dimensions: %dx%d.\n", "Ignoring cropping information.\n", "changing width %d -> %d / height %d -> %d on slice %d\n", "Reinit context to %dx%d, pix_fmt: %s\n", "h264_slice_header_init() failed\n", "Cannot (re-)initialize context during parallel decoding.\n", "Frame num change from %d to %d\n", "This stream was generated by a broken encoder, invalid 8x8 inference\n", "Changing field mode (%d -> %d) between slices is not allowed\n", "unset cur_pic_ptr on slice %d\n", "Invalid field mode combination %d/%d\n", "Found reference and non-reference fields in the same frame, which", "deblocking_filter_idc %u out of range\n", "deblocking filter parameters %d %d out of range\n", "Cannot parallelize slice decoding with deblocking filter type 1, decoding such frames in sequential order\nTo parallelize slice decoding you need video encoded with disable_deblocking_filter_idc set to 2 (deblock only edges that do not cross slices).\nSetting the flags2 libavcodec option to +fast (-flags2 +fast) will disable deblocking across slices and enable parallel slice decoding but will generate non-standard-compliant output.\n", "Deblocking switched inside frame.\n", "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n", "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n", "context_count && h->slice_ctx[context_count - 1].mb_y < h->mb_height", "Internal error, IDCT permutation not set\n", "Butterworth filter currently only supports low-pass filter mode\n", "Butterworth filter currently only supports even filter orders\n", "Biquad filter currently only supports high-pass and low-pass filter modes\n", "Biquad filter must have order of 2\n", "filter type is not currently implemented\n", "Marker bit missing at %d of %d %s\n", "Intel H263 free format not supported\n", "qp:%d %c size:%d rnd:%d%s%s%s%s%s%s%s%s%s %d/%d\n", "Header looks like RTP instead of H.263\n", "Syntax-based Arithmetic Coding (SAC) not supported\n", "Reference Picture Selection not supported\n", "Independent Segment Decoding not supported\n", "rectangular slices not supported\n", "unordered slices not supported\n", "Error: nal buffer is too small\n", "-qscale is ignored, -crf is recommended.\n", "Error setting preset/tune %s/%s.\n", "Error parsing option '%s' with value '%s'.\n", "Error parsing option '%s = %s'.\n", "libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB", "libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10", "Set the encoding preset (cf. x264 --fullhelp)", "Tune the encoding params (cf. x264 --fullhelp)", "Set profile restrictions (cf. x264 --fullhelp) ", "Use fast settings when encoding first pass", "Specify level (as defined by Annex A)", "Weighted prediction for P-frames", "Select the quality for constant quality mode", "In CRF mode, prevents VBV from lowering quality beyond this point.", "Constant quantization parameter rate control method", "Auto-variance AQ with bias to dark scenes", "AQ strength. Reduces blocking and blurring in flat and textured areas.", "Use psychovisual optimizations.", "Strength of psychovisual optimization, in <psy-rd>:<psy-trellis> format.", "Number of frames to look ahead for frametype and ratecontrol", "Weighted prediction for B-frames.", "Weighted prediction analysis method.", "Calculate and print SSIM stats.", "Use Periodic Intra Refresh instead of IDR frames.", "Bluray compatibility workarounds.", "Influences how often B-frames are used", "Keep some B-frames as references.", "Non-strict (not Blu-ray compatible)", "One reference per partition, as opposed to one reference per macroblock", "Use macroblock tree ratecontrol.", "Loop filter parameters, in <alpha:beta> form.", "Reduce fluctuations in QP (before curve compression)", "A comma-separated list of partitions to consider. Possible values: p8x8, p4x4, b8x8, i8x8, i4x4, none, all", "Limit the size of each slice in bytes", "Signal HRD information (requires vbv-bufsize; cbr not allowed in .mp4)", "If forcing keyframes, force them as IDR frames.", "Override the x264 configuration using a :-separated list of key=value parameters", "lpc_type == FF_LPC_TYPE_CHOLESKY || lpc_type == FF_LPC_TYPE_LEVINSON", "internal error in cmp function selection\n", "nb_components>=1 && nb_components<=4", "mjpeg_decode_dc: bad vlc: %d:%d (%p)\n", "class=%d index=%d nb_codes=%d\n", "error using external huffman table, switching back to internal\n", "lowres is not possible with lossless jpeg\n", "nb_components changing in interlaced picture\n", "JPEG-LS that is not <= 8 bits/component or 16-bit gray", "Invalid sampling factor in component %d %d:%d\n", "component %d %d:%d id: %d quant:%d\n", "progressively coded interlaced picture", "Unhandled pixel format 0x%x bits:%d\n", "lowres not supported for weird subsampling\n", "Unsupported number of components %d\n", "Could not get a pixel format descriptor.\n", "decode_sof0: error, len(%d) mismatch\n", "Unsupported coding and pixel format combination\n", "Can not process SOS before SOF, skipping\n", "decode_sos: nb_components (%d) unsupported\n", "decode_sos: index(%d) out of components\n", "%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\n", "AVRn interlaced picture marker found\n", "decode_sos: ac/dc index out of range\n", "MJPEG packet 0x%x too big (%d/%d), corrupt data?\n", "marker=%x avail_size_in_buf=%td\n", "mjpeg: JFIF header found (version: %x.%x) SAR=%d/%d\n", "mjpeg: Adobe header found, transform=%d\n", "Pegasus lossless jpeg header found\n", "mjpeg: invalid TIFF header in EXIF data\n", "mjpeg: error decoding EXIF data\n", "mjpeg: Apple MJPEG-A header found\n", "mjpeg: error, decode_app parser read over the end\n", "Intel(R) JPEG Library, version 1", "Found EOI before any SOF, ignoring\n", "mjpeg: unsupported coding type (%x)\n", "marker parser used %d bytes (%d bits)\n", "avctx->pix_fmt == AV_PIX_FMT_YUVJ444P || avctx->pix_fmt == AV_PIX_FMT_YUV444P || avctx->pix_fmt == AV_PIX_FMT_YUVJ440P || avctx->pix_fmt == AV_PIX_FMT_YUV440P || avctx->pix_fmt == AV_PIX_FMT_YUVA444P || avctx->pix_fmt == AV_PIX_FMT_YUVJ420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P16LE|| avctx->pix_fmt == AV_PIX_FMT_YUVA420P || avctx->pix_fmt == AV_PIX_FMT_YUVA420P16LE|| avctx->pix_fmt == AV_PIX_FMT_GBRP || avctx->pix_fmt == AV_PIX_FMT_GBRAP", "avctx->pix_fmt == AV_PIX_FMT_YUVJ444P || avctx->pix_fmt == AV_PIX_FMT_YUV444P || avctx->pix_fmt == AV_PIX_FMT_YUVJ422P || avctx->pix_fmt == AV_PIX_FMT_YUV422P || avctx->pix_fmt == AV_PIX_FMT_YUVJ420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P || avctx->pix_fmt == AV_PIX_FMT_YUV440P || avctx->pix_fmt == AV_PIX_FMT_YUVJ440P || avctx->pix_fmt == AV_PIX_FMT_YUVA444P || avctx->pix_fmt == AV_PIX_FMT_YUVA420P || avctx->pix_fmt == AV_PIX_FMT_YUVA420P16LE|| avctx->pix_fmt == AV_PIX_FMT_GBRP || avctx->pix_fmt == AV_PIX_FMT_GBRAP", "decode frame unused %td bytes\n", "JPEG does not support resolutions above 65500x65500\n", "avctx->codec->priv_data_size == sizeof(MpegEncContext)", "ME_MAP size is too small for SAB diamond\n", "me_method is only allowed to be set to zero and epzs; for hex,umh,full and others see dia_size\n", "ME_MAP size may be a little small for the selected diamond size\n", "s->quarter_sample==0 || s->quarter_sample==1", "s->pict_type==AV_PICTURE_TYPE_P", "range <= 16 || !s->msmpeg4_version", "range <=256 || !(s->codec_id == AV_CODEC_ID_MPEG2VIDEO && s->avctx->strict_std_compliance >= 0)", "static_size <= (sizeof(table) / sizeof((table)[0]))", "FFmpeg v%d.%d.%d / libavcodec build: %d", "low_delay flag set incorrectly, clearing it\n", "time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\n", "time_increment_bits set to %d bits, based on bitstream analysis\n", "sprite_brightness_change not supported\n", "Error, header damaged or not MPEG4 header (qscale=0)\n", "Error, header damaged or not MPEG4 header (f_code=0)\n", "Error, header damaged or not MPEG4 header (b_code=0)\n", "qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%lld tincr:%d\n", "load backward shape isn't supported\n", "looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n", "1. marker bit missing in rvlc esc\n", "2. marker bit missing in rvlc esc\n", "1. marker bit missing in 3. esc\n", "2. marker bit missing in 3. esc\n", "|level| overflow in 3. esc, qp=%d\n", "texture corrupted at %d %d %d\n", "illegal mb_num in video packet (%d %d) \n", "before time_increment in video packed header", "before vop_coding_type in video packed header", "Error, video packet header damaged (f_code=0)\n", "Error, video packet header damaged (b_code=0)\n", "marker missing after first I partition at %d %d\n", "marker missing after first P partition at %d %d\n", "bugs: %X lavc_build:%d xvid_build:%d divx_version:%d divx_build:%d %s\n", "after first_half_vbv_buffer_size", "after first_half_vbv_occupancy", "after latter_half_vbv_occupancy", "only rectangular vol supported\n", "before time_increment_resolution", "MPEG4 OBMC not supported (very likely buggy encoder)\n", "in complexity estimation part 1", "in complexity estimation part 2", "Invalid Complexity estimation method %d\n", "reduced resolution VOP not supported\n", "tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\n", "Video uses a non-standard and wasteful way to store B-frames ('packed B-frames'). Consider using the mpeg4_unpack_bframes bitstream filter without encoding but stream copy to fix it.\n", "Basic Animated Texture Profile", "Advanced Real Time Simple Profile", "Advanced Scalable Texture Profile", "dimensions too large for MPEG-4\n", "Flags common for all mpegvideo-based encoders.", "RD optimal MB level residual skipping", "Use rate distortion optimization for qp selection", "use rate distortion optimization for CBP", "normalize adaptive quantization", "single coefficient elimination threshold for luminance (negative values also consider dc coefficient)", "single coefficient elimination threshold for chrominance (negative values also consider dc coefficient)", "Simulate errors in the bitstream to test error concealment.", "how to keep quantizer between qmin and qmax (0 = clip, 1 = use differentiable function)", "experimental quantizer modulation", "Set rate control equation. When computing the expression, besides the standard functions defined in the section 'Expression Evaluation', the following functions are available: bits2qp(bits), qp2bits(qp). Also the following constants are available: iTex pTex tex mv fCode iCount mcVar var isI isP isB avgQP qComp avgIITex avgPITex avgPPTex avgBPTex avgTex.", "initial complexity for 1-pass encoding", "increase the quantizer for macroblocks close to borders", "Interlaced error concealment is not fully implemented\n", "libavcodec/mpegaudiodec_template.c", "offset == (sizeof(huff_vlc_tables) / sizeof((huff_vlc_tables)[0]))", "overread, skip %d enddists: %d %d\n", "incorrect frame size - multiple frames in buffer?\n", "Error while decoding MPEG audio frame.\n", "Image too small, temporary buffers cannot function\n", "alloc_frame_buffer() failed (hwaccel private data allocation)\n", "get_buffer() failed (stride changed)\n", "get_buffer() failed (uv stride mismatch)\n", "get_buffer() failed to allocate context scratch buffers.\n", "Internal error, picture buffer overflow\n", "failed to allocate context scratch buffers.\n", "decoding to AV_PIX_FMT_NONE is not supported.\n", "too many threads/slices (%d), reducing to %d\n", "!s->picture || s->picture != s1->picture", "Failed to allocate context scratch buffers.\n", "Context scratch buffers could not be allocated due to unknown size.\n", "allocating dummy last picture for B frame\n", "warning: first frame is no keyframe\n", "allocate dummy last picture for field based first keyframe\n", "s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr && s->last_picture_ptr->f->buf[0])", "Adding %d MVs info to frame %d\n", "ref->size >= offset + s->mb_stride * ((f->height+15)/16)", "warning, clipping %d dct coefficients to %d..%d\n", "Warning, QMAT_SHIFT is larger than %d, overflows possible\n", "Invalid pts (%lld) <= last (%lld)\n", "Warning: AVFrame.pts=? trying to guess (%lld)\n", "warning, too many b frames in a row\n", "s->pb.buf == avctx->internal->byte_buffer", "Internal error, negative bits\n", "only YUV420 and YUV422 are supported\n", "keyframe interval too large!, reducing it from %d to %d\n", "Too many B-frames requested, maximum is %d.\n", "intra dc precision must be positive, note some applications use 0 and some 8 as base meaning 8bit, the value must not be smaller than that\n", "Automatically choosing VBV buffer size of %d kbyte\n", "Either both buffer size and max rate or neither must be specified\n", "Warning min_rate > 0 but min_rate != max_rate isn't recommended!\n", "impossible bitrate constraints, this will fail\n", "VBV buffer too small for bitrate\n", "bitrate tolerance %d too small for bitrate %d, overriding\n", "Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n", "OBMC is only supported with simple mb decision\n", "b frames not supported by codec\n", "max b frames must be 0 or positive for mpegvideo based encoders\n", "Invalid pixel aspect ratio %i/%i, limit is 255/255 reducing\n", "H.263 does not support resolutions above 2048x1152\n", "MPEG-1 does not support resolutions above 4095x4095\n", "MPEG-2 does not support resolutions above 16383x16383\n", "width and height must be a multiple of 16\n", "width and height must be a multiple of 4\n", "interlacing not supported by codec\n", "mpeg2 style quantization not supported by codec\n", "closed gop with scene change detection are not supported yet, set threshold to 1000000000\n", "low delay forcing is only available for mpeg2\n", "b frames cannot be used with low delay\n", "non linear quant only supports qmax <= 28 currently\n", "multi threaded encoding not supported by codec\n", "automatic thread number detection not supported by codec, patch welcome\n", "notice: b_frame_strategy only affects the first pass\n", "removing common factors from framerate\n", "qmin and or qmax are invalid, they must be 0 < min <= max\n", "intra_quant_bias = %d inter_quant_bias = %d\n", "timebase %d/%d not supported by MPEG 4 standard, the maximum admitted value for the timebase denominator is %d\n", "The specified picture size of %dx%d is not valid for the H.263 codec.\nValid sizes are 128x96, 176x144, 352x288, 704x576, and 1408x1152. Try H.263+.\n", "colorspace not supported in jpeg\n", "8*buffer_size > s->size_in_bits", "encoded partitioned frame too large\n", "use overlapped block motion compensation.", "Write slice start position at every GOB header instead of just GOB number.", "emit macroblock info for RFC 2190 packetization, the parameter value is the maximum payload size", "MPEG motion vector out of boundary (%d %d)\n", "Tried to copy AVCodecContext %p into already-initialized %p\n", "dest->subtitle_header_size == src->subtitle_header_size", "Set video bitrate tolerance (in bits/s). In 1-pass mode, bitrate tolerance specifies how far ratecontrol is willing to deviate from the target average bitrate value. This is not related to minimum/maximum bitrate. Lowering tolerance too much has an adverse effect on quality.", "allow decoders to produce unaligned output", "use four motion vectors per macroblock (MPEG-4)", "use 1/4-pel motion compensation", "use internal 2-pass ratecontrol in first  pass mode", "use internal 2-pass ratecontrol in second pass mode", "error[?] variables will be set during encoding", "place global headers in extradata instead of every keyframe", "use only bitexact functions (except (I)DCT)", "H.263 advanced intra coding / MPEG-4 AC prediction", "Output even potentially corrupted frames", "allow non-spec-compliant speedup tricks", "ignore cropping information from sps", "place global headers at every keyframe instead of in extradata", "Frame data might be split into multiple chunks", "Show all frames before the first keyframe", "export motion vectors through frame side data", "do not skip samples and export skip information as frame side data", "zero motion estimation (fastest)", "full motion estimation (slowest)", "EPZS motion estimation (default)", "esa motion estimation (alias for full)", "diamond motion estimation (alias for EPZS)", "set the group of picture (GOP) size", "set audio sampling rate (in Hz)", "video quantizer scale compression (VBR). Constant of ratecontrol equation. Recommended range for default rc_eq: 0.0-1.0", "video quantizer scale blur (VBR)", "minimum video quantizer scale (VBR)", "maximum video quantizer scale (VBR)", "maximum difference between the quantizer scales (VBR)", "set maximum number of B frames between non-B-frames", "QP factor between P- and B-frames", "strategy to choose between I/P/B-frames", "work around not autodetected encoder bugs", "some old lavc-generated MSMPEG4v3 files (no autodetection)", "Xvid interlacing bug (autodetected if FOURCC == XVIX)", "(autodetected if FOURCC == UMP4)", "illegal VLC bug (autodetected per FOURCC)", "old standard qpel (autodetected per FOURCC/version)", "direct-qpel-blocksize bug (autodetected per FOURCC/version)", "edge padding bug (autodetected per FOURCC/version)", "work around various bugs in Microsoft's broken decoders", "how strictly to follow the standards", "strictly conform to a older more strict version of the spec or reference software", "strictly conform to all the things in the spec no matter what the consequences", "allow non-standardized experimental things", "QP offset between P- and B-frames", "detect bitstream specification deviations", "detect improper bitstream length", "abort decoding on minor error detection", "consider things that violate the spec, are fast to check and have not been seen in the wild as errors", "consider all spec non compliancies as errors", "consider things that a sane encoder should not do as an error", "use MPEG quantizers instead of H.263", "deprecated, use encoder private options instead", "maximum bitrate (in bits/s). Used for VBV together with bufsize.", "minimum bitrate (in bits/s). Most useful in setting up a CBR encode. It is of little use otherwise.", "set ratecontrol buffer size (in bits)", "QP factor between P- and I-frames", "QP offset between P- and I-frames", "compresses bright areas stronger than medium ones", "compresses dark areas stronger than medium ones", "deprecated, for compatibility only", "set error concealment strategy", "iterative motion vector (MV) search (slow)", "use strong deblock filter for damaged MBs", "favor predicting from the previous frame", "per-block quantization parameter (QP)", "memory management control operations (H.264)", "visualize quantization parameter (QP), lower QP are tinted greener", "visualize motion vectors (MVs) (deprecated)", "forward predicted MVs of P-frames", "forward predicted MVs of B-frames", "backward predicted MVs of B-frames", "interlaced DCT compare function", "diamond type & size for motion estimation", "amount of motion predictors from the previous frame", "pre motion estimation compare function", "sum of absolute differences, fast (default)", "sum of absolute Hadamard transformed differences", "sum of absolute DCT transformed differences", "sum of squared quantization errors (avoid, low quality)", "number of bits needed for the block", "sum of absolute vertical differences", "sum of squared vertical differences", "noise preserving sum of squared differences", "diamond type & size for motion estimation pre-pass", "sub-pel motion estimation quality", "limit motion vectors range (1023 for DivX player)", "variable length coder / Huffman coder", "macroblock decision algorithm (high quality mode)", "number of bits which should be loaded into the rc buffer before decoding starts", "autodetect a suitable number of threads to use", "number of macroblock rows at the top which are skipped", "number of macroblock rows at the bottom which are skipped", "decode at 1= 1/2, 2=1/4, 3=1/8 resolutions", "minimum macroblock Lagrange factor (VBR)", "maximum macroblock Lagrange factor (VBR)", "motion estimation bitrate penalty compensation (1.0 = 256)", "skip loop filtering process for the selected frames", "skip IDCT/dequantization for the selected frames", "skip decoding for the selected frames", "discard all non-reference frames", "discard all bidirectional frames", "discard all frames except keyframes", "discard all frames except I frames", "refine the two motion vectors used in bidirectional macroblocks", "downscale frames for dynamic B-frame decision", "minimum interval between IDR-frames", "reference frames to consider for motion compensation", "rate-distortion optimal quantization", "multiplied by qscale for each frame and added to scene_change_score", "adjust sensitivity of b_frame_strategy 1", "GOP timecode frame start number, in non-drop-frame format", "set desired number of audio channels", "color transfer characteristics", "number of slices, used in parallelized encoding", "sample format audio decoders should prefer", "set input text subtitles character encoding", "set input text subtitles character encoding mode", "set information dump field separator", "List of decoders that are allowed to be used", "Failed to reallocate parser buffer to %d\n", "Invalid PCM packet, data has size %d but at least a size of %d was expected\n", "Invalid PNG signature 0x%08llX.\n", "inflateInit returned error %d\n", "width=%d height=%d depth=%d color_type=%d compression_type=%d filter_type=%d interlace_type=%d\n", "unsupported bit depth %d and color type %d\n", "%d undecompressed bytes left in buffer\n", "Only one of 'dpi' or 'dpm' options should be set\n", "Input contains more than one unique palette. APNG does not support multiple palettes.\n", "Set image resolution (in dots per inch)", "Set image resolution (in dots per meter)", "Application has requested %d threads. Using a thread count greater than %d is not recommended.\n", "p->avctx->codec_type == AVMEDIA_TYPE_VIDEO || p->avctx->codec_type == AVMEDIA_TYPE_AUDIO", "thread awaiting %d field %d from %p\n", "Multiple ff_thread_finish_setup() calls\n", "A frame threaded decoder did not free the frame on failure. This is a bug, please report it.\n", "get_format() cannot be called after ff_thread_finish_setup()\n", "get_buffer() cannot be called after ff_thread_finish_setup()\n", "thread_release_buffer called on pic %p\n", "in:%d out:%d type:%d q:%d itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%lld var:%lld icount:%d skipcount:%d hbits:%d;\n", "max bitrate possibly too small or try trellis with large lmax or increase qmax\n", "picture_number < rcc->num_entries", " in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%lld var:%lld icount:%d skipcount:%d hbits:%d", "statistics are damaged at line %d, parser out=%d\n", "[lavc rc] requested bitrate: %lld bps  expected bitrate: %lld bps\n", "[lavc rc] estimated target average qp: %.3f\n", "[lavc rc] Using all of requested bitrate is not necessary for this video with these parameters.\n", "[lavc rc] Error: bitrate too low for this video with these parameters.\n", "[lavc rc] Error: 2pass curve failed to converge\n", "Xvid ratecontrol requires libavcodec compiled with Xvid support.\n", "Input is longer than 2-pass log file\n", "pict_type == rce->new_pict_type", "%c qp:%d<%2.1f<%d %d want:%d total:%d comp:%f st_q:%2.2f size:%d var:%lld/%lld br:%lld fps:%d\n", "Resampling with input channels greater than %d is unsupported.\n", "Unsupported audio resampling. Allowed output channels for %d input channel%s", "Can't allocate memory for resample context.\n", "Cannot convert %s sample format to s16 sample format\n", "Cannot convert s16 sample format to %s sample format\n", "Audio sample format conversion failed\n", "s->codec_type == AVMEDIA_TYPE_VIDEO", "Failed to set dimensions %d %d\n", "This decoder does not support parameter changes, but PARAM_CHANGE side data was sent to it.\n", "PARAM_CHANGE side data too small.\n", "pic->data[0]!=NULL in avcodec_default_get_buffer\n", "default_get_buffer called on pic %p\n", "default_get_buffer called on frame %p", "Inconsistent channel configuration.\n", "video_get_buffer: image parameters invalid\n", "avctx->codec_type == AVMEDIA_TYPE_VIDEO", "Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\n", "Invalid negative user packet size %d\n", "Invalid minimum required packet size %lld (max allowed is %d)\n", "!avpkt->data || avpkt->data != avctx->internal->byte_buffer", "User packet is too small (%d < %lld)\n", "Failed to allocate packet of size %lld\n", "Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\n", "more samples than frame size (avcodec_encode_audio2)\n", "nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\n", "Provided packet is too small, needs to be %d\n", "AVFrame.width or height is not set\n", "buffer smaller than minimum size\n", "start_display_time must be 0.\n", "Error applying parameter changes.\n", "!picture->extended_data || picture->extended_data == picture->data", "invalid packet: NULL data, size != 0\n", "skip %d / discard %d samples due to side data\n", "skip whole frame, skip left: %d\n", "Could not update timestamps for skipped samples.\n", "Could not update timestamps for discarded samples.\n", "Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\n", "Please port your application to avcodec_decode_audio4()\n", "output buffer size is too small for the current frame (%d < %d)\n", "Invalid media type for subtitles\n", "requesting subtitles recoding without iconv", "Invalid UTF-8 in decoded subtitles text; maybe missing -sub_charenc option\n", "Codec 0x%x is not in the full list.\n", "--arch=x86 --cpu=i686 --enable-yasm --enable-gpl --enable-encoder=libx264 --enable-libx264 --enable-gpl --disable-nonfree --enable-runtime-cpudetect --disable-gray --disable-swscale-alpha --disable-programs --disable-ffmpeg --disable-ffplay --disable-ffprobe --disable-ffserver --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-avdevice --enable-avcodec --enable-avformat --enable-avutil --enable-swresample --enable-swscale --enable-postproc --enable-avfilter --enable-avresample --enable-network --disable-dxva2 --disable-vaapi --disable-vda --disable-vdpau --disable-encoders --enable-encoder=libx264 --enable-encoder=aac --enable-encoder=mjpeg --enable-encoder=png --enable-encoder=mpeg4 --disable-decoders --enable-decoder=aac --enable-decoder=aac_latm --enable-decoder=flv --enable-decoder=h264 --enable-decoder=mp3 --enable-decoder=png --enable-decoder=pcm_s16le --enable-decoder=mpeg4 --enable-decoder=mjpeg --disable-hwaccels --disable-muxers --enable-muxer=mpegts --enable-muxer=mp4 --enable-muxer=flv --enable-muxer=wav --enable-muxer=ipod --enable-muxer=mov --enable-muxer=h264 --enable-muxer=image2 --enable-muxer=mjpeg --enable-muxer=mp3 --disable-demuxers --enable-demuxer=aac --enable-demuxer=concat --enable-demuxer=flv --enable-demuxer=hls --enable-demuxer=latm --enable-demuxer=live_flv --enable-demuxer=m4v --enable-demuxer=mov --enable-demuxer=mp3 --enable-demuxer=mpegts --enable-demuxer=mpegvideo --enable-demuxer=image2 --enable-demuxer=h264 --enable-demuxer=wav --enable-demuxer=mjpeg --disable-parsers --enable-parser=aac --enable-parser=aac_latm --enable-parser=h264 --enable-parser=mpegvideo --enable-parser=mpeg4video --disable-bsfs --enable-bsf=aac_adtstoasc --enable-bsf=h264_mp4toannexb --disable-protocols --enable-protocol=http --enable-protocol=https --enable-protocol=hls --enable-protocol=rtmp --enable-protocol=file --enable-protocol=concat --disable-devices --enable-filters --disable-iconv --prefix=/Users/shilingkai/Desktop/Musically_Projects/live-sdk/MediaPlayer/ThirdParty/ijk/ijkplayer_musically/android/contrib/build/ffmpeg-x86/output --cross-prefix=i686-linux-android- --enable-cross-compile --target-os=linux --enable-pic --enable-asm --enable-inline-asm --extra-cflags='-O3 -Wall -pipe -std=c99 -ffast-math -fstrict-aliasing -Werror=strict-aliasing -Wno-psabi -Wa,--noexecstack -DANDROID -DNDEBUG -I/Users/shilingkai/Desktop/Musically_Projects/live-sdk/MediaPlayer/ThirdParty/ijk/ijkplayer_musically/android/contrib/x264-x86/include -march=atom -msse3 -ffast-math -mfpmath=sse' --extra-ldflags='-L/Users/shilingkai/Desktop/Musically_Projects/live-sdk/MediaPlayer/ThirdParty/ijk/ijkplayer_musically/android/contrib/x264-x86/lib -lx264 '", "libavcodec license: GPL version 2 or later", "avcodec_encode_audio() does not support this codec\n", "If you want to help, upload a sample of this file to ftp://upload.ffmpeg.org/incoming/ and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\n", "%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\n", "Ignoring experimental hwaccel: %s\n", "Could not find an AVHWAccel for the pixel format: %s", "Insufficient thread locking. At least %d threads are calling avcodec_open2() at the same time right now.\n", "No lock manager is set, please see av_lockmgr_register()\n", "No codec provided to avcodec_open2()\n", "This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\n", "Ignoring invalid width/height values\n", "The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\n", "Alternatively use the non experimental %s '%s'.\n", "The maximum value for lowres supported by the decoder is %d\n", "The 'vismv' option is deprecated, see the codecview filter instead.\n", "Specified sample format %s is invalid or not supported\n", "Specified pixel format %s is invalid or not supported\n", "Specified sample rate %d is not supported\n", "Channel layout '%s' with %d channels does not match number of specified channels %d\n", "Specified number of channels %d is not supported\n", "Bitrate %d is extremely low, maybe you mean %dk\n", "gray decoding requested but not enabled at configuration time\n", "Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\n", "Character encoding is only supported with subtitles codecs\n", "Codec '%s' is bitmap-based, subtitles character encoding will be ignored\n", "Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\n", "*(const AVClass **)avctx->priv_data == codec->priv_class", "Specified channel layout '%s' is not supported\n", "Wrong packet type in Id header\n", "Invalid packet signature in Id header\n", "Invalid framing bit in Id header\n", "Wrong packet type in Setup header\n", "Invalid packet signature in Setup header\n", "%d modes (either a false positive or a sample from an unknown encoder)", "Channels expressions list is empty\n", "Mismatch between the specified number of channel expressions '%d' and the number of expected output channels '%d' for the specified channel layout\n", "Invalid number of channels '%d' provided\n", "sample_rate:%d chlayout:%s duration:%lld\n", "Filter audio signal according to a specified expression.", "set the '|'-separated list of channels expressions", "Generate an audio signal generated by an expression.", "set the number of samples per requested frame", "Delay must be non negative number.\n", "At least one delay >0 must be specified.\n", "Delay one or more audio channels.", "set list of delays for each channel", "Missing delays and/or decays.\n", "Number of delays %d differs from number of decays %d.\n", "At least one decay & delay must be set.\n", "delay[%d]: %f is out of allowed range: (0, 90000]\n", "decay[%d]: %f is out of allowed range: (0, 1]\n", "Nothing to echo - missing delay samples.\n", "out_gain %f can cause saturation of output\n", "Inputs must have the same sample rate %d for in0 vs %d for in1\n", "Cross fade two input audio streams.", "set number of samples for cross fade duration", "overlap 1st stream end with 2nd stream start", "set fade curve type for 1st stream", "set fade curve type for 2nd stream", "set number of first sample to start fading", "set number of samples for fade duration", "This syntax is deprecated, use '|' to separate %s.\n", "Error parsing sample format: %s.\n", "Error parsing sample rate: %s.\n", "Error parsing channel layout: %s.\n", "Convert the input audio to one of the specified formats.", "A comma-separated list of sample formats.", "A comma-separated list of sample rates.", "A comma-separated list of channel layouts.", "No channel layout for input %d\n", "Input channel layouts overlap: output layout will be determined by the number of distinct input channels\n", "Inputs must have the same sample rate %d for in%d vs %d\n", "Buffer queue overflow, dropping.\n", "Merge two or more audio streams into a single multi-channel stream.", "inputs:%d fmt:%s srate:%d cl:%s\n", "How to determine the end-of-stream.", "Transition time, in seconds, for volume renormalization when an input stream ends.", "Pass the source unchanged to the output.", "padding n_out:%d pad_len_left:%lld\n", "outsamplesref->sample_rate == outlink->sample_rate", "outsamplesref->nb_samples == n_out", "Both whole and pad length are set, this is not possible\n", "set number of samples of silence to add", "set minimum target number of samples in the audio stream", "Add a phasing effect to the audio.", "Cannot allocate output samplerates.\n", "outlink->sample_rate == out_rate", "outlink->channel_layout == out_layout || !outlink->channel_layout", "ch:%d chl:%s fmt:%s r:%dHz -> ch:%d chl:%s fmt:%s r:%dHz\n", "No space for %d samples, stretching audio fifo\n", "Stretching audio fifo failed, discarded %d samples\n", "Set the number of samples for each output audio frames.", "set the number of per-frame output samples", "Change the sample rate without altering the data.", "n:%lld pts:%s pts_time:%s pos:%lld fmt:%s channels:%d chlayout:%s rate:%d nb_samples:%d checksum:%08X ", " Mix levels: center %f (%f ltrt) - surround %f (%f ltrt) - lfe %f", "unknown side data type: %d, size %d bytes", "Show textual information for each audio frame.", "Show time domain statistics about audio frames.", "inject metadata in the filtergraph", "recalculate stats after this many frames", "Copy two streams of audio data in a configurable order.", "set stream selection expression", "Trimming %d samples from start\n", "Discontinuity - %lld samples.\n", "Compensating %d samples per second.\n", "Non-monotonous timestamps, dropping whole buffer.\n", "Stretch/squeeze the data to make it match the timestamps", "Minimum difference between timestamps and audio data (in seconds) to trigger padding/trimmin the data.", "Maximum compensation in samples per second.", "Assume the first pts should be this value.", "Tempo value %f exceeds [0.5, 2.0] range\n", "start_here <= stop_here && frag->position[1] <= start_here && overlap <= frag->nsamples", "atempo->position[0] <= stop_here", "start_here <= stop_here && frag->position[1] <= start_here", "Invalid frequency %f and/or width %f <= 0\n", "Invalid frequency %f. Frequency must be less than half the sample-rate %d.\n", "Apply a biquad IIR filter with the given coefficients.", "Apply a two-pole all-pass filter.", "Apply a high-pass filter with 3dB point frequency.", "Apply a low-pass filter with 3dB point frequency.", "Apply a two-pole Butterworth band-reject filter.", "Apply a two-pole Butterworth band-pass filter.", "Boost or cut upper frequencies.", "Boost or cut lower frequencies.", "Apply two-pole peaking equalization (EQ) filter.", "input channel '%s' not available from input layout '%s'\n", "input channel #%d not available from input layout '%s'\n", "This syntax is deprecated, use '|' to separate the mappings.\n", "Too many channels mapped: '%d'.\n", "Error parsing channel layout: '%s'.\n", "Output channel layout '%s' does not match the list of channel mapped: '%s'.\n", "Output channel layout %s does not match the number of channels mapped %d.\n", "Output channel layout is not set and cannot be guessed from the maps.\n", "A comma-separated list of input channel numbers in output order.", "Error parsing channel layout '%s'.\n", "Split audio into per-channel streams.", "Both delays & decays & speeds & depths must be set.\n", "Number of delays & decays & speeds & depths given must be same.\n", "At least one delay & decay & speed & depth must be set.\n", "output gain can cause saturation or clipping of output\n", "Add a chorus effect to the audio.", "Invalid number of channels: %d\n", "Number of attacks/decays bigger than number of channels.\n", "Number of attacks %d differs from number of decays %d.\n", "Invalid and/or missing input/output value.\n", "Transfer function input values must be increasing.\n", "Compress or expand audio dynamic range.", "set time over which increase of volume is determined", "set time over which decrease of volume is determined", "set points of transfer function", "set delay for samples before sending them to volume adjuster", "Apply a DC shift to the audio.", "filter size %d is invalid. Must be an odd value.\n", "cqueue_size(s->gain_history_original[channel]) == s->filter_size", "cqueue_size(s->gain_history_minimum[channel]) == s->filter_size", "enable alternative boundary mode", "Apply a flanging effect to the audio.", "added swept delay in milliseconds", "percentage regeneration (delayed signal feedback)", "percentage of delayed signal mixed with original", "swept wave percentage phase-shift for multi-channel", "Missing separator '-' in channel map '%s'\n", "Channel map describes more than one output channel.\n", "Output channel '%s' is not present in requested channel layout.\n", "Multiple maps for output channel '%s'.\n", "Invalid input stream index: %d.\n", "Channel map describes more than one input channel.\n", "Requested channel %s is not present in input stream #%d.\n", "Could not find input channel for output channel '%s'.\n", "No channels are used from input stream %d.\n", "Join multiple audio streams into multi-channel output.", "Channel layout of the output stream.", "A comma-separated list of channels maps in the format 'input_stream.input_channel-output_channel.", "pan filter needs a channel layout and a set of channels definitions as parameter\n", "Expected out channel name, got \"%.8s\"\n", "Channel \"%.8s\" does not exist in the chosen layout\n", "Invalid out channel name \"%.8s\"\n", "Syntax error after channel name in \"%.8s\"\n", "Expected in channel name, got \"%.8s\"\n", "Can not mix named and numbered channels\n", "af_pan support a maximum of %d channels. Feel free to ask for a higher limit.\n", "Degenerate coefficients while renormalizing\n", "Pure channel mapping detected:", "Remix channels with coefficients (panning).", "i < (sizeof(freqinfos) / sizeof((freqinfos)[0]))", "fmt:%s srate:%d cl:%s -> fmt:%s srate:%d cl:%s\n", "First timestamp is missing, assuming 0.\n", "Audio resampling and conversion.", "No channel layout for input 1\n", "libavfilter/af_sidechaincompress.c", "silence_end: %s | silence_duration: %s\n", "set minimum duration in seconds", "n:%f t:%f pts:%f precision:%s ", "Error when evaluating the volume expression '%s'\n", "tb:%f sample_rate:%f nb_channels:%f\n", "Both ReplayGain gain values are unknown.\n", "Using gain %f dB from replaygain side data.\n", "set volume adjustment expression", "specify when to evaluate expressions", "eval volume expression per-frame", "Apply replaygain side data when present", "replaygain side data is dropped", "replaygain side data is ignored", "Apply replaygain pre-amplification", "Apply replaygain clipping prevention", "Do absolutely nothing with the input audio.", "sample_rate:%d channel_layout:'%s' nb_samples:%d\n", "Null audio source, return empty audio frames.", "Generate sine wave audio signal.", "set the number of samples per frame", "channels == av_get_channel_layout_nb_channels(link->channel_layout) || !av_get_channel_layout_nb_channels(link->channel_layout)", "channel_layout == 0 || channels == av_get_channel_layout_nb_channels(channel_layout)", "Layout indicates a different number of channels than actually present\n", "Convert input audio to phase meter video output.", "Convert input audio to vectorscope video output.", "Input link %s parameters (size %dx%d, SAR %d:%d) do not match the corresponding output link %s parameters (%dx%d, SAR %d:%d)\n", "EOF on %s, %d streams left in segment.\n", "Concatenate audio and video streams.", "specify the number of segments", "specify the number of video streams", "specify the number of audio streams", "Rate (%u) is not divisible by fps*count (%u*%u)\n", "Freetype is not available, ignoring fontfile option\n", "Calculating spectral kernel, please wait\n", "at freq %g: tlength is %g, setting it to %g\n", "at freq %g: volume is %g, setting it to %g\n", "Elapsed time %.6f s (fft_len=%u, num_coeffs=%u)\n", "Convert input audio to a CQT (Constant Q Transform) spectrum video output.", "set number of transform per frame", "st(0, (midi(f)-59.5)/12);st(1, if(between(ld(0),0,1), 0.5-0.5*cos(2*PI*ld(0)), 0));r(1-ld(1)) + b(ld(1))", "Unable to create FFT context. The window size might be too high.\n", "Convert input audio to a frequencies video output.", "red|green|blue|yellow|orange|lime|pink|magenta|brown", "Unable to create RDFT context. The window size might be too high.\n", "libavfilter/avf_showspectrum.c", "insamples->nb_samples <= win_size", "insamples->nb_samples == win_size", "Convert input audio to a spectrum video output.", "separate color for each channel", "Convert input audio volume to video output.", "if(gte(VOLUME,-2), if(gte(VOLUME,-1),0xff0000ff, 0xff00ffff),0xff00ff00)", "Could not allocate showwaves buffer\n", "Create frame averaging %lld samples per column\n", "Convert input audio to a video output single picture.", "Convert input audio to a video output.", "draw a centered line for each sample", "set how many samples to show in the same point", "Timeline ('enable' option) not supported with filter '%s'\n", "Error when evaluating the expression '%s' for enable\n", "libavfilter license: GPL version 2 or later", "Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\n", "auto-inserting filter '%s' between the filter '%s' and the filter '%s'\n", "Not all input and output are properly linked (%d).\n", "circular filter chain detected\n", "Source filters and filters with more than one input must set config_props() callbacks on all outputs\n", "Failed to configure output pad on %s\n", "Video source filters must set their output link's width and height\n", "Failed to configure input pad on %s\n", "Processing command time:%f command:%s arg:%s\n", "!link->frame_requested || link->flags & FF_LINK_FLAG_REQUEST_LOOP", "(filter->flags & ((1 << 16) | (1 << 17))) != ((1 << 16) | (1 << 17))", "!input->filter_frame || (!input->start_frame && !input->end_frame)", "Error applying generic filter options.\n", "Error applying options to the filter.\n", "This filter does not take any options, but options were provided: %s.\n", "This syntax is deprecated. Use '|' to separate the list items.\n", "compat: called with args=[%s]\n", "Samples dropped due to memory allocation failure.\n", "Query format failed for '%s': %s\n", "All layouts set on non-empty list\n", "All counts without all layouts\n", "Cannot select sample rate for the link between filters %s and %s.\n", "Cannot select channel layout for the link between filters %s and %s.\n", "Unknown channel layouts not supported, try specifying a channel layout using 'aformat=channel_layouts=something'.\n", "Error initializing threading.\n", "'scale' filter not present, cannot convert pixel formats.\n", "'aresample' filter not present, cannot convert audio formats.\n", "inlink-> in_formats->refcount > 0", "inlink->out_formats->refcount > 0", "outlink-> in_formats->refcount > 0", "outlink->out_formats->refcount > 0", "inlink-> in_samplerates->refcount > 0", "inlink->out_samplerates->refcount > 0", "outlink-> in_samplerates->refcount > 0", "outlink->out_samplerates->refcount > 0", "inlink-> in_channel_layouts->refcount > 0", "inlink->out_channel_layouts->refcount > 0", "outlink-> in_channel_layouts->refcount > 0", "outlink->out_channel_layouts->refcount > 0", "Impossible to convert between the formats supported by the filter '%s' and the filter '%s'\n", "query_formats: %d queried, %d merged, %d already done, %d delayed\n", "The following filters could not choose their formats: %s\nConsider inserting the (a)format filter near their input or output.\n", "Input pad \"%s\" with type %s of the filter instance \"%s\" of %s not connected to any source\n", "Output pad \"%s\" with type %s of the filter instance \"%s\" of %s not connected to any destination\n", "picking %s out of %d ref:%s alpha:%d\n", "default aresample filter options", "Invalid size for pixel_fmts: %d, should be multiple of %d\n", "Cannot buffer more frames. Consume some available frames before adding new ones.\n", "%d buffers queued in %s, something may be wrong.\n", "Invalid size for sample_fmts: %d, should be multiple of %d\n", "Invalid size for sample_rates: %d, should be multiple of %d\n", "Invalid size for channel_layouts: %d, should be multiple of %d\n", "Invalid size for channel_counts: %d, should be multiple of %d\n", "Conflicting all_channel_counts and list in options\n", "!strcmp(ctx->filter->name, \"buffersink\") || !strcmp(ctx->filter->name, \"abuffersink\") || !strcmp(ctx->filter->name, \"ffbuffersink\") || !strcmp(ctx->filter->name, \"ffabuffersink\")", "!strcmp(ctx->filter->name, \"buffersink\") || !strcmp(ctx->filter->name, \"ffbuffersink\")", "Buffer audio frames, and make them available to the end of the filter graph.", "Buffer video frames, and make them available to the end of the filter graph.", "set the supported sample formats", "set the supported sample rates", "set the supported channel layouts", "set the supported channel counts", "set the supported pixel formats", "Changing frame properties on the fly is not supported by all filters.\n", "Changing frame properties on the fly is not supported.\n", "w:%d h:%d pixfmt:%s tb:%d/%d fr:%d/%d sar:%d/%d sws_param:%s\n", "Sample format was not set or was invalid\n", "Mismatching channel count %d and layout '%s' (%d channels)\n", "Neither number of channels nor channel layout specified\n", "tb:%d/%d samplefmt:%s samplerate:%d chlayout:%s\n", "Buffer audio frames, and make them accessible to the filterchain.", "Buffer video frames, and make them accessible to the filterchain.", "Color conversion not implemented for %s\n", "max is same or lower than min\n", "Draw a graph using input audio metadata.", "Draw a graph using input video metadata.", "set 1st foreground color expression", "set 2nd foreground color expression", "set 3rd foreground color expression", "set 4th foreground color expression", "Summary:\n\n  Integrated loudness:\n    I:         %5.1f LUFS\n    Threshold: %5.1f LUFS\n\n  Loudness range:\n    LRA:       %5.1f LU\n    Threshold: %5.1f LUFS\n    LRA low:   %5.1f LUFS\n    LRA high:  %5.1f LUFS", "\n\n  Sample peak:\n    Peak:      %5.1f dBFS", "\n\n  True peak:\n    Peak:      %5.1f dBFS", "Video size %dx%d is too small, minimum size is 640x480\n", "M:%6.1f S:%6.1f     I:%6.1f LUFS     LRA:%6.1f LU     ", "t: %-10s M:%6.1f S:%6.1f     I:%6.1f LUFS     LRA:%6.1f LU", "Parameters for input link %s (size %dx%d, SAR %d:%d) do not match the corresponding output link parameters (%dx%d, SAR %d:%d)\n", "NOPTS value for input frame cannot be accepted, frame discarded\n", "frame pts:%f -> queue idx:%d available:%d\n", "Temporally interleave audio inputs.", "Temporally interleave video inputs.", "Set permissions for the output video frame.", "Set permissions for the output audio frame.", "set all output frames read-only", "set all output frames writable", "set the seed for the random mode", "Error while parsing expression '%s'\n", "Scene detection is ignored in aselect filter\n", " interlace_type:%c pict_type:%c scene:%f", " samples_n:%d consumed_samples_n:%f", "Select video frames to pass in output.", "set an expression to use for selecting frames", "Select audio frames to pass in output.", "One and only one of the filename or commands options must be specified\n", "Invalid start time specification '%s' in interval #%d\n", "Invalid end time specification '%s' in interval #%d\n", "Invalid end time '%s' in interval #%d: cannot be lesser than start time '%s'\n", "Unknown flag '%s' in interval #%d, command #%d\n", "Invalid flags char '%c' in interval #%d, command #%d\n", "Missing flag terminator or extraneous data found at the end of flags in interval #%d, command #%d\n", "No target specified in interval #%d, command #%d\n", "No command specified in interval #%d, command #%d\n", "Could not (re)allocate command array\n", "Missing separator or extraneous data found at the end of interval #%d, in command #%d\n", "Command was parsed as: flags:[%s] target:%s command:%s arg:%s\n", "No interval specified for interval #%d\n", "Missing terminator or extraneous data found at the end of interval #%d\n", "Could not (re)allocate intervals array\n", "start_time:%f end_time:%f index:%d\n", "    [%s] target:%s command:%s arg:%s index:%d\n", "[%s] interval #%d start_ts:%f end_ts:%f ts:%f\n", "Processing command #%d target:%s command:%s arg:%s\n", "Command reply for command #%d: ret:%s res:%s\n", "request_samples changed before the buffer was returned.\n", "Buffer input frames and send them when they are requested.", "Buffer input images and send them when they are requested.", "Duplicate formats in avfilter_merge_formats() detected\n", "libavfilter/generate_wave_table.c", "Error initializing filter '%s'", "Cannot create the link %s:%d -> %s:%d\n", "Too many inputs specified for the \"%s\" filter.\n", "Bad (empty?) label found in the following: \"%s\".\n", "Mismatched '[' found in the following: \"%s\".\n", "No output pad can be associated to link label '%s'.\n", "sws_flags not terminated with ';'.\n", "Unable to parse graph description substring: \"%s\"\n", "Not enough inputs specified for the \"%s\" filter.\n", "Invalid filterchain containing an unlabelled output pad: \"%s\"\n", "Failed to open input file '%s'\n", "Failed to read frame from file\n", "Failed to decode image from file\n", "Error loading image file '%s'\n", "Impossible to create scale context for the conversion fmt:%s s:%dx%d -> fmt:%s s:%dx%d\n", "TB:%f FRAME_RATE:%f SAMPLE_RATE:%f\n", " NB_SAMPLES:%lld NB_CONSUMED_SAMPLES:%lld", "Set PTS for the output audio frame.", "Set PTS for the output video frame.", "Expression determining the frame timestamp", "Invalid expression '%s' for timebase.\n", "Invalid non-positive values for the timebase num:%d or den:%d.\n", "tb:%d/%d pts:%lld -> tb:%d/%d pts:%lld\n", "Set timebase for the audio output link.", "set expression determining the output timebase", "Set timebase for the video output link.", "Pass on the audio input to N audio outputs.", "Pass on the input to N video outputs.", "Format changed %s -> %s, discarding frame\n", "matched only already used streams", "Loop with several streams is currently unsupported\n", "Failed to avformat_open_input '%s'\n", "%s: seek value overflow with start_time:%lld seek_point:%lld\n", "%s: could not seek to position %lld\n", "No %s stream with index '%d' found\n", "Invalid stream specifier \"%s\"\n", "Ambiguous stream specifier \"%s\", using #%d\n", "Stream specifier \"%s\" matched a %s stream,currently unsupported by libavfilter\n", "Channel layout is not set in stream %d, and could not be guessed from the number of channels (%d)\n", "Channel layout is not set in output stream %d, guessed channel layout is '%s'\n", "seek_point:%lli format_name:%s file_name:%s stream_index:%d\n", "Read audio from a movie source.", "start_sample < end_sample || (start_sample == end_sample && !frame->nb_samples)", "Pick one continuous section from the input, drop the rest.", "Timestamp of the first frame that should be passed", "Timestamp of the first frame that should be dropped again", "Timestamp of the first frame that should be  passed", "Maximum duration of the output", "Number of the first audio sample that should be passed to the output", "Number of the first audio sample that should be dropped again", "Timestamp in seconds of the first frame that should be passed", "Timestamp in seconds of the first frame that should be dropped again", "Maximum duration of the output in seconds", "Number of the first frame that should be passed to the output", "Number of the first frame that should be dropped again", "Input frame sizes do not match (%dx%d vs %dx%d).\n", "Copy the luma value of the second input into the alpha channel of the first input.", "num:den syntax is deprecated, please use num/den or named options instead\n", "Unable to parse ratio numerator \"%s\"\n", "Error when evaluating the expression '%s'\n", "Invalid string '%s' for aspect ratio\n", "w:%d h:%d dar:%d/%d sar:%d/%d -> dar:%d/%d sar:%d/%d\n", "w:%d h:%d sar:%d/%d dar:%d/%d -> sar:%d/%d dar:%d/%d\n", "Set the pixel sample aspect ratio.", "set sample (pixel) aspect ratio", "set max value for nominator or denominator in the ratio", "Set the frame display aspect ratio.", "size %d is invalid. Must be an odd value.\n", "Apply an Adaptive Temporal Averaging Denoiser.", " x1:%d x2:%d y1:%d y2:%d w:%d h:%d crop=%d:%d:%d:%d drawbox=%d:%d:%d:%d", "Compute bounding box for each frame.", "set minimum luminance value for bounding box", "black_min_duration:%s pixel_black_th:%f pixel_black_th_i:%d picture_black_ratio_th:%f\n", "black_start:%s black_end:%s black_duration:%s\n", "frame:%lld picture_black_ratio:%f pts:%s t:%s type:%c\n", "Detect video intervals that are (almost) black.", "set minimum detected black duration in seconds", "set the picture black ratio threshold", "frame:%u pblack:%u pts:%lld t:%f type:%c last_keyframe:%d\n", "Detect frames that are (almost) black.", "Percentage of the pixels that have to be below the threshold for the frame to be considered black.", "threshold below which a pixel value is considered black", "inputs must be of same pixel format\n", "First input link %s parameters (size %dx%d, SAR %d:%d) do not match the corresponding second input link %s parameters (%dx%d, SAR %d:%d)\n", "set blend mode for all components", "set color component #0 expression", "set color component #1 expression", "set color component #2 expression", "set color component #3 expression", "set expression for all color components", "set color component #0 opacity", "set color component #1 opacity", "set color component #2 opacity", "set color component #3 opacity", "set opacity for all color components", "Blend two video frames into each other.", "force termination when the shortest input terminates", "Error when evaluating luma radius expression '%s'\n", "Error when evaluating chroma radius expression '%s'\n", "Error when evaluating alpha radius expression '%s'\n", "luma_radius:%d luma_power:%d chroma_radius:%d chroma_power:%d alpha_radius:%d alpha_power:%d w:%d chroma_w:%d h:%d chroma_h:%d\n", "Invalid luma radius value %d, must be >= 0 and <= %d\n", "Invalid chroma radius value %d, must be >= 0 and <= %d\n", "Invalid alpha radius value %d, must be >= 0 and <= %d\n", "Luma radius expression is not set.\n", "Radius of the luma blurring box", "How many times should the boxblur be applied to luma", "Radius of the chroma blurring box", "How many times should the boxblur be applied to chroma", "Radius of the alpha blurring box", "How many times should the boxblur be applied to alpha", "Visualize information about some codecs", "set motion vectors to visualize", "Adjust colors by mixing color channels.", "set the red gain for the red channel", "set the green gain for the red channel", "set the blue gain for the red channel", "set the alpha gain for the red channel", "set the red gain for the green channel", "set the green gain for the green channel", "set the blue gain for the green channel", "set the alpha gain for the green channel", "set the red gain for the blue channel", "set the green gain for the blue channel", "set the blue gain for the blue channel", "set the alpha gain for the blue channel", "set the red gain for the alpha channel", "set the green gain for the alpha channel", "set the blue gain for the alpha channel", "set the alpha gain for the alpha channel", "set the colorkey similarity value", "set the colorkey key blend value", "error calculating conversion coefficients\n", "Input frame does not specify a supported colorspace, and none has been specified as source either\n", "Unspecified destination color space\n", "Source and destination color space must not be identical\n", "Copy the input video unchanged to the output.", "cover image is not a YUV420 image\n", "Find and cover a user specified object", "n:%d t:%f pos:%f x:%d y:%d x+w:%d y+h:%d\n", "Too big value or invalid expression for out_w/ow or out_h/oh. Maybe the expression for out_w:'%s' or for out_h:'%s' is self-referencing.\n", "w:%d h:%d sar:%d/%d -> w:%d h:%d sar:%d/%d\n", "Invalid too big or non positive size for width '%d' or height '%d'\n", "set the width crop area expression", "set the height crop area expression", "set the x crop area expression", "set the y crop area expression", "limit:%f round:%d reset_count:%d\n", "x1:%d x2:%d y1:%d y2:%d w:%d h:%d x:%d y:%d pts:%lld t:%f crop=%d:%d:%d:%d\n", "Threshold below which the pixel is considered black", "Value by which the width/height should be divisible", "Recalculate the crop area after this many frames", "curves %d (intid=%d) [%d points]: [%s]\n", "Invalid key point coordinates (%f;%f), x and y must be in the [0;1] range.\n", "Key point coordinates (%f;%f) and (%f;%f) are too close from each other or not strictly increasing on the x-axis\n", "x_start >= 0 && x_start <= 255 && x_end >= 0 && x_end <= 255", "0/1 0.129/1 0.466/0.498 0.725/0 1/0", "0/1 0.109/1 0.301/0.498 0.517/0 1/0", "0/1 0.098/1 0.235/0.498 0.423/0 1/0", "0.25/0.156 0.501/0.501 0.686/0.745", "0.25/0.188 0.38/0.501 0.745/0.815 1/0.815", "0.149/0.066 0.831/0.905 0.905/0.98", "0.301/0.196 0.592/0.6 0.686/0.737", "set points coordinates for all components", "set Photoshop curves file name", "Overlap value can not except %d with a block size of %dx%d\n", "The last %d horizontal pixels won't be denoised\n", "The last %d vertical pixels won't be denoised\n", "threads: [max=%d hmax=%d user=%d] => %d\n", "set number of block overlapping pixels", "set coefficient factor expression", "set the block size, expressed in bits", "  #%d: totdiff=%08llx maxbdiff=%08llx%s%s%s%s\n", "blockx and blocky settings must be power of two\n", "The input needs a constant frame rate; current rate of %d/%d is invalid\n", "Decimate frames (post field matching filter).", "set the number of frame from which one will be dropped", "set the size of the x-axis blocks used during metric calculations", "set the size of the y-axis blocks used during metric calculations", "mark main input as a pre-processed input and activate clean source input stream", "set whether or not chroma is considered in the metric calculations", "Remove judder produced by pullup.", "set the length of the cycle to use for dejuddering", "x:%d y:%d, w:%d h:%d band:%d show:%d\n", "Ori x, Avg x, Fin x, Ori y, Avg y, Fin y, Ori angle, Avg angle, Fin angle, Ori zoom, Avg zoom, Fin zoom\n", "OpenCL support was not enabled in this build, cannot be selected\n", "cx: %d, cy: %d, cw: %d, ch: %d, rx: %d, ry: %d, edge: %d blocksize: %d contrast: %d search: %d\n", "%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f\n", "set x for the rectangular search area", "set y for the rectangular search area", "set width for the rectangular search area", "set height for the rectangular search area", "fill zeroes at blank locations", "original image at blank locations", "extruded edge value at blank locations", "mirrored edge at blank locations", "set contrast threshold for blocks", "set motion search detailed log file name", "use OpenCL filtering capabilities", "Provided pattern includes non-numeric characters.\n", "Detelecine pattern %s removes up to %d frames per frame, pts advance factor: %d/%d\n", "Apply an inverse telecine pattern.", "pattern that describe for how many fields a frame is to be displayed", "position of first frame with respect to the pattern if stream is cut", "Size values less than 0 are not acceptable.\n", "x:%d y:%d w:%d h:%d color:0x%02X%02X%02X%02X\n", "Error when evaluating the expression '%s'.\n", "Draw a colored grid on the input video.", "Draw a colored box on the input video.", "set horizontal position of the left box edge", "set vertical position of the top box edge", "pal8 output allows max 256 codebook length.\n", "Apply posterize effect, using the ELBG algorithm.", "set max number of steps used to compute the mapping", "Error when parsing the expression '%s' for %s\n", "Adjust brightness, contrast, gamma, and saturation.", "set the contrast adjustment, negative values give a negative image", "set the gamma weight which reduces the effect of gamma on bright areas", "eval expressions once during initialization", "Requested planes not available.\n", "Extract an alpha channel as a grayscale image component.", "Extract planes as grayscale frames.", "type:%s start_frame:%d nb_frames:%d alpha:%d\n", "type:%s start_time:%f duration:%f alpha:%d\n", "'in' or 'out' for fade-in/fade-out", "Number of the first frame to which to apply the effect.", "Number of frames to which the effect should be applied.", "fade alpha if it is available on the input", "Number of seconds of the beginning of the effect.", "Duration of the effect in seconds.", "Apply arbitrary expressions to samples in frequency domain", "set luminance expression in Y plane", "set chrominance expression in U plane", "set chrominance expression in V plane", "w:%d h:%d type:%s -> w:%d h:%d\n", "Extract a field from the input video.", "set field type (top or bottom)", "Combed pixel should not be larger than blockx x blocky\n", "fm->prv2 && fm->src2 && fm->nxt2", "order == 0 || order == 1 || field == 0 || field == 1", "Frame #%lld at %s is still interlaced\n", "SC:%d | COMBS: %3d %3d %3d %3d %3d (combpel=%d) match=%d combed=%s\n", "Field matching for inverse telecine.", "specify the assumed field order", "set the matching mode or strategy to use", "2-way match + 3rd match on combed (p/c + u)", "2-way match + 3rd match (same order) on combed (p/c + u)", "2-way match + 3rd match on combed + 4th/5th matches if still combed (p/c + u + u/b)", "3-way match + 4th/5th matches on combed (p/c/n + u/b)", "automatic (same value as 'order')", "set whether or not chroma is included during the match comparisons", "define an exclusion band which excludes the lines between y0 and y1 from the field matching decision", "set scene change detection threshold", "enable combmatching only on scene change", "enable combmatching all the time", "set the area combing threshold used for combed frame detection", "set whether or not chroma is considered in the combed frame decision", "set the x-axis size of the window used during combed frame detection", "set the y-axis size of the window used during combed frame detection", "set the number of combed pixels inside any of the blocky by blockx size blocks on the frame for the frame to be detected as combed", "picture will move %s one line\n", "object image is not a grayscale image\n", "Force libavfilter not to use any of the specified pixel formats for the input to the next filter.", "Convert the input video to one of the specified pixel formats.", "A '|'-separated list of pixel formats", "%d frames in, %d frames out; %d frames dropped, %d frames duplicated.\n", "Set first pts to (in:%lld out:%lld)\n", "Discarding initial frame(s) with no timestamp.\n", "A string describing desired output framerate", "Assume the first PTS should be this value.", "set rounding method for timestamps", "Left and right sizes differ (%dx%d vs %dx%d).\n", "Left and right time bases differ (%d/%d vs %d/%d).\n", "Left and right framerates differ (%d/%d vs %d/%d).\n", "Generate a frame packed stereoscopic video.", "Views are packed next to each other", "Views are packed on top of each other", "Views are interleaved by lines", "Views are interleaved by columns", "config_output() input time base:%u/%u (%f)\n", "time base:%u/%u -> %u/%u exact:%d\n", "Timebase conversion is not exact\n", "config_output() output time base:%u/%u (%f) w:%d h:%d\n", "fps -> fps:%u/%u scene score:%f interpolate start:%d end:%d\n", "set_work_frame_pts() srce crnt pts:%lld\n", "set_work_frame_pts() srce next pts:%lld\n", "set_work_frame_pts() srce prev pts:%lld\n", "set_work_frame_pts() initial average srce pts:%lld\n", "set_work_frame_pts() average srce pts:%lld\n", "set_work_frame_pts() average srce pts:%lld at dest time base:%u/%u\n", "Buggy path reached, use settb filter before this filter!\n", "set_frame_pts() average output pts from input timebase\n", "set_work_frame_pts() average dest pts delta:%lld\n", "set_work_frame_pts() calculated pts:%lld at dest time base:%u/%u\n", "process_work_frame() pending_input_frames %d\n", "process_work_frame() srce prev pts:%lld\n", "process_work_frame() srce crnt pts:%lld\n", "process_work_frame() srce next pts:%lld\n", "process_work_frame() no current frame cached: move on to next frame, do not output a frame\n", "process_work_frame() work crnt pts:%lld\n", "process_work_frame() work next pts:%lld\n", "process_work_frame() srce prev pts:%lld at dest time base:%u/%u\n", "process_work_frame() srce crnt pts:%lld at dest time base:%u/%u\n", "process_work_frame() srce next pts:%lld at dest time base:%u/%u\n", "process_work_frame() work crnt pts >= srce next pts: SKIP FRAME, move on to next frame, do not output a frame\n", "process_work_frame() interpolate:%d/256\n", "process_work_frame() source is:NEXT\n", "process_work_frame() source is:PREV\n", "process_work_frame() interpolate source is:NEXT\n", "process_work_frame() interpolate source is:PREV\n", "get_scene_score() result is:%f\n", "process_work_frame() interpolate scene score:%f\n", "process_work_frame() INTERPOLATE to create work frame\n", "process_work_frame() CUT - DON'T INTERPOLATE\n", "process_work_frame() COPY to the work frame\n", "process_work_frame() REPEAT FRAME\n", "process_work_frame() CONSUME FRAME, move to next frame\n", "process_work_frame() output a frame\n", "request_frame() call source's request_frame()\n", "request_frame() source's request_frame() returned error:%d\n", "request_frame() source's request_frame() returned:%d\n", "request_frame() REPEAT or FLUSH\n", "request_frame() nothing else to do, return:EOF\n", "request_frame() copy:%d to:%d\n", "Interlaced frame found - the output will not be correct.\n", "Upsamples or downsamples progressive source between specified frame rates.", "required output frames per second rate", "point to start linear interpolation", "point to end linear interpolation", "step:%d frame_rate:%d/%d(%f) -> frame_rate:%d/%d(%f)\n", "Select one frame every N frames.", "Apply Fast Simple Post-processing filter.", "force a constant quantizer parameter", "A luminance or RGB expression is mandatory\n", "Either YCbCr or RGB but not both must be specified\n", "Apply generic equation to each pixel.", "Debands video quickly using gradients.", "The maximum amount by which the filter will change any one pixel.", "The neighborhood to fit the gradient to.", "Horizontally flip the input video.", "strength:%0.3f intensity:%0.3f antibanding:%d\n", "Apply global color histogram equalization.", "This mode is deprecated, please use waveform filter instead.\n", "This mode is deprecated, use vectorscope filter instead.", "per row/column luminance graph", "set color components to display", "Apply a High Quality 3D Denoiser.", "fmt:%s size:%dx%d -> size:%dx%d\n", "Scale the input by 2, 3 or 4 using the hq*x magnification algorithm.", "Error when evaluating the expression '%s' for %s\n", "H and h options are incompatible and cannot be specified at the same time\n", "H_expr:%s h_deg_expr:%s s_expr:%s b_expr:%s\n", "Saturation value not in range [%d,%d]: clipping value to %0.1f\n", "Brightness value not in range [%d,%d]: clipping value to %0.1f\n", "H:%0.1f*PI h:%0.1f s:%0.1f b:%0.f t:%0.1f n:%d\n", "Adjust the hue and saturation of the input video.", "set the hue angle degrees expression", "set the hue angle radians expression", "Repeated Fields: Neither:%6lld Top:%6lld Bottom:%6lld\n", "Single frame detection: TFF:%6lld BFF:%6lld Progressive:%6lld Undetermined:%6lld\n", "Multi frame detection: TFF:%6lld BFF:%6lld Progressive:%6lld Undetermined:%6lld\n", "Repeated Field:%12s, Single frame:%12s, Multi frame:%12s\n", "lavfi.idet.repeated.current_frame", "lavfi.idet.single.current_frame", "lavfi.idet.single.undetermined", "lavfi.idet.multiple.current_frame", "lavfi.idet.multiple.progressive", "lavfi.idet.multiple.undetermined", "half life of cumulative statistics", "set number of frames to use to determine if the interlace flag is accurate", "Deinterleave or interleave fields.", "input video height is too small\n", "Lowpass filter is disabled, the resulting video will be aliased rather than interlaced.\n", "%s interlacing %s lowpass filter\n", "video is already interlaced, adjusting framerate only\n", "Convert progressive video into interlaced.", "enable vertical low-pass filter", "Apply kernel deinterlacing to the input.", "Rectify the image by correcting for lens distortion.", "set quadratic distortion factor", "set double quadratic distortion factor", "Error when parsing the expression '%s' for the component %d and color %d.\n", "Compute and apply a lookup table to the RGB input video.", "Compute and apply a lookup table to the YUV input video.", "Compute and apply a lookup table to the RGB/YUV input video.", "Padding on the right (%dpx) of the Hald CLUT will be ignored\n", "Padding at the bottom (%dpx) of the Hald CLUT will be ignored\n", "The Hald CLUT width does not match the level\n", "Too large Hald CLUT (maximum level is %d, or %dx%d CLUT)\n", "Unable to guess the format from the extension\n", "Too large or invalid 3D LUT size\n", "min: %f %f %f | max: %f %f %f\n", "Adjust colors using a Hald CLUT.", "continue applying the last clut after eos", "use values from the nearest defined points", "interpolate values using the 8 points defining a cube", "interpolate values using a tetrahedron", "Snow encoder is not enabled in libavcodec\n", "Apply motion compensating deinterlacing.", "set the assumed picture field parity", "Only planar formats with more than one component are supported.\n", "Mapping with out of range input and/or plane number.\n", "s->nb_inputs && s->nb_inputs <= 4", "input #%d link %s SAR %d:%d does not match output link %s SAR %d:%d\n", "input %d does not have %d plane\n", "output plane %d depth %d does not match input %d plane %d depth %d\n", "output plane %d width %d does not match input %d plane %d width %d\n", "output plane %d height %d does not match input %d plane %d height %d\n", "set input to output plane mapping", "max_drop_count:%d hi:%d lo:%d frac:%f\n", "%s pts:%s pts_time:%s drop_count:%d\n", "set the maximum number of consecutive dropped frames (positive), or the minimum interval between dropped frames (negative)", "set fraction dropping threshold", "The rgb option is deprecated and is overriding the format option, use format instead\n", "Incoming frame (time:%s) from link #%d\n", "main w:%d h:%d fmt:%s overlay w:%d h:%d fmt:%s eof_action:%s\n", "n:%f t:%f pos:%f x:%f xi:%d y:%f yi:%d\n", "Overlay a video source on top of the input.", "Action to take when encountering EOF from secondary input ", "force packed RGB in input and output (deprecated)", "repeat overlay of the last overlay frame", "Negative values are not acceptable.\n", "w:%d h:%d -> w:%d h:%d x:%d y:%d color:0x%02X%02X%02X%02X\n", "Input area %d:%d:%d:%d not within the padded area 0:0:%d:%d or zero-sized\n", "Direct padding impossible allocating new frame\n", "set the pad area width expression", "set the pad area height expression", "set the x offset expression for the input image position", "set the y offset expression for the input image position", "set the color of the padded area border", "%d%s colors generated out of %d colors; ratio=%f\n", "Unable to allocate references for %d different colors\n", "Find the optimal palette for a given stream.", "set the maximum number of colors to use in the palette", "reserve a palette entry for transparency", "compute histograms only for the part that differs from previous frame", "Palette input must contain exactly %d pixels. Specified input has %dx%d=%d pixels\n", "%*cnode%d [label=\"%c%02X%c%02X%c%02X%c\" fillcolor=\"#%02x%02x%02x\" fontcolor=\"#%06X\"]\n", "Cannot open file '%s' for writing: %s\n", "    node [style=filled fontsize=10 shape=box]\n", "/!\\ %02X%02X%02X: %d ! %d (%06X ! %06X) / dist: %d ! %d\n", "Use a palette to downsample an input video stream.", "ordered 8x8 bayer dithering (deterministic)", "dithering as defined by Paul Heckbert in 1982 (simple error diffusion)", "Floyd and Steingberg dithering (error diffusion)", "Frankie Sierra dithering v2 (error diffusion)", "Frankie Sierra dithering v2 \"Lite\" (error diffusion)", "process smallest different rectangle", "save Graphviz graph of the kdtree in specified file", "set reverse colormap color search method", "Correct the perspective of video.", "specify the sense of the coordinates", "specify locations in source to send to corners in destination", "specify locations in destination to send corners of source", "mode=%c tdiff=%f bdiff=%f pdiff=%f\n", "Test pixel format definitions.", "Filter video using libpostproc.", "Apply Postprocessing 7 filter.", "PSNR%s average:%0.2f min:%0.2f max:%0.2f\n", "Could not open stats file %s: %s\n", "Width and height of input videos must be same.\n", "Inputs must be of same pixel format.\n", "Calculate the PSNR between two video streams.", "Set file where to store per-frame difference information", "input format does not have such plane\n", "Pullup from field sequence to frames.", "Change video quantization parameters.", "Mask image size %dx%d does not match with the input video size %dx%d\n", "The bitmap file name is mandatory\n", "full x1:%d x2:%d y1:%d y2:%d max_mask_size:%d\n", "half x1:%d x2:%d y1:%d y2:%d max_mask_size:%d\n", "Remove a TV logo based on a mask image.", "Unexpected field flags: state=%d top_field_first=%d repeat_first_field=%d\n", "Hard repeat fields based on MPEG repeat field flag.", "Error when parsing the expression '%s' for angle command\n", "Error occurred parsing angle expression '%s'\n", "Error parsing or evaluating expression for option %s: invalid expression '%s' or non-positive or indefinite value %f\n", "luma_radius:%f luma_pre_filter_radius::%f luma_strength:%f chroma_radius:%f chroma_pre_filter_radius:%f chroma_strength:%f\n", "Rescaled value for width or height is too big.\n", "w:%d h:%d fmt:%s sar:%d/%d -> w:%d h:%d fmt:%s sar:%d/%d flags:0x%0x\n", "Error when evaluating the expression '%s'.\nMaybe the expression for out_w:'%s' or for out_h:'%s' is self-referencing.\n", "Size and width/height expressions cannot be set at the same time.\n", "w:%s h:%s flags:'%s' interl:%d\n", "Detected unsupported YCgCo colorspace.\n", "Scale the input video size and/or convert the image format.", "input vertical chroma position in luma grid/256", "input horizontal chroma position in luma grid/256", "output vertical chroma position in luma grid/256", "output horizontal chroma position in luma grid/256", "decrease or increase w/h if necessary to keep the original AR", "Scale the input video size and/or convert the image format to the given reference.", "Split input video frames into fields.", "Force field for the output video frame.", "config %s time_base: %d/%d, frame_rate: %d/%d\n", "n:%4lld pts:%7s pts_time:%-7s pos:%9lld fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c checksum:%08X plane_checksum:[%08X", "A/53 closed captions (%d bytes)", "side by side (quincunx subsampling)", "displaymatrix: rotation of %.2f degrees", "unknown side data type %d (%d bytes)", "Show textual information for each video frame.", "Non-existing input plane #%d mapped to output plane #%d.\n", "Cannot map between a subsampled chroma plane and a luma or alpha plane.\n", "Cannot map between a palette plane and a data plane.\n", "Index of the input plane to be used as the first output plane ", "Index of the input plane to be used as the second output plane ", "Index of the input plane to be used as the third output plane ", "Index of the input plane to be used as the fourth output plane ", "Generate statistics from video analysis.", "analyze pixels for temporal outliers", "analyze video lines for vertical line repetition", "analyze for pixels outside of broadcast range", "highlight pixels that depict temporal outliers", "highlight video lines that depict vertical line repetition", "highlight pixels that are outside of broadcast range", "luma_radius:%f luma_strength:%f luma_threshold:%d chroma_radius:%f chroma_strength:%f chroma_threshold:%d\n", "Blur the input video without impacting the outlines.", "Apply a simple post processing filter.", "Calculate the SSIM between two video streams.", "Input %d width %d does not match input %d width %d.\n", "Input %d height %d does not match input %d height %d.\n", "Stack video inputs vertically.", "Stack video inputs horizontally.", "input format %d is not supported\n", "output format %d is not supported\n", "Convert video stereoscopic 3D view.", "above below half height left first", "above below half height right first", "alternating frames right first", "side by side half width left first", "side by side half width right first", "anaglyph green magenta half color", "anaglyph yellow blue half color", "Scale the input by 2x using the Super2xSaI pixel art algorithm.", "Telecine pattern %s yields up to %d frames per frame, pts advance factor: %d/%d\n", "frame id #%d (pts_time=%f) selected from a set of %d images\n", "Allocation failure, try to lower the number of frames\n", "Select the most representative frame in a given sequence of consecutive frames.", "nb_frames must be less than or equal to %dx%d=%d\n", "Total width %ux%u is too much.\n", "Total height %ux%u is too much.\n", "Tile several successive frames together.", "set maximum number of frame to render", "set outer border margin in pixels", "set inner border thickness in pixels", "set the color of the unused area", "low_pass_filter flag ignored with mode %d\n", "mode:%d filter:%s h:%d -> h:%d\n", "Perform temporal field interlacing.", "pad alternate lines with black", "interleave top and bottom fields", "interleave bottom and top fields", "interlace fields from two consecutive frames", "force a timebase which can represent timestamps exactly", "dir values greater than 3 are deprecated, use the passthrough option instead\n", "w:%d h:%d -> w:%d h:%d (passthrough mode)\n", "w:%d h:%d dir:%d -> w:%d h:%d rotation:%s vflip:%d\n", "rotate counter-clockwise with vertical flip", "rotate clockwise with vertical flip", "do not apply transposition if the input matches the specified geometry", "Invalid even size for %s matrix size %dx%d\n", "effect:%s type:%s msize_x:%d msize_y:%d amount:%0.2f\n", "Sharpen or blur the input video.", "set luma matrix horizontal size", "set chroma matrix horizontal size", "set chroma matrix vertical size", "Apply Ultra Simple / Slow Post-processing filter.", "Flip the input video vertically.", "Unable to parse expression for 'angle'\n", "Unable to parse expression for 'x0'\n", "Unable to parse expression for 'y0'\n", "Make or reverse a vignette effect.", "set circle center position on x-axis", "set circle center position on y-axis", "eval expressions for each frame", "Apply Martin Weston three field deinterlace.", "specify which frames to deinterlace", "only deinterlace frames marked as interlaced", "Scale the input using xBR algorithm.", "Video of less than 3 columns or lines is not supported\n", "Reallocating frame due to differing stride\n", "send one frame for each frame, but skip spatial interlacing check", "send one frame for each field, but skip spatial interlacing check", "specify the assumed picture field parity", "Do absolutely nothing with the input video.", "The specified width is %d which cannot contain the provided string width of %d\n", "Only one of the filename or pattern options can be used\n", "s:%dx%d r:%d/%d rule:%d stitch:%d scroll:%d full:%d seed:%u\n", "Create pattern generated by an elementary cellular automaton.", "read initial pattern from file", "set fill ratio for filling initial grid randomly", "set the seed for filling the initial grid randomly", "Invalid rule code '%s' provided\n", "Mold color is set while mold isn't, ignoring the color.\n", "The specified size is %dx%d which cannot contain the provided file size of %dx%d\n", "s:%dx%d r:%d/%d rule:%s stay_rule:%d born_rule:%d stitch:%d seed:%u\n", "Mandelbrot cache is too small!\n", "set normalized iteration count mode", "color based on point closest to the origin of the iterations", "Generate various test pattern.", "size:%dx%d rate:%d/%d duration:%f sar:%d/%d\n", "w == h && w == level*level*level", "set number of decimals to show", "Null video source, return unprocessed video frames.", "Provide an identity Hald CLUT.", "Provide an uniformly colored input.", "raw ADTS AAC (Advanced Audio Coding)", "audio/aac,audio/aacp,audio/x-aac", "MPEG-4 AOT %d is not allowed in ADTS\n", "Escape sample rate index illegal in ADTS\n", "960/120 MDCT window is not allowed in ADTS\n", "Scalable configurations are not allowed in ADTS\n", "Extension flag is not allowed in ADTS\n", "ADTS frame size too large: %u (max %d)\n", "ADTS AAC (Advanced Audio Coding)", "Unsupported tag version. (>=%d)\n", "Non ASCII keys are not allowed\n", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.", "No URL Protocols are registered. Missing call to av_register_all()?\n", "Impossible to open the '%s' protocol for reading\n", "Impossible to open the '%s' protocol for writing\n", "Error parsing options string %s\n", "https protocol not found, recompile FFmpeg with openssl, gnutls,\nor securetransport enabled.\n", "Invaid UTF8 sequence in avio_put_str16%s\n", "Failed to decrease buffer size\n", "Statistics: %d seeks, %d writeouts\n", "Statistics: %lld bytes read, %d seeks\n", "Match slave stream #%d with stream #%d id 0x%x\n", "Auto-inserting h264_mp4toannexb bitstream filter\n", "h264_mp4toannexb bitstream filter required for H.264 streams\n", "file:%d stream:%d pts:%s pts_time:%s dts:%s dts_time:%s", " -> pts:%s pts_time:%s dts:%s dts_time:%s\n", "Line %d: packet metadata required\n", "Line %d: failed to parse metadata string\n", "Line %d: exact_stream_id without stream\n", "Line %d: unknown keyword '%s'\n", "automatically convert bitstream format", "quality factor: %d, pict_type: %c", "truncate existing files on write", "set I/O operation maximum block size", "AMF_DATA_TYPE_STRING parsing failed\n", "Invalid keyframes object, skipping.\n", "Keyframe index parsing failed\n", "Missing AMF_END_OF_OBJECT in AMF_DATA_TYPE_OBJECT\n", "Missing AMF_END_OF_OBJECT in AMF_DATA_TYPE_MIXEDARRAY\n", "type:%d, size:%d, dts:%lld pos:%lld\n", "Found invalid index entries, clearing the index.\n", "Skipping flv packet: type %d, size %d, flags %d.\n", "Stream discovered after head already parsed\n", "Negative cts, previous timestamps might be wrong.\n", "Allocate streams according to the onMetaData array", "Failed to update header with correct duration.\n", "Failed to update header with correct filesize.\n", "FLV only supports wideband (16kHz) Speex audio\n", "FLV only supports mono Speex audio\n", "FLV does not support sample rate %d, choose from (44100, 22050, 11025)\n", "Audio codec '%s' not compatible with FLV\n", "at most one video stream is supported in flv\n", "%s codec %s not compatible with flv\n", "Muxing VP6 in flv will produce flipped video on playback.\n", "at most one audio stream is supported in flv\n", "16-bit big-endian audio in flv is valid but most likely unplayable (hardware dependent); use s16le\n", "Subtitle codec '%s' for stream %d is not compatible with FLV\n", "Codec type '%s' for stream %d is not compatible with FLV\n", "Codec %s is not supported in the official FLV specification,\n", "use vstrict=-1 / -strict -1 to use it anyway.\n", "Packets are not in the proper order with respect to DTS\n", "Malformed AAC bitstream detected: use the audio bitstream filter 'aac_adtstoasc' to fix it ('-bsf:a aac_adtstoasc' option with ffmpeg)\n", "Warning: Speex stream has more than 8 frames per packet. Adobe Flash Player cannot handle this!\n", "Too large packet with size %u >= %u\n", "Specified probe size value %u cannot be < %u\n", "Format %s detected only with low score of %d, misdetection possible!\n", "Format %s probed with size=%d and score=%d\n", "configurationVersion:                %u\n", "general_profile_space:               %u\n", "general_tier_flag:                   %u\n", "general_profile_idc:                 %u\n", "general_profile_compatibility_flags: 0x%08x\n", "general_constraint_indicator_flags:  0x%012llx\n", "general_level_idc:                   %u\n", "min_spatial_segmentation_idc:        %u\n", "parallelismType:                     %u\n", "chromaFormat:                        %u\n", "bitDepthLumaMinus8:                  %u\n", "bitDepthChromaMinus8:                %u\n", "avgFrameRate:                        %u\n", "constantFrameRate:                   %u\n", "numTemporalLayers:                   %u\n", "temporalIdNested:                    %u\n", "lengthSizeMinusOne:                  %u\n", "numOfArrays:                         %u\n", "array_completeness[%u]:               %u\n", "NAL_unit_type[%u]:                    %u\n", "numNalus[%u]:                         %u\n", "nalUnitLength[%u][%u]:                 %u\n", "HLS request for url '%s', offset %lld, playlist %d\n", "SAMPLE-AES encryption is not supported yet\n", "Unable to seek to offset %lld of HLS segment '%s'\n", "public.accessibility.describes-music-and-sound", "public.accessibility.describes-video", "No longer receiving playlist %d\n", "skipping %d segments ahead, expired from playlists\n", "Failed to open segment of playlist %d\n", "Too large HLS ID3 tag (%d > %lld bytes)\n", "Stripped additional %d HLS ID3 bytes\n", "Invalid HLS ID3 audio timestamp %lld\n", "Changing ID3 metadata in HLS audio elementary stream", "Now receiving playlist %d, segment %d\n", "Error when loading first segment '%s'\n", "No expected HTTP requests have been made\n", "segment index to start live streams at (negative values are from the end)", "skipping %d segments ahead, expired from playlist\n", "Using the hls protocol is discouraged, please try using the hls demuxer instead. The hls demuxer should be more complete and work as well as the protocol implementation. (If not, please report it.) To use the demuxer, simply use %s as url.\n", "No nested protocol specified. Specify e.g. hls+http://%s\n", "HTTP/1.1 %03d %s\r\nContent-Type: %s\r\nContent-Length: %zu\r\n\r\n%03d %s\r\n", "HTTP/1.1 %03d %s\r\nContent-Type: %s\r\nTransfer-Encoding: chunked\r\n\r\n", "Stream ends prematurely at %lld, should be %lld\n", "Received and expected HTTP method do not match. (%s expected, %s received)\n", "Received and autodetected HTTP method did not match (%s autodetected %s received)\n", "Malformed HTTP version string.\n", "Error during zlib initialisation: %s\n", "Your zlib was compiled without gzip support.\n", "Invalid cookie found, no value, path or domain specified\n", "try to fix missing 'Content-Range' at server side (%lld,%lld) => (%lld,%lld)", "Chunked encoding data size: %lld'\n", "No trailing CRLF found in HTTP header.\n", "control seekability of connection", "use chunked transfer-encoding for posts", "set custom HTTP headers, can override built in default headers", "set a specific content type for the POST messages", "set cookies to be sent in applicable future requests, use newline delimited Set-Cookie HTTP field value syntax", "return current ICY metadata packet", "metadata read from the bitstream", "No auth method set, autodetect", "Force sending an Expect: 100-continue header for POST", "The actual location of the data received", "try to limit the request to bytes preceding this offset", "Override the HTTP method or set the expected HTTP method from a client", "auto reconnect after disconnect before EOF", "The resource requested by a client", "The http status code to return to a client", "Cannot read BOM value, input too short\n", "Error reading frame %s, skipped\n", "No AVFormatContext, skipped ID3 chapter data\n", "invalid extended header length", "id3v2 ver:%d flags:%02X len:%d\n", "Invalid empty frame %s, skipping.\n", "Compresssed frame %s tlen=%d dlen=%ld\n", "Failed to read compressed tag\n", "invalid frame id, assuming padding\n", "Error reading lyrics, skipped\n", "ID3v2.%d tag skipped, cannot handle %s\n", "Unknown attached picture mimetype: %s, skipping.\n", "Unknown attached picture type %d.\n", "Error decoding attached picture description.\n", "Error reading GEOB frame, data truncated.\n", "Lead artist/lead performer/soloist", "No mimetype is known for stream %d, cannot write an attached picture.\n", "POSIX.1-2008 not supported, nanosecond file timestamps unavailable\n", "Could find no file with path '%s' and index in the range %d-%d\n", "Pattern type 'glob' was selected but globbing is not supported by this libavformat build\n", "Unknown value '%d' for pattern_type option\n", "force loop over input file sequence", "select glob/sequence pattern type", "set first number in the sequence", "set range for looking at the first sequence number", "set frame timestamp from file's one", "Could not get frame filename with strftime\n", "Could not get frame filename number %d from pattern '%s' (either set updatefirst or use a pattern like %%03d within the filename pattern)\n", "bmp,dpx,jls,jpeg,jpg,ljpg,pam,pbm,pcx,pgm,pgmyuv,png,ppm,sgi,tga,tif,tiff,jp2,j2c,j2k,xwd,sun,ras,rs,im1,im8,im24,sunras,xbm,xface,pix,y", "continuously overwrite one file", "MPEG4 description: tag=0x%02x len=%d\n", "codec open in read_dec_config_descr\n", "mp4a config channels %d obj %d ext obj %d sample rate %d ext sample rate %d\n", "Extradata is larger than currently supported.\n", "BUG: ALS offset is not byte-aligned\n", "Muxing MPEG-4 AOT %d in LATM is not supported\n", "ADTS header detected - ADTS will not be incorrectly muxed into LATM\n", "LATM packet size larger than maximum size 0x1fff\n", "Unknown MOV field order 0x%04x\n", "Detected moov in a free atom.\n", "Broken file, trak/mdat not at top-level\n", "type: %08x '%.4s' parent:'%.4s' sz: %lld %lld %lld\n", "overread end of atom '%.4s' by %lld bytes\n", "Found duplicated MOOV Atom. Skipped it\n", "ISO: File Type Major Brand: %.4s\n", "found fragment index for track %u\n", "track %u has a fragment index but it doesn't have an (in-order) entry for moof_offset %lld\n", "found fragment index entry for track %u and moof_offset %lld\n", "could not find corresponding trex\n", "could not find corresponding track id %d\n", "sample_count=%d, sample_duration=%d\n", "duration=%lld time=%lld rate=%f\n", "unknown compression for cmov atom !\n", "found frag time %lld sc->dts_shift %d ctts.duration %d sc->time_offset %lld flags & MOV_TRUN_SAMPLE_CTS %d\n", "found frag time %lld, using it for dts\n", "AVIndex stream %d, sample %d, offset %llx, dts %lld, size %d, distance %d, keyframe %d\n", "sample aspect ratio already set to %d:%d, ignoring 'pasp' atom (%d:%d)\n", "stream %d, sample %d, dts %lld\n", "stream has moof boxes, will look for a mfra\n", "doesn't look like mfra (unreasonable size)\n", "doesn't look like mfra (size mismatch)\n", "doesn't look like mfra (tag mismatch)\n", "failed to seek back after looking for mfra\n", "found a moof box but failed to read the mfra (may be a live ismv)\n", "found a moof box but stream is not seekable, can not look for mfra\n", "[aax] activation_bytes option is missing!\n", "[aax] activation_bytes value needs to be 4 bytes!\n", "[aax] audible_fixed_key value needs to be 16 bytes!\n", "[aax] error in drm blob decryption!\n", "unsupported color_parameter_type %s\n", "stream %d, timestamp %lld, sample %d\n", "no space for coordinates left (%d)\n", "UDTA parsing failed retrying raw\n", "tag \"%s\" value \"%s\" atom \"%.4s\" %d %lld\n", "Unhandled or malformed custom metadata of size %lld\n", "ignored unknown aclr value (%d)\n", "aclr not decoded - incomplete atom\n", "aclr not decoded - unexpected size %lld\n", "aclr not decoded - unable to add atom to extradata\n", "Using absolute path on user request, this is a possible security issue\n", "Absolute path %s not tried for security reasons, set demuxer option use_absolute_path to allow absolute paths\n", "Reference with mismatching origin, %s not tried for security reasons, set demuxer option use_absolute_path to allow it anyway\n", "stream %d, missing mandatory atoms, broken header\n", "multiple edit list entries, a/v desync might occur, patch welcome\n", "STSZ sample size %d invalid (too large), ignoring\n", "STSZ sample size %d invalid (too small), ignoring\n", "Invalid SampleDelta %d in STTS, at %d st:%d\n", "Zero bytes per frame, but %d samples per frame", "AVIndex stream %d, chunk %d, offset %llx, dts %lld, size %d, duration %d\n", "stream %d, error opening alias: path='%s', dir='%s', filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\n", "ignoring stream duration which is shorter than chapters\n", "Referenced QT chapter track not found\n", "next root atom offset 0x%llx: partial file\n", "read fragments, offset 0x%llx\n", "stream %d, offset 0x%llx: partial file\n", "Cannot append palette to packet\n", "sample_size = %d sample_count = %d\n", "Found media data tag MPEG indicating this is a MOV-packed MPEG-PS.\n", "multiple fourcc not supported\n", "Concatenated H.264 or H.265 might not play correctly.\n", "size=%lld 4CC= %c%c%c%c/0x%08x codec_type=%d\n", "allow using absolute path when opening alias, this is a possible security issue", "Seek each stream individually to the to the closest point", "use mfra for fragment timestamps", "Export unrecognized metadata entries", "Secret bytes for Audible AAX files", "Fixed key used for handling Audible AAX files", "77214d4b196a87cd520045fd20a51d67", "chan: layout=%u bitmap=%u num_descr=%u\n", "reached EOF while reading channel layout\n", "Unknown hldr_type for %s / 0x%04X, writing dummy values\n", "PSP mode need one video and one audio stream\n", "Non-consecutive fragments, writing incorrect sidx\n", "not writing 'chan' tag due to lack of channel information\n", "timecode: tbc=%d/%d invalid, fallback on %d/%d\n", "Could not locate DNxHD bit stream in vos_data\n", "Could not locate DNxHD bit stream, vos_data too small\n", "moov atom written before any packets, unable to write correct dvc1 atom. Set the delay_moov flag to fix this.\n", "gamma value unknown, unable to write gama atom\n", "Not writing 'gama' atom. Format is not MOV.\n", "color primaries unspecified, assuming bt709\n", "color primaries unspecified, assuming bt470bg\n", "color primaries unspecified, assuming smpte170\n", "color primaries unspecified, unable to assume anything\n", "track->mode == 0x02 || track->mode == 0x01", "Not writing 'colr' atom. Format is not MOV or MP4.\n", "reel_name length %llu is too large\n", "EDTS using dts:%lld cts:%d instead of dts:%lld cts:%lld tid:%d\n", "av_rescale_rnd(start_dts, 1000, track->timescale, AV_ROUND_DOWN) <= 0", "Not writing any edit list even though one would have been required\n", "FATAL error, file duration too long for timebase, this file will not be\nplayable with quicktime. Choose a different timebase or a different\ncontainer format\n", "Estimating the duration of the last packet in a fragment, consider setting the duration field in AVPacket instead.\n", "Unable to re-open %s output file for the second pass (faststart)\n", "Application provided duration: %lld / timestamp: %lld is out of range for mov/mp4 format\n", "Application provided duration: %d is invalid\n", "fatal error, input is not a single packet, implement a AVParser for it\n", "Track %d starts with a nonzero dts %lld, while the moov already has been written. Set the delay_moov flag to handle this case.\n", "Starting second pass: moving the moov atom to the beginning of the file\n", "reserved_moov_size is too small, needed %lld additional\n", "Starting second pass: inserting sidx atoms\n", "No meaningful edit list will be written when using empty_moov without delay_moov\n", "Sample interleaving in fragments is mutually exclusive with omit_tfhd_offset and separate_moof\n", "muxer does not support non seekable output\n", "You requested a copy of the original timecode track so timecode metadata are now ignored\n", "Warning, extension is not .m4a, .m4v nor  .m4b Quicktime/Ipod might not play the file\n", "unsupported height for dv codec\n", "%s rawvideo cannot be written to mov, output file will be unreadable\n", "Using MS style video codec tag, the file may be unplayable!\n", "Using MS style audio codec tag, the file may be unplayable!\n", "Could not find tag for codec %s in stream #%d, codec not currently supported in container\n", "D-10/IMX must use 720x608 or 720x512 video resolution\n", "Resolution %dx%d too large for mov/mp4\n", "WARNING codec timebase is very high. If duration is too long,\nfile may not be playable by quicktime. Specify a shorter timebase\nor choose different container.\n", "track %d: codec frame size is not set\n", "track %d: codec block align is not set for adpcm\n", "track %d: muxing mp3 at %dhz is not standard, to mux anyway set strict to -1\n", "track %d: muxing mp3 at %dhz is not standard in MP4\n", "%06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x", "Failed to parse creation_time %s\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n", "<smil xmlns=\"http://www.w3.org/2001/SMIL20/Language\">\n", "<meta name=\"creator\" content=\"%s\" />\n", "<param name=\"%s\" value=\"%d\" valuetype=\"data\"/>\n", "<param name=\"%s\" value=\"%s\" valuetype=\"data\"/>\n", "iPod H.264 MP4 (MPEG-4 Part 14)", "maximum moov size so it can be placed at the begin", "Make the initial moov atom empty", "Write separate moof/mdat atoms for each track", "Flush fragments on caller requests", "Create a live smooth streaming feed (for pushing to a publishing point)", "Run a second pass to put the index (moov atom) at the beginning of the file", "Omit the base data offset in tfhd atoms", "Set the default-base-is-moof flag in tfhd atoms", "Write DASH compatible fragmented MP4", "Signal that the next fragment is discontinuous from earlier ones", "Delay writing the initial moov until the first fragment is cut, or until the first fragment flush", "Write a global sidx index at the start of the file", "Write colr atom (Experimental, may be renamed or changed, do not use from scripts)", "Use MP4A-LATM packetization instead of MPEG4-GENERIC for AAC", "Use RFC 2190 packetization instead of RFC 4629 for H.263", "Don't send RTCP sender reports", "Send RTCP BYE packets when finishing", "Number of lookahead entries for ISM files", "set timescale of all video tracks", "Fragment number of the next fragment", "Interleave samples within fragments (max number of consecutive samples, lower is tighter interleaving, but with more overhead)", "Unable to initialize hinting of stream %d\n", "invalid concatenated file detected - using bitrate for duration\n", "filesize and duration do not match (growing file?)\n", "Cannot determine file size, skipping TOC table.\n", "Skipping %d bytes of junk at %lld.\n", "Unsupported sample rate, not writing Xing header.\n", "Unsupported number of channels, not writing Xing header.\n", "Too many samples of initial padding.\n", "Invalid ID3v2 version requested: %d. Only 3, 4 or 0 (disabled) are allowed.\n", "Invalid audio stream. Exactly one MP3 audio stream is required.\n", "Only audio streams and pictures are allowed in MP3.\n", "Attached pictures were requested, but the ID3v2 header is disabled.\n", "Audio packet of size %d (starting with %08X...) is invalid, writing it anyway.\n", "No packets were sent for some of the attached pictures.\n", "Not enough memory to buffer audio. Skipping picture streams\n", "Got more than one picture in stream %d, ignoring.\n", "Select ID3v2 version to write. Currently 3 and 4 are supported.", "Enable ID3v1 writing. ID3v1 tags are written in UTF-8 which may not be supported by most software.", "Write the Xing header containing file duration.", "max resync size reached, could not find sync byte\n", "All programs have pmt, headers found\n", "Continuity check failed for pid %d expected %d got %d\n", "cannot set stream info, codec is open\n", "stream=%d stream_type=%x pid=%x prog_reg_desc=%.4s\n", "pid=%x stream_type=%x probing\n", "Failed to allocate buffers for seekback\n", "score: %d, dvhs_score: %d, fec_score: %d \n", "Unable to seek back to the start\n", "start=%0.3f pcr=%0.3f incr=%d\n", "Could not detect TS packet size, defaulting to non-FEC/DVHS\n", "Tag %x length violation new length %d bytes remaining %d\n", "Maximum MP4 descriptor level exceeded\n", "DVB subtitles with multiple languages", "Opus in MPEG-TS - channel_config_code > 0x8", "sid=0x%x sec_num=%d/%d version=%d\n", "raw MPEG-TS (MPEG-2 Transport Stream)", "MPEG-TS (MPEG-2 Transport Stream)", "set size limit for looking up a new synchronization", "compute exact PCR for each transport stream packet", "output option carrying the raw packet size", "try to fix pts values of dvb teletext streams", "skip changing / adding streams / programs", "Invalid stream id %d, must be less than 8191\n", "pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\n", "ts_st->payload != buf || st->codec->codec_type != AVMEDIA_TYPE_VIDEO", "The PMT section cannot fit stream %d and all following streams.\nTry reducing the number of languages in the audio streams or the total number of streams.\n", "H.264 bitstream malformed, no startcode found, use the video bitstream filter 'h264_mp4toannexb' to fix it ('-bsf:v h264_mp4toannexb' option with ffmpeg)\n", "H.264 bitstream error, startcode missing, size %d", "resend_headers option is deprecated, use -mpegts_flags resend_headers\n", "AAC bitstream not in ADTS format and extradata missing\n", "pkt->dts != ((int64_t)0x8000000000000000ULL)", "HEVC bitstream malformed, no startcode found\n", "HEVC bitstream error, startcode missing, size %d", "Set transport_stream_id field.", "Set original_network_id field.", "Minimum PES packet payload in bytes", "Reemit PAT/PMT before writing the next packet", "Use LATM packetization for AAC", "Reemit PAT and PMT at each video frame", "Omit the PES packet length for video packets", "PAT/PMT retransmission time limit in seconds", "SDT retransmission time limit in seconds", "compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\n", "Packet with invalid duration %d in stream %d\n", "Encoder did not produce proper pts, making some up.\n", "Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\n", "pts (%s) < dts (%s) in stream %d\n", "av_write_frame: pts2:%s dts2:%s\n", "Requested output format '%s' is not a suitable output format\n", "Unable to find a suitable output format for '%s'\n", "Setting the AVFormatContext to bitexact mode, because the AVCodecContext is in that mode. This behavior will change in the future. To keep the current behavior, set AVFormatContext.flags |= AVFMT_FLAG_BITEXACT.\n", "No streams to mux were specified\n", "Using AVStream.codec.time_base as a timebase hint to the muxer is deprecated. Set AVStream.time_base instead.\n", "Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\n", "Codec for stream %d does not use global headers but container format requires global headers\n", "Tag %s/0x%08x incompatible with output codec id '%d' (%s)\n", "Invalid packet stream index: %d\n", "Received a packet for an attachment stream.\n", "failed to avoid negative pts %s in stream %d.\nTry -avoid_negative_ts 1 as a possible workaround.\n", "Packets poorly interleaved, failed to avoid negative timestamp %s in stream %d.\nTry -max_interleave_delta 0 as a possible workaround.\n", "pkt->size == ((-2147483647 - 1) / 3 * 2 + (int)sizeof(AVFrame))", "Delay between the first packet and last packet in the muxing queue is %lld > %lld: forcing output\n", "av_interleaved_write_frame size:%d dts:%s pts:%s\n", "av_interleaved_write_frame FLUSH\n", "Using network protocols without global network initialization. Please use avformat_network_init(), this will become mandatory later.\n", "setsockopt(SO_REUSEADDR) failed\n", "Connection to %s failed (%s), trying next address\n", "number of bytes to probe file format", "reduce the latency by flushing out packets immediately", "do not fill in missing values that can be exactly calculated", "disable AVParsers, this needs nofillin too", "try to interleave outputted packets by dts", "reduce the latency introduced by optional buffering", "allow seeking to non-keyframes on demuxer level when supported", "do not write random/volatile data", "specify how many microseconds are analyzed to probe the input", "max memory used for timestamp index (per stream)", "max memory used for buffering real-time frames", "maximum muxing or demuxing delay in microseconds", "wall-clock time when stream begins (PTS==0)", "number of frames used to probe fps", "microseconds by which audio packets should be interleaved earlier", "set error detection flags (deprecated; use err_detect, save via avconv)", "consider things that a sane encoder shouldn't do as an error", "set number of bytes to skip before reading header and frames", "correct single timestamp overflows", "enable flushing of the I/O context after each packet", "set number of bytes to be written as padding in a metadata header", "maximum buffering duration for interleaving", "how strictly to follow the standards (deprecated; use strict, save via avconv)", "allow non-standardized experimental variants", "maximum number of packets to read while waiting for the first timestamp", "shift timestamps so they start at 0", "enabled when required by target format", "shift timestamps so they are non negative", "List of demuxers that are allowed to be used", "%s files have exactly one stream\n", "WAVEFORMATEX support for RIFX files\n", "unknown subformat:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x {%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n", "The bitrate %llu is too large.\n", "The bitrate %llu is too large, resetting to 0.", "out of memory, unable to read INFO tag\n", "premature end of file while reading INFO tag\n", "requested bits_per_coded_sample (%d) and actually stored (%d) differ\n", "Unable to read as many bytes as AMF string signaled\n", "RTMP packet type '%s'(%d) for channel %d, timestamp %d, extra field %d size %d\n", "Too short chunk size change packet (%d)\n", "Unable to create response packet\n", "Incomplete flv packets in RTMP_PT_METADATA packet\n", "NetStream.Play.UnpublishNotify", "Unable to find / in url %s, bad format\n", "Unexpected stream %s, expecting %s\n", "Unknown connect error (unsupported authentication method?)\n", "?authmod=%s&user=%s&challenge=%s&response=%s", "?authmod=%s&user=%s&nonce=%s&cnonce=%s&nc=%s&response=%s", "Sending publish command for '%s'\n", "Seek on stream index %d at timestamp %lld with flags %08x\n", "Sending seek command for timestamp %lld\n", "Unable to send seek command on stream index %d at timestamp %lld with flags %08x\n", "Sending pause command for timestamp %d\n", "Unable to send pause command at timestamp %d\n", "Ignoring SWFVerification request.\n", "Client bandwidth report packet is less than 4 bytes long (%d)\n", "Incorrect client bandwidth %d\n", "Too short server bandwidth report packet (%d)\n", "Incorrect server bandwidth %d\n", "Unexpected reply on connect()\n", "Sending play command for '%s'\n", "Unexpected reply on getStreamLength()\n", "Unknown packet type received 0x%02X\n", "Detected librtmp style URL parameters, these aren't supported by the libavformat internal RTMP handler currently enabled. See the documentation for the correct way to pass parameters.\n", "rtmp_listen not available for %s\n", "Genuine Adobe Flash Player 001", "Cannot write RTMP handshake request\n", "Cannot read RTMP handshake response\n", "Server response validating failed\n", "Hash of the decompressed SWF file is not 32 bytes long.\n", "RTMP protocol version mismatch\n", "Unable to write answer - RTMP S0\n", "Erroneous Message size %d not following standard\n", "Erroneous C2 Message epoch does not match up with C1 epoch\n", "Erroneous C2 Message random does not match up\n", "Proto = %s, path = %s, app = %s, fname = %s\n", "Unable to read command string\n", "App field not found in connect\n", "App field don't match up: %s <-> %s\n", "Name of application to connect to on the RTMP server", "Set buffer time in milliseconds. The default is 3000.", "Append arbitrary AMF data to the Connect message", "Version of the Flash plugin used to run the SWF player.", "Number of packets flushed in the same request (RTMPT only).", "Specify that the media is a live stream.", "URL of the web page in which the media was embedded. By default no value will be sent.", "Stream identifier to play or to publish", "Name of live stream to subscribe to. Defaults to rtmp_playpath.", "SHA256 hash of the decompressed SWF file (32 bytes).", "Size of the decompressed SWF file, required for SWFVerification.", "URL of the SWF player. By default no value will be sent", "URL to player swf file, compute hash/size automatically.", "URL of the target stream. Defaults to proto://host[:port]/app.", "Listen for incoming rtmp connections", "Maximum timeout (in seconds) to wait for incoming connections. -1 is infinite. Implies -rtmp_listen 1", "Failed to resolve hostname %s: %s\n", "Listen for incoming connections", "set timeout (in microseconds) of socket I/O operations", "Connection awaiting timeout (in milliseconds)", "Socket send buffer size (in bytes)", "Socket receive buffer size (in bytes)", "nothing to probe for stream %d\n", "Probe with size=%d, packets=%d detected %s with score=%d\n", "libavformat license: GPL version 2 or later", "!dst->codec_whitelist && !dst->format_whitelist", "Failed to duplicate whitelist\n", "Truncating packet of size %d to %lld\n", "Attached picture on stream %d has invalid size, ignoring\n", "invalid dts/pts combination %lli\n", "first_dts %s not matching first dts %s (pts %s, duration %d) in the queue\n", "IN delayed:%d pts:%s, dts:%s cur_dts:%s st:%d pc:%p duration:%d delay:%d onein_oneout:%d\n", "OUTdelayed:%d/%d pts:%s, dts:%s cur_dts:%s\n", "first_dts %s but no packet with dts in the queue\n", "index == 0 || ie[-1].timestamp < timestamp", "Protocol name not provided, cannot determine if input is local or a network protocol, buffers and access patterns cannot be configured optimally without knowing the protocol\n", "Reconfiguring buffers to size %lld\n", "pos_min=0x%llx pos_max=0x%llx dts_min=%s dts_max=%s\n", "%lld %lld %lld / %s %s %s target:%s limit:%lld start:%lld noc:%d\n", "read_timestamp() failed in the middle\n", "using cached pos_min=0x%llx dts_min=%s\n", "using cached pos_max=0x%llx pos_limit=0x%llx dts_max=%s\n", "Failed to read extradata of size %d\n", "Setting avg frame rate based on r frame rate\n", "Dropped corrupted packet (stream = %d)\n", "Failed to reallocate probe buffer for stream %d\n", "Invalid timestamps stream=%d, pts=%s, dts=%s, size=%d\n", "ff_read_packet stream=%d, pts=%s, dts=%s, size=%d, duration=%d, flags=%d\n", "parser not found for codec %s, packets or times may be invalid.\n", "demuxer injecting skip %d / discard %d\n", "Could not inject global side data\n", "read_frame_internal stream=%d, pts=%s, dts=%s, size=%d, duration=%d, flags=%d\n", "seek_frame_generic failed as this stream seems to contain no keyframes after the target timestamp, %d non keyframes found\n", "Ignoring outlier non primary stream starttime %f\n", "unspecified number of channels", "no frame in rv30/40 and no sar", "Before avformat_find_stream_info() pos: %lld bytes read:%lld seeks:%d\n", "Failed to open codec in av_find_stream_info\n", "Probe buffer size limit of %lld bytes reached\n", "Stream #%d: not enough frames to estimate rate; consider increasing probesize\n", "Non-increasing DTS in stream %d: packet %d with DTS %lld, packet %d with DTS %lld\n", "DTS discontinuity in stream %d: packet %d with DTS %lld, packet %d with DTS %lld\n", "max_analyze_duration %lld reached at %lld microseconds st:%d\n", "decoding for stream %d failed\n", "start time for stream %d is not set in estimate_timings_from_pts\n", "stream %d : no PTS found at end of file, duration not set\n", "stream %d : no TS found at start of file, duration not set\n", "Estimating duration from bitrate, this may be inaccurate\n", "stream: start_time: %0.3f duration: %0.3f bitrate=%d kb/s\n", "%d: start_time: %0.3f duration: %0.3f\n", "After avformat_find_stream_info() pos: %lld bytes read:%lld seeks:%d frames:%d\n", "Could not find codec parameters for stream %d (%s): %s\nConsider increasing the value for the 'analyzeduration' and 'probesize' options\n", "s->streams[ s->nb_streams - 1 ] == st", "Chapter end time %lld before start %lld\n", "Input context has not been properly allocated by avformat_alloc_context() and is not NULL either\n", "Custom AVIOContext makes no sense and will be ignored with AVFMT_NOFILE format.\n", "demuxer does not support additional id3 data, skipping\n", "st:%d removing common factor %d from timebase\n", "st:%d has too large timebase, reducing\n", "Ignoring attempt to set invalid timebase %d/%d for st:%d\n", "Invalid stream specifier: %s.\n", "0x%016llX%016llX%016llX%016llX", "0x%016llX%016llX%016llX%016llX%016llX%016llX%016llX%016llX", "invalid start code %s in RIFF header\n", "invalid format in RIFF header\n", "negative data_size and/or sample_count in ds64: data_size = %lld, sample_count = %lld\n", "found no 'fmt ' tag before the 'data' tag\n", "Ignoring maximum wav data size, file may be invalid\n", "found no 'fmt ' tag before the 'SMV0' tag\n", "Could not allocate extradata.\n", "ignoring wrong sample_count %lld\n", "found more than one 'fmt ' tag\n", "Writing local time and date to Peak Envelope Chunk\n", "Filesize %lld invalid for wav, output file will be broken\n", "WAVE files have exactly one stream\n", "%s codec not supported in WAVE format\n", "%s codec not supported for Peak Chunk\n", "Writing 16 bit peak for 8 bit audio does not make sense\n", "Append peak chunk after wav data.", "Write only peak chunk, omit wav data.", "Use RF64 header rather than RIFF for large files.", "Write RF64 header if file grows large enough.", "Always write RF64 header regardless of file size.", "Never write RF64 header regardless of file size.", "Number of audio samples used to generate each peak frame.", "The format of the peak envelope data (1: uint8, 2: uint16).", "Number of peak points per peak value (1 or 2).", "Single channel layout '%.*s' is interpreted as a number of channels, switch to the syntax '%.*sc' otherwise it will be interpreted as a channel layout number in a later version\n", "MMX implied by specified flags\n", "Internal bug, should not have happened", "Generic error in an external library", "Invalid data found when processing input", "Not yet implemented in FFmpeg, patches welcome", "Server returned 400 Bad Request", "Server returned 401 Unauthorized (authorization failed)", "Server returned 403 Forbidden (access denied)", "Server returned 4XX Client Error, but not one of 40{0,1,3,4}", "Server returned 5XX Server Error reply", "Undefined constant or missing '(' in '%s'\n", "Missing ')' or too many args in '%s'\n", "Invalid chars '%s' at the end of expression '%s'\n", "Error occurred in fstat(): %s\n", "ff_tempfile: Cannot allocate file name\n", "ff_tempfile: Cannot open temporary file %s\n", "ATSC A53 Part 4 Closed Captions", "Metadata relevant to a downmix procedure", "Picture size %ux%u is invalid\n", "abs(src_linesize) >= bytewidth", "abs(dst_linesize) >= bytewidth", "    Last message repeated %d times\r", "    Last message repeated %d times\n", " is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\n", "in_ts != ((int64_t)0x8000000000000000ULL)", "Value %f for parameter '%s' out of range [%g - %g]\n", "Value %f for parameter '%s' is not a valid set of 32bit integer flags\n", "Unable to parse option value \"%s\" as %s\n", "Value %d for parameter '%s' out of %s format range [%d - %d]\n", "Unable to parse option value \"%s\" as color\n", "Unable to parse option value \"%s\" as image size\n", "Unable to parse option value \"%s\" as video rate\n", "AVOption type %d of option %s not implemented yet\n", "The value set by option '%s' is not an image size.\n", "Invalid negative size value %dx%d for size '%s'\n", "The value set by option '%s' is not a video rate.\n", "The value set by option '%s' is not a %s format", "The value set by option '%s' is not a channel layout.\n", "The value for option '%s' is not an image size.\n", "The value for option '%s' is not a %s format.\n", "The value for option '%s' is not a channel layout.\n", "const_values array too small for %s\n", "Unable to parse option value \"%s\"\n", "Unable to parse option value \"%s\" as duration\n", "Unable to parse option value \"%s\" as channel layout\n", "Missing key or no key/value separator found after key '%s'\n", "Setting entry with key '%s' to value '%s'\n", "Error setting option %s to value %s.\n", "Not supported option type: %d, option name: %s\n", "Invalid 0xRRGGBB[AA] color string: '%s'\n", "Invalid alpha value specifier '%s' in '%s'\n", "(d->nb_components==4 || d->nb_components==2) == !!(d->flags & (1 << 7))", "!c->plane && !c->step_minus1 && !c->offset_plus1 && !c->shift && !c->depth_minus1", "c->step_minus1 >= c->depth_minus1", "8*(c->step_minus1+1) >= c->depth_minus1+1", "Timecode frame rate must be specified\n", "Drop frame is only allowed with 30000/1001 or 60000/1001 FPS\n", "Timecode frame rate %d/%d not supported\n", "Unable to parse timecode, syntax: hh:mm:ss[:;.]ff\n", "ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "libavutil license: GPL version 2 or later", "ctx->channels == out->ch_count", "s->dither.method < SWR_DITHER_NB", "Requested noise shaping dither not available at this sampling rate, using triangular hp dither\n", "select triangular dither with high pass", "select lipshitz noise shaping dither", "select shibata noise shaping dither", "select low shibata noise shaping dither", "select high shibata noise shaping dither", "select f-weighted noise shaping dither", "select modified-e-weighted noise shaping dither", "select improved-e-weighted noise shaping dither", "set swr resampling filter size", "set swr resampling phase shift", "set soxr resampling precision (in bits)", "enable soxr Chebyshev passband & higher-precision irrational ratio approximation", "set minimum difference between timestamps and audio data (in seconds) below which no timestamp compensation of either kind is applied", "set minimum difference between timestamps and audio data (in seconds) to trigger padding/trimming the data.", "set duration (in seconds) over which data is stretched/squeezed to make it match the timestamps.", "set maximum factor by which data is stretched/squeezed to make it match the timestamps.", "simplified 1 parameter audio timestamp matching, 0(disabled), 1(filling and trimming), >1(maximum stretch/squeeze in samples per second)", "Assume the first pts should be this value (in samples).", "select Blackman Nuttall Windowed Sinc", "set swr number of output sample bits", "Input channel layout '%s' is not supported\n", "Output channel layout '%s' is not supported\n", "!s->out_ch_layout || out->ch_count == av_get_channel_layout_nb_channels(s->out_ch_layout)", "!s-> in_ch_layout || in ->ch_count == av_get_channel_layout_nb_channels(s-> in_ch_layout)", "libswresample license: GPL version 2 or later", "Requested input sample format %d is invalid\n", "Requested output sample format %d is invalid\n", "Input channel layout 0x%llx is invalid or unsupported.\n", "Output channel layout 0x%llx is invalid or unsupported.\n", "Requested resampling engine is unavailable\n", "Input channel layout has a different number of channels than the number of used channels, ignoring layout\n", "Using %s internally between filters\n", "Requested sample format %s is not supported internally, S16/S32/FLT/DBL is supported\n", "Failed to initialize resampler\n", "Resampling only supported with internal s16/s32/flt/dbl\n", "Input channel count and layout are unset\n", "Output channel layout %s mismatches specified channel count %d\n", "Input channel layout %s mismatches specified channel count %d\n", "Rematrix is needed between %s and %s but there is not enough information to do it\n", "s->midbuf.ch_count == s->used_ch_count", "s->midbuf.ch_count == s->out.ch_count", "s->dither.noise.ch_count == preout->ch_count", "Context has not been initialized\n", "adding %d audio samples of silence\n", "s->out_sample_rate == s->in_sample_rate", "Failed to compensate for timestamp delta of %f\n", "compensating audio timestamp drift:%f compensation:%d in:%d\n", "plane_count == nb_components - 1", "source vertical chroma position in luma grid/256", "source horizontal chroma position in luma grid/256", "destination vertical chroma position in luma grid/256", "destination horizontal chroma position in luma grid/256", "n == s->plane[ii].available_lines", "Warning: dstStride is not aligned!\n         ->cannot do aligned memory accesses anymore\n", "Warning: data is not aligned! This can lead to a speedloss\n", "firstLumSrcY >= lastInLumBuf - vLumBufSize + 1", "firstChrSrcY >= lastInChrBuf - vChrBufSize + 1", "One of the input parameters to sws_scale() is NULL, please check the calling code\n", "unsupported planar RGB conversion %s -> %s\n", "unsupported conversion to planar RGB %s -> %s\n", "internal error %s -> %s converter\n", "SwScaler: reducing / aligning filtersize %d -> %d\n", "(*filterPos)[i] + j < srcW || !filter[i * filterSize + j]", "SwScaler: zero vector in scaling\n", "libswscale license: GPL version 2 or later", "deprecated pixel format used, make sure you did set range correctly\n", "%s is not supported as input pixel format\n", "%s is not supported as output pixel format\n", "Exactly one scaler algorithm must be chosen, got %X\n", "%dx%d -> %dx%d is invalid scaling dimension\n", "Forcing full internal H chroma due to odd output size\n", "Forcing full internal H chroma due to input having non subsampled chroma\n", "Desired dithering only supported in full chroma interpolation for destination format '%s'\n", "Ordered dither is not supported in full chroma interpolation for destination format '%s'\n", "%s output is not supported with half chroma resolution, switching to full\n", "full chroma interpolation for destination format '%s' not yet implemented\n", "output width is not a multiple of 32 -> no MMXEXT scaler\n", "Failed to allocate MMX2FilterCode\n", "mprotect failed, cannot use fast bilinear scaler\n", "lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n", "chr srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n", "using alpha blendaway %s -> %s special converter\n", "using unscaled %s -> %s special converter\n", "YUV color matrix differs for YUV->YUV, using intermediate RGB to convert\n", "luma bicubic / chroma bilinear", "No accelerated colorspace conversion found from %s to %s.\n", "%ibpp not supported by yuv2rgb\n", "Visualization is currently only supported with the accurate deblock filter without SIMD\n", "libpostproc license: GPL version 2 or later", "%d errors in postprocess string \"%s\"\n", "audio_convert: found function: %-4s to %-4s (%s)\n", "%d samples - audio_convert: %s to %s (dithered)\n", "%d samples - audio_convert: %s to %s (%s)\n", "cannot remap packed format during conversion\n", "invalid NULL pointer for src[%d]\n", "cannot remap packed format during copy\n", "offset out-of-bounds: src=%d dst=%d\n", "audio_mix: found function: [fmt=%s] [c=%s] %s(%s)\n", "audio_mix: %d samples - %d to %d channels (%s)\n", "audio_mix: NO FUNCTION FOUND: [fmt=%s] [c=%s] [%d to %d]\n", "Unsupported internal format for mixing: %s\n", "dithering %s to %s is not supported\n", "sample rate must be 48000 or 44100 Hz for triangular_ns dither. using triangular_hp instead.\n", "Blackman Nuttall Windowed Sinc", "Triangular Dither With High Pass", "Triangular Dither With Noise Shaping", "Unsupported internal format for resampling: %s\n", "resample: %s from %d Hz to %d Hz\n", "Error reallocating resampling buffer\n", "resampled %d in + %d leftover to %d out + %d leftover\n", "The resampling context is already open.\n", "Invalid input channel layout: %llu\n", "Invalid output channel layout: %llu\n", "Using %s as internal sample format\n", "remap channels during in_copy\n", "remap channels during in_convert\n", "remap channels during out_convert\n", "remap channels during out_copy\n", "[FIFO] read from out_fifo to output\n", "libavresample license: GPL version 2 or later", "./libswscale/swscale_internal.h", "%s profile doesn't support lossless\n", "%s profile doesn't support 4:4:4\n", "%s profile doesn't support 4:2:2\n", "baseline profile doesn't support interlacing\n", "baseline profile doesn't support fake interlacing\n", "only 1 psy tuning can be used: ignoring tune %s\n", " b_pyramid=%d b_adapt=%d b_bias=%d direct=%d weightb=%d open_gop=%d", " keyint_min=%d scenecut=%d intra_refresh=%d", " qcomp=%.2f qpmin=%d qpmax=%d qpstep=%d", " vbv_maxrate=%d vbv_bufsize=%d", "x264 - core %d%s - H.264/MPEG-4 AVC codec - Copy%s 2003-2016 - http://www.videolan.org/x264.html - options: %s", "AVC-Intra SEI is too large (%d)\n", "frame MB size (%dx%d) > level limit (%d)\n", "DPB size (%d frames, %d mbs) > level limit (%d frames, %d mbs)\n", "VBV bitrate (%lld) > level limit (%d)\n", "VBV buffer (%lld) > level limit (%d)\n", "MV range (%lld) > level limit (%d)\n", "interlaced (%lld) > level limit (%d)\n", "fake interlaced (%lld) > level limit (%d)\n", "MB rate (%lld) > level limit (%d)\n", "pf_log not set! did you forget to call x264_param_default?\n", "invalid width x height (%dx%d)\n", "invalid CSP (only I420/YV12/NV12/NV21/I422/YV16/NV16/I444/YV24/BGR/BGRA/RGB supported)\n", "width not divisible by %d (%dx%d)\n", "height not divisible by %d (%dx%d)\n", "invalid crop-rect %u,%u,%u,%u\n", "crop-rect %u,%u,%u,%u not divisible by %dx%d\n", "OpenCL: frame size is too small, disabling opencl\n", "OpenCL: device id and device skip count configured; dropping skip\n", "ignoring unknown frame packing value\n", "cropped resolution %dx%d not compatible with tile format frame packing\n", "broken ffmpeg default settings detected\n", "use an encoding preset (e.g. -vpre medium)\n", "preset usage: -vpre <speed> -vpre <profile>\n", "speed presets are listed in x264 --help\n", "profile is optional; x264 defaults to high\n", "no ratecontrol method specified\n", "%2d-bit AVC-Intra is not widely compatible\n", "10-bit x264 is required to encode AVC-Intra\n", "VBV is incompatible with constant QP, ignored.\n", "VBV maxrate unspecified, assuming CBR\n", "VBV bufsize set but maxrate unspecified, ignored\n", "max bitrate less than average bitrate, assuming CBR\n", "VBV maxrate specified, but no bufsize, ignored\n", "interlace + slice-min-mbs is not implemented\n", "slice-min-mbs > row mb size (%d) not implemented\n", "subme=0 + direct=temporal is not supported\n", "b-pyramid normal + intra-refresh is not supported\n", "ref > 1 + intra-refresh is not supported\n", "intra-refresh is not compatible with open-gop\n", "lookaheadless mb-tree requires intra refresh or infinite keyint\n", "--%s used with psy on: results will be invalid!\n", "--ssim used with AQ off: results will be invalid!\n", "--psnr used with AQ on: results will be invalid!\n", "interlace + me=esa is not implemented\n", "interlace + weightp is not implemented\n", "NAL HRD parameters require VBV parameters\n", "CBR HRD requires constant bitrate\n", "--tune %s should be used if attempting to benchmark %s!\n", "cannot create valid sample aspect ratio\n", "invalid DTS: PTS is less than DTS\n", "frame=%4d QP=%.2f NAL=%d Slice:%c Poc:%-3d I:%-4d P:%-4d SKIP:%-4d size=%d bytes%s\n", "slice-max-size violated (frame %d, cause: slice-min-mbs)\n", "Effective timebase denominator %u exceeds H.264 maximum\n", "MV cost test failed: x264 has been miscompiled!\n", "CLZ test failed: x264 has been miscompiled!\n", "Are you attempting to run an SSE4a/LZCNT-targeted build on a CPU that\n", "dump_yuv: incompatible with non-regular file %s\n", "profile %s, level %s, %s %d-bit\n", "x264_encoder_invalidate_reference is not supported with B-frames enabled\n", "x264_encoder_invalidate_reference is not supported with intra refresh enabled\n", "lookahead thread is already stopped\n", "h->i_ref[0] + h->i_ref[1] <= X264_REF_MAX", "x264_clip3( denom, 0, 7 ) == denom", "h->sh.weight[j][i].i_denom == denom", "h->thread[i]->fenc->i_reference_count == 1", "frame %c:%-5d Avg QP:%5.2f  size:%6.0f  PSNR Mean Y:%5.2f U:%5.2f V:%5.2f Avg:%5.2f Global:%5.2f\n", "frame %c:%-5d Avg QP:%5.2f  size:%6.0f\n", "mb P  %s  P16..4: %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%%    skip:%4.1f%%\n", "  B16..8: %4.1f%% %4.1f%% %4.1f%%  direct:%4.1f%%  skip:%4.1f%%", "  L0:%4.1f%% L1:%4.1f%% BI:%4.1f%%", "direct mvs  spatial:%.1f%% temporal:%.1f%%\n", "coded y,%s,%s intra: %.1f%% %.1f%% %.1f%%%s\n", "i16 v,h,dc,p: %2.0f%% %2.0f%% %2.0f%% %2.0f%%\n", "i%d v,h,dc,ddl,ddr,vr,hd,vl,hu: %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%% %2.0f%%\n", "i8c dc,h,v,p: %2.0f%% %2.0f%% %2.0f%% %2.0f%%\n", "Weighted P-Frames: Y:%.1f%% UV:%.1f%%\n", "PSNR Mean Y:%6.3f U:%6.3f V:%6.3f Avg:%6.3f Global:%6.3f kb/s:%.2f\n", "(*frame)->i_reference_count > 0", "I16..4%s: %4.1f%% %4.1f%% %4.1f%%", "OpenCL: fatal error, aborting encode\n", "OpenCL: Unable to query installed platforms\n", "OpenCL: malloc of installed platforms buffer failed\n", "OpenCL: %s does not support required image formats\n", "OpenCL: Unable to find a compatible device\n", "ADL_Adapter_NumberOfAdapters_Get", "OpenCL acceleration enabled with %s %s %s\n", "OpenCL: unable to create program\n", "OpenCL: unable to open clbin file for write\n", "OpenCL: Unable to query program binary size, no cache file generated\n", "OpenCL: Unable to query program binary, no cache file generated\n", "OpenCL: Compilation failed, unable to query build log\n", "OpenCL: Compilation failed, unable to alloc build log\n", "OpenCL: Compilation failed, unable to get build log\n", "OpenCL: Compilation failed, unable to create file x264_kernel_build_log.txt\n", "OpenCL: kernel build errors written to x264_kernel_build_log.txt\n", "OpenCL: Unable to compile kernel '%s' (%d)\n", "OpenCL: Unable to allocate page-locked buffer, error '%d'\n", "OpenCL: Unable to map page-locked buffer, error '%d'\n", "OpenCL acceleration disabled, switchable graphics detected\n", "dist_scale_factor >= -63 && dist_scale_factor <= 127", "This build of x264 requires 8-bit input. Rebuild to support high depth input.\n", "v210 input is only compatible with bit-depth of 10 bits\n", "forced frame type (%d) at %d is unknown\n", "Input picture width (%d) is greater than stride (%d)\n", "not enough coefficients in list '%s'\n", "Impossible QP constraints for CQM (min=%d, max=%d)\n", "internal error P_L0 and partition=%d\n", "internal error (invalid MB type)\n", "internal error (MV out of thread range)\n", "recovering by using intra mode\n", "h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1", "a->l0.me16x16.mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1", "internal error (!8x8 && !4x4)\n", "scene cut at %d Icost:%d Pcost:%d ratio:%.4f bias:%.4f gop:%d (imb:%d pmb:%d)\n", "forced frame type (%d) at %d was changed to frame type (%d)\n", "B-ref at frame %d incompatible with B-pyramid %s \n", "B-ref at frame %d incompatible with B-pyramid %s and %d reference frames\n", "specified frame type (%d) at %d is not compatible with keyframe interval\n", "specified frame type is not compatible with max B-frames\n", "slice=%c but 2pass stats say %c\n", "MB-tree frametype %d doesn't match actual frametype %d.\n", "Incomplete MB-tree stats file.\n", "VBV buffer size cannot be smaller than one frame, using %d kbit\n", "VBV parameters cannot be changed when NAL HRD is in use\n", "CRF max must be greater than CRF\n", "constant rate-factor is incompatible with 2pass.\n", "HRD with very large timescale and bufsize not supported\n", "bitrate tolerance too small, using .01\n", "invalid zone: start=%d end=%d\n", "invalid zone: bitrate_factor=%f\n", "ratecontrol_init: can't open stats file\n", "ratecontrol_init: can't open mbtree stats file\n", "options list in stats file not valid\n", "resolution specified in stats file not valid\n", "timebase specified in stats file not valid\n", "timebase mismatch with 1st pass (%u/%u vs %u/%u)\n", "different bitdepth setting than first pass (%d vs %d)\n", "different weightp setting than first pass (%d vs %d)\n", "different bframes setting than first pass (%d vs %d)\n", "different b_pyramid setting than first pass (%d vs %d)\n", "different intra_refresh setting than first pass (%d vs %d)\n", "different open_gop setting than first pass (%d vs %d)\n", "different bluray_compat setting than first pass (%d vs %d)\n", "different interlaced setting than first pass (%s vs %s)\n", "different keyint setting than first pass (%.*s vs %.*s)\n", "1st pass was lossless, bitrate prediction will be inaccurate\n", "direct=auto not used on the first pass\n", "b_adapt method specified in stats file not valid\n", "2nd pass has fewer frames than 1st pass (%d vs %d)\n", "2nd pass has more frames than 1st pass (%d vs %d)\n", "bad frame number (%d) at stats line %d\n", "bad frame output number (%d) at stats line %d\n", " in:%*d out:%*d type:%c dur:%lld cpbdur:%lld q:%f aq:%f tex:%d mv:%d misc:%d imb:%d pmb:%d smb:%d d:%c", "w:%hd,%hd,%hd,%hd,%hd,%hd,%hd,%hd", "requested bitrate is too low. estimated minimum is %d kbps\n", "vbv-maxrate issue, qpmax or vbv-maxrate too low\n", "Error: 2pass curve failed to converge\n", "target: %.2f kbit/s, expected: %.2f kbit/s, avg QP: %.4f\n", "try reducing target bitrate or reducing qp_min (currently %d)\n", "try increasing target bitrate or increasing qp_max (currently %d)\n", "try increasing target bitrate\n", "failed to rename \"%s\" to \"%s\"\n", "frame >= 0 && frame < rc->num_entries", "2nd pass has more frames than 1st pass (%d)\n", "continuing anyway, at constant QP=%d\n", "in:%d out:%d type:%c dur:%lld cpbdur:%lld q:%.2f aq:%.2f tex:%d mv:%d misc:%d imb:%d pmb:%d smb:%d d:%c ref:", "VBV underflow due to CRF-max (frame %d, %.0f bits)\n", "VBV underflow (frame %d, %.0f bits)\n", "ratecontrol_end: stats file could not be written to\n", "CPB %s: %.0f bits in a %.0f-bit buffer\n", "clEnqueueWriteBuffer error '%d'\n", "clEnqueueNDRangeKernel error '%d'\n", "clEnqueueReadBuffer error '%d'\n", "clEnqueueCopyBuffer error '%d'\n", "33s?", "6<5?", "))/113//+++((", "GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "ImageWidth", "Gray", "I420", "IYUV", "YV16\f", "I420\f", "IYUV\f", "YV12\r", "Y42B\r", "YUNVw", "NV21.", "RGB\f@", "BGR\f?", "\fBGRA", "422P\r", "422P!", "440P\"", "444P\t", "B1W0\n", "R4BY*", "RGB0)", "0RGBD", "BGR0C", "0BGR ", "Y3\u000b\nG", "\n\u000b3YJ", "Y3\n\nI", "\n\n3YN", "Y4\u000b\t[", "\t\u000b4Y^", "Y4\n\t]", "\t\n4Y`", "Y4\u000b\na", "\n\u000b4Yd", "Y4\n\nc", "\n\n4Yf", "XYZ$o", "DVOO.", "L555,", "L565+", "b16g)", "b48r,", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "EF G A BC D ", "image/gif", "image/jpeg", "image/jpg", "image/png", "image/tiff", "image/bmp", "TDATTIMETORYTRDATSIZTYER", "TDENTDORTDRCTDRLTDTGTIPLTMCLTMOOTPROTSOATSOPTSOTTSST", "TALBTBPMTCOMTCONTCOPTDLYTENCTEXTTFLTTIT1TIT2TIT3TKEYTLANTLENTMEDTOALTOFNTOLYTOPETOWNTPE1TPE2TPE3TPE4TPOSTPUBTRCKTRSNTRSOTSRCTSSE", "tx3g806cc608", "sac3", "alac", ".mp1", "twos", "lpcm", "lpcm\r", "in24\f", "in24\t", "WMA2cvessevcvmssssmv", "dmb1\t", "SVQ3\r", "mp4v\r", "DIVX\r", "XVID\r", "VP31+", "rpza,", "cvid1", "8BPS2", "smc 8", "rle RIGSrle1.", "WRLE;", "mp2vY", "mjp2^", "tga a", "tiffb", "gif >", "png >", "MNG G", "vc-1X", "avs2u", "dracd", "AVupf", "ap4x3", "HapY", "562H#", "avc1k", "VP6A]", "VP6F", "avc1\r", "mp4a", "tx3g", "avc1\r", "text", "Lavf", "3DIT", "drac", "HEVC", "AVLKVC-1", "SUPO", "XTDB", "562HB", "CNOSH ", "LNOSH ", "U263\r", "FMP4\r", "DIVX\r", "DX50\r", "XVID\r", "MP4S\r", "M4S2\r", "ZMP4\r", "DIV1\r", "BLZ0\r", "mp4v\r", "UMP4\r", "WV1F\r", "SEDG\r", "RMP4\r", "3IV2\r", "WAWV\r", "FFDS\r", "FVFW\r", "DCOD\r", "MVXM\r", "PM4V\r", "SMP4\r", "DXGM\r", "VIDM\r", "M4T3\r", "GEOX\r", "G264\r", "HDX4\r", "DM4V\r", "DMK2\r", "DYM4\r", "DIGI\r", "EPHV\r", "EM4A\r", "M4CC\r", "SN40\r", "VSPX\r", "ULDX\r", "GEOV\r", "SIPP\r", "SM4V\r", "XVIX\r", "DreX\r", "QMP4\r", "PLV1\r", "GLV4\r", "GMP4\r", "mjpa\n", "JPGL\f", "MJLS\f", "HFYUD", "IV32p", "IV41q", "VP30[", "VP50\\", "VP60\\", "VP61\\", "VP62k", "VP6A]", "VP6F]", "VP90 ", "ASV1!", "ASV2$", "VCR1\"", "FFV1*", "Xxanr", "LM20.", "mrle.", "MSVC/", "msvc/", "CRAM/", "cram/", "WHAM/", "wham,", "cvid4", "DUCK4", "PVEZ6", "MSZH7", "ZLIBWONSSNOW#", "S263W", "svq19", "tscc:", "ULTI<", "VIXL=", "QPEG=", "Q1.0=", "Q1.1H", "WMVPG", "WVC1G", "WVP2I", "LOCOJ", "WNV1J", "YUV8K", "AAS4K", "AASCL", "RT21M", "theoN", "TM20P", "CSCDR", "ZMBVV", "KMVCX", "CAVSY", "mjp2Y", "MJ2CY", "LJ2CY", "LJ2KY", "IPJ2Z", "VMnc^", "tga >", "MPNG>", "PNG1>", "png %", "CLJRu", "drac+", "azpr+", "RPZA+", "rpza\u000b", "SP54|", "AURA}", "LAGSl", "ZECOP14YY41P3", "SVQ3V210012vV210a12vM2G", "G2M2M2G", "G2M3M2G", "G2M4M2G", "CUVC", "IARL", "IART", "ICMS", "ICMT", "ICOP", "ICRD", "ICRP", "IDIM", "IDPI", "IENG", "IGNR", "IKEY", "ILGT", "ILNG", "IMED", "INAM", "IPLT", "IPRD", "IPRT", "ITRK", "ISBJ", "ISFT", "ISHP", "ISMP", "ISRC", "ISRF", "ITCH", "PCMU", "G723", "DVI4", "DVI4", "PCMA", "G722", "QCELP", "G728", "DVI4", "DVI4", "G729", "CelB", "JPEG", "H261", "MP2T", "H263", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "s16p", "s32p", "fltp", "dblp", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "<fBBf<", "fffffff", "fff$", "000`", "<00000000<", "<\f\f\f\f\f\f\f\f<", "<ll>", "8ll8", "8ll8", "|||||||", "<fBBf<", "0xx00", "x00000x", "x`````x", "p000x", "p00000x", "p000x", "p000x", "p000x", "<ll>", "8ll8", "8ll8", "<<<<", "Available postprocessing filters:\nFilters                        Options\nshort  long name       short   long option     Description\n*      *               a       autoq           CPU power dependent enabler\n                       c       chrom           chrominance filtering enabled\n                       y       nochrom         chrominance filtering disabled\n                       n       noluma          luma filtering disabled\nhb     hdeblock        (2 threshold)           horizontal deblocking filter\n       1. difference factor: default=32, higher -> more deblocking\n       2. flatness threshold: default=39, lower -> more deblocking\n                       the h & v deblocking filters share these\n                       so you can't set different thresholds for h / v\nvb     vdeblock        (2 threshold)           vertical deblocking filter\nha     hadeblock       (2 threshold)           horizontal deblocking filter\nva     vadeblock       (2 threshold)           vertical deblocking filter\nh1     x1hdeblock                              experimental h deblock filter 1\nv1     x1vdeblock                              experimental v deblock filter 1\ndr     dering                                  deringing filter\nal     autolevels                              automatic brightness / contrast\n                       f        fullyrange     stretch luminance to (0..255)\nlb     linblenddeint                           linear blend deinterlacer\nli     linipoldeint                            linear interpolating deinterlace\nci     cubicipoldeint                          cubic interpolating deinterlacer\nmd     mediandeint                             median deinterlacer\nfd     ffmpegdeint                             ffmpeg deinterlacer\nl5     lowpass5                                FIR lowpass deinterlacer\nde     default                                 hb:a,vb:a,dr:a\nfa     fast                                    h1:a,v1:a,dr:a\nac                                             ha:a:128:7,va:a,dr:a\ntn     tmpnoise        (3 threshold)           temporal noise reducer\n                     1. <= 2. <= 3.            larger -> stronger filtering\nfq     forceQuant      <quantizer>             force quantizer\nUsage:\n<filterName>[:<option>[:<option>...]][[,|/][-]<filterName>[:<option>...]]...\nlong form example:\nvdeblock:autoq/hdeblock:autoq/linblenddeint    default,-vdeblock\nshort form example:\nvb:a/hb:a/lb                                   de,-vb\nmore examples:\ntn:64:128:256\n\n", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "x264_slice_header_write", "x264_weighted_pred_init", "x264_reference_build_list", "c8ef3d10dedcd2579b7ae8c9f0d18028", "#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\nconstant sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n/* 7.18.1.1  Exact-width integer types */\ntypedef signed char int8_t;\ntypedef unsigned char   uint8_t;\ntypedef short  int16_t;\ntypedef unsigned short  uint16_t;\ntypedef int  int32_t;\ntypedef unsigned   uint32_t;\ntypedef uint8_t  pixel;\ntypedef uint16_t sum_t;\ntypedef uint32_t sum2_t;\n#define LOWRES_COST_MASK ((1<<14)-1)\n#define LOWRES_COST_SHIFT 14\n#define COST_MAX (1<<28)\n#define PIXEL_MAX 255\n#define BITS_PER_SUM (8 * sizeof(sum_t))\n/* Constants for offsets into frame statistics buffer */\n#define COST_EST    0\n#define COST_EST_AQ 1\n#define INTRA_MBS   2\n#define COPY2_IF_LT( x, y, a, b )\\\nif((y)<(x))\\\n{\\\n(x) = (y);\\\n(a) = (b);\\\n}\nconstant int2 dia_offs[4] =\n{\n{0, -1}, {-1, 0}, {1, 0}, {0, 1},\n};\ninline pixel x264_clip_pixel( int x )\n{\nreturn (pixel) clamp( x, (int) 0, (int) PIXEL_MAX );\n}\ninline int2 x264_median_mv( short2 a, short2 b, short2 c )\n{\nshort2 t1 = min(a, b);\nshort2 t2 = min(max(a, b), c);\nreturn convert_int2(max(t1, t2));\n}\ninline sum2_t abs2( sum2_t a )\n{\nsum2_t s = ((a >> (BITS_PER_SUM - 1)) & (((sum2_t)1 << BITS_PER_SUM) + 1)) * ((sum_t)-1);\nreturn (a + s) ^ s;\n}\n#define HADAMARD4( d0, d1, d2, d3, s0, s1, s2, s3 ) {\\\nsum2_t t0 = s0 + s1;\\\nsum2_t t1 = s0 - s1;\\\nsum2_t t2 = s2 + s3;\\\nsum2_t t3 = s2 - s3;\\\nd0 = t0 + t2;\\\nd2 = t0 - t2;\\\nd1 = t1 + t3;\\\nd3 = t1 - t3;\\\n}\n#define HADAMARD4V( d0, d1, d2, d3, s0, s1, s2, s3 ) {\\\nint2 t0 = s0 + s1;\\\nint2 t1 = s0 - s1;\\\nint2 t2 = s2 + s3;\\\nint2 t3 = s2 - s3;\\\nd0 = t0 + t2;\\\nd2 = t0 - t2;\\\nd1 = t1 + t3;\\\nd3 = t1 - t3;\\\n}\n#define SATD_C_8x4_Q( name, q1, q2 )\\\nint name( q1 pixel *pix1, int i_pix1, q2 pixel *pix2, int i_pix2 )\\\n{\\\nsum2_t tmp[4][4];\\\nsum2_t a0, a1, a2, a3;\\\nsum2_t sum = 0;\\\nfor( int i = 0; i < 4; i++, pix1 += i_pix1, pix2 += i_pix2 )\\\n{\\\na0 = (pix1[0] - pix2[0]) + ((sum2_t)(pix1[4] - pix2[4]) << BITS_PER_SUM);\\\na1 = (pix1[1] - pix2[1]) + ((sum2_t)(pix1[5] - pix2[5]) << BITS_PER_SUM);\\\na2 = (pix1[2] - pix2[2]) + ((sum2_t)(pix1[6] - pix2[6]) << BITS_PER_SUM);\\\na3 = (pix1[3] - pix2[3]) + ((sum2_t)(pix1[7] - pix2[7]) << BITS_PER_SUM);\\\nHADAMARD4( tmp[i][0], tmp[i][1], tmp[i][2], tmp[i][3], a0, a1, a2, a3 );\\\n}\\\nfor( int i = 0; i < 4; i++ )\\\n{\\\nHADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );\\\nsum += abs2( a0 ) + abs2( a1 ) + abs2( a2 ) + abs2( a3 );\\\n}\\\nreturn (((sum_t)sum) + (sum>>BITS_PER_SUM)) >> 1;\\\n}\n/*\n* Utility function to perform a parallel sum reduction of an array of integers\n*/\nint parallel_sum( int value, int x, volatile local int *array )\n{\narray[x] = value;\nbarrier( CLK_LOCAL_MEM_FENCE );\nint dim = get_local_size( 0 );\nwhile( dim > 1 )\n{\ndim >>= 1;\nif( x < dim )\narray[x] += array[x + dim];\nif( dim > 32 )\nbarrier( CLK_LOCAL_MEM_FENCE );\n}\nreturn array[0];\n}\nint mv_cost( uint2 mvd )\n{\nfloat2 mvdf = (float2)(mvd.x, mvd.y) + 1.0f;\nfloat2 cost = round( log2(mvdf) * 2.0f + 0.718f + (float2)(!!mvd.x, !!mvd.y) );\nreturn (int) (cost.x + cost.y);\n}\n/* Mode selection routines, select the least SATD cost mode for each lowres\n* macroblock.  When measuring B slices, this includes measuring the cost of\n* three bidir modes.  */\n/* Four threads cooperatively measure 8x8 BIDIR cost with SATD */\nint bidir_satd_8x8_ii_coop4( read_only image2d_t fenc_lowres,\nint2 fencpos,\nread_only image2d_t fref0_planes,\nint2 qpos0,\nread_only image2d_t fref1_planes,\nint2 qpos1,\nint weight,\nlocal sum2_t *tmpp,\nint idx )\n{\nvolatile local sum2_t( *tmp )[4] = (volatile local sum2_t( * )[4])tmpp;\nsum2_t b0, b1, b2, b3;\nsum2_t sum = 0;\nint2 fref0Apos = (int2)(qpos0.x>>2, qpos0.y>>2);\nint hpel0A = ((qpos0.x&2)>>1) + (qpos0.y&2);\nint2 qpos0B = (int2)qpos0 + (int2)(((qpos0.x&1)<<1), ((qpos0.y&1)<<1));\nint2 fref0Bpos = (int2)(qpos0B.x>>2, qpos0B.y>>2);\nint hpel0B = ((qpos0B.x&2)>>1) + (qpos0B.y&2);\nint2 fref1Apos = (int2)(qpos1.x>>2, qpos1.y>>2);\nint hpel1A = ((qpos1.x&2)>>1) + (qpos1.y&2);\nint2 qpos1B = (int2)qpos1 + (int2)(((qpos1.x&1)<<1), ((qpos1.y&1)<<1));\nint2 fref1Bpos = (int2)(qpos1B.x>>2, qpos1B.y>>2);\nint hpel1B = ((qpos1B.x&2)>>1) + (qpos1B.y&2);\nuint mask_shift0A = 8 * hpel0A, mask_shift0B = 8 * hpel0B;\nuint mask_shift1A = 8 * hpel1A, mask_shift1B = 8 * hpel1B;\nuint vA, vB;\nuint enc, ref0, ref1;\nuint a0, a1;\nconst int weight2 = 64 - weight;\n#define READ_BIDIR_DIFF( OUT, X )\\\nenc = read_imageui( fenc_lowres, sampler, fencpos + (int2)(X, idx) ).s0;\\\nvA = (read_imageui( fref0_planes, sampler, fref0Apos + (int2)(X, idx) ).s0 >> mask_shift0A) & 0xFF;\\\nvB = (read_imageui( fref0_planes, sampler, fref0Bpos + (int2)(X, idx) ).s0 >> mask_shift0B) & 0xFF;\\\nref0 = rhadd( vA, vB );\\\nvA = (read_imageui( fref1_planes, sampler, fref1Apos + (int2)(X, idx) ).s0 >> mask_shift1A) & 0xFF;\\\nvB = (read_imageui( fref1_planes, sampler, fref1Bpos + (int2)(X, idx) ).s0 >> mask_shift1B) & 0xFF;\\\nref1 = rhadd( vA, vB );\\\nOUT = enc - ((ref0 * weight + ref1 * weight2 + (1 << 5)) >> 6);\n#define READ_DIFF_EX( OUT, a, b )\\\nREAD_BIDIR_DIFF( a0, a );\\\nREAD_BIDIR_DIFF( a1, b );\\\nOUT = a0 + (a1<<BITS_PER_SUM);\n#define ROW_8x4_SATD( a, b, c )\\\nfencpos.y += a;\\\nfref0Apos.y += b;\\\nfref0Bpos.y += b;\\\nfref1Apos.y += c;\\\nfref1Bpos.y += c;\\\nREAD_DIFF_EX( b0, 0, 4 );\\\nREAD_DIFF_EX( b1, 1, 5 );\\\nREAD_DIFF_EX( b2, 2, 6 );\\\nREAD_DIFF_EX( b3, 3, 7 );\\\nHADAMARD4( tmp[idx][0], tmp[idx][1], tmp[idx][2], tmp[idx][3], b0, b1, b2, b3 );\\\nHADAMARD4( b0, b1, b2, b3, tmp[0][idx], tmp[1][idx], tmp[2][idx], tmp[3][idx] );\\\nsum += abs2( b0 ) + abs2( b1 ) + abs2( b2 ) + abs2( b3 );\nROW_8x4_SATD( 0, 0, 0 );\nROW_8x4_SATD( 4, 4, 4 );\n#undef READ_BIDIR_DIFF\n#undef READ_DIFF_EX\n#undef ROW_8x4_SATD\nreturn (((sum_t)sum) + (sum>>BITS_PER_SUM)) >> 1;\n}\n/*\n* mode selection - pick the least cost partition type for each 8x8 macroblock.\n* Intra, list0 or list1.  When measuring a B slice, also test three bidir\n* possibilities.\n*\n* fenc_lowres_mvs[0|1] and fenc_lowres_mv_costs[0|1] are large buffers that\n* hold many frames worth of motion vectors.  We must offset into the correct\n* location for this frame's vectors:\n*\n*   CPU equivalent: fenc->lowres_mvs[0][b - p0 - 1]\n*   GPU equivalent: fenc_lowres_mvs0[(b - p0 - 1) * mb_count]\n*\n* global launch dimensions for P slice estimate:  [mb_width, mb_height]\n* global launch dimensions for B slice estimate:  [mb_width * 4, mb_height]\n*/\nkernel void mode_selection( read_only image2d_t   fenc_lowres,\nread_only image2d_t   fref0_planes,\nread_only image2d_t   fref1_planes,\nconst global short2  *fenc_lowres_mvs0,\nconst global short2  *fenc_lowres_mvs1,\nconst global short2  *fref1_lowres_mvs0,\nconst global int16_t *fenc_lowres_mv_costs0,\nconst global int16_t *fenc_lowres_mv_costs1,\nconst global uint16_t *fenc_intra_cost,\nglobal uint16_t      *lowres_costs,\nglobal int           *frame_stats,\nlocal int16_t        *cost_local,\nlocal sum2_t         *satd_local,\nint                   mb_width,\nint                   bipred_weight,\nint                   dist_scale_factor,\nint                   b,\nint                   p0,\nint                   p1,\nint                   lambda )\n{\nint mb_x = get_global_id( 0 );\nint b_bidir = b < p1;\nif( b_bidir )\n{\n/* when mode_selection is run for B frames, it must perform BIDIR SATD\n* measurements, so it is launched with four times as many threads in\n* order to spread the work around more of the GPU.  And it can add\n* padding threads in the X direction. */\nmb_x >>= 2;\nif( mb_x >= mb_width )\nreturn;\n}\nint mb_y = get_global_id( 1 );\nint mb_height = get_global_size( 1 );\nint mb_count = mb_width * mb_height;\nint mb_xy = mb_x + mb_y * mb_width;\n/* Initialize int frame_stats[4] for next kernel (sum_inter_cost) */\nif( mb_x < 4 && mb_y == 0 )\nframe_stats[mb_x] = 0;\nint bcost = COST_MAX;\nint list_used = 0;\nif( !b_bidir )\n{\nint icost = fenc_intra_cost[mb_xy];\nCOPY2_IF_LT( bcost, icost, list_used, 0 );\n}\nif( b != p0 )\n{\nint mv_cost0 = fenc_lowres_mv_costs0[(b - p0 - 1) * mb_count + mb_xy];\nCOPY2_IF_LT( bcost, mv_cost0, list_used, 1 );\n}\nif( b != p1 )\n{\nint mv_cost1 = fenc_lowres_mv_costs1[(p1 - b - 1) * mb_count + mb_xy];\nCOPY2_IF_LT( bcost, mv_cost1, list_used, 2 );\n}\nif( b_bidir )\n{\nint2 coord = (int2)(mb_x, mb_y) << 3;\nint mb_i = get_global_id( 0 ) & 3;\nint mb_in_group = get_local_id( 1 ) * (get_local_size( 0 ) >> 2) + (get_local_id( 0 ) >> 2);\ncost_local += mb_in_group * 4;\nsatd_local += mb_in_group * 16;\n#define TRY_BIDIR( mv0, mv1, penalty )\\\n{\\\nint2 qpos0 = (int2)((coord.x<<2) + mv0.x, (coord.y<<2) + mv0.y);\\\nint2 qpos1 = (int2)((coord.x<<2) + mv1.x, (coord.y<<2) + mv1.y);\\\ncost_local[mb_i] = bidir_satd_8x8_ii_coop4( fenc_lowres, coord, fref0_planes, qpos0, fref1_planes, qpos1, bipred_weight, satd_local, mb_i );\\\nint cost = cost_local[0] + cost_local[1] + cost_local[2] + cost_local[3];\\\nCOPY2_IF_LT( bcost, penalty * lambda + cost, list_used, 3 );\\\n}\n/* temporal prediction */\nshort2 dmv0, dmv1;\nshort2 mvr = fref1_lowres_mvs0[mb_xy];\ndmv0 = (mvr * (short) dist_scale_factor + (short) 128) >> (short) 8;\ndmv1 = dmv0 - mvr;\nTRY_BIDIR( dmv0, dmv1, 0 )\nif( as_uint( dmv0 ) || as_uint( dmv1 ) )\n{\n/* B-direct prediction */\ndmv0 = 0; dmv1 = 0;\nTRY_BIDIR( dmv0, dmv1, 0 );\n}\n/* L0+L1 prediction */\ndmv0 = fenc_lowres_mvs0[(b - p0 - 1) * mb_count + mb_xy];\ndmv1 = fenc_lowres_mvs1[(p1 - b - 1) * mb_count + mb_xy];\nTRY_BIDIR( dmv0, dmv1, 5 );\n#undef TRY_BIDIR\n}\nlowres_costs[mb_xy] = min( bcost, LOWRES_COST_MASK ) + (list_used << LOWRES_COST_SHIFT);\n}\n/*\n* parallel sum inter costs\n*\n* global launch dimensions: [256, mb_height]\n*/\nkernel void sum_inter_cost( const global uint16_t *fenc_lowres_costs,\nconst global uint16_t *inv_qscale_factor,\nglobal int           *fenc_row_satds,\nglobal int           *frame_stats,\nint                   mb_width,\nint                   bframe_bias,\nint                   b,\nint                   p0,\nint                   p1 )\n{\nint y = get_global_id( 1 );\nint mb_height = get_global_size( 1 );\nint row_satds = 0;\nint cost_est = 0;\nint cost_est_aq = 0;\nint intra_mbs = 0;\nfor( int x = get_global_id( 0 ); x < mb_width; x += get_global_size( 0 ))\n{\nint mb_xy = x + y * mb_width;\nint cost = fenc_lowres_costs[mb_xy] & LOWRES_COST_MASK;\nint list = fenc_lowres_costs[mb_xy] >> LOWRES_COST_SHIFT;\nint b_frame_score_mb = (x > 0 && x < mb_width - 1 && y > 0 && y < mb_height - 1) || mb_width <= 2 || mb_height <= 2;\nif( list == 0 && b_frame_score_mb )\nintra_mbs++;\nint cost_aq = (cost * inv_qscale_factor[mb_xy] + 128) >> 8;\nrow_satds += cost_aq;\nif( b_frame_score_mb )\n{\ncost_est += cost;\ncost_est_aq += cost_aq;\n}\n}\nlocal int buffer[256];\nint x = get_global_id( 0 );\nrow_satds   = parallel_sum( row_satds, x, buffer );\ncost_est    = parallel_sum( cost_est, x, buffer );\ncost_est_aq = parallel_sum( cost_est_aq, x, buffer );\nintra_mbs   = parallel_sum( intra_mbs, x, buffer );\nif( b != p1 )\ncost_est = (int)((float)cost_est * 100.0f / (120.0f + (float)bframe_bias));\nif( get_global_id( 0 ) == 0 )\n{\nfenc_row_satds[y] = row_satds;\natomic_add( frame_stats + COST_EST, cost_est );\natomic_add( frame_stats + COST_EST_AQ, cost_est_aq );\natomic_add( frame_stats + INTRA_MBS, intra_mbs );\n}\n}\n/*\n* downscale lowres luma: full-res buffer to down scale image, and to packed hpel image\n*\n* --\n*\n* fenc_img is an output image (area of memory referenced through a texture\n* cache). A read of any pixel location (x,y) returns four pixel values:\n*\n* val.s0 = P(x,y)\n* val.s1 = P(x+1,y)\n* val.s2 = P(x+2,y)\n* val.s3 = P(x+3,y)\n*\n* This is a 4x replication of the lowres pixels, a trade-off between memory\n* size and read latency.\n*\n* --\n*\n* hpel_planes is an output image that contains the four HPEL planes used for\n* subpel refinement. A read of any pixel location (x,y) returns a UInt32 with\n* the four planar values C | V | H | F\n*\n* launch dimensions:  [lowres-width, lowres-height]\n*/\nkernel void downscale_hpel( const global pixel *fenc,\nwrite_only image2d_t fenc_img,\nwrite_only image2d_t hpel_planes,\nint stride )\n{\nint x = get_global_id( 0 );\nint y = get_global_id( 1 );\nuint4 values;\nfenc += y * stride * 2;\nconst global pixel *src1 = fenc + stride;\nconst global pixel *src2 = (y == get_global_size( 1 )-1) ? src1 : src1 + stride;\nint2 pos = (int2)(x, y);\npixel right, left;\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s0 = rhadd( right, left );           // F\nright = rhadd( fenc[2*x+1], src1[2*x+1] );\nleft  = rhadd( fenc[2*x+2], src1[2*x+2] );\nvalues.s1 = rhadd( right, left );           // H\nright = rhadd( src1[2*x], src2[2*x] );\nleft  = rhadd( src1[2*x+1], src2[2*x+1] );\nvalues.s2 = rhadd( right, left );           // V\nright = rhadd( src1[2*x+1], src2[2*x+1] );\nleft  = rhadd( src1[2*x+2], src2[2*x+2] );\nvalues.s3 = rhadd( right, left );           // C\nuint4 val = (uint4) ((values.s3 & 0xff) << 24) | ((values.s2 & 0xff) << 16) | ((values.s1 & 0xff) << 8) | (values.s0 & 0xff);\nwrite_imageui( hpel_planes, pos, val );\nx = select( x, x+1, x+1 < get_global_size( 0 ) );\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s1 = rhadd( right, left );\nx = select( x, x+1, x+1 < get_global_size( 0 ) );\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s2 = rhadd( right, left );\nx = select( x, x+1, x+1 < get_global_size( 0 ) );\nright = rhadd( fenc[x*2], src1[x*2] );\nleft  = rhadd( fenc[x*2+1], src1[x*2+1] );\nvalues.s3 = rhadd( right, left );\nwrite_imageui( fenc_img, pos, values );\n}\n/*\n* downscale lowres hierarchical motion search image, copy from one image to\n* another decimated image.  This kernel is called iteratively to generate all\n* of the downscales.\n*\n* launch dimensions:  [lower_res width, lower_res height]\n*/\nkernel void downscale1( read_only image2d_t higher_res, write_only image2d_t lower_res )\n{\nint x = get_global_id( 0 );\nint y = get_global_id( 1 );\nint2 pos = (int2)(x, y);\nint gs = get_global_size( 0 );\nuint4 top, bot, values;\ntop = read_imageui( higher_res, sampler, (int2)(x*2, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2, 2*y+1) );\nvalues.s0 = rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) );\n/* these select statements appear redundant, and they should be, but tests break when\n* they are not here.  I believe this was caused by a driver bug\n*/\nvalues.s1 = select( values.s0, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 1 < gs) );\ntop = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y+1) );\nvalues.s2 = select( values.s1, rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) ), ( x + 2 < gs ) );\nvalues.s3 = select( values.s2, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 3 < gs ) );\nwrite_imageui( lower_res, pos, (uint4)(values) );\n}\n/*\n* Second copy of downscale kernel, no differences. This is a (no perf loss)\n* workaround for a scheduling bug in current Tahiti drivers.  This bug has\n* theoretically been fixed in the July 2012 driver release from AMD.\n*/\nkernel void downscale2( read_only image2d_t higher_res, write_only image2d_t lower_res )\n{\nint x = get_global_id( 0 );\nint y = get_global_id( 1 );\nint2 pos = (int2)(x, y);\nint gs = get_global_size( 0 );\nuint4 top, bot, values;\ntop = read_imageui( higher_res, sampler, (int2)(x*2, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2, 2*y+1) );\nvalues.s0 = rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) );\nvalues.s1 = select( values.s0, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 1 < gs) );\ntop = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y) );\nbot = read_imageui( higher_res, sampler, (int2)(x*2+4, 2*y+1) );\nvalues.s2 = select( values.s1, rhadd( rhadd( top.s0, bot.s0 ), rhadd( top.s1, bot.s1 ) ), ( x + 2 < gs ) );\nvalues.s3 = select( values.s2, rhadd( rhadd( top.s2, bot.s2 ), rhadd( top.s3, bot.s3 ) ), ( x + 3 < gs ) );\nwrite_imageui( lower_res, pos, (uint4)(values) );\n}\n/* OpenCL 1.2 finally added a memset command, but we're not targeting 1.2 */\nkernel void memset_int16( global int16_t *buf, int16_t value )\n{\nbuf[get_global_id( 0 )] = value;\n}\n/* Lookahead lowres intra analysis\n*\n* Each intra analysis function has been implemented twice, once for scalar GPUs\n* (NV) and once for vectorized GPUs (AMD pre-Southern Islands).  x264 detects\n* the GPU type and sets the -DVECTORIZE compile flag accordingly.\n*\n* All the intra analysis functions were based on their C versions in pixel.c\n* and produce the exact same results.\n*/\n/* force all clamp arguments and return value to int, prevent ambiguous types */\n#define clamp_int( X, MIN, MAX ) (int) clamp( (int)(X), (int)(MIN), (int)(MAX) )\n#if VECTORIZE\nint satd_8x4_intra_lr( const local pixel *data, int data_stride, int8 pr0, int8 pr1, int8 pr2, int8 pr3 )\n{\nint8 a_v, d_v;\nint2 tmp00, tmp01, tmp02, tmp03, tmp10, tmp11, tmp12, tmp13;\nint2 tmp20, tmp21, tmp22, tmp23, tmp30, tmp31, tmp32, tmp33;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr0).s04152637;\nHADAMARD4V( tmp00, tmp01, tmp02, tmp03, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\ndata += data_stride;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr1).s04152637;\nHADAMARD4V( tmp10, tmp11, tmp12, tmp13, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\ndata += data_stride;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr2).s04152637;\nHADAMARD4V( tmp20, tmp21, tmp22, tmp23, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\ndata += data_stride;\nd_v = convert_int8( vload8( 0, data ) );\na_v.s01234567 = (d_v - pr3).s04152637;\nHADAMARD4V( tmp30, tmp31, tmp32, tmp33, a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi );\nuint8 sum_v;\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp00, tmp10, tmp20, tmp30 );\nsum_v = abs( a_v );\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp01, tmp11, tmp21, tmp31 );\nsum_v += abs( a_v );\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp02, tmp12, tmp22, tmp32 );\nsum_v += abs( a_v );\nHADAMARD4V( a_v.lo.lo, a_v.lo.hi, a_v.hi.lo, a_v.hi.hi, tmp03, tmp13, tmp23, tmp33 );\nsum_v += abs( a_v );\nuint4 sum2 = sum_v.hi + sum_v.lo;\nuint2 sum3 = sum2.hi + sum2.lo;\nreturn ( sum3.hi + sum3.lo ) >> 1;\n}\n#else\nSATD_C_8x4_Q( satd_8x4_lp, const local, private )\n#endif\n/****************************************************************************\n* 8x8 prediction for intra luma block\n****************************************************************************/\n#define F1            rhadd\n#define F2( a, b, c ) ( a+2*b+c+2 )>>2\n#if VECTORIZE\nint x264_predict_8x8_ddl( const local pixel *src, int src_stride, const local pixel *top )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = ( 2 + top[0] + 2*top[1] + top[2] ) >> 2;\npr0.s1 = ( 2 + top[1] + 2*top[2] + top[3] ) >> 2;\npr0.s2 = ( 2 + top[2] + 2*top[3] + top[4] ) >> 2;\npr0.s3 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr0.s4 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr0.s5 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr0.s6 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr0.s7 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr1.s0 = ( 2 + top[1] + 2*top[2] + top[3] ) >> 2;\npr1.s1 = ( 2 + top[2] + 2*top[3] + top[4] ) >> 2;\npr1.s2 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr1.s3 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr1.s4 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr1.s5 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr1.s6 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr1.s7 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr2.s0 = ( 2 + top[2] + 2*top[3] + top[4] ) >> 2;\npr2.s1 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr2.s2 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr2.s3 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr2.s4 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr2.s5 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr2.s6 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr2.s7 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr3.s0 = ( 2 + top[3] + 2*top[4] + top[5] ) >> 2;\npr3.s1 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr3.s2 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr3.s3 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr3.s4 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr3.s5 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr3.s6 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr3.s7 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = ( 2 + top[4] + 2*top[5] + top[6] ) >> 2;\npr0.s1 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr0.s2 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr0.s3 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr0.s4 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr0.s5 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr0.s6 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr0.s7 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr1.s0 = ( 2 + top[5] + 2*top[6] + top[7] ) >> 2;\npr1.s1 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr1.s2 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr1.s3 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr1.s4 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr1.s5 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr1.s6 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr1.s7 = ( 2 + top[12] + 2*top[13] + top[14] ) >> 2;\npr2.s0 = ( 2 + top[6] + 2*top[7] + top[8] ) >> 2;\npr2.s1 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr2.s2 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr2.s3 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr2.s4 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr2.s5 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr2.s6 = ( 2 + top[12] + 2*top[13] + top[14] ) >> 2;\npr2.s7 = ( 2 + top[13] + 2*top[14] + top[15] ) >> 2;\npr3.s0 = ( 2 + top[7] + 2*top[8] + top[9] ) >> 2;\npr3.s1 = ( 2 + top[8] + 2*top[9] + top[10] ) >> 2;\npr3.s2 = ( 2 + top[9] + 2*top[10] + top[11] ) >> 2;\npr3.s3 = ( 2 + top[10] + 2*top[11] + top[12] ) >> 2;\npr3.s4 = ( 2 + top[11] + 2*top[12] + top[13] ) >> 2;\npr3.s5 = ( 2 + top[12] + 2*top[13] + top[14] ) >> 2;\npr3.s6 = ( 2 + top[13] + 2*top[14] + top[15] ) >> 2;\npr3.s7 = ( 2 + top[14] + 3*top[15] ) >> 2;\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_ddr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nint8 pr0, pr1, pr2, pr3;\npr3.s0 = F2( left[1], left[2], left[3] );\npr2.s0 = pr3.s1 = F2( left[0], left[1], left[2] );\npr1.s0 = pr2.s1 = pr3.s2 = F2( left[1], left[0], left_top );\npr0.s0 = pr1.s1 = pr2.s2 = pr3.s3 = F2( left[0], left_top, top[0] );\npr0.s1 = pr1.s2 = pr2.s3 = pr3.s4 = F2( left_top, top[0], top[1] );\npr0.s2 = pr1.s3 = pr2.s4 = pr3.s5 = F2( top[0], top[1], top[2] );\npr0.s3 = pr1.s4 = pr2.s5 = pr3.s6 = F2( top[1], top[2], top[3] );\npr0.s4 = pr1.s5 = pr2.s6 = pr3.s7 = F2( top[2], top[3], top[4] );\npr0.s5 = pr1.s6 = pr2.s7 = F2( top[3], top[4], top[5] );\npr0.s6 = pr1.s7 = F2( top[4], top[5], top[6] );\npr0.s7 = F2( top[5], top[6], top[7] );\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr3.s0 = F2( left[5], left[6], left[7] );\npr2.s0 = pr3.s1 = F2( left[4], left[5], left[6] );\npr1.s0 = pr2.s1 = pr3.s2 = F2( left[3], left[4], left[5] );\npr0.s0 = pr1.s1 = pr2.s2 = pr3.s3 = F2( left[2], left[3], left[4] );\npr0.s1 = pr1.s2 = pr2.s3 = pr3.s4 = F2( left[1], left[2], left[3] );\npr0.s2 = pr1.s3 = pr2.s4 = pr3.s5 = F2( left[0], left[1], left[2] );\npr0.s3 = pr1.s4 = pr2.s5 = pr3.s6 = F2( left[1], left[0], left_top );\npr0.s4 = pr1.s5 = pr2.s6 = pr3.s7 = F2( left[0], left_top, top[0] );\npr0.s5 = pr1.s6 = pr2.s7 = F2( left_top, top[0], top[1] );\npr0.s6 = pr1.s7 = F2( top[0], top[1], top[2] );\npr0.s7 = F2( top[1], top[2], top[3] );\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_vr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nint8 pr0, pr1, pr2, pr3;\npr2.s0 = F2( left[1], left[0], left_top );\npr3.s0 = F2( left[2], left[1], left[0] );\npr1.s0 = pr3.s1 = F2( left[0], left_top, top[0] );\npr0.s0 = pr2.s1 = F1( left_top, top[0] );\npr1.s1 = pr3.s2 = F2( left_top, top[0], top[1] );\npr0.s1 = pr2.s2 = F1( top[0], top[1] );\npr1.s2 = pr3.s3 = F2( top[0], top[1], top[2] );\npr0.s2 = pr2.s3 = F1( top[1], top[2] );\npr1.s3 = pr3.s4 = F2( top[1], top[2], top[3] );\npr0.s3 = pr2.s4 = F1( top[2], top[3] );\npr1.s4 = pr3.s5 = F2( top[2], top[3], top[4] );\npr0.s4 = pr2.s5 = F1( top[3], top[4] );\npr1.s5 = pr3.s6 = F2( top[3], top[4], top[5] );\npr0.s5 = pr2.s6 = F1( top[4], top[5] );\npr1.s6 = pr3.s7 = F2( top[4], top[5], top[6] );\npr0.s6 = pr2.s7 = F1( top[5], top[6] );\npr1.s7 = F2( top[5], top[6], top[7] );\npr0.s7 = F1( top[6], top[7] );\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr2.s0 = F2( left[5], left[4], left[3] );\npr3.s0 = F2( left[6], left[5], left[4] );\npr0.s0 = pr2.s1 = F2( left[3], left[2], left[1] );\npr1.s0 = pr3.s1 = F2( left[4], left[3], left[2] );\npr0.s1 = pr2.s2 = F2( left[1], left[0], left_top );\npr1.s1 = pr3.s2 = F2( left[2], left[1], left[0] );\npr1.s2 = pr3.s3 = F2( left[0], left_top, top[0] );\npr0.s2 = pr2.s3 = F1( left_top, top[0] );\npr1.s3 = pr3.s4 = F2( left_top, top[0], top[1] );\npr0.s3 = pr2.s4 = F1( top[0], top[1] );\npr1.s4 = pr3.s5 = F2( top[0], top[1], top[2] );\npr0.s4 = pr2.s5 = F1( top[1], top[2] );\npr1.s5 = pr3.s6 = F2( top[1], top[2], top[3] );\npr0.s5 = pr2.s6 = F1( top[2], top[3] );\npr1.s6 = pr3.s7 = F2( top[2], top[3], top[4] );\npr0.s6 = pr2.s7 = F1( top[3], top[4] );\npr1.s7 = F2( top[3], top[4], top[5] );\npr0.s7 = F1( top[4], top[5] );\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n#undef PRED\n}\nint x264_predict_8x8_hd( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = F1( left_top, left[0] ); pr0.s1 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\npr0.s2 = F2( top[1], top[0], left_top ); pr0.s3 = F2( top[2], top[1], top[0] );\npr0.s4 = F2( top[3], top[2], top[1] ); pr0.s5 = F2( top[4], top[3], top[2] );\npr0.s6 = F2( top[5], top[4], top[3] ); pr0.s7 = F2( top[6], top[5], top[4] );\npr1.s0 = F1( left[0], left[1] ); pr1.s1 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr1.s2 = F1( left_top, left[0] ); pr1.s3 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\npr1.s4 = F2( top[1], top[0], left_top ); pr1.s5 = F2( top[2], top[1], top[0] );\npr1.s6 = F2( top[3], top[2], top[1] ); pr1.s7 = F2( top[4], top[3], top[2] );\npr2.s0 = F1( left[1], left[2] ); pr2.s1 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr2.s2 = F1( left[0], left[1] ); pr2.s3 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr2.s4 = F1( left_top, left[0] ); pr2.s5 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\npr2.s6 = F2( top[1], top[0], left_top ); pr2.s7 = F2( top[2], top[1], top[0] );\npr3.s0 = F1( left[2], left[3] ); pr3.s1 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr3.s2 = F1( left[1], left[2] ); pr3.s3 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr3.s4 = F1( left[0], left[1] ); pr3.s5 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr3.s6 = F1( left_top, left[0] ); pr3.s7 = (left[0] + 2 * left_top + top[0] + 2) >> 2;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = F1( left[3], left[4] ); pr0.s1 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr0.s2 = F1( left[2], left[3] ); pr0.s3 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr0.s4 = F1( left[1], left[2] ); pr0.s5 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr0.s6 = F1( left[0], left[1] ); pr0.s7 = (left_top + 2 * left[0] + left[1] + 2) >> 2;\npr1.s0 = F1( left[4], left[5] ); pr1.s1 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr1.s2 = F1( left[3], left[4] ); pr1.s3 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr1.s4 = F1( left[2], left[3] ); pr1.s5 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr1.s6 = F1( left[1], left[2] ); pr1.s7 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr2.s0 = F1( left[5], left[6] ); pr2.s1 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr2.s2 = F1( left[4], left[5] ); pr2.s3 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr2.s4 = F1( left[3], left[4] ); pr2.s5 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr2.s6 = F1( left[2], left[3] ); pr2.s7 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr3.s0 = F1( left[6], left[7] ); pr3.s1 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr3.s2 = F1( left[5], left[6] ); pr3.s3 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr3.s4 = F1( left[4], left[5] ); pr3.s5 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr3.s6 = F1( left[3], left[4] ); pr3.s7 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\nreturn satd + satd_8x4_intra_lr( src + (src_stride << 2), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_vl( const local pixel *src, int src_stride, const local pixel *top )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = F1( top[0], top[1] );\npr1.s0 = F2( top[0], top[1], top[2] );\npr2.s0 = pr0.s1 = F1( top[1], top[2] );\npr3.s0 = pr1.s1 = F2( top[1], top[2], top[3] );\npr2.s1 = pr0.s2 = F1( top[2], top[3] );\npr3.s1 = pr1.s2 = F2( top[2], top[3], top[4] );\npr2.s2 = pr0.s3 = F1( top[3], top[4] );\npr3.s2 = pr1.s3 = F2( top[3], top[4], top[5] );\npr2.s3 = pr0.s4 = F1( top[4], top[5] );\npr3.s3 = pr1.s4 = F2( top[4], top[5], top[6] );\npr2.s4 = pr0.s5 = F1( top[5], top[6] );\npr3.s4 = pr1.s5 = F2( top[5], top[6], top[7] );\npr2.s5 = pr0.s6 = F1( top[6], top[7] );\npr3.s5 = pr1.s6 = F2( top[6], top[7], top[8] );\npr2.s6 = pr0.s7 = F1( top[7], top[8] );\npr3.s6 = pr1.s7 = F2( top[7], top[8], top[9] );\npr2.s7 = F1( top[8], top[9] );\npr3.s7 = F2( top[8], top[9], top[10] );\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = F1( top[2], top[3] );\npr1.s0 = F2( top[2], top[3], top[4] );\npr2.s0 = pr0.s1 = F1( top[3], top[4] );\npr3.s0 = pr1.s1 = F2( top[3], top[4], top[5] );\npr2.s1 = pr0.s2 = F1( top[4], top[5] );\npr3.s1 = pr1.s2 = F2( top[4], top[5], top[6] );\npr2.s2 = pr0.s3 = F1( top[5], top[6] );\npr3.s2 = pr1.s3 = F2( top[5], top[6], top[7] );\npr2.s3 = pr0.s4 = F1( top[6], top[7] );\npr3.s3 = pr1.s4 = F2( top[6], top[7], top[8] );\npr2.s4 = pr0.s5 = F1( top[7], top[8] );\npr3.s4 = pr1.s5 = F2( top[7], top[8], top[9] );\npr2.s5 = pr0.s6 = F1( top[8], top[9] );\npr3.s5 = pr1.s6 = F2( top[8], top[9], top[10] );\npr2.s6 = pr0.s7 = F1( top[9], top[10] );\npr3.s6 = pr1.s7 = F2( top[9], top[10], top[11] );\npr2.s7 = F1( top[10], top[11] );\npr3.s7 = F2( top[10], top[11], top[12] );\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8_hu( const local pixel *src, int src_stride, const local pixel *left )\n{\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = F1( left[0], left[1] ); pr0.s1 = (left[0] + 2 * left[1] + left[2] + 2) >> 2;\npr0.s2 = F1( left[1], left[2] ); pr0.s3 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr0.s4 = F1( left[2], left[3] ); pr0.s5 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr0.s6 = F1( left[3], left[4] ); pr0.s7 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr1.s0 = F1( left[1], left[2] ); pr1.s1 = (left[1] + 2 * left[2] + left[3] + 2) >> 2;\npr1.s2 = F1( left[2], left[3] ); pr1.s3 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr1.s4 = F1( left[3], left[4] ); pr1.s5 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr1.s6 = F1( left[4], left[5] ); pr1.s7 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr2.s0 = F1( left[2], left[3] ); pr2.s1 = (left[2] + 2 * left[3] + left[4] + 2) >> 2;\npr2.s2 = F1( left[3], left[4] ); pr2.s3 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr2.s4 = F1( left[4], left[5] ); pr2.s5 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr2.s6 = F1( left[5], left[6] ); pr2.s7 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr3.s0 = F1( left[3], left[4] ); pr3.s1 = (left[3] + 2 * left[4] + left[5] + 2) >> 2;\npr3.s2 = F1( left[4], left[5] ); pr3.s3 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr3.s4 = F1( left[5], left[6] ); pr3.s5 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr3.s6 = F1( left[6], left[7] ); pr3.s7 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npr0.s0 = F1( left[4], left[5] ); pr0.s1 = (left[4] + 2 * left[5] + left[6] + 2) >> 2;\npr0.s2 = F1( left[5], left[6] ); pr0.s3 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr0.s4 = F1( left[6], left[7] ); pr0.s5 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\npr0.s6 = left[7]; pr0.s7 = left[7];\npr1.s0 = F1( left[5], left[6] ); pr1.s1 = (left[5] + 2 * left[6] + left[7] + 2) >> 2;\npr1.s2 = F1( left[6], left[7] ); pr1.s3 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\npr1.s4 = left[7]; pr1.s5 = left[7];\npr1.s6 = left[7]; pr1.s7 = left[7];\npr2.s0 = F1( left[6], left[7] ); pr2.s1 = (left[6] + 2 * left[7] + left[7] + 2) >> 2;\npr2.s2 = left[7]; pr2.s3 = left[7];\npr2.s4 = left[7]; pr2.s5 = left[7];\npr2.s6 = left[7]; pr2.s7 = left[7];\npr3 = (int8)left[7];\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8c_h( const local pixel *src, int src_stride )\n{\nconst local pixel *src_l = src;\nint8 pr0, pr1, pr2, pr3;\npr0 = (int8)src[-1]; src += src_stride;\npr1 = (int8)src[-1]; src += src_stride;\npr2 = (int8)src[-1]; src += src_stride;\npr3 = (int8)src[-1]; src += src_stride;\nint satd = satd_8x4_intra_lr( src_l, src_stride, pr0, pr1, pr2, pr3 );\npr0 = (int8)src[-1]; src += src_stride;\npr1 = (int8)src[-1]; src += src_stride;\npr2 = (int8)src[-1]; src += src_stride;\npr3 = (int8)src[-1];\nreturn satd + satd_8x4_intra_lr( src_l + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8c_v( const local pixel *src, int src_stride )\n{\nint8 pred = convert_int8( vload8( 0, &src[-src_stride] ));\nreturn satd_8x4_intra_lr( src, src_stride, pred, pred, pred, pred ) +\nsatd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pred, pred, pred, pred );\n}\nint x264_predict_8x8c_p( const local pixel *src, int src_stride )\n{\nint H = 0, V = 0;\nfor( int i = 0; i < 4; i++ )\n{\nH += (i + 1) * (src[4 + i - src_stride] - src[2 - i - src_stride]);\nV += (i + 1) * (src[-1 + (i + 4) * src_stride] - src[-1 + (2 - i) * src_stride]);\n}\nint a = 16 * (src[-1 + 7 * src_stride] + src[7 - src_stride]);\nint b = (17 * H + 16) >> 5;\nint c = (17 * V + 16) >> 5;\nint i00 = a - 3 * b - 3 * c + 16;\nint pix = i00;\nint8 pr0, pr1, pr2, pr3;\npr0.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr1.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr2.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr3.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\nint satd = satd_8x4_intra_lr( src, src_stride, pr0, pr1, pr2, pr3 );\npix = i00;\npr0.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr0.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr1.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr1.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr2.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr2.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\npix = i00;\npr3.s0 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s1 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s2 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s3 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s4 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s5 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s6 = x264_clip_pixel( pix >> 5 ); pix += b;\npr3.s7 = x264_clip_pixel( pix >> 5 ); i00 += c;\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, pr0, pr1, pr2, pr3 );\n}\nint x264_predict_8x8c_dc( const local pixel *src, int src_stride )\n{\nint s0 = 0, s1 = 0, s2 = 0, s3 = 0;\nfor( int i = 0; i < 4; i++ )\n{\ns0 += src[i - src_stride];\ns1 += src[i + 4 - src_stride];\ns2 += src[-1 + i * src_stride];\ns3 += src[-1 + (i+4)*src_stride];\n}\nint8 dc0;\ndc0.lo = (int4)( (s0 + s2 + 4) >> 3 );\ndc0.hi = (int4)( (s1 + 2) >> 2 );\nint satd = satd_8x4_intra_lr( src, src_stride, dc0, dc0, dc0, dc0 );\ndc0.lo = (int4)( (s3 + 2) >> 2 );\ndc0.hi = (int4)( (s1 + s3 + 4) >> 3 );\nreturn satd + satd_8x4_intra_lr( src + ( src_stride << 2 ), src_stride, dc0, dc0, dc0, dc0 );\n}\n#else  /* not vectorized: private is cheap registers are scarce */\nint x264_predict_8x8_ddl( const local pixel *src, int src_stride, const local pixel *top )\n{\nprivate pixel pred[32];\nfor( int y = 0; y < 4; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\npixel x_plus_y = (pixel) clamp_int( x + y, 0, 13 );\npred[x + y*8] = ( 2 + top[x_plus_y] + 2*top[x_plus_y + 1] + top[x_plus_y + 2] ) >> 2;\n}\n}\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\nfor( int y = 4; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\npixel x_plus_y = (pixel) clamp_int( x + y, 0, 13 );\npred[x + ( y - 4 )*8] = ( 2 + top[x_plus_y] + 2*top[x_plus_y + 1] + top[x_plus_y + 2] ) >> 2;\n}\n}\npred[31] = ( 2 + top[14] + 3*top[15] ) >> 2;\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8_ddr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nprivate pixel pred[32];\n#define PRED( x, y ) pred[(x) + (y)*8]\nPRED( 0, 3 ) = F2( left[1], left[2], left[3] );\nPRED( 0, 2 ) = PRED( 1, 3 ) = F2( left[0], left[1], left[2] );\nPRED( 0, 1 ) = PRED( 1, 2 ) = PRED( 2, 3 ) = F2( left[1], left[0], left_top );\nPRED( 0, 0 ) = PRED( 1, 1 ) = PRED( 2, 2 ) = PRED( 3, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 1, 0 ) = PRED( 2, 1 ) = PRED( 3, 2 ) = PRED( 4, 3 ) = F2( left_top, top[0], top[1] );\nPRED( 2, 0 ) = PRED( 3, 1 ) = PRED( 4, 2 ) = PRED( 5, 3 ) = F2( top[0], top[1], top[2] );\nPRED( 3, 0 ) = PRED( 4, 1 ) = PRED( 5, 2 ) = PRED( 6, 3 ) = F2( top[1], top[2], top[3] );\nPRED( 4, 0 ) = PRED( 5, 1 ) = PRED( 6, 2 ) = PRED( 7, 3 ) = F2( top[2], top[3], top[4] );\nPRED( 5, 0 ) = PRED( 6, 1 ) = PRED( 7, 2 ) = F2( top[3], top[4], top[5] );\nPRED( 6, 0 ) = PRED( 7, 1 ) = F2( top[4], top[5], top[6] );\nPRED( 7, 0 ) = F2( top[5], top[6], top[7] );\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\nPRED( 0, 3 ) = F2( left[5], left[6], left[7] );\nPRED( 0, 2 ) = PRED( 1, 3 ) = F2( left[4], left[5], left[6] );\nPRED( 0, 1 ) = PRED( 1, 2 ) = PRED( 2, 3 ) = F2( left[3], left[4], left[5] );\nPRED( 0, 0 ) = PRED( 1, 1 ) = PRED( 2, 2 ) = PRED( 3, 3 ) = F2( left[2], left[3], left[4] );\nPRED( 1, 0 ) = PRED( 2, 1 ) = PRED( 3, 2 ) = PRED( 4, 3 ) = F2( left[1], left[2], left[3] );\nPRED( 2, 0 ) = PRED( 3, 1 ) = PRED( 4, 2 ) = PRED( 5, 3 ) = F2( left[0], left[1], left[2] );\nPRED( 3, 0 ) = PRED( 4, 1 ) = PRED( 5, 2 ) = PRED( 6, 3 ) = F2( left[1], left[0], left_top );\nPRED( 4, 0 ) = PRED( 5, 1 ) = PRED( 6, 2 ) = PRED( 7, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 5, 0 ) = PRED( 6, 1 ) = PRED( 7, 2 ) = F2( left_top, top[0], top[1] );\nPRED( 6, 0 ) = PRED( 7, 1 ) = F2( top[0], top[1], top[2] );\nPRED( 7, 0 ) = F2( top[1], top[2], top[3] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n#undef PRED\n}\nint x264_predict_8x8_vr( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nprivate pixel pred[32];\n#define PRED( x, y ) pred[(x) + (y)*8]\nPRED( 0, 2 ) = F2( left[1], left[0], left_top );\nPRED( 0, 3 ) = F2( left[2], left[1], left[0] );\nPRED( 0, 1 ) = PRED( 1, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 0, 0 ) = PRED( 1, 2 ) = F1( left_top, top[0] );\nPRED( 1, 1 ) = PRED( 2, 3 ) = F2( left_top, top[0], top[1] );\nPRED( 1, 0 ) = PRED( 2, 2 ) = F1( top[0], top[1] );\nPRED( 2, 1 ) = PRED( 3, 3 ) = F2( top[0], top[1], top[2] );\nPRED( 2, 0 ) = PRED( 3, 2 ) = F1( top[1], top[2] );\nPRED( 3, 1 ) = PRED( 4, 3 ) = F2( top[1], top[2], top[3] );\nPRED( 3, 0 ) = PRED( 4, 2 ) = F1( top[2], top[3] );\nPRED( 4, 1 ) = PRED( 5, 3 ) = F2( top[2], top[3], top[4] );\nPRED( 4, 0 ) = PRED( 5, 2 ) = F1( top[3], top[4] );\nPRED( 5, 1 ) = PRED( 6, 3 ) = F2( top[3], top[4], top[5] );\nPRED( 5, 0 ) = PRED( 6, 2 ) = F1( top[4], top[5] );\nPRED( 6, 1 ) = PRED( 7, 3 ) = F2( top[4], top[5], top[6] );\nPRED( 6, 0 ) = PRED( 7, 2 ) = F1( top[5], top[6] );\nPRED( 7, 1 ) = F2( top[5], top[6], top[7] );\nPRED( 7, 0 ) = F1( top[6], top[7] );\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\nPRED( 0, 2 ) = F2( left[5], left[4], left[3] );\nPRED( 0, 3 ) = F2( left[6], left[5], left[4] );\nPRED( 0, 0 ) = PRED( 1, 2 ) = F2( left[3], left[2], left[1] );\nPRED( 0, 1 ) = PRED( 1, 3 ) = F2( left[4], left[3], left[2] );\nPRED( 1, 0 ) = PRED( 2, 2 ) = F2( left[1], left[0], left_top );\nPRED( 1, 1 ) = PRED( 2, 3 ) = F2( left[2], left[1], left[0] );\nPRED( 2, 1 ) = PRED( 3, 3 ) = F2( left[0], left_top, top[0] );\nPRED( 2, 0 ) = PRED( 3, 2 ) = F1( left_top, top[0] );\nPRED( 3, 1 ) = PRED( 4, 3 ) = F2( left_top, top[0], top[1] );\nPRED( 3, 0 ) = PRED( 4, 2 ) = F1( top[0], top[1] );\nPRED( 4, 1 ) = PRED( 5, 3 ) = F2( top[0], top[1], top[2] );\nPRED( 4, 0 ) = PRED( 5, 2 ) = F1( top[1], top[2] );\nPRED( 5, 1 ) = PRED( 6, 3 ) = F2( top[1], top[2], top[3] );\nPRED( 5, 0 ) = PRED( 6, 2 ) = F1( top[2], top[3] );\nPRED( 6, 1 ) = PRED( 7, 3 ) = F2( top[2], top[3], top[4] );\nPRED( 6, 0 ) = PRED( 7, 2 ) = F1( top[3], top[4] );\nPRED( 7, 1 ) = F2( top[3], top[4], top[5] );\nPRED( 7, 0 ) = F1( top[4], top[5] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n#undef PRED\n}\ninline uint32_t pack16to32( uint32_t a, uint32_t b )\n{\nreturn a + (b << 16);\n}\ninline uint32_t pack8to16( uint32_t a, uint32_t b )\n{\nreturn a + (b << 8);\n}\nint x264_predict_8x8_hd( const local pixel *src, int src_stride, const local pixel *top, const local pixel *left, pixel left_top )\n{\nprivate pixel pred[32];\nint satd;\nint p1 =  pack8to16( (F1( left[6], left[7] )), ((left[5] + 2 * left[6] + left[7] + 2) >> 2) );\nint p2 =  pack8to16( (F1( left[5], left[6] )), ((left[4] + 2 * left[5] + left[6] + 2) >> 2) );\nint p3 =  pack8to16( (F1( left[4], left[5] )), ((left[3] + 2 * left[4] + left[5] + 2) >> 2) );\nint p4 =  pack8to16( (F1( left[3], left[4] )), ((left[2] + 2 * left[3] + left[4] + 2) >> 2) );\nint p5 =  pack8to16( (F1( left[2], left[3] )), ((left[1] + 2 * left[2] + left[3] + 2) >> 2) );\nint p6 =  pack8to16( (F1( left[1], left[2] )), ((left[0] + 2 * left[1] + left[2] + 2) >> 2) );\nint p7 =  pack8to16( (F1( left[0], left[1] )), ((left_top + 2 * left[0] + left[1] + 2) >> 2) );\nint p8 =  pack8to16( (F1( left_top, left[0] )), ((left[0] + 2 * left_top + top[0] + 2) >> 2) );\nint p9 =  pack8to16( (F2( top[1], top[0], left_top )), (F2( top[2], top[1], top[0] )) );\nint p10 =  pack8to16( (F2( top[3], top[2], top[1] )), (F2( top[4], top[3], top[2] )) );\nint p11 =  pack8to16( (F2( top[5], top[4], top[3] )), (F2( top[6], top[5], top[4] )) );\nvstore4( as_uchar4( pack16to32( p8, p9 ) ), 0, &pred[0 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p10, p11 ) ), 0, &pred[4 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[0 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p9, p10 ) ), 0, &pred[4 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[0 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p8, p9 ) ), 0, &pred[4 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[0 + 3 * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[4 + 3 * 8] );\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[0 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[4 + 0 * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[0 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[4 + 1 * 8] );\nvstore4( as_uchar4( pack16to32( p2, p3 ) ), 0, &pred[0 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[4 + 2 * 8] );\nvstore4( as_uchar4( pack16to32( p1, p2 ) ), 0, &pred[0 + 3 * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[4 + 3 * 8] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8_vl( const local pixel *src, int src_stride, const local pixel *top )\n{\nprivate pixel pred[32];\nint satd;\n#define PRED( x, y ) pred[(x) + (y)*8]\nPRED( 0, 0 ) = F1( top[0], top[1] );\nPRED( 0, 1 ) = F2( top[0], top[1], top[2] );\nPRED( 0, 2 ) = PRED( 1, 0 ) = F1( top[1], top[2] );\nPRED( 0, 3 ) = PRED( 1, 1 ) = F2( top[1], top[2], top[3] );\nPRED( 1, 2 ) = PRED( 2, 0 ) = F1( top[2], top[3] );\nPRED( 1, 3 ) = PRED( 2, 1 ) = F2( top[2], top[3], top[4] );\nPRED( 2, 2 ) = PRED( 3, 0 ) = F1( top[3], top[4] );\nPRED( 2, 3 ) = PRED( 3, 1 ) = F2( top[3], top[4], top[5] );\nPRED( 3, 2 ) = PRED( 4, 0 ) = F1( top[4], top[5] );\nPRED( 3, 3 ) = PRED( 4, 1 ) = F2( top[4], top[5], top[6] );\nPRED( 4, 2 ) = PRED( 5, 0 ) = F1( top[5], top[6] );\nPRED( 4, 3 ) = PRED( 5, 1 ) = F2( top[5], top[6], top[7] );\nPRED( 5, 2 ) = PRED( 6, 0 ) = F1( top[6], top[7] );\nPRED( 5, 3 ) = PRED( 6, 1 ) = F2( top[6], top[7], top[8] );\nPRED( 6, 2 ) = PRED( 7, 0 ) = F1( top[7], top[8] );\nPRED( 6, 3 ) = PRED( 7, 1 ) = F2( top[7], top[8], top[9] );\nPRED( 7, 2 ) = F1( top[8], top[9] );\nPRED( 7, 3 ) = F2( top[8], top[9], top[10] );\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nPRED( 0, 0 ) = F1( top[2], top[3] );\nPRED( 0, 1 ) = F2( top[2], top[3], top[4] );\nPRED( 0, 2 ) = PRED( 1, 0 ) = F1( top[3], top[4] );\nPRED( 0, 3 ) = PRED( 1, 1 ) = F2( top[3], top[4], top[5] );\nPRED( 1, 2 ) = PRED( 2, 0 ) = F1( top[4], top[5] );\nPRED( 1, 3 ) = PRED( 2, 1 ) = F2( top[4], top[5], top[6] );\nPRED( 2, 2 ) = PRED( 3, 0 ) = F1( top[5], top[6] );\nPRED( 2, 3 ) = PRED( 3, 1 ) = F2( top[5], top[6], top[7] );\nPRED( 3, 2 ) = PRED( 4, 0 ) = F1( top[6], top[7] );\nPRED( 3, 3 ) = PRED( 4, 1 ) = F2( top[6], top[7], top[8] );\nPRED( 4, 2 ) = PRED( 5, 0 ) = F1( top[7], top[8] );\nPRED( 4, 3 ) = PRED( 5, 1 ) = F2( top[7], top[8], top[9] );\nPRED( 5, 2 ) = PRED( 6, 0 ) = F1( top[8], top[9] );\nPRED( 5, 3 ) = PRED( 6, 1 ) = F2( top[8], top[9], top[10] );\nPRED( 6, 2 ) = PRED( 7, 0 ) = F1( top[9], top[10] );\nPRED( 6, 3 ) = PRED( 7, 1 ) = F2( top[9], top[10], top[11] );\nPRED( 7, 2 ) = F1( top[10], top[11] );\nPRED( 7, 3 ) = F2( top[10], top[11], top[12] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n#undef PRED\n}\nint x264_predict_8x8_hu( const local pixel *src, int src_stride, const local pixel *left )\n{\nprivate pixel pred[32];\nint satd;\nint p1 = pack8to16( (F1( left[0], left[1] )), ((left[0] + 2 * left[1] + left[2] + 2) >> 2) );\nint p2 = pack8to16( (F1( left[1], left[2] )), ((left[1] + 2 * left[2] + left[3] + 2) >> 2) );\nint p3 = pack8to16( (F1( left[2], left[3] )), ((left[2] + 2 * left[3] + left[4] + 2) >> 2) );\nint p4 = pack8to16( (F1( left[3], left[4] )), ((left[3] + 2 * left[4] + left[5] + 2) >> 2) );\nint p5 = pack8to16( (F1( left[4], left[5] )), ((left[4] + 2 * left[5] + left[6] + 2) >> 2) );\nint p6 = pack8to16( (F1( left[5], left[6] )), ((left[5] + 2 * left[6] + left[7] + 2) >> 2) );\nint p7 = pack8to16( (F1( left[6], left[7] )), ((left[6] + 2 * left[7] + left[7] + 2) >> 2) );\nint p8 = pack8to16( left[7], left[7] );\nvstore4( as_uchar4( pack16to32( p1, p2 ) ), 0, &pred[( 0 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[( 4 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p2, p3 ) ), 0, &pred[( 0 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[( 4 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p3, p4 ) ), 0, &pred[( 0 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[( 4 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p4, p5 ) ), 0, &pred[( 0 ) + ( 3 ) * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[( 4 ) + ( 3 ) * 8] );\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nvstore4( as_uchar4( pack16to32( p5, p6 ) ), 0, &pred[( 0 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[( 4 ) + ( 0 ) * 8] );\nvstore4( as_uchar4( pack16to32( p6, p7 ) ), 0, &pred[( 0 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 4 ) + ( 1 ) * 8] );\nvstore4( as_uchar4( pack16to32( p7, p8 ) ), 0, &pred[( 0 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 4 ) + ( 2 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 0 ) + ( 3 ) * 8] );\nvstore4( as_uchar4( pack16to32( p8, p8 ) ), 0, &pred[( 4 ) + ( 3 ) * 8] );\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8c_h( const local pixel *src, int src_stride )\n{\nprivate pixel pred[32];\nconst local pixel *src_l = src;\nvstore8( (uchar8)(src[-1]), 0, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 1, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 2, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 3, pred ); src += src_stride;\nint satd = satd_8x4_lp( src_l, src_stride, pred, 8 );\nvstore8( (uchar8)(src[-1]), 0, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 1, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 2, pred ); src += src_stride;\nvstore8( (uchar8)(src[-1]), 3, pred );\nreturn satd + satd_8x4_lp( src_l + ( src_stride << 2 ), src_stride, pred, 8 );\n}\nint x264_predict_8x8c_v( const local pixel *src, int src_stride )\n{\nprivate pixel pred[32];\nuchar16 v16;\nv16.lo = vload8( 0, &src[-src_stride] );\nv16.hi = vload8( 0, &src[-src_stride] );\nvstore16( v16, 0, pred );\nvstore16( v16, 1, pred );\nreturn satd_8x4_lp( src, src_stride, pred, 8 ) +\nsatd_8x4_lp( src + (src_stride << 2), src_stride, pred, 8 );\n}\nint x264_predict_8x8c_p( const local pixel *src, int src_stride )\n{\nint H = 0, V = 0;\nprivate pixel pred[32];\nint satd;\nfor( int i = 0; i < 4; i++ )\n{\nH += (i + 1) * (src[4 + i - src_stride] - src[2 - i - src_stride]);\nV += (i + 1) * (src[-1 + (i + 4) * src_stride] - src[-1 + (2 - i) * src_stride]);\n}\nint a = 16 * (src[-1 + 7 * src_stride] + src[7 - src_stride]);\nint b = (17 * H + 16) >> 5;\nint c = (17 * V + 16) >> 5;\nint i00 = a - 3 * b - 3 * c + 16;\nfor( int y = 0; y < 4; y++ )\n{\nint pix = i00;\nfor( int x = 0; x < 8; x++ )\n{\npred[x + y*8] = x264_clip_pixel( pix >> 5 );\npix += b;\n}\ni00 += c;\n}\nsatd = satd_8x4_lp( src, src_stride, pred, 8 );\nfor( int y = 0; y < 4; y++ )\n{\nint pix = i00;\nfor( int x = 0; x < 8; x++ )\n{\npred[x + y*8] = x264_clip_pixel( pix >> 5 );\npix += b;\n}\ni00 += c;\n}\nsatd += satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\nreturn satd;\n}\nint x264_predict_8x8c_dc( const local pixel *src, int src_stride )\n{\nprivate pixel pred[32];\nint s0 = 0, s1 = 0, s2 = 0, s3 = 0;\nfor( int i = 0; i < 4; i++ )\n{\ns0 += src[i - src_stride];\ns1 += src[i + 4 - src_stride];\ns2 += src[-1 + i * src_stride];\ns3 += src[-1 + (i+4)*src_stride];\n}\nuchar8 dc0;\ndc0.lo = (uchar4)( (s0 + s2 + 4) >> 3 );\ndc0.hi = (uchar4)( (s1 + 2) >> 2 );\nvstore8( dc0, 0, pred );\nvstore8( dc0, 1, pred );\nvstore8( dc0, 2, pred );\nvstore8( dc0, 3, pred );\nint satd = satd_8x4_lp( src, src_stride, pred, 8 );\ndc0.lo = (uchar4)( (s3 + 2) >> 2 );\ndc0.hi = (uchar4)( (s1 + s3 + 4) >> 3 );\nvstore8( dc0, 0, pred );\nvstore8( dc0, 1, pred );\nvstore8( dc0, 2, pred );\nvstore8( dc0, 3, pred );\nreturn satd + satd_8x4_lp( src + ( src_stride << 2 ), src_stride, pred, 8 );\n}\n#endif\n/* Find the least cost intra mode for 32 8x8 macroblocks per workgroup\n*\n* Loads 33 macroblocks plus the pixels directly above them into local memory,\n* padding where necessary with edge pixels.  It then cooperatively calculates\n* smoothed top and left pixels for use in some of the analysis.\n*\n* Then groups of 32 threads each calculate a single intra mode for each 8x8\n* block.  Since consecutive threads are calculating the same intra mode there\n* is no code-path divergence.  8 intra costs are calculated simultaneously.  If\n* the \"slow\" argument is not zero, the final two (least likely) intra modes are\n* tested in a second pass.  The slow mode is only enabled for presets slow,\n* slower, and placebo.\n*\n* This allows all of the pixels functions to read pixels from local memory, and\n* avoids re-fetching edge pixels from global memory.  And it allows us to\n* calculate all of the intra mode costs simultaneously without branch divergence.\n*\n* Local dimension:    [ 32, 8 ]\n* Global dimensions:  [ paddedWidth, height ] */\nkernel void mb_intra_cost_satd_8x8( read_only image2d_t  fenc,\nglobal uint16_t     *fenc_intra_cost,\nglobal int          *frame_stats,\nint                  lambda,\nint                  mb_width,\nint                  slow )\n{\n#define CACHE_STRIDE 265\n#define BLOCK_OFFSET 266\nlocal pixel cache[2385];\nlocal int cost_buf[32];\nlocal pixel top[32 * 16];\nlocal pixel left[32 * 8];\nlocal pixel left_top[32];\nint lx = get_local_id( 0 );\nint ly = get_local_id( 1 );\nint gx = get_global_id( 0 );\nint gy = get_global_id( 1 );\nint gidx = get_group_id( 0 );\nint gidy = get_group_id( 1 );\nint linear_id = ly * get_local_size( 0 ) + lx;\nint satd = COST_MAX;\nint basex = gidx << 8;\nint basey = (gidy << 3) - 1;\n/* Load 33 8x8 macroblocks and the pixels above them into local cache */\nfor( int y = 0; y < 9 && linear_id < (33<<3)>>2; y++ )\n{\nint x = linear_id << 2;\nuint4 data = read_imageui( fenc, sampler, (int2)(x + basex, y + basey) );\ncache[y * CACHE_STRIDE + 1 + x] = data.s0;\ncache[y * CACHE_STRIDE + 1 + x + 1] = data.s1;\ncache[y * CACHE_STRIDE + 1 + x + 2] = data.s2;\ncache[y * CACHE_STRIDE + 1 + x + 3] = data.s3;\n}\n/* load pixels on left edge */\nif( linear_id < 9 )\ncache[linear_id * CACHE_STRIDE] = read_imageui( fenc, sampler, (int2)( basex - 1, linear_id + basey) ).s0;\nbarrier( CLK_LOCAL_MEM_FENCE );\nint j = ly;\ntop[lx*16 + j] = ( cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j - 1, -1, 15 )] +\n2*cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j, 0, 15 )] +\ncache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j + 1, 0, 15 )] + 2 ) >> 2;\nj += 8;\ntop[lx*16 + j] = ( cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j - 1, -1, 15 )] +\n2*cache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j, 0, 15 )] +\ncache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE + clamp_int( j + 1, 0, 15 )] + 2 ) >> 2;\nleft[lx*8 + ly] = ( cache[BLOCK_OFFSET + 8*lx - 1 + CACHE_STRIDE*(ly - 1)] +\n2*cache[BLOCK_OFFSET + 8*lx - 1 + CACHE_STRIDE*ly] +\ncache[BLOCK_OFFSET + 8*lx - 1 + CACHE_STRIDE*clamp((ly + 1), 0, 7 )] + 2 ) >> 2;\nif( 0 == ly )\n{\nleft_top[lx] = ( cache[BLOCK_OFFSET + 8*lx - 1] + 2*cache[BLOCK_OFFSET + 8*lx - 1 - CACHE_STRIDE] +\ncache[BLOCK_OFFSET + 8*lx - CACHE_STRIDE] + 2 ) >> 2;\ncost_buf[lx] = COST_MAX;\n}\nbarrier( CLK_LOCAL_MEM_FENCE );\nswitch( ly )\n{\ncase 0:\nsatd = x264_predict_8x8c_h( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 1:\nsatd = x264_predict_8x8c_v( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 2:\nsatd = x264_predict_8x8c_dc( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 3:\nsatd = x264_predict_8x8c_p( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE );\nbreak;\ncase 4:\nsatd = x264_predict_8x8_ddr( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx], &left[8*lx], left_top[lx] );\nbreak;\ncase 5:\nsatd = x264_predict_8x8_vr( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx], &left[8*lx], left_top[lx] );\nbreak;\ncase 6:\nsatd = x264_predict_8x8_hd( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx], &left[8*lx], left_top[lx] );\nbreak;\ncase 7:\nsatd = x264_predict_8x8_hu( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &left[8*lx] );\nbreak;\ndefault:\nbreak;\n}\natom_min( &cost_buf[lx], satd );\nif( slow )\n{\nswitch( ly )\n{\ncase 0: // DDL\nsatd = x264_predict_8x8_ddl( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx] );\natom_min( &cost_buf[lx], satd );\nbreak;\ncase 1: // VL\nsatd = x264_predict_8x8_vl( &cache[BLOCK_OFFSET + 8*lx], CACHE_STRIDE, &top[16*lx] );\natom_min( &cost_buf[lx], satd );\nbreak;\ndefault:\nbreak;\n}\n}\nbarrier( CLK_LOCAL_MEM_FENCE );\nif( (0 == ly) && (gx < mb_width) )\nfenc_intra_cost[gidy * mb_width + gx] = cost_buf[lx]+ 5*lambda;\nif( gx < 2 && gy == 0 )\nframe_stats[gx] = 0;\n#undef CACHE_STRIDE\n#undef BLOCK_OFFSET\n}\n/*\n* parallel sum intra costs\n*\n* global launch dimensions: [256, mb_height]\n*/\nkernel void sum_intra_cost( const global uint16_t *fenc_intra_cost,\nconst global uint16_t *inv_qscale_factor,\nglobal int           *fenc_row_satds,\nglobal int           *frame_stats,\nint                   mb_width )\n{\nint y = get_global_id( 1 );\nint mb_height = get_global_size( 1 );\nint row_satds = 0;\nint cost_est = 0;\nint cost_est_aq = 0;\nfor( int x = get_global_id( 0 ); x < mb_width; x += get_global_size( 0 ))\n{\nint mb_xy = x + y * mb_width;\nint cost = fenc_intra_cost[mb_xy];\nint cost_aq = (cost * inv_qscale_factor[mb_xy] + 128) >> 8;\nint b_frame_score_mb = (x > 0 && x < mb_width - 1 && y > 0 && y < mb_height - 1) || mb_width <= 2 || mb_height <= 2;\nrow_satds += cost_aq;\nif( b_frame_score_mb )\n{\ncost_est += cost;\ncost_est_aq += cost_aq;\n}\n}\nlocal int buffer[256];\nint x = get_global_id( 0 );\nrow_satds   = parallel_sum( row_satds, x, buffer );\ncost_est    = parallel_sum( cost_est, x, buffer );\ncost_est_aq = parallel_sum( cost_est_aq, x, buffer );\nif( get_global_id( 0 ) == 0 )\n{\nfenc_row_satds[y] = row_satds;\natomic_add( frame_stats + COST_EST,    cost_est );\natomic_add( frame_stats + COST_EST_AQ, cost_est_aq );\n}\n}\n/* Hierarchical (iterative) OpenCL lowres motion search */\ninline int find_downscale_mb_xy( int x, int y, int mb_width, int mb_height )\n{\n/* edge macroblocks might not have a direct descendant, use nearest */\nx = select( x >> 1, (x - (mb_width&1)) >> 1, x == mb_width-1 );\ny = select( y >> 1, (y - (mb_height&1)) >> 1, y == mb_height-1 );\nreturn (mb_width>>1) * y + x;\n}\n/* Four threads calculate an 8x8 SAD.  Each does two rows */\nint sad_8x8_ii_coop4( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref, int2 frefpos, int idx, local int16_t *costs )\n{\nfrefpos.y += idx << 1;\nfencpos.y += idx << 1;\nint cost = 0;\nif( frefpos.x < 0 )\n{\n/* slow path when MV goes past left edge.  The GPU clamps reads from\n* (-1, 0) to (0,0), so you get pixels [0, 1, 2, 3] when what you really\n* want are [0, 0, 1, 2]\n*/\nfor( int y = 0; y < 2; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\npixel enc = read_imageui( fenc, sampler, fencpos + (int2)(x, y) ).s0;\npixel ref = read_imageui( fref, sampler, frefpos + (int2)(x, y) ).s0;\ncost += abs_diff( enc, ref );\n}\n}\n}\nelse\n{\nuint4 enc, ref, costs = 0;\nenc = read_imageui( fenc, sampler, fencpos );\nref = read_imageui( fref, sampler, frefpos );\ncosts += abs_diff( enc, ref );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(4, 0) );\nref = read_imageui( fref, sampler, frefpos + (int2)(4, 0) );\ncosts += abs_diff( enc, ref );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(0, 1) );\nref = read_imageui( fref, sampler, frefpos + (int2)(0, 1) );\ncosts += abs_diff( enc, ref );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(4, 1) );\nref = read_imageui( fref, sampler, frefpos + (int2)(4, 1) );\ncosts += abs_diff( enc, ref );\ncost = costs.s0 + costs.s1 + costs.s2 + costs.s3;\n}\ncosts[idx] = cost;\nreturn costs[0] + costs[1] + costs[2] + costs[3];\n}\n/* One thread performs 8x8 SAD */\nint sad_8x8_ii( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref, int2 frefpos )\n{\nif( frefpos.x < 0 )\n{\n/* slow path when MV goes past left edge */\nint cost = 0;\nfor( int y = 0; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\nuint enc = read_imageui( fenc, sampler, fencpos + (int2)(x, y) ).s0;\nuint ref = read_imageui( fref, sampler, frefpos + (int2)(x, y) ).s0;\ncost += abs_diff( enc, ref );\n}\n}\nreturn cost;\n}\nelse\n{\nuint4 enc, ref, cost = 0;\nfor( int y = 0; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x += 4 )\n{\nenc = read_imageui( fenc, sampler, fencpos + (int2)(x, y) );\nref = read_imageui( fref, sampler, frefpos + (int2)(x, y) );\ncost += abs_diff( enc, ref );\n}\n}\nreturn cost.s0 + cost.s1 + cost.s2 + cost.s3;\n}\n}\n/*\n* hierarchical motion estimation\n*\n* Each kernel launch is a single iteration\n*\n* MB per work group is determined by lclx / 4 * lcly\n*\n* global launch dimensions:  [mb_width * 4, mb_height]\n*/\nkernel void hierarchical_motion( read_only image2d_t  fenc,\nread_only image2d_t  fref,\nconst global short2 *in_mvs,\nglobal short2       *out_mvs,\nglobal int16_t      *out_mv_costs,\nglobal short2       *mvp_buffer,\nlocal int16_t       *cost_local,\nlocal short2        *mvc_local,\nint                  mb_width,\nint                  lambda,\nint                  me_range,\nint                  scale,\nint                  b_shift_index,\nint                  b_first_iteration,\nint                  b_reverse_references )\n{\nint mb_x = get_global_id( 0 ) >> 2;\nif( mb_x >= mb_width )\nreturn;\nint mb_height = get_global_size( 1 );\nint mb_i = get_global_id( 0 ) & 3;\nint mb_y = get_global_id( 1 );\nint mb_xy = mb_y * mb_width + mb_x;\nconst int mb_size = 8;\nint2 coord = (int2)(mb_x, mb_y) * mb_size;\nconst int mb_in_group = get_local_id( 1 ) * (get_local_size( 0 ) >> 2) + (get_local_id( 0 ) >> 2);\ncost_local += 4 * mb_in_group;\nint i_mvc = 0;\nmvc_local += 4 * mb_in_group;\nmvc_local[mb_i] = 0;\nint2 mvp =0;\nif( !b_first_iteration )\n{\n#define MVC( DX, DY )\\\n{\\\nint px = mb_x + DX;\\\nint py = mb_y + DY;\\\nmvc_local[i_mvc] = b_shift_index ? in_mvs[find_downscale_mb_xy( px, py, mb_width, mb_height )] : \\\nin_mvs[mb_width * py + px];\\\nmvc_local[i_mvc] >>= (short) scale;\\\ni_mvc++;\\\n}\n/* Find MVP from median of MVCs */\nif( b_reverse_references )\n{\n/* odd iterations: derive MVP from down and right */\nif( mb_x < mb_width - 1 )\nMVC( 1, 0 );\nif( mb_y < mb_height - 1 )\n{\nMVC( 0, 1 );\nif( mb_x > b_shift_index )\nMVC( -1, 1 );\nif( mb_x < mb_width - 1 )\nMVC( 1, 1 );\n}\n}\nelse\n{\n/* even iterations: derive MVP from up and left */\nif( mb_x > 0 )\nMVC( -1, 0 );\nif( mb_y > 0 )\n{\nMVC( 0, -1 );\nif( mb_x < mb_width - 1 )\nMVC( 1, -1 );\nif( mb_x > b_shift_index )\nMVC( -1, -1 );\n}\n}\n#undef MVC\nmvp = (i_mvc <= 1) ? convert_int2_sat(mvc_local[0]) : x264_median_mv( mvc_local[0], mvc_local[1], mvc_local[2] );\n}\n/* current mvp matches the previous mvp and we have not changed scale.  We know\n* we're going to arrive at the same MV again, so just copy the previous\n* result to our output. */\nif( !b_shift_index && mvp.x == mvp_buffer[mb_xy].x && mvp.y == mvp_buffer[mb_xy].y )\n{\nout_mvs[mb_xy] = in_mvs[mb_xy];\nreturn;\n}\nmvp_buffer[mb_xy] = convert_short2_sat(mvp);\nint2 mv_min = -mb_size * (int2)(mb_x, mb_y) - 4;\nint2 mv_max = mb_size * ((int2)(mb_width, mb_height) - (int2)(mb_x, mb_y) - 1) + 4;\nint2 bestmv = clamp(mvp, mv_min, mv_max);\nint2 refcrd = coord + bestmv;\n/* measure cost at bestmv */\nint bcost = sad_8x8_ii_coop4( fenc, coord, fref, refcrd, mb_i, cost_local ) +\nlambda * mv_cost( abs_diff( bestmv, mvp ) << (2 + scale) );\ndo\n{\n/* measure costs at offsets from bestmv */\nrefcrd = coord + bestmv + dia_offs[mb_i];\nint2 trymv = bestmv + dia_offs[mb_i];\nint cost = sad_8x8_ii( fenc, coord, fref, refcrd ) +\nlambda * mv_cost( abs_diff( trymv, mvp ) << (2 + scale) );\ncost_local[mb_i] = (cost<<2) | mb_i;\ncost = min( cost_local[0], min( cost_local[1], min( cost_local[2], cost_local[3] ) ) );\nif( (cost >> 2) >= bcost )\nbreak;\nbestmv += dia_offs[cost&3];\nbcost = cost>>2;\nif( bestmv.x >= mv_max.x || bestmv.x <= mv_min.x || bestmv.y >= mv_max.y || bestmv.y <= mv_min.y )\nbreak;\n}\nwhile( --me_range > 0 );\nint2 trymv = 0, diff = 0;\n#define COST_MV_NO_PAD( L )\\\ntrymv = clamp( trymv, mv_min, mv_max );\\\ndiff = convert_int2_sat(abs_diff( mvp, trymv ));\\\nif( diff.x > 1 || diff.y > 1 ) {\\\nint2 refcrd = coord + trymv;\\\nint cost = sad_8x8_ii_coop4( fenc, coord, fref, refcrd, mb_i, cost_local ) +\\\nL * mv_cost( abs_diff( trymv, mvp ) << (2 + scale) );\\\nif( cost < bcost ) { bcost = cost; bestmv = trymv; } }\nCOST_MV_NO_PAD( 0 );\nif( !b_first_iteration )\n{\n/* try cost at previous iteration's MV, if MVP was too far away */\nint2 prevmv = b_shift_index ? convert_int2_sat(in_mvs[find_downscale_mb_xy( mb_x, mb_y, mb_width, mb_height )]) : convert_int2_sat(in_mvs[mb_xy]);\nprevmv >>= scale;\ntrymv = prevmv;\nCOST_MV_NO_PAD( lambda );\n}\nfor( int i = 0; i < i_mvc; i++ )\n{\n/* try cost at each candidate MV, if MVP was too far away */\ntrymv = convert_int2_sat( mvc_local[i] );\nCOST_MV_NO_PAD( lambda );\n}\nif( mb_i == 0 )\n{\nbestmv <<= scale;\nout_mvs[mb_xy] = convert_short2_sat(bestmv);\nout_mv_costs[mb_xy] = min( bcost, LOWRES_COST_MASK );\n}\n}\n/* OpenCL lowres subpel Refine */\n/* Each thread performs 8x8 SAD.  4 threads per MB, so the 4 DIA HPEL offsets are\n* calculated simultaneously */\nint sad_8x8_ii_hpel( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref_planes, int2 qpos )\n{\nint2 frefpos = qpos >> 2;\nint hpel_idx = ((qpos.x & 2) >> 1) + (qpos.y & 2);\nuint mask_shift = 8 * hpel_idx;\nuint4 cost4 = 0;\nfor( int y = 0; y < 8; y++ )\n{\nuint4 enc, val4;\nenc = read_imageui( fenc, sampler, fencpos + (int2)(0, y));\nval4.s0 = (read_imageui( fref_planes, sampler, frefpos + (int2)(0, y)).s0 >> mask_shift) & 0xFF;\nval4.s1 = (read_imageui( fref_planes, sampler, frefpos + (int2)(1, y)).s0 >> mask_shift) & 0xFF;\nval4.s2 = (read_imageui( fref_planes, sampler, frefpos + (int2)(2, y)).s0 >> mask_shift) & 0xFF;\nval4.s3 = (read_imageui( fref_planes, sampler, frefpos + (int2)(3, y)).s0 >> mask_shift) & 0xFF;\ncost4 += abs_diff( enc, val4 );\nenc = read_imageui( fenc, sampler, fencpos + (int2)(4, y));\nval4.s0 = (read_imageui( fref_planes, sampler, frefpos + (int2)(4, y)).s0 >> mask_shift) & 0xFF;\nval4.s1 = (read_imageui( fref_planes, sampler, frefpos + (int2)(5, y)).s0 >> mask_shift) & 0xFF;\nval4.s2 = (read_imageui( fref_planes, sampler, frefpos + (int2)(6, y)).s0 >> mask_shift) & 0xFF;\nval4.s3 = (read_imageui( fref_planes, sampler, frefpos + (int2)(7, y)).s0 >> mask_shift) & 0xFF;\ncost4 += abs_diff( enc, val4 );\n}\nreturn cost4.s0 + cost4.s1 + cost4.s2 + cost4.s3;\n}\n/* One thread measures 8x8 SAD cost at a QPEL offset into an HPEL plane */\nint sad_8x8_ii_qpel( read_only image2d_t fenc, int2 fencpos, read_only image2d_t fref_planes, int2 qpos )\n{\nint2 frefApos = qpos >> 2;\nint hpelA = ((qpos.x & 2) >> 1) + (qpos.y & 2);\nint2 qposB = qpos + ((qpos & 1) << 1);\nint2 frefBpos = qposB >> 2;\nint hpelB = ((qposB.x & 2) >> 1) + (qposB.y & 2);\nuint mask_shift0 = 8 * hpelA, mask_shift1 = 8 * hpelB;\nint cost = 0;\nfor( int y = 0; y < 8; y++ )\n{\nfor( int x = 0; x < 8; x++ )\n{\nuint enc = read_imageui( fenc, sampler, fencpos + (int2)(x, y)).s0;\nuint vA = (read_imageui( fref_planes, sampler, frefApos + (int2)(x, y)).s0 >> mask_shift0) & 0xFF;\nuint vB = (read_imageui( fref_planes, sampler, frefBpos + (int2)(x, y)).s0 >> mask_shift1) & 0xFF;\ncost += abs_diff( enc, rhadd( vA, vB ) );\n}\n}\nreturn cost;\n}\n/* Four threads measure 8x8 SATD cost at a QPEL offset into an HPEL plane\n*\n* Each thread collects 1/4 of the rows of diffs and processes one quarter of\n* the transforms\n*/\nint satd_8x8_ii_qpel_coop4( read_only image2d_t fenc,\nint2 fencpos,\nread_only image2d_t fref_planes,\nint2 qpos,\nlocal sum2_t *tmpp,\nint idx )\n{\nvolatile local sum2_t( *tmp )[4] = (volatile local sum2_t( * )[4])tmpp;\nsum2_t b0, b1, b2, b3;\nint2 frefApos = qpos >> 2;\nint hpelA = ((qpos.x&2)>>1) + (qpos.y&2);\nint2 qposB = qpos + (int2)(((qpos.x&1)<<1), ((qpos.y&1)<<1));\nint2 frefBpos = qposB >> 2;\nint hpelB = ((qposB.x&2)>>1) + (qposB.y&2);\nuint mask_shift0 = 8 * hpelA, mask_shift1 = 8 * hpelB;\nuint vA, vB;\nuint a0, a1;\nuint enc;\nsum2_t sum = 0;\n#define READ_DIFF( OUT, X )\\\nenc = read_imageui( fenc, sampler, fencpos + (int2)(X, idx) ).s0;\\\nvA = (read_imageui( fref_planes, sampler, frefApos + (int2)(X, idx) ).s0 >> mask_shift0) & 0xFF;\\\nvB = (read_imageui( fref_planes, sampler, frefBpos + (int2)(X, idx) ).s0 >> mask_shift1) & 0xFF;\\\nOUT = enc - rhadd( vA, vB );\n#define READ_DIFF_EX( OUT, a, b )\\\n{\\\nREAD_DIFF( a0, a );\\\nREAD_DIFF( a1, b );\\\nOUT = a0 + (a1<<BITS_PER_SUM);\\\n}\n#define ROW_8x4_SATD( a, b )\\\n{\\\nfencpos.y += a;\\\nfrefApos.y += b;\\\nfrefBpos.y += b;\\\nREAD_DIFF_EX( b0, 0, 4 );\\\nREAD_DIFF_EX( b1, 1, 5 );\\\nREAD_DIFF_EX( b2, 2, 6 );\\\nREAD_DIFF_EX( b3, 3, 7 );\\\nHADAMARD4( tmp[idx][0], tmp[idx][1], tmp[idx][2], tmp[idx][3], b0, b1, b2, b3 );\\\nHADAMARD4( b0, b1, b2, b3, tmp[0][idx], tmp[1][idx], tmp[2][idx], tmp[3][idx] );\\\nsum += abs2( b0 ) + abs2( b1 ) + abs2( b2 ) + abs2( b3 );\\\n}\nROW_8x4_SATD( 0, 0 );\nROW_8x4_SATD( 4, 4 );\n#undef READ_DIFF\n#undef READ_DIFF_EX\n#undef ROW_8x4_SATD\nreturn (((sum_t)sum) + (sum>>BITS_PER_SUM)) >> 1;\n}\nconstant int2 hpoffs[4] =\n{\n{0, -2}, {-2, 0}, {2, 0}, {0, 2}\n};\n/* sub pixel refinement of motion vectors, output MVs and costs are moved from\n* temporary buffers into final per-frame buffer\n*\n* global launch dimensions:  [mb_width * 4, mb_height]\n*\n* With X being the source 16x16 pixels, F is the lowres pixel used by the\n* motion search.  We will now utilize the H V and C pixels (stored in separate\n* planes) to search at half-pel increments.\n*\n* X X X X X X\n*  F H F H F\n* X X X X X X\n*  V C V C V\n* X X X X X X\n*  F H F H F\n* X X X X X X\n*\n* The YX HPEL bits of the motion vector selects the plane we search in.  The\n* four planes are packed in the fref_planes 2D image buffer.  Each sample\n* returns:  s0 = F, s1 = H, s2 = V, s3 = C */\nkernel void subpel_refine( read_only image2d_t   fenc,\nread_only image2d_t   fref_planes,\nconst global short2  *in_mvs,\nconst global int16_t *in_sad_mv_costs,\nlocal int16_t        *cost_local,\nlocal sum2_t         *satd_local,\nlocal short2         *mvc_local,\nglobal short2        *fenc_lowres_mv,\nglobal int16_t       *fenc_lowres_mv_costs,\nint                   mb_width,\nint                   lambda,\nint                   b,\nint                   ref,\nint                   b_islist1 )\n{\nint mb_x = get_global_id( 0 ) >> 2;\nif( mb_x >= mb_width )\nreturn;\nint mb_height = get_global_size( 1 );\nint mb_i = get_global_id( 0 ) & 3;\nint mb_y = get_global_id( 1 );\nint mb_xy = mb_y * mb_width + mb_x;\n/* fenc_lowres_mv and fenc_lowres_mv_costs are large buffers that\n* hold many frames worth of motion vectors.  We must offset into the correct\n* location for this frame's vectors.  The kernel will be passed the correct\n* directional buffer for the direction of the search: list1 or list0\n*\n*   CPU equivalent: fenc->lowres_mvs[0][b - p0 - 1]\n*   GPU equivalent: fenc_lowres_mvs[(b - p0 - 1) * mb_count] */\nfenc_lowres_mv +=       (b_islist1 ? (ref-b-1) : (b-ref-1)) * mb_width * mb_height;\nfenc_lowres_mv_costs += (b_islist1 ? (ref-b-1) : (b-ref-1)) * mb_width * mb_height;\n/* Adjust pointers into local memory buffers for this thread's data */\nint mb_in_group = get_local_id( 1 ) * (get_local_size( 0 ) >> 2) + (get_local_id( 0 ) >> 2);\ncost_local += mb_in_group * 4;\nsatd_local += mb_in_group * 16;\nmvc_local += mb_in_group * 4;\nint i_mvc = 0;\nmvc_local[0] = mvc_local[1] = mvc_local[2] = mvc_local[3] = 0;\n#define MVC( DX, DY ) mvc_local[i_mvc++] = in_mvs[mb_width * (mb_y + DY) + (mb_x + DX)];\nif( mb_x > 0 )\nMVC( -1, 0 );\nif( mb_y > 0 )\n{\nMVC( 0, -1 );\nif( mb_x < mb_width - 1 )\nMVC( 1, -1 );\nif( mb_x > 0 )\nMVC( -1, -1 );\n}\n#undef MVC\nint2 mvp = (i_mvc <= 1) ? convert_int2_sat(mvc_local[0]) : x264_median_mv( mvc_local[0], mvc_local[1], mvc_local[2] );\nint bcost =  in_sad_mv_costs[mb_xy];\nint2 coord = (int2)(mb_x, mb_y) << 3;\nint2 bmv = convert_int2_sat( in_mvs[mb_xy] );\n/* Make mvp and bmv QPEL MV */\nmvp <<= 2; bmv <<= 2;\n#define HPEL_QPEL( ARR, FUNC )\\\n{\\\nint2 trymv = bmv + ARR[mb_i];\\\nint2 qpos = (coord << 2) + trymv;\\\nint cost = FUNC( fenc, coord, fref_planes, qpos ) + lambda * mv_cost( abs_diff( trymv, mvp ) );\\\ncost_local[mb_i] = (cost<<2) + mb_i;\\\ncost = min( cost_local[0], min( cost_local[1], min( cost_local[2], cost_local[3] ) ) );\\\nif( (cost>>2) < bcost )\\\n{\\\nbmv += ARR[cost&3];\\\nbcost = cost>>2;\\\n}\\\n}\nHPEL_QPEL( hpoffs, sad_8x8_ii_hpel );\nHPEL_QPEL( dia_offs, sad_8x8_ii_qpel );\nfenc_lowres_mv[mb_xy] = convert_short2_sat( bmv );\n/* remeasure cost of bmv using SATD */\nint2 qpos = (coord << 2) + bmv;\ncost_local[mb_i] = satd_8x8_ii_qpel_coop4( fenc, coord, fref_planes, qpos, satd_local, mb_i );\nbcost = cost_local[0] + cost_local[1] + cost_local[2] + cost_local[3];\nbcost += lambda * mv_cost( abs_diff( bmv, mvp ) );\nfenc_lowres_mv_costs[mb_xy] = min( bcost, LOWRES_COST_MASK );\n}\n/* Weightp filter a downscaled image into a temporary output buffer.\n* This kernel is launched once for each scale.\n*\n* Launch dimensions: width x height (in pixels)\n*/\nkernel void weightp_scaled_images( read_only image2d_t in_plane,\nwrite_only image2d_t out_plane,\nuint offset,\nuint scale,\nuint denom )\n{\nint gx = get_global_id( 0 );\nint gy = get_global_id( 1 );\nuint4 input_val;\nuint4 output_val;\ninput_val = read_imageui( in_plane, sampler, (int2)(gx, gy));\noutput_val = (uint4)(offset) + ( ( ((uint4)(scale)) * input_val ) >> ((uint4)(denom)) );\nwrite_imageui( out_plane, (int2)(gx, gy), output_val );\n}\n/* Weightp filter for the half-pel interpolated image\n*\n* Launch dimensions: width x height (in pixels)\n*/\nkernel void weightp_hpel( read_only image2d_t in_plane,\nwrite_only image2d_t out_plane,\nuint offset,\nuint scale,\nuint denom )\n{\nint gx = get_global_id( 0 );\nint gy = get_global_id( 1 );\nuint input_val;\nuint output_val;\ninput_val = read_imageui( in_plane, sampler, (int2)(gx, gy)).s0;\nuint4 temp;\ntemp.s0 = input_val & 0x00ff; temp.s1 = (input_val >> 8) & 0x00ff;\ntemp.s2 = (input_val >> 16) & 0x00ff; temp.s3 = (input_val >> 24) & 0x00ff;\ntemp = (uint4)(offset) + ( ( ((uint4)(scale)) * temp ) >> ((uint4)(denom)) );\noutput_val = temp.s0 | (temp.s1 << 8) | (temp.s2 << 16) | (temp.s3 << 24);\nwrite_imageui( out_plane, (int2)(gx, gy), output_val );\n}\n", "x264_macroblock_bipred_init", "(Px264_frame_push_blank_unused", "x264_frame_push_unused", "x264_frame_shift", "x264_frame_pop", "x264_slicetype_analyse", "x264_macroblock_analyse", "Gg!x264_cabac_8x8_mvd", "x264_ratecontrol_start", "init_pass2", "x264_ratecontrol_new", "Gg!x264_cabac_8x8_mvd", "(Px264_opencl_alloc_locked", "x264_macroblock_cache_rect"], "stringidentifiers": ["infinity", "aac_adtstoasc", "aac_latm", "Main", "dual_mono_mode", "auto", "autoselection", "main", "both", "stereo_mode", "ms_off", "ms_force", "aac_coder", "faac", "anmr", "twoloop", "fast", "aac_pns", "disable", "enable", "aac_is", "intensity_stereo", "aac_tns", "aac_pred", "AVDCT", "fastint", "altivec", "faan", "idct", "simple", "simplemmx", "simplearm", "simplearmv5te", "simplearmv6", "simpleneon", "simplealpha", "xvid", "xvidmmx", "faani", "simpleauto", "bits_per_sample", "Palette", "mpeg1video", "mpeg2video", "mpegvideo_xvmc", "h261", "h263", "rv10", "rv20", "mjpeg", "mjpegb", "mpeg4", "rawvideo", "msmpeg4v1", "msmpeg4v2", "msmpeg4v3", "wmv1", "wmv2", "h263p", "h263i", "flv1", "svq1", "svq3", "dvvideo", "huffyuv", "HuffYUV", "cyuv", "h264", "indeo3", "theora", "Theora", "asv1", "asv2", "ffv1", "vcr1", "cljr", "mdec", "interplayvideo", "xan_wc3", "xan_wc4", "rpza", "cinepak", "Cinepak", "ws_vqa", "msrle", "msvideo1", "idcin", "flic", "truemotion1", "vmdvideo", "mszh", "zlib", "qtrle", "snow", "Snow", "tscc", "ulti", "qdraw", "vixl", "qpeg", "ffvhuff", "rv30", "rv40", "wmv3", "loco", "LOCO", "wnv1", "aasc", "indeo2", "fraps", "Fraps", "truemotion2", "cscd", "CamStudio", "mmvideo", "zmbv", "smackvideo", "kmvc", "flashsv", "cavs", "jpeg2000", "vmnc", "vp6f", "dsicinvideo", "tiertexseqvideo", "dnxhd", "bethsoftvid", "vp6a", "indeo4", "indeo5", "mimic", "Mimic", "escape124", "dirac", "Dirac", "motionpixels", "aura", "aura2", "v210x", "v210", "frwu", "flashsv2", "cdgraphics", "r210", "binkvideo", "iff_ilbm", "iff_byterun1", "kgv1", "pictor", "a64_multi", "a64_multi5", "r10k", "mvc1", "mvc2", "mxpeg", "lagarith", "prores", "utvideo", "bmv_video", "vble", "dxtory", "Dxtory", "v410", "cdxl", "zerocodec", "mss1", "msa1", "tscc2", "mts2", "cllc", "mss2", "y41p", "escape130", "avrp", "avui", "ayuv", "targa_y216", "v308", "v408", "yuv4", "avrn", "cpia", "xface", "smvjpeg", "Go2Meeting", "hnm4video", "hevc", "paf_video", "sanm", "sgirle", "hq_hqa", "alias_pix", "ansi", "brender_pix", "jpegls", "ljpeg", "pgmyuv", "sp5x", "sunrast", "targa", "tdsc", "TDSC", "tiff", "vc1image", "webp", "WebP", "wmv3image", "apng", "pcm_s16le", "pcm_s16be", "pcm_u16le", "pcm_u16be", "pcm_s8", "pcm_u8", "pcm_mulaw", "pcm_alaw", "pcm_s32le", "pcm_s32be", "pcm_u32le", "pcm_u32be", "pcm_s24le", "pcm_s24be", "pcm_u24le", "pcm_u24be", "pcm_s24daud", "pcm_zork", "pcm_s16be_planar", "pcm_s16le_planar", "pcm_s24le_planar", "pcm_s32le_planar", "pcm_dvd", "pcm_f32be", "pcm_f32le", "pcm_f64be", "pcm_f64le", "pcm_bluray", "pcm_lxf", "s302m", "pcm_s8_planar", "adpcm_ima_qt", "adpcm_ima_wav", "adpcm_ima_dk3", "adpcm_ima_dk4", "adpcm_ima_ws", "adpcm_ima_smjpeg", "adpcm_ms", "adpcm_4xm", "adpcm_xa", "adpcm_adx", "adpcm_ea", "adpcm_g726", "adpcm_ct", "adpcm_swf", "adpcm_yamaha", "adpcm_sbpro_4", "adpcm_sbpro_3", "adpcm_sbpro_2", "adpcm_thp", "adpcm_thp_le", "adpcm_ima_amv", "adpcm_ea_r1", "adpcm_ea_r3", "adpcm_ea_r2", "adpcm_ima_ea_sead", "adpcm_ima_ea_eacs", "adpcm_ea_xas", "adpcm_ea_maxis_xa", "adpcm_ima_iss", "adpcm_g722", "adpcm_ima_apc", "adpcm_afc", "adpcm_ima_oki", "adpcm_dtk", "adpcm_ima_rad", "adpcm_g726le", "adpcm_vima", "amr_nb", "amr_wb", "ra_144", "ra_288", "roq_dpcm", "interplay_dpcm", "xan_dpcm", "sol_dpcm", "vorbis", "Vorbis", "dvaudio", "wmav1", "wmav2", "mace3", "mace6", "vmdaudio", "flac", "mp3adu", "mp3on4", "MP3onMP4", "shorten", "Shorten", "alac", "westwood_snd1", "qdm2", "cook", "truespeech", "smackaudio", "qcelp", "wavpack", "WavPack", "dsicinaudio", "musepack7", "gsm_ms", "atrac3", "voxware", "nellymoser", "musepack8", "speex", "Speex", "wmavoice", "wmapro", "wmalossless", "atrac3p", "eac3", "sipr", "twinvq", "truehd", "TrueHD", "mp4als", "atrac1", "binkaudio_rdft", "binkaudio_dct", "qdmc", "celt", "g723_1", "dss_sp", "g729", "bmv_audio", "ralf", "ilbc", "wavesynth", "sonic", "Sonic", "sonicls", "opus", "comfortnoise", "metasound", "paf_audio", "evrc", "dsd_lsbf", "dsd_msbf", "dsd_lsbf_planar", "dsd_msbf_planar", "dvd_subtitle", "dvb_subtitle", "text", "xsub", "XSUB", "mov_text", "hdmv_pgs_subtitle", "dvb_teletext", "subrip", "microdvd", "mpl2", "eia_608", "jacosub", "sami", "realtext", "subviewer1", "subviewer", "vplayer", "webvtt", "hdmv_text_subtitle", "bintext", "xbin", "dvd_nav_packet", "timed_id3", "bin_data", "brender_pix_deprecated", "escape130_deprecated", "exr_deprecated", "g2m_deprecated", "hevc_deprecated", "paf_video_deprecated", "sanm_deprecated", "vp7_deprecated", "webp_deprecated", "vima", "adpcm_vima_deprecated", "opus_deprecated", "paf_audio_deprecated", "pcm_s24le_planar_deprecated", "pcm_s32le_planar_deprecated", "pcm_s16be_planar_deprecated", "tak_deprecated", "non_deterministic", "threads", "L263", "S263", "GEOV", "GEOX", "Q264", "Baseline", "Extended", "High", "is_avc", "nal_length_size", "enable_er", "private_spspps_buf", "h264_mp4toannexb", "REDU", "CONSTR", "LPAR", "weighted", "CABAC", "CAVLC", "checkerboard_rl", "checkerboard_lr", "col_interleaved_rl", "col_interleaved_lr", "row_interleaved_rl", "row_interleaved_lr", "right_left", "left_right", "bottom_top", "top_bottom", "block_rl", "block_lr", "mono", "TEMP", "SPAT", "desc", "SEPB1", "SEPB2", "ZYGO", "weightp", "level", "deblock", "partitions", "stats", "baseline", "high", "high10", "high422", "high444", "libx264rgb", "libx264", "flags2", "i_qfactor", "b_qfactor", "qmin", "qmax", "qdiff", "qblur", "qcomp", "refs", "sc_threshold", "trellis", "me_range", "me_method", "subq", "b_strategy", "keyint_min", "coder", "thread_type", "flags", "rc_init_occupancy", "preset", "medium", "tune", "profile", "fastfirstpass", "passlogfile", "wpredp", "x264opts", "crf_max", "aq_mode", "none", "variance", "autovariance", "weightb", "smart", "ssim", "b_pyramid", "strict", "normal", "mbtree", "cplxblur", "spatial", "temporal", "tesa", "film", "animation", "grain", "stillimage", "psnr", "fastdecode", "zerolatency", "ultrafast", "superfast", "veryfast", "faster", "slow", "slower", "veryslow", "placebo", "MJPG", "PRCT", "lossless", "CJPG", "AVID", "AVI1", "JFIF", "Adob", "LJIF", "colr", "xfrm", "_JPS", "Exif", "mjpg", "extern_huff", "ffmpeg", "XVIX", "UMP4", "XVID", "RMP4", "ZMP4", "SIPP", "DIVX", "Reserved", "reserved", "WV1F", "QMP4", "MP4S", "quarter_sample", "divx_packed", "data_partitioning", "alternate_scan", "mpv_flags", "skip_rd", "strict_gop", "qp_rd", "cbp_rd", "luma_elim_threshold", "chroma_elim_threshold", "quantizer_noise_shaping", "error_rate", "qsquish", "rc_qmod_amp", "rc_qmod_freq", "rc_eq", "rc_init_cplx", "rc_buf_aggressivity", "border_mask", "lmin", "lmax", "ibias", "pbias", "rc_strategy", "motion_est", "zero", "epzs", "xone", "VCR2", "msmpeg4", "obmc", "structured_slices", "mb_info", "NULL", "AVSubtitleRect", "type", "forced", "AVFrame", "best_effort_timestamp", "pkt_pos", "pkt_size", "sample_aspect_ratio", "width", "height", "format", "channel_layout", "sample_rate", "AVCodecContext", "unaligned", "qpel", "loop", "qscale", "input_preserved", "pass1", "pass2", "gray", "emu_edge", "truncated", "ildct", "low_delay", "global_header", "bitexact", "ilme", "cgop", "output_corrupt", "noout", "ignorecrop", "local_header", "chunks", "showall", "export_mvs", "skip_manual", "full", "phods", "iter", "time_base", "cutoff", "frame_size", "frame_number", "delay", "mv_bits", "header_bits", "i_tex_bits", "p_tex_bits", "i_count", "p_count", "skip_count", "misc_bits", "frame_bits", "codec_tag", "autodetect", "old_msmpeg4", "xvid_ilace", "ump4", "no_padding", "ac_vlc", "qpel_chroma", "std_qpel", "qpel_chroma2", "direct_blocksize", "edge", "hpel_chroma", "dc_clip", "trunc", "very", "unofficial", "experimental", "b_qoffset", "err_detect", "crccheck", "bitstream", "buffer", "explode", "ignore_err", "careful", "compliant", "aggressive", "has_b_frames", "block_align", "mpeg_quant", "rc_override_count", "maxrate", "minrate", "bufsize", "i_qoffset", "lumi_mask", "tcplx_mask", "scplx_mask", "p_mask", "dark_mask", "slice_count", "guess_mvs", "favor_inter", "bits_per_coded_sample", "pred", "left", "plane", "median", "aspect", "debug", "pict", "mb_type", "dct_coeff", "green_metadata", "skip", "startcode", "mmco", "bugs", "vis_qp", "vis_mb_type", "buffers", "thread_ops", "nomc", "vismv", "debug_mv", "cmp_func", "subcmp", "mbcmp", "ildctcmp", "dia_size", "last_pred", "preme", "precmp", "satd", "vsad", "vsse", "nsse", "dctmax", "chroma", "pre_dia_size", "dtg_active_format", "global_quality", "deflate", "context", "slice_flags", "xvmc_acceleration", "bits", "stream_codec_tag", "error", "me_threshold", "mb_threshold", "intra_dc_precision", "nssew", "skip_top", "skip_bottom", "unknown", "aac_main", "aac_low", "aac_ssr", "aac_ltp", "aac_he", "aac_he_v2", "aac_ld", "aac_eld", "mpeg2_aac_low", "mpeg2_aac_he", "dts_es", "dts_96_24", "dts_hd_hra", "dts_hd_ma", "mpeg4_sp", "mpeg4_core", "mpeg4_main", "mpeg4_asp", "lowres", "skip_threshold", "skip_factor", "skip_exp", "skipcmp", "mblmin", "mblmax", "mepc", "skip_loop_filter", "avdiscard", "skip_idct", "skip_frame", "default", "noref", "bidir", "nokey", "nointra", "bidir_refine", "brd_scale", "chromaoffset", "sc_factor", "mv0_threshold", "b_sensitivity", "compression_level", "min_prediction_order", "max_prediction_order", "timecode_frame_start", "request_channels", "bits_per_raw_sample", "request_channel_layout", "rc_max_vbv_use", "rc_min_vbv_use", "ticks_per_frame", "color_primaries", "color_primaries_type", "bt709", "unspecified", "Unspecified", "bt470m", "bt470bg", "smpte170m", "smpte240m", "Film", "bt2020", "color_trc", "color_trc_type", "gamma22", "gamma28", "linear", "Linear", "log_sqrt", "iec61966_2_4", "bt1361", "iec61966_2_1", "bt2020_10bit", "bt2020_12bit", "colorspace", "colorspace_type", "ycocg", "YCOCG", "bt2020_ncl", "bt2020_cl", "color_range", "color_range_type", "mpeg", "jpeg", "chroma_sample_location", "chroma_sample_location_type", "Left", "center", "Center", "topleft", "bottomleft", "bottom", "Bottom", "log_level_offset", "slices", "slice", "frame", "audio_service_type", "Effects", "Dialogue", "Commentary", "Emergency", "Karaoke", "request_sample_fmt", "pkt_timebase", "sub_charenc", "sub_charenc_mode", "do_nothing", "pre_decoder", "refcounted_frames", "side_data_only_packets", "skip_alpha", "field_order", "progressive", "dump_separator", "codec_whitelist", "pixel_format", "video_size", "MPNG", "bits2qp", "qp2bits", "iTex", "pTex", "fCode", "iCount", "mcVar", "avgQP", "qComp", "avgIITex", "avgPITex", "avgPPTex", "avgBPTex", "avgTex", "audioresample", "ReSampleContext", "unknown_codec", "ff_avcodec_locked", "encoder", "decoder", "aeval", "same", "exprs", "aevalsrc", "nb_samples", "duration", "nb_in_channels", "nb_out_channels", "adelay", "delays", "aecho", "in_gain", "out_gain", "decays", "acrossfade", "crossfade0", "crossfade1", "overlap", "curve1", "qsin", "esin", "hsin", "logarithmic", "ipar", "quadratic", "cubic", "parabola", "exponential", "iqsin", "ihsin", "dese", "desi", "curve2", "afade", "start_sample", "start_time", "curve", "aformat", "sample_fmts", "sample_rates", "channel_layouts", "amerge", "inputs", "info", "amix", "longest", "shortest", "first", "dropout_transition", "anull", "apad", "packet_size", "pad_len", "whole_len", "aphaser", "decay", "speed", "triangular", "sinusoidal", "aresample", "asetnsamples", "nb_out_samples", "asetrate", "ashowinfo", "DC_offset", "Min_level", "Max_level", "Min_difference", "Max_difference", "Mean_difference", "Peak_level", "RMS_level", "RMS_peak", "RMS_trough", "Crest_factor", "Flat_factor", "Peak_count", "Bit_depth", "astats", "length", "metadata", "reset", "astreamsync", "out1", "out2", "expr", "in_channel_layout", "out_channel_layout", "in_sample_fmt", "out_sample_fmt", "in_sample_rate", "out_sample_rate", "force_resampling", "asyncts", "compensate", "min_delta", "max_comp", "first_pts", "tempo", "atempo", "biquad", "allpass", "frequency", "width_type", "octave", "slope", "highpass", "poles", "lowpass", "bandreject", "bandpass", "treble", "gain", "bass", "equalizer", "channelmap", "channelsplit", "stereo", "chorus", "speeds", "depths", "compand", "attacks", "points", "volume", "dcshift", "shift", "limitergain", "dynaudnorm", "earwax", "flanger", "depth", "regen", "shape", "phase", "interp", "itype", "join", "args", "replaygain", "resample", "sidechaincompress", "sidechain", "threshold", "ratio", "attack", "release", "makeup", "knee", "link", "average", "maximum", "detection", "peak", "silencedetect", "noise", "silenceremove", "start_periods", "start_duration", "start_threshold", "stop_periods", "stop_duration", "stop_threshold", "leave_silence", "precision", "fixed", "float", "double", "eval", "once", "drop", "ignore", "track", "album", "replaygain_preamp", "replaygain_noclip", "nb_channels", "nb_consumed_samples", "startpts", "startt", "volumedetect", "anullsink", "anullsrc", "sine", "beep_factor", "samples_per_frame", "channels", "aphasemeter", "rate", "size", "avectorscope", "mode", "lissajous", "lissajous_xy", "polar", "zoom", "concat", "unsafe", "midi", "a_weighting", "b_weighting", "c_weighting", "timeclamp", "freq", "showcqt", "tlength", "coeffclamp", "gamma", "gamma2", "fullhd", "count", "fontfile", "fontcolor", "showfreqs", "line", "ascale", "sqrt", "cbrt", "fscale", "rlog", "win_size", "w128", "w256", "w512", "w1024", "w2048", "w4096", "w8192", "w16384", "w32768", "w65536", "win_func", "rect", "Rectangular", "bartlett", "Bartlett", "hanning", "Hanning", "hamming", "Hamming", "blackman", "Blackman", "welch", "Welch", "flattop", "bharris", "bnuttall", "bhann", "Sine", "nuttall", "Nuttall", "averaging", "colors", "showspectrum", "slide", "replace", "scroll", "fullframe", "combined", "separate", "color", "channel", "intensity", "scale", "saturation", "hann", "showvolume", "VOLUME", "CHANNEL", "showwavespic", "split_channels", "showwaves", "point", "cline", "ping", "noformat", "frei0r", "frei0r_src", "AVFilter", "fifo", "afifo", "AVFilterGraph", "scale_sws_opts", "aresample_swr_opts", "pix_fmts", "channel_counts", "all_channel_counts", "buffersink", "abuffersink", "ffbuffersink", "ffabuffersink", "abuffer", "sample_fmt", "pix_fmt", "time_base_num", "time_base_den", "sar_num", "sar_den", "pixel_aspect", "frame_rate", "sws_param", "pix_desc", "mainpic", "adrawgraph", "drawgraph", "white", "rscroll", "out0", "ebur128", "video", "meter", "framelog", "verbose", "sample", "true", "ainterleave", "nb_inputs", "interleave", "perms", "aperms", "toggle", "random", "seed", "areverse", "reverse", "scene", "select", "outputs", "aselect", "start_pts", "prev_pts", "prev_selected_pts", "start_t", "prev_t", "prev_selected_t", "pict_type", "PICT_TYPE_I", "PICT_TYPE_P", "PICT_TYPE_B", "PICT_TYPE_S", "PICT_TYPE_SI", "PICT_TYPE_SP", "PICT_TYPE_BI", "interlace_type", "PROGRESSIVE", "TOPFIRST", "BOTTOMFIRST", "consumed_samples_n", "samples_n", "selected_n", "prev_selected_n", "enter", "leave", "asendcmd", "sendcmd", "commands", "filename", "framesync", "image2", "asetpts", "setpts", "FRAME_RATE", "INTERLACED", "NB_CONSUMED_SAMPLES", "NB_SAMPLES", "PREV_INPTS", "PREV_INT", "PREV_OUTPTS", "PREV_OUTT", "SAMPLE_RATE", "STARTPTS", "STARTT", "RTCTIME", "RTCSTART", "asettb", "intb", "settb", "AVTB", "asplit", "split", "amovie", "movie", "format_name", "stream_index", "seek_point", "streams", "atrim", "starti", "endi", "end_pts", "durationi", "end_sample", "start", "trim", "start_frame", "end_frame", "alphamerge", "alpha", "setsar", "setdar", "dar_den", "hsub", "vsub", "atadenoise", "bbox", "min_val", "blackdetect", "black_min_duration", "picture_black_ratio_th", "pic_th", "pixel_black_th", "pix_th", "blackframe", "amount", "thresh", "tblend", "c0_mode", "c1_mode", "c2_mode", "c3_mode", "all_mode", "addition", "burn", "darken", "difference", "difference128", "divide", "dodge", "exclusion", "glow", "hardlight", "hardmix", "lighten", "linearlight", "multiply", "negation", "overlay", "phoenix", "pinlight", "reflect", "screen", "softlight", "subtract", "vividlight", "c0_expr", "c1_expr", "c2_expr", "c3_expr", "all_expr", "c0_opacity", "c1_opacity", "c2_opacity", "c3_opacity", "all_opacity", "blend", "repeatlast", "BOTTOM", "boxblur", "luma_radius", "luma_power", "chroma_radius", "chroma_power", "alpha_radius", "alpha_power", "codecview", "colorbalance", "colorchannelmixer", "colorkey", "black", "similarity", "colorlevels", "rimin", "gimin", "bimin", "aimin", "rimax", "gimax", "bimax", "aimax", "romin", "gomin", "bomin", "aomin", "romax", "gomax", "bomax", "aomax", "colormatrix", "bt601", "color_mode", "bt470", "copy", "cover_rect", "cover", "blur", "out_w", "out_h", "crop", "keep_aspect", "in_w", "in_h", "cropdetect", "limit", "round", "reset_count", "max_outliers", "last", "curves", "preset_name", "color_negative", "cross_process", "darker", "increase_contrast", "lighter", "linear_contrast", "medium_contrast", "negative", "strong_contrast", "vintage", "master", "green", "blue", "psfile", "dctdnoiz", "sigma", "deband", "range", "direction", "clean_src", "decimate", "cycle", "dupthresh", "scthresh", "blockx", "blocky", "ppsrc", "dejudder", "delogo", "band", "show", "deshake", "blank", "original", "clamp", "mirror", "blocksize", "contrast", "search", "smode", "exhaustive", "less", "opencl", "detelecine", "first_field", "field", "pattern", "invert", "drawgrid", "thickness", "drawbox", "edgedetect", "wires", "colormix", "elbg", "codebook_length", "nb_steps", "pal8", "brightness", "gamma_r", "gamma_g", "gamma_b", "gamma_weight", "init", "alphaextract", "extractplanes", "planes", "fade", "nb_frames", "weight_Y", "weight_U", "weight_V", "fftfilt", "dc_Y", "dc_U", "dc_V", "field_type", "fieldmatch", "order", "pc_n", "pc_u", "pc_n_ub", "pcn_ub", "mchroma", "combmatch", "combmatching", "combdbg", "dbglvl", "pcnub", "cthresh", "combpel", "down", "fieldorder", "find_rect", "object", "mipmaps", "xmin", "ymin", "xmax", "ymax", "near", "framepack", "packed", "right", "frameseq", "lines", "columns", "framerate", "interp_start", "interp_end", "scene_change_detect", "framestep", "step", "fspp", "quality", "strength", "use_bframe_qp", "lum_expr", "cb_expr", "cr_expr", "alpha_expr", "red_expr", "green_expr", "blue_expr", "gradfun", "radius", "hflip", "histeq", "antibanding", "weak", "strong", "histogram", "levels", "waveform", "color2", "level_height", "scale_height", "waveform_mode", "column", "waveform_mirror", "display_mode", "parade", "levels_mode", "components", "hqdn3d", "luma_spatial", "chroma_spatial", "luma_tmp", "chroma_tmp", "undetermined", "neither", "idet", "intl_thres", "prog_thres", "rep_thres", "half_life", "analyze_interlaced_flag", "luma_mode", "deinterleave", "chroma_mode", "alpha_mode", "luma_swap", "chroma_swap", "alpha_swap", "with", "without", "interlace", "scan", "kerndeint", "sharp", "twoway", "lenscorrection", "negval", "negate", "negate_alpha", "lutrgb", "lutyuv", "clip", "gammaval", "gammaval709", "maxval", "minval", "clipval", "cube", "DOMAIN_", "values", "haldclut", "clut", "interp_mode", "nearest", "trilinear", "tetrahedral", "lut3d", "file", "memc_only", "no_bitstream", "mcdeint", "extra_slow", "parity", "mergeplanes", "mapping", "keep", "mpdecimate", "frac", "erosion", "dilation", "inflate", "threshold0", "threshold1", "threshold2", "threshold3", "coordinates", "all_seed", "all_strength", "alls", "all_flags", "allf", "c0_seed", "c0_strength", "c0_flags", "c1_seed", "c1_strength", "c1_flags", "c2_seed", "c2_strength", "c2_flags", "c3_seed", "c3_strength", "c3_flags", "null", "eof_action", "repeat", "endall", "pass", "yuv420", "yuv422", "yuv444", "main_w", "main_h", "overlay_w", "overlay_h", "owdenoise", "luma_strength", "chroma_strength", "palettegen", "max_colors", "reserve_transparent", "stats_mode", "diff", "paletteuse", "palette", "dither", "dithering_mode", "bayer", "heckbert", "floyd_steinberg", "sierra2", "sierra2_4a", "bayer_scale", "diff_mode", "rectangle", "debug_kdtree", "color_search", "nns_iterative", "nns_recursive", "bruteforce", "mean_err", "debug_accuracy", "perspective", "interpolation", "sense", "source", "destination", "analyze", "pixdesctest", "subfilters", "hard", "soft", "reference", "stats_file", "pullup", "luma", "known", "frames", "removegrain", "removelogo", "repeatfields", "angle", "rotate", "rotw", "roth", "fillcolor", "bilinear", "luma_pre_filter_radius", "lpfr", "chroma_pre_filter_radius", "cpfr", "srcw", "srch", "src_format", "dstw", "dsth", "dst_format", "sws_flags", "param0", "param1", "src_range", "dst_range", "src_h_chr_pos", "src_v_chr_pos", "dst_h_chr_pos", "dst_v_chr_pos", "scale2ref", "interl", "in_color_matrix", "out_color_matrix", "in_range", "out_range", "in_v_chr_pos", "in_h_chr_pos", "out_v_chr_pos", "out_h_chr_pos", "force_original_aspect_ratio", "force_oar", "decrease", "increase", "ohsub", "ovsub", "separatefields", "setfield", "prog", "checkerboard", "showinfo", "showpalette", "shuffleplanes", "map0", "map1", "map2", "map3", "TOUT", "VREP", "BRNG", "signalstats", "stat", "filters", "tout", "vrep", "brng", "yellow", "smartblur", "luma_threshold", "chroma_threshold", "vstack", "hstack", "stereo3d", "ab2l", "ab2r", "sbs2l", "sbs2r", "sbsl", "sbsr", "agmc", "agmd", "agmg", "agmh", "arbg", "arcc", "arcd", "arcg", "arch", "argg", "aybc", "aybd", "aybg", "aybh", "super2xsai", "swapuv", "telecine", "thumbnail", "tile", "layout", "margin", "padding", "tinterlace", "merge", "drop_even", "drop_odd", "interleave_top", "interleave_bottom", "interlacex2", "low_pass_filter", "vlpf", "exact_tb", "clockwise", "counterclockwise", "transpose", "cclock_flip", "clock", "cclock", "clock_flip", "passthrough", "portrait", "landscape", "sharpen", "unsharp", "luma_msize_x", "luma_msize_y", "luma_amount", "chroma_msize_x", "chroma_msize_y", "chroma_amount", "uspp", "vectorscope", "color3", "color4", "envelope", "instant", "vflip", "vignette", "forward", "backward", "w3fdif", "filter", "complex", "deint", "interlaced", "display", "flat", "aflat", "achroma", "yadif", "send_frame", "send_field", "send_frame_nospatial", "send_field_nospatial", "zoompan", "hd720", "pduration", "time", "pzoom", "nullsink", "cellauto", "rule", "random_fill_ratio", "random_seed", "start_full", "stitch", "bBsS", "life", "mold", "life_color", "death_color", "mold_color", "mandelbrot", "maxiter", "start_x", "start_y", "start_scale", "end_scale", "bailout", "morphxf", "morphyf", "morphamp", "outer", "iteration_count", "normalized_iteration_count", "outz", "inner", "period", "convergence", "mincol", "mptestsrc", "test", "dc_luma", "dc_chroma", "freq_luma", "freq_chroma", "amp_luma", "amp_chroma", "ring1", "ring2", "allrgb", "allyuv", "smptehdbars", "smptebars", "rgbtestsrc", "testsrc", "decimals", "nullsrc", "haldclutsrc", "adts", "write_id3v2", "write_apetag", "APETAGEX", "URLContext", "AVIOContext", "inpoint", "outpoint", "file_packet_metadata", "stream", "exact_stream_id", "ffconcat", "version", "safe", "auto_convert", "language", "effects", "dialogue", "comentary", "emergency", "karaoke", "Output", "from", "Input", "name", "truncate", "false", "keyframes", "times", "filepositions", "videodatarate", "audiodatarate", "datastream", "videocodecid", "audiocodecid", "audiosamplerate", "audiosamplesize", "filesize", "onTextData", "onCaption", "onCaptionInfo", "onMetaData", "onCuePoint", "Encoder", "live_flv", "live_flvdec", "flvdec", "flv_metadata", "datasize", "lasttimestamp", "totalframes", "hasAudio", "hasVideo", "hasCuePoints", "hasMetadata", "hasKeyframes", "Video", "Audio", "Data", "Text", "segment", "ssegment", "image2pipe", "mime_type", "comment", "cookies", "headers", "seekable", "offset", "end_offset", "location", "AUDIO", "VIDEO", "EVENT", "PRIV", "APIC", "user_agent", "variant_bitrate", "live_start_index", "Forbidden", "POST", "Location", "bytes", "chunked", "Connection", "close", "Server", "AkamaiGHost", "MediaGateway", "gzip", "identity", "http_proxy", "no_proxy", "https", "listen", "icy_metadata_packet", "http", "chunked_post", "content_type", "multiple_requests", "post_data", "icy_metadata_headers", "auth_type", "basic", "send_expect_100", "method", "reconnect", "resource", "reply_code", "auth", "title", "artist", "date", "genre", "Blues", "Country", "Dance", "Disco", "Funk", "Grunge", "Jazz", "Metal", "Oldies", "Other", "Reggae", "Rock", "Techno", "Industrial", "Alternative", "Pranks", "Soundtrack", "Ambient", "Vocal", "Fusion", "Trance", "Classical", "Instrumental", "Acid", "House", "Game", "Gospel", "Noise", "AlternRock", "Bass", "Soul", "Punk", "Space", "Meditative", "Ethnic", "Gothic", "Darkwave", "Electronic", "Eurodance", "Dream", "Comedy", "Cult", "Gangsta", "Jungle", "Cabaret", "Psychadelic", "Rave", "Showtunes", "Trailer", "Tribal", "Polka", "Retro", "Musical", "Folk", "Swing", "Bebob", "Latin", "Revival", "Celtic", "Bluegrass", "Avantgarde", "Chorus", "Acoustic", "Humour", "Speech", "Chanson", "Opera", "Sonata", "Symphony", "Primus", "Satire", "Club", "Tango", "Samba", "Folklore", "Ballad", "Freestyle", "Duet", "Hardcore", "Terror", "Indie", "BritPop", "Negerpunk", "Beat", "Crossover", "Merengue", "Salsa", "Anime", "JPop", "SynthPop", "TCON", "TXXX", "encrypted", "compression", "USLT", "CHAP", "GEOB", "TYER", "TDAT", "TIME", "Conductor", "Composer", "Illustration", "compilation", "encoded_by", "album_artist", "performer", "TCMP", "TDRC", "TDRL", "TDEN", "creation_time", "TSOA", "TSOP", "TSOT", "TALB", "TCOM", "composer", "TCOP", "copyright", "TENC", "TIT2", "TLAN", "TPE1", "TPE2", "TPE3", "TPOS", "disc", "TPUB", "publisher", "TRCK", "TSSE", "lyrics", "ljpg", "im24", "im32", "sunras", "yuv10", "SDPX", "XPDS", "webp_pipe", "tiff_pipe", "sunrast_pipe", "sgi_pipe", "qdraw_pipe", "png_pipe", "pictor_pipe", "jpegls_pipe", "jpeg_pipe", "j2k_pipe", "exr_pipe", "dpx_pipe", "dds_pipe", "bmp_pipe", "pattern_type", "glob_sequence", "glob", "sequence", "start_number", "start_number_range", "ts_from_file", "ts_type", "UVAx", "updatefirst", "update", "strftime", "latm", "major_brand", "minor_version", "compatible_brands", "handler_name", "nclx", "nclc", "warning", "subtitle", "original_source", "playback_requirements", "performers", "producer", "original_artist", "model", "make", "host_computer", "grouping", "original_format", "edit_date", "disclaimer", "director", "chapter", "season_number", "network", "episode_sort", "episode_id", "media_type", "sort_show", "sort_name", "sort_composer", "sort_artist", "sort_album", "sort_album_artist", "rating", "purchase_date", "gapless_playback", "podcast", "synopsis", "keywords", "hd_video", "episode_uid", "description", "category", "account_id", "account_type", "quicktime_version", "premiere_version", "iTunSMPB", "cdec", "timecode", "root", "tmcd", "reel_name", "stsd", "avc1", "hvc1", "hev1", "mp4s", "use_absolute_path", "seek_streams_individually", "ignore_editlist", "use_mfra_for", "export_all", "export_xmp", "activation_bytes", "audible_fixed_key", "disk", "trkn", "stss", "stps", "mhlr", "vide", "VideoHandler", "soun", "SoundHandler", "subp", "SubtitleHandler", "hint", "HintHandler", "TimeCodeHandler", "DataHandler", "clcp", "ClosedCaptionHandler", "sbtl", "dhlr", "handler", "yrrc", "albm", "lpcm", "XDCAM", "DpxE", "perf", "titl", "author", "gnre", "dscp", "cprt", "aART", "encoding_tool", "ldes", "tvsh", "tven", "tvnn", "tmpo", "wide", "free", "audio", "ipod", "ismv", "systemBitrate", "trackID", "CodecPrivateData", "H264", "FourCC", "WVC1", "MaxWidth", "MaxHeight", "DisplayWidth", "DisplayHeight", "AACL", "WMAP", "AudioTag", "Channels", "SamplingRate", "BitsPerSample", "PacketSize", "movflags", "rtphint", "moov_size", "empty_moov", "frag_keyframe", "separate_moof", "frag_custom", "isml", "faststart", "omit_tfhd_offset", "disable_chpl", "default_base_moof", "dash", "frag_discont", "delay_moov", "global_sidx", "write_colr", "write_gama", "rtpflags", "rfc2190", "skip_rtcp", "h264_mode0", "send_bye", "skip_iods", "iods_audio_profile", "iods_video_profile", "frag_duration", "min_frag_duration", "frag_size", "ism_lookahead", "video_track_timescale", "brand", "use_editlist", "fragment_index", "mov_gamma", "frag_interleave", "rtpo", "usetoc", "id3v2_version", "write_id3v1", "write_xing", "service_name", "service_provider", "HDMV", "HDPR", "mpegtsraw", "mpegts", "resync_size", "compute_pcr", "ts_packetsize", "fix_teletext_pts", "scan_all_pmts", "skip_changes", "skip_clear", "Service01", "FFmpeg", "m2ts", "flag", "mpegts_transport_stream_id", "mpegts_original_network_id", "mpegts_service_id", "mpegts_service_type", "digital_tv", "digital_radio", "teletext", "advanced_codec_digital_radio", "mpeg2_digital_hdtv", "advanced_codec_digital_sdtv", "advanced_codec_digital_hdtv", "mpegts_pmt_start_pid", "mpegts_start_pid", "mpegts_m2ts_mode", "muxrate", "pes_payload_size", "mpegts_flags", "resend_headers", "pat_pmt_at_frames", "mpegts_copyts", "tables_version", "omit_video_pes_length", "pcr_period", "pat_period", "sdt_period", "mpegvideo", "AVFormatContext", "avioflags", "direct", "probesize", "formatprobesize", "packetsize", "fflags", "flush_packets", "ignidx", "genpts", "nofillin", "noparse", "igndts", "discardcorrupt", "sortdts", "keepside", "fastseek", "nobuffer", "seek2any", "analyzeduration", "cryptokey", "indexmem", "rtbufsize", "fdebug", "max_delay", "start_time_realtime", "fpsprobesize", "audio_preload", "chunk_duration", "chunk_size", "f_err_detect", "use_wallclock_as_timestamps", "skip_initial_bytes", "correct_ts_overflow", "metadata_header_padding", "output_ts_offset", "max_interleave_delta", "f_strict", "max_ts_probe", "avoid_negative_ts", "disabled", "make_non_negative", "make_zero", "format_whitelist", "REPLAYGAIN_TRACK_GAIN", "REPLAYGAIN_TRACK_PEAK", "REPLAYGAIN_ALBUM_GAIN", "REPLAYGAIN_ALBUM_PEAK", "IART", "ICMT", "ICOP", "ICRD", "IGNR", "ILNG", "INAM", "IPRD", "IPRT", "ITRK", "ISFT", "ISMP", "ITCH", "BottomUp", "LIST", "notification", "invoke", "_result", "code", "onStatus", "status", "details", "clientid", "FCPublish", "publish", "onFCPublish", "play", "createStream", "_checkbw", "releaseStream", "FCSubscribe", "getStreamLength", "connect", "user", "salt", "opaque", "challenge", "nonce", "adobe", "live", "llnw", "FCUnpublish", "deleteStream", "seek", "pause", "_error", "onBWDone", "rtmp", "rtmpt", "rtmpts", "ffrtmphttp_tls", "ffrtmphttp", "rtmps", "rtmpe", "rtmpte", "ffrtmpcrypt_tunneling", "ffrtmpcrypt", "rtmp_swfhash", "nonprivate", "flashVer", "swfUrl", "tcUrl", "fpad", "capabilities", "audioCodecs", "videoCodecs", "videoFunction", "pageUrl", "fmsVer", "objectEncoding", "rtmp_app", "rtmp_buffer", "rtmp_conn", "rtmp_flashver", "rtmp_flush_interval", "rtmp_live", "recorded", "rtmp_pageurl", "rtmp_playpath", "rtmp_subscribe", "rtmp_swfsize", "rtmp_swfurl", "rtmp_swfverify", "rtmp_tcurl", "rtmp_listen", "timeout", "payload_type", "listen_timeout", "send_buffer_size", "recv_buffer_size", "pipe", "cache", "mp4v", "dvbsub", "loas", "WAVE", "RIFF", "RIFX", "RF64", "ds64", "originator", "originator_reference", "origination_date", "origination_time", "time_reference", "umid", "coding_history", "ignore_length", "levl", "JUNK", "NONE", "fact", "bext", "data", "write_bext", "write_peak", "only", "rf64", "always", "never", "peak_block_size", "peak_format", "peak_ppv", "quad", "hexagonal", "octagonal", "hexadecagonal", "downmix", "LFE2", "mmx2", "mmxext", "sse2", "sse2slow", "sse3", "sse3slow", "ssse3", "atom", "avxslow", "fma3", "fma4", "avx2", "bmi1", "bmi2", "cmov", "pentium2", "pentium3", "pentium4", "athlon", "athlonxp", "cpuflags", "BSF_NOT_FOUND", "BUG2", "BUFFER_TOO_SMALL", "DECODER_NOT_FOUND", "DEMUXER_NOT_FOUND", "ENCODER_NOT_FOUND", "EXIT", "EXTERNAL", "FILTER_NOT_FOUND", "INPUT_CHANGED", "INVALIDDATA", "MUXER_NOT_FOUND", "OPTION_NOT_FOUND", "OUTPUT_CHANGED", "PATCHWELCOME", "PROTOCOL_NOT_FOUND", "STREAM_NOT_FOUND", "UNKNOWN", "EXPERIMENTAL", "INPUT_AND_OUTPUT_CHANGED", "HTTP_BAD_REQUEST", "HTTP_UNAUTHORIZED", "HTTP_FORBIDDEN", "HTTP_NOT_FOUND", "HTTP_OTHER_4XX", "HTTP_SERVER_ERROR", "sinh", "cosh", "tanh", "asin", "acos", "squish", "gauss", "isnan", "isinf", "while", "taylor", "floor", "ceil", "print", "hypot", "ifnot", "bitand", "bitor", "between", "atan", "QP2LAMBDA", "Eval", "FILE", "AVPanScan", "AVMatrixEncoding", "AVReplayGain", "YCgCo", "murmur3", "RIPEMD128", "RIPEMD160", "RIPEMD256", "RIPEMD320", "SHA160", "SHA224", "SHA256", "SHA384", "SHA512", "CRC32", "adler32", "IMGUTILS", "TERM", "NO_COLOR", "AV_LOG_FORCE_NOCOLOR", "AV_LOG_FORCE_COLOR", "AV_LOG_FORCE_256COLOR", "quiet", "fatal", "panic", "INT_MAX", "INT_MIN", "UINT32_MAX", "I64_MAX", "I64_MIN", "FLT_MAX", "FLT_MIN", "DBL_MAX", "DBL_MIN", "pixel", "ntsc", "qntsc", "qpal", "sntsc", "spal", "bikeshed", "AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "Blue", "BlueViolet", "Brown", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "Coral", "CornflowerBlue", "Cornsilk", "Crimson", "Cyan", "DarkBlue", "DarkCyan", "DarkGoldenRod", "DarkGray", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "Darkorange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "GoldenRod", "Gray", "Green", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Khaki", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenRodYellow", "LightGreen", "LightGrey", "LightPink", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Magenta", "Maroon", "MediumAquaMarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "Orchid", "PaleGoldenRod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Pink", "Plum", "PowderBlue", "Purple", "RosyBrown", "RoyalBlue", "SaddleBrown", "Salmon", "SandyBrown", "SeaGreen", "SeaShell", "Sienna", "Silver", "SkyBlue", "SlateBlue", "SlateGray", "SpringGreen", "SteelBlue", "Teal", "Thistle", "Tomato", "Turquoise", "Violet", "Wheat", "White", "WhiteSmoke", "Yellow", "YellowGreen", "sqcif", "qcif", "qqvga", "qvga", "svga", "uxga", "qxga", "sxga", "qsxga", "hsxga", "wvga", "wxga", "wsxga", "wuxga", "woxga", "wqsxga", "wquxga", "whsxga", "whuxga", "hd480", "hd1080", "hqvga", "wqvga", "fwqvga", "hvga", "uhd2160", "uhd4320", "bgra", "rgba", "rgb32", "bgr32", "yuvj", "bayer_", "ycgco", "bt2020nc", "bt2020c", "log100", "log316", "bt1361e", "yuv420p", "yuyv422", "rgb24", "bgr24", "yuv422p", "yuv444p", "yuv410p", "yuv411p", "monow", "monob", "yuvj420p", "yuvj422p", "yuvj444p", "xvmcmc", "xvmcidct", "uyvy422", "uyyvyy411", "bgr8", "bgr4", "bgr4_byte", "rgb8", "rgb4", "rgb4_byte", "nv12", "nv21", "argb", "abgr", "gray16be", "y16be", "gray16le", "y16le", "yuv440p", "yuvj440p", "yuva420p", "vdpau_h264", "vdpau_mpeg1", "vdpau_mpeg2", "vdpau_wmv3", "vdpau_vc1", "rgb48be", "rgb48le", "rgb565be", "rgb565le", "rgb555be", "rgb555le", "bgr565be", "bgr565le", "bgr555be", "bgr555le", "vaapi_moco", "vaapi_idct", "vaapi_vld", "yuv420p16le", "yuv420p16be", "yuv422p16le", "yuv422p16be", "yuv444p16le", "yuv444p16be", "vdpau_mpeg4", "dxva2_vld", "rgb444le", "rgb444be", "bgr444le", "bgr444be", "gray8a", "bgr48be", "bgr48le", "yuv420p9be", "yuv420p9le", "yuv420p10be", "yuv420p10le", "yuv422p10be", "yuv422p10le", "yuv444p9be", "yuv444p9le", "yuv444p10be", "yuv444p10le", "yuv422p9be", "yuv422p9le", "vda_vld", "gbrp", "gbrp9be", "gbrp9le", "gbrp10be", "gbrp10le", "gbrp16be", "gbrp16le", "yuva420p9be", "yuva420p9le", "yuva422p9be", "yuva422p9le", "yuva444p9be", "yuva444p9le", "yuva420p10be", "yuva420p10le", "yuva422p10be", "yuva422p10le", "yuva444p10be", "yuva444p10le", "yuva420p16be", "yuva420p16le", "yuva422p16be", "yuva422p16le", "yuva444p16be", "yuva444p16le", "vdpau", "xyz12le", "xyz12be", "nv16", "nv20le", "nv20be", "yvyu422", "ya16be", "ya16le", "mmal", "d3d11va_vld", "rgba64be", "rgba64le", "bgra64be", "bgra64le", "rgb0", "bgr0", "yuva444p", "yuva422p", "yuv420p12be", "yuv420p12le", "yuv420p14be", "yuv420p14le", "yuv422p12be", "yuv422p12le", "yuv422p14be", "yuv422p14le", "yuv444p12be", "yuv444p12le", "yuv444p14be", "yuv444p14le", "gbrp12be", "gbrp12le", "gbrp14be", "gbrp14le", "gbrap", "gbrap16be", "gbrap16le", "yuvj411p", "bayer_bggr8", "bayer_rggb8", "bayer_gbrg8", "bayer_grbg8", "bayer_bggr16le", "bayer_bggr16be", "bayer_rggb16le", "bayer_rggb16be", "bayer_gbrg16le", "bayer_gbrg16be", "bayer_grbg16le", "bayer_grbg16be", "yuv440p10le", "yuv440p10be", "yuv440p12le", "yuv440p12be", "ayuv64le", "ayuv64be", "videotoolbox_vld", "attachment", "SWResampler", "in_channel_count", "out_channel_count", "used_channel_count", "internal_sample_fmt", "clev", "center_mix_level", "slev", "surround_mix_level", "lfe_mix_level", "rmvol", "rematrix_volume", "rematrix_maxval", "swr_flags", "dither_scale", "dither_method", "rectangular", "triangular_hp", "lipshitz", "shibata", "low_shibata", "high_shibata", "f_weighted", "modified_e_weighted", "improved_e_weighted", "filter_size", "phase_shift", "linear_interp", "resample_cutoff", "resampler", "soxr", "cheby", "min_comp", "min_hard_comp", "comp_duration", "max_soft_comp", "async", "matrix_encoding", "dolby", "dplii", "filter_type", "blackman_nuttall", "kaiser", "kaiser_beta", "output_sample_bits", "swscaler", "SWScaler", "fast_bilinear", "bicubic", "neighbor", "area", "bicublin", "gaussian", "sinc", "lanczos", "spline", "print_info", "accurate_rnd", "full_chroma_int", "full_chroma_inp", "error_diffusion", "sws_dither", "a_dither", "x_dither", "alphablend", "uniform_color", "MMXEXT", "Gaussian", "Lanczos", "postproc", "help", "autoq", "nochrom", "chrom", "noluma", "fullyrange", "Postproc", "hdeblock", "vdeblock", "x1hdeblock", "x1vdeblock", "ahdeblock", "avdeblock", "dering", "autolevels", "linblenddeint", "linipoldeint", "cubicipoldeint", "mediandeint", "ffmpegdeint", "lowpass5", "tmpnoise", "forcequant", "visualize", "AudioData", "AVAudioResampleContext", "s16p", "s32p", "fltp", "dblp", "mix_coeff_type", "normalize_mix_level", "None", "Dolby", "Cubic", "triangular_ns", "in_buffer", "resample_out_buffer", "out_buffer", "output", "input", "AuthenticAMD", "GenuineIntel", "SSE2", "SSE2SLOW", "SSSE3", "SSE4", "FMA4", "deterministic", "overscan", "videoformat", "fullrange", "colorprim", "transfer", "chromaloc", "frameref", "keyint", "infinite", "scenecut", "bframes", "cabac", "cqmfile", "cqm4", "cqm8", "cqm4i", "cqm4p", "cqm4iy", "cqm4ic", "cqm4py", "cqm4pc", "cqm8i", "cqm8p", "analyse", "i4x4", "i8x8", "p8x8", "p4x4", "b8x8", "merange", "mvrange", "subme", "bitrate", "qp_constant", "qpmin", "qpmax", "qpstep", "ratetol", "ipratio", "pbratio", "zones", "annexb", "filler", "stitchable", "touhou", "fake", "undef", "component", "secam", "SSE3", "BMI1", "uvAC", "uvDC", "clBuildProgram", "clCreateBuffer", "clCreateCommandQueue", "clCreateContext", "clCreateImage2D", "clCreateKernel", "clCreateProgramWithBinary", "clCreateProgramWithSource", "clEnqueueCopyBuffer", "clEnqueueMapBuffer", "clEnqueueNDRangeKernel", "clEnqueueReadBuffer", "clEnqueueWriteBuffer", "clFinish", "clGetCommandQueueInfo", "clGetDeviceIDs", "clGetDeviceInfo", "clGetKernelWorkGroupInfo", "clGetPlatformIDs", "clGetProgramBuildInfo", "clGetProgramInfo", "clGetSupportedImageFormats", "clReleaseCommandQueue", "clReleaseContext", "clReleaseKernel", "clReleaseMemObject", "clReleaseProgram", "clSetKernelArg", "ADL_Main_Control_Create", "ADL_Main_Control_Destroy", "ADL_PowerXpress_Scheme_Get", "mb_intra_cost_satd_8x8", "sum_intra_cost", "downscale_hpel", "downscale1", "downscale2", "memset_int16", "weightp_scaled_images", "weightp_hpel", "hierarchical_motion", "subpel_refine", "mode_selection", "sum_inter_cost", "INTRA4X4_LUMA", "INTER4X4_LUMA", "INTRA4X4_CHROMA", "INTER4X4_CHROMA", "INTRA8X8_LUMA", "INTER8X8_LUMA", "INTRA8X8_CHROMA", "INTER8X8_CHROMA", "underflow", "overflow", "ADL_Adapter_NumberOfAdapters_Get", "GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "ImageWidth", "Gray", "I420", "IYUV", "YUNVw", "BGR0C", "TDATTIMETORYTRDATSIZTYER", "TDENTDORTDRCTDRLTDTGTIPLTMCLTMOOTPROTSOATSOPTSOTTSST", "TALBTBPMTCOMTCONTCOPTDLYTENCTEXTTFLTTIT1TIT2TIT3TKEYTLANTLENTMEDTOALTOFNTOLYTOPETOWNTPE1TPE2TPE3TPE4TPOSTPUBTRCKTRSNTRSOTSRCTSSE", "tx3g806cc608", "sac3", "alac", "twos", "lpcm", "WMA2cvessevcvmssssmv", "cvid1", "mp2vY", "tiffb", "avs2u", "dracd", "AVupf", "ap4x3", "HapY", "avc1k", "VP6F", "mp4a", "tx3g", "text", "Lavf", "drac", "HEVC", "SUPO", "XTDB", "HFYUD", "IV32p", "IV41q", "VP62k", "Xxanr", "cvid4", "DUCK4", "PVEZ6", "MSZH7", "S263W", "svq19", "WMVPG", "WVC1G", "WVP2I", "LOCOJ", "WNV1J", "YUV8K", "AAS4K", "AASCL", "RT21M", "theoN", "TM20P", "CSCDR", "ZMBVV", "KMVCX", "CAVSY", "mjp2Y", "MJ2CY", "LJ2CY", "LJ2KY", "IPJ2Z", "CLJRu", "LAGSl", "ZECOP14YY41P3", "SVQ3V210012vV210a12vM2G", "G2M2M2G", "G2M3M2G", "G2M4M2G", "CUVC", "IARL", "IART", "ICMS", "ICMT", "ICOP", "ICRD", "ICRP", "IDIM", "IDPI", "IENG", "IGNR", "IKEY", "ILGT", "ILNG", "IMED", "INAM", "IPLT", "IPRD", "IPRT", "ITRK", "ISBJ", "ISFT", "ISHP", "ISMP", "ISRC", "ISRF", "ITCH", "PCMU", "G723", "DVI4", "DVI4", "PCMA", "G722", "QCELP", "G728", "DVI4", "DVI4", "G729", "CelB", "JPEG", "H261", "MP2T", "H263", "s16p", "s32p", "fltp", "dblp", "fffffff", "x00000x", "p000x", "p00000x", "p000x", "p000x", "p000x", "x264_slice_header_write", "x264_weighted_pred_init", "x264_reference_build_list", "c8ef3d10dedcd2579b7ae8c9f0d18028", "x264_macroblock_bipred_init", "x264_frame_push_unused", "x264_frame_shift", "x264_frame_pop", "x264_slicetype_analyse", "x264_macroblock_analyse", "x264_ratecontrol_start", "init_pass2", "x264_ratecontrol_new", "x264_macroblock_cache_rect"], "debugstrings": ["On2 VP6 (Flash version)", "ffconcat version 1.0", "version", "Line %d: invalid version\n", "HTTP version string: %s\n", "minor_version", "quicktime_version", "premiere_version", "Version %d", "version =%d, isom =%d\n", "id3v2_version", "tables_version", "set PAT, PMT and SDT version", "Server version %d.%d.%d.%d\n", "Unknown SMV version found\n", "unsupported bayer conversion\n", "[start conversion]\n", "[end conversion]\n", "H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2", "MPEG-4 part 2 Microsoft variant version 1", "MPEG-4 part 2 Microsoft variant version 2", "MPEG-4 part 2 Microsoft variant version 3", "H.263+ / H.263-1998 / H.263 version 2", "On2 VP6 (Flash version, with alpha channel)", "mjpeg: JFIF header found (version: %x.%x) SAR=%d/%d\n", "Intel(R) JPEG Library, version 1", "range <= 16 || !s->msmpeg4_version", "bugs: %X lavc_build:%d xvid_build:%d divx_version:%d divx_build:%d %s\n", "old standard qpel (autodetected per FOURCC/version)", "direct-qpel-blocksize bug (autodetected per FOURCC/version)", "edge padding bug (autodetected per FOURCC/version)", "strictly conform to a older more strict version of the spec or reference software", "Audio sample format conversion failed\n", "libavcodec license: GPL version 2 or later", "Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\n", "Audio resampling and conversion.", "libavfilter license: GPL version 2 or later", "Color conversion not implemented for %s\n", "Impossible to create scale context for the conversion fmt:%s s:%dx%d -> fmt:%s s:%dx%d\n", "error calculating conversion coefficients\n", "Timebase conversion is not exact\n", "Unsupported tag version. (>=%d)\n", "configurationVersion:                %u\n", "Malformed HTTP version string.\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n", "Invalid ID3v2 version requested: %d. Only 3, 4 or 0 (disabled) are allowed.\n", "Select ID3v2 version to write. Currently 3 and 4 are supported.", "sid=0x%x sec_num=%d/%d version=%d\n", "RTMP protocol version mismatch\n", "Version of the Flash plugin used to run the SWF player.", "libavformat license: GPL version 2 or later", "libavutil license: GPL version 2 or later", "libswresample license: GPL version 2 or later", "unsupported planar RGB conversion %s -> %s\n", "unsupported conversion to planar RGB %s -> %s\n", "libswscale license: GPL version 2 or later", "No accelerated colorspace conversion found from %s to %s.\n", "libpostproc license: GPL version 2 or later", "cannot remap packed format during conversion\n", "libavresample license: GPL version 2 or later", "GPSVersionID", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "FFmpeg version ff2.8--ijk0.4.1.1--dev0.3.3--rc4", "GCC: (GNU) 4.8", "GCC: (GNU) 4.9 20140827 (prerelease)"], "localsymbols": [""], "dependencies": ["libm.so", "libz.so", "libdl.so", "libc.so"], "elfname": "libijkffmpeg.so"}