{"globalvars": ["__stop_pre_merge_jni_libraries", "__start_pre_merge_jni_libraries"], "importedglobals": ["_ZTVN10__cxxabiv120__si_class_type_infoE", "_ctype_", "_ZTISt9exception", "__stack_chk_guard", "_ZTVN10__cxxabiv117__class_type_infoE", "__sF"], "importedfunctions": ["_Znaj", "__android_log_print", "_ZNSt8ios_base4InitC1Ev", "strdup", "_ZNSt8ios_base4InitD1Ev", "memmove", "cos", "__stack_chk_fail", "__gxx_personality_v0", "strlen", "_ZNSt9exceptionD2Ev", "fflush", "sqrt", "pthread_mutex_init", "memset", "_ZdaPv", "close", "abort", "_ZdlPv", "_ZSt20__throw_length_errorPKc", "calloc", "pthread_mutexattr_destroy", "sqrtf", "_Znwj", "open", "pthread_mutexattr_settype", "vsnprintf", "pthread_mutex_lock", "pthread_mutex_unlock", "free", "sprintf", "pthread_mutexattr_init", "memcpy", "read", "sin", "__gnu_ldivmod_helper", "lrint", "pthread_mutex_destroy", "fprintf", "lrintf", "malloc"], "exportedfunctions": ["_ZN2cv6String8allocateEj", "_ZN2cvplERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv9transposeERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cvmiERKNS_7MatExprERKNS_7Scalar_IdEE", "_ZN2cvplERKNS_7MatExprES2_", "_ZN2cvdvERKNS_7MatExprEd", "_ZN2cv9minMaxLocERKNS_11_InputArrayEPdS3_PNS_6Point_IiEES6_S2_", "_ZN2cv3Mat10deallocateEv", "_ZN2cv16MatConstIterator4seekEPKib", "_ZNK2cv3Mat3mulERKNS_11_InputArrayEd", "_ZN2cvmlERKNS_7MatExprES2_", "_ZN2cv3MatC1ERKS0_RKNS_5RangeES5_", "_ZN2cv3Mat5zerosEiii", "_ZN2cvmlEdRKNS_3MatE", "_ZNK2cv11_InputArray7getMat_Ei", "JNI_OnLoad_Weak", "_ZN2cv4normERKNS_11_InputArrayEiS2_", "_ZN2cv10meanStdDevERKNS_11_InputArrayERKNS_12_OutputArrayES5_S2_", "_ZN2cv11mixChannelsEPKNS_3MatEjPS0_jPKij", "_ZN2cvmlERKNS_7MatExprERKNS_3MatE", "_ZNK2cv12_OutputArray6createEiiiibi", "_ZN2cv3MatC1ERKS0_RKNS_5Rect_IiEE", "_ZN2cv14copyMakeBorderERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiiRKNS_7Scalar_IdEE", "_ZNK2cv11_InputArray4sizeEi", "_ZN2cvmiERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv5errorEiRKNS_6StringEPKcS4_i", "_ZN2cv16MatConstIterator4seekEib", "_ZN2cv5splitERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZNK2cv3Mat9convertToERKNS_12_OutputArrayEidd", "_ZN2cv3Mat6createEiPKii", "_ZNK2cv3Mat1tEv", "_ZN2cvdvERKNS_3MatEd", "_ZNK2cv3Mat3invEi", "_ZN2cv3MataSERKNS_7Scalar_IdEE", "_ZN2cvmlEdRKNS_7MatExprE", "_ZN2cvmlERKNS_3MatES2_", "_ZN2cv17getOptimalDFTSizeEi", "_ZN2cv8fastFreeEPv", "_ZN2cv6String10deallocateEv", "_ZN2cv4flipERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv16ParallelLoopBodyD2Ev", "_ZN2cv3addERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "_ZN2cv3Mat8copySizeERKS0_", "_ZN2cv3maxEdRKNS_3MatE", "_ZNK2cv3Mat9locateROIERNS_5Size_IiEERNS_6Point_IiEE", "_ZN2cv3dftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZNK2cv3Mat7reshapeEii", "_ZNK2cv12_OutputArray6assignERKNS_3MatE", "_ZN2cv12mulSpectrumsERKNS_11_InputArrayES2_RKNS_12_OutputArrayEib", "_ZN2cv3Mat9adjustROIEiiii", "_ZNK2cv11_InputArray4kindEv", "_ZNK2cv3Mat7reshapeEiiPKi", "_ZN2cv13parallel_for_ERKNS_5RangeERKNS_16ParallelLoopBodyEd", "_ZN2cv4idftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv3sumERKNS_11_InputArrayE", "_ZN2cv7noArrayEv", "_ZN2cv17borderInterpolateEiii", "_ZNK2cv3Mat6copyToERKNS_12_OutputArrayE", "_ZN2cv5mergeERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv7absdiffERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv3expERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cvmiERKNS_7Scalar_IdEERKNS_7MatExprE"], "allstrings": ["com/facebook/soloader/MergedSoMapping$Invoke_JNI_OnLoad", "jni_lib_merge-stub", "Failed to allocate %lu bytes", "third-party/opencv/src/modules/core/src/alloc.cpp", "Step must be a multiple of esz1", "buck-out/gen/third-party/opencv/opencv-coreAndroid#header-mode-symlink-tree-only,headers/opencv2/core/mat.inl.hpp", "total() == 0 || data != NULL", "scn == 1", "third-party/opencv/src/modules/core/src/arithm.cpp", "The operation is neither 'array op array' (where arrays have the same size and type), nor 'array op scalar', nor 'scalar op array'", "psrc1->sameSize(*psrc2) && type1 == type2", "(mtype == CV_8U || mtype == CV_8S) && _mask.sameSize(*psrc1)", "src1.size == dst.size && src1.type() == dst.type()", "src.size == dst.size && src.type() == dst.type()", "The operation is neither 'array op array' (where arrays have the same size and the same number of channels), nor 'array op scalar', nor 'scalar op array'", "type2 == CV_64F && (sz2.height == 1 || sz2.height == 4)", "When the input arrays in add/subtract/multiply/divide functions have different types, the output array type must be explicitly specified", "(mtype == CV_8UC1 || mtype == CV_8SC1) && _mask.sameSize(*psrc1)", "src1.size == dst.size && src1.channels() == dst.channels()", "src2.size == dst.size && src2.channels() == dst.channels()", "The lower bounary is neither an array of the same size and same type as src, nor a scalar", "The upper bounary is neither an array of the same size and same type as src, nor a scalar", "lbScalar == ubScalar", "lb.type() == ub.type()", "src1.size == dst.size && dst.type() == CV_8U", "op == CMP_LT || op == CMP_LE || op == CMP_EQ || op == CMP_NE || op == CMP_GE || op == CMP_GT", "The operation is neither 'array op array' (where arrays have the same size and the same type), nor 'array op scalar', nor 'scalar op array'", "func != 0", "third-party/opencv/src/modules/core/src/convert.cpp", "Unknown/unsupported norm type", "src.size == dst.size && dst.type() == CV_8UC(src.channels())", "src.size == dst.size && src.channels() == dst.channels()", "dst.size() == src.size() && src.channels() == dst.channels()", "!_mv.fixedType() || _mv.empty() || _mv.type() == m.depth()", "src && nsrcs > 0 && dst && ndsts > 0 && fromTo && npairs > 0", "j < nsrcs && src[j].depth() == depth", "i1 >= 0 && j < ndsts && dst[j].depth() == depth", "nz > 0", "dvec[j].size() == src.size()", "dvec[j].depth() == src.depth()", "dvec[j].channels() == 1", "i < src.channels()", "mv && n > 0", "0 < cn && cn <= CV_CN_MAX", "mv[i].size == mv[0].size && mv[i].depth() == depth", "svec[j].size == dst.size && svec[j].depth() == dst.depth() && svec[j].channels() == 1 && i < dst.channels()", "nsrc > 0 && ndst > 0", "fromTo.size()%2 == 0 && nsrc > 0 && ndst > 0", "(lutcn == cn || lutcn == 1) && _lut.total() == 256 && _lut.isContinuous() && (depth == CV_8U || depth == CV_8S)", "dst.size() == src.size() && dst.type() == CV_MAKETYPE(lut.depth(), src.channels())", "0 <= coi && coi < cn", "0 <= coi && coi < dcn && scn == 1", "_src.sameSize(_dst) && sdepth == ddepth", "channels() == CV_MAT_CN(dtype)", "third-party/opencv/src/modules/core/src/copy.cpp", "size() == mask.size()", "mask.depth() == CV_8U && (mcn == 1 || mcn == cn)", "_src.dims() <= 2", "ny > 0 && nx > 0", "len > 0", "Unknown/unsupported border type", "maskarr == 0", "src.channels() == dst.channels()", "src.depth() == dst.depth() && src.size == dst.size", "(coi1 != 0 || src.channels() == 1) && (coi2 != 0 || dst.channels() == 1)", "src.type() == dst.type() && dst.rows % src.rows == 0 && dst.cols % src.cols == 0", "checkScalar(value, type(), _value.kind(), _InputArray::MAT )", "mask.empty() || (mask.type() == CV_8U && size == mask.size)", "src.type() == dst.type() && src.size() == dst.size()", "top >= 0 && bottom >= 0 && left >= 0 && right >= 0", "value[0] == value[1] && value[0] == value[2] && value[0] == value[3]", "The library is compiled without CUDA support", "buck-out/gen/third-party/opencv/opencv-coreAndroid#header-mode-symlink-tree-only,headers/opencv2/core/private.cuda.hpp", "0 <= rowRange_.start && rowRange_.start <= rowRange_.end && rowRange_.end <= m.rows", "third-party/opencv/src/modules/core/src/cuda_gpu_mat.cpp", "0 <= colRange_.start && colRange_.start <= colRange_.end && colRange_.end <= m.cols", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows", "The matrix is not continuous, thus its number of rows can not be changed", "Bad new number of rows", "The total number of matrix elements is not divisible by the new number of rows", "The total width is not divisible by the new number of channels", "third-party/opencv/src/modules/core/src/cuda_host_mem.cpp", "factors[0] == factors[nf-1]", "third-party/opencv/src/modules/core/src/dxt.cpp", "type == srcB.type() && srcA.size() == srcB.size()", "type == CV_32FC1 || type == CV_32FC2 || type == CV_64FC1 || type == CV_64FC2", "srcA.size == dst.size && srcA.type() == dst.type()", "This mode (using nonzero_rows with a single-column matrix) breaks the function's logic, so it is prohibited.\nFor fast convolution/correlation use 2-column matrix or single-row matrix instead", "src.size == dst.size", "dst.data == dst0.data", "type == CV_32FC1 || type == CV_64FC1", "Odd-size DCT's are not implemented", "The library is compiled without OpenGL support", "third-party/opencv/src/modules/core/src/gl_core_3_1.cpp", "!mat.empty()", "third-party/opencv/src/modules/core/src/lapack.cpp", "mat.rows == mat.cols && (type == CV_32F || type == CV_64F)", "rows == mat->cols", "src.rows == src.cols", "type == CV_32F || type == CV_64F", "p == evects0.ptr()", "p == evals0.ptr()", "u.cols >= nm && vt.rows >= nm && (w.size() == Size(nm, 1) || w.size() == Size(1, nm) || w.size() == Size(vt.rows, u.cols))", "w.type() == u.type() && u.type() == vt.type() && u.data && vt.data && w.data", "rhs.data == 0 || (rhs.type() == type && rhs.rows == m)", "(method != DECOMP_LU && method != DECOMP_CHOLESKY) || is_normal || src.rows == src.cols", "The function can not solve under-determined linear systems", "type == _src2.type() && (type == CV_32F || type == CV_64F)", "A.type() == x.type() && A.cols == x.rows && x.cols == b.cols", "m == n", "method == DECOMP_LU || method == DECOMP_CHOLESKY", "src.type() == dst.type() && src.rows == dst.cols && src.cols == dst.rows", "w.type() == type && (w.size() == cv::Size(nm,1) || w.size() == cv::Size(1, nm) || w.size() == cv::Size(nm, nm) || w.size() == cv::Size(n, m))", "u.type() == type", "v.type() == type", "u.size() == svd.u.size()", "v.size() == svd.vt.size()", "src1.size() == src2.size() && type == src2.type() && (depth == CV_32F || depth == CV_64F)", "third-party/opencv/src/modules/core/src/mathfuncs.cpp", "depth == CV_32F || depth == CV_64F", "_a.depth() == CV_32F", "src.type() == dst.type() && src.size == dst.size", "ctype == CV_32F || ctype == CV_64F", "(coeffs.size() == Size(n0, 1) || coeffs.size() == Size(n0+1, 1) || coeffs.size() == Size(1, n0) || coeffs.size() == Size(1, n0+1))", "_roots.data == _roots0.data", "pt == NULL", "the value at (%d, %d)=%s is out of range [%f, %f)", "X.size == Y.size && type == Y.type() && (depth == CV_32F || depth == CV_64F)", "Mag.size() == X.size() && Mag.type() == X.type()", "Angle.size() == X.size() && Angle.type() == X.type()", "Mag.empty() || Angle.size == Mag.size", "(depth == CV_32F || depth == CV_64F) && (src1.empty() || src1.type() == type)", "Mag.size() == Angle.size() && Mag.type() == Angle.type()", "X.size() == Angle.size() && X.type() == Angle.type()", "Y.size() == Angle.size() && Y.type() == Angle.type()", "CV_MAT_DEPTH(ctype) >= CV_32F && CV_MAT_CN(ctype) <= 2", "coeffs0.rows == 1 || coeffs0.cols == 1", "_r.data == _r0.data", "type == _src2.type()", "third-party/opencv/src/modules/core/src/matmul.cpp", "src1.size == src2.size", "mat.type() == type() && mat.size == size && func != 0", "(evals0.cols == 1 || evals0.rows == 1) && ecount0 <= ecount && evects0.cols == evects.cols && evects0.rows == ecount0", "mean0.data == mean.data", "dst.cols <= evects.rows && dst.rows == data.rows", "dst.rows <= evects.rows && dst.cols == data.cols", "dst0.data == dst.data", "data.cols <= evects.rows && dst.rows == data.rows", "data.rows <= evects.rows && dst.cols == data.cols", "a_size.width == len", "a_size.height == len", "type == CV_64FC2", "type == B.type() && (type == CV_32FC1 || type == CV_64FC1 || type == CV_32FC2 || type == CV_64FC2)", "C.type() == type && (((flags&GEMM_3_T) == 0 && C.rows == d_size.height && C.cols == d_size.width) || ((flags&GEMM_3_T) != 0 && C.rows == d_size.width && C.cols == d_size.height))", "src.channels() == 1", "delta.channels() == 1 && (delta.rows == src.rows || delta.rows == 1) && (delta.cols == src.cols || delta.cols == 1)", "src.size() > 0", "(*each).size() == size && (*each).type() == type", "_mean.size() == size", "((flags & CV_COVAR_ROWS) != 0) ^ ((flags & CV_COVAR_COLS) != 0)", "nsamples > 0", "mean.size() == size", "data && nsamples > 0", "data[i].size() == size && data[i].type() == type", "vecarr != 0 && count >= 1", "(D.rows == ((flags & CV_GEMM_A_T) == 0 ? A.rows : A.cols)) && (D.cols == ((flags & CV_GEMM_B_T) == 0 ? B.cols : B.rows)) && D.type() == A.type()", "scn == m.cols || scn + 1 == m.cols", "dst.depth() == src.depth() && dst.channels() == m.rows", "scn + 1 == m.cols", "dst.type() == src.type() && dst.channels() == m.rows-1", "type == v2.type() && type == icovar.type() && sz == v2.size() && len == icovar.rows && len == icovar.cols", "Unknown operation", "third-party/opencv/src/modules/core/src/matop.cpp", "CV_MAT_CN(_type) == e.a.channels()", "Invalid matrix initializer type", "u->urefcount == 0", "third-party/opencv/src/modules/core/src/matrix.cpp", "u->refcount == 0", "total <= step[i]", "0 <= _dims && _dims <= CV_MAX_DIM", "s >= 0", "The total matrix size does not fit to \"size_t\" type", "0 <= d && d <= CV_MAX_DIM && _sizes", "u != 0", "step[dims-1] == (size_t)CV_ELEM_SIZE(flags)", "m.dims <= 2", "ranges", "r == Range::all() || (0 <= r.start && r.start < r.end && r.end <= m.size[i])", "dims <= 2", "dims <= 2 && step[0] > 0", "cn <= 4", "You should explicitly call mapDevice/unmapDevice methods for ogl::Buffer object", "getGpuMat is available only for cuda::GpuMat and cuda::HostMem", "k == OPENGL_BUFFER", "i < 0", "i < (int)vv.size()", "Unknown/unsupported array type", "(flags & FIXED_TYPE) != 0", "(size_t)i < vv.size()", "k == MAT", "k == STD_VECTOR_MAT", "i < (int)v.size()", "k == UMAT", "k == STD_VECTOR_UMAT", "k == CUDA_GPU_MAT", "k == STD_VECTOR_CUDA_GPU_MAT", "k == CUDA_HOST_MEM", "The function only supports 32sC1 and 32fC1 datatypes", "_arrays && (_ptrs || _planes)", "narrays <= 1000", "arrays[i] != 0", "A.size == arrays[i0]->size", "A.step[d-1] == A.elemSize()", "sz[i] <= (size_t)INT_MAX", "m != 0 && _idx", "hdr && hdr->dims == 2", "hdr && hdr->dims == 3", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2", "Only 32f and 64f are supported", "abs(vecs[0].dot(vecs[1])) / (norm(vecs[0]) * norm(vecs[1])) <= FLT_EPSILON", "vector::_M_default_append", "_sizes && 0 < d && d <= CV_MAX_DIM", "_sizes[i] > 0", "m.dims >= 2", "0 <= _rowRange.start && _rowRange.start <= _rowRange.end && _rowRange.end <= m.rows", "0 <= _colRange.start && _colRange.start <= _colRange.end && _colRange.end <= m.cols", "You should explicitly call mapHost/unmapHost methods for ogl::Buffer object", "You should explicitly call download method for cuda::GpuMat object", "0 <= i && i < (int)vv.size()", "0 <= i && i < (int)v.size()", "_m.dims() <= 2", "m.dims <= 2 && m.rows == m.cols", "dims <= 2 && m.dims <= 2 && size() == m.size() && tp == m.type() && ((rows == 3 && cols == 1) || (cols*channels() == 3 && rows == 1))", "checkScalar(value, type(), arr.kind(), _InputArray::CUDA_GPU_MAT)", "nelems <= (size_t)size.p[0]", "(int)nelems >= 0", "COI is not supported by the function", "img->dataOrder == IPL_DATA_ORDER_PIXEL", "img->dataOrder == IPL_DATA_ORDER_PIXEL || img->roi->coi != 0", "total > 0 && CV_ELEM_SIZE(seq->flags) == esz", "Unknown array type", "!centers.empty()", "centers.rows == cluster_count", "centers.cols == data.cols", "centers.depth() == data.depth()", "labels.isContinuous() && labels.type() == CV_32S && (labels.cols == 1 || labels.rows == 1) && labels.cols + labels.rows - 1 == data.rows", "CV_IS_IMAGE(arr)", "ch.size == mat.size && ch.depth() == mat.depth() && 0 <= coi && coi < mat.channels()", "srcA.size() == dst.size() && srcA.type() == dst.type()", "CV_MAT_TYPE(mtype) == m.type()", "m.dims == d", "m.size[j] == sizes[j]", "mtype == type0 || (CV_MAT_CN(mtype) == 1 && ((1 << type0) & fixedDepthMask) != 0)", "d == 2 && ((sizes[0] == sz.height && sizes[1] == sz.width) || (allowTransposed && sizes[0] == sz.width && sizes[1] == sz.height))", "d == 2 && (sizes[0] == 1 || sizes[1] == 1 || sizes[0]*sizes[1] == 0)", "mtype == type0 || (CV_MAT_CN(mtype) == CV_MAT_CN(type0) && ((1 << type0) & fixedDepthMask) != 0)", "Vectors with element size %d are not supported. Please, modify OutputArray::create()\n", "create() called for the missing output array", "v[j].empty()", "!fixedType() && !fixedSize()", "!fixedSize() || len == vv.size()", "!fixedSize() || len == ((std::vector<uchar>*)v)->size() / esz", "!fixedSize() || len == len0", "0 <= coi && coi < mat.channels()", "!fixedSize() || ((Mat*)obj)->size.operator()() == _sz", "!fixedSize() || ((UMat*)obj)->size.operator()() == _sz", "!fixedSize() || ((cuda::GpuMat*)obj)->size() == _sz", "!fixedSize() || ((ogl::Buffer*)obj)->size() == _sz", "!fixedSize() || ((cuda::HostMem*)obj)->size() == _sz", "!fixedType() || ((Mat*)obj)->type() == mtype", "!fixedType() || ((UMat*)obj)->type() == mtype", "!fixedType() || ((cuda::GpuMat*)obj)->type() == mtype", "!fixedType() || ((ogl::Buffer*)obj)->type() == mtype", "!fixedType() || ((cuda::HostMem*)obj)->type() == mtype", "!fixedSize()", "src.dims <= 2 && src.channels() == 1 && func != 0", "src.size() == idx.size() && idx.type() == CV_32S && src.data != idx.data", "idx0.data == idx.data", "src.size() == dst.size() && src.type() == dst.type()", "!fixedSize() || ((Mat*)obj)->size.operator()() == Size(_cols, _rows)", "!fixedSize() || ((UMat*)obj)->size.operator()() == Size(_cols, _rows)", "!fixedSize() || ((cuda::GpuMat*)obj)->size() == Size(_cols, _rows)", "!fixedSize() || ((ogl::Buffer*)obj)->size() == Size(_cols, _rows)", "!fixedSize() || ((cuda::HostMem*)obj)->size() == Size(_cols, _rows)", "src[i].dims <= 2 && src[i].rows == src[0].rows && src[i].type() == src[0].type()", "src[i].dims <= 2 && src[i].cols == src[0].cols && src[i].type() == src[0].type()", "src.size() == dst.size() && (src.cols == 1 || src.rows == 1)", "dst.cols == dst.rows", "_src.dims() <= 2 && esz <= 32", "d.cols == 1 || d.rows == 1", "src.rows == dst.cols && src.cols == dst.rows && src.type() == dst.type()", "cn == CV_MAT_CN(dtype)", "op == CV_REDUCE_SUM || op == CV_REDUCE_MAX || op == CV_REDUCE_MIN || op == CV_REDUCE_AVG", "Unsupported combination of input and output array formats", "The reduced dimensionality index is out of range", "The output array size is incorrect", "Input and output arrays must have the same number of channels", "_cn >= 0 && _newndims > 0 && _newndims <= CV_MAX_DIM && _newsz", "_cn <= CV_CN_MAX", "_newsz[i] >= 0", "Copy dimension (which has zero size) is not present in source matrix", "Requested and source matrices have different count of elements", "Reshaping of n-dimensional non-continuous matrices is not supported yet", "hdr && hdr->dims == 1", "hdr != 0", "src.data != dst.data", "third-party/opencv/src/modules/core/src/opengl.cpp", "OpenCV was build without OpenGL support", "cn == 2 || cn == 3 || cn == 4", "depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "cn == 3 || cn == 4", "cn == 3", "depth == CV_8S || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "cn >= 1 && cn <= 4", "cn == 1", "third-party/opencv/src/modules/core/src/stat.cpp", "(cn == 1 && (_mask.empty() || _mask.type() == CV_8U)) || (cn > 1 && _mask.empty() && !minIdx && !maxIdx)", "_img.dims() <= 2", "src.type() == CV_8UC1", "idx.isContinuous()", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && _src.type() == CV_8U)", "mask.empty() || mask.type() == CV_8U", "_src1.sameSize(_src2) && _src1.type() == _src2.type()", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && src1.type() == CV_8U)", "_src1.depth() == CV_8U", "mask.empty() || mask.type() == CV_8UC1", "dst.type() == CV_64F && dst.isContinuous() && (dst.cols == 1 || dst.rows == 1) && dcn >= cn", "cn <= 4 && func != 0", "_nidx.needed() == (K > 0)", "(type == CV_8U && dtype == CV_32S) || dtype == CV_32F", "type == src2.type() && src1.cols == src2.cols && (type == CV_32F || type == CV_8U)", "K == 1 && update == 0 && mask.empty()", "The combination of type=%d, dtype=%d and normType=%d is not supported", "0 < coi && coi <= 4", "\nGeneral configuration for OpenCV 3.1.0 =====================================\n  Version control:               unknown\n\n  Platform:\n    Host:                        Darwin 15.6.0 x86_64\n    CMake:                       3.6.1\n    CMake generator:             Unix Makefiles\n    CMake build tool:            /usr/bin/make\n    Configuration:               RELEASE\n\n  C/C++:\n    Built as dynamic libs?:      YES\n    C++ Compiler:                /Applications/Xcode7.3.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++  (ver 7.3.0.7030031)\n    C++ flags (Release):         -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG  -DNDEBUG\n    C++ flags (Debug):           -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -g  -O0 -DDEBUG -D_DEBUG\n    C Compiler:                  /Applications/Xcode7.3.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc\n    C flags (Release):           -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG  -DNDEBUG\n    C flags (Debug):             -fsigned-char -W -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-unnamed-type-template-args -fdiagnostics-show-option -Wno-long-long -Qunused-arguments -Wno-semicolon-before-method-body -fno-omit-frame-pointer -msse -msse2 -mno-avx -msse3 -mno-ssse3 -mno-sse4.1 -mno-sse4.2 -fvisibility=hidden -fvisibility-inlines-hidden -g  -O0 -DDEBUG -D_DEBUG\n    Linker flags (Release):\n    Linker flags (Debug):\n    Precompiled headers:         NO\n    Extra dependencies:          -framework OpenCL -framework Cocoa avcodec avformat avutil swscale avresample /usr/lib/libbz2.dylib -framework VideoDecodeAcceleration bz2 -framework QTKit -framework QuartzCore -framework AppKit\n    3rdparty dependencies:       libjpeg libwebp libpng libtiff libjasper IlmImf zlib libprotobuf\n\n  OpenCV modules:\n    To be built:                 core flann imgproc ml photo reg surface_matching video dnn fuzzy imgcodecs shape videoio highgui objdetect plot superres ts xobjdetect xphoto bgsegm bioinspired dpm face features2d line_descriptor saliency text calib3d ccalib datasets rgbd stereo structured_light tracking videostab xfeatures2d ximgproc aruco optflow stitching\n    Disabled:                    world contrib_world\n    Disabled by dependency:      -\n    Unavailable:                 cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev java python2 python3 viz cvv hdf matlab sfm\n\n  GUI: \n    QT:                          NO\n    Cocoa:                       YES\n    OpenGL support:              NO\n    VTK support:                 NO\n\n  Media I/O: \n    ZLib:                        build (ver 1.2.8)\n    JPEG:                        build (ver 90)\n    WEBP:                        build (ver 0.3.1)\n    PNG:                         build (ver 1.6.19)\n    TIFF:                        build (ver 42 - 4.0.2)\n    JPEG 2000:                   build (ver 1.900.1)\n    OpenEXR:                     build (ver 1.7.1)\n    GDAL:                        NO\n\n  Video I/O:\n    DC1394 1.x:                  NO\n    DC1394 2.x:                  NO\n    FFMPEG:                      YES\n      codec:                     YES (ver 57.48.101)\n      format:                    YES (ver 57.41.100)\n      util:                      YES (ver 55.28.100)\n      swscale:                   YES (ver 4.1.100)\n      resample:                  YES (ver 3.0.0)\n      gentoo-style:              YES\n    GStreamer:                   NO\n    OpenNI:                      NO\n    OpenNI PrimeSensor Modules:  NO\n    OpenNI2:                     NO\n    PvAPI:                       NO\n    GigEVisionSDK:               NO\n    QuickTime:                   NO\n    QTKit:                       YES\n    V4L/V4L2:                    NO/NO\n    XIMEA:                       NO\n    gPhoto2:                     NO\n\n  Parallel framework:            GCD\n\n  Other third-party libraries:\n    Use IPP:                     9.0.1 [9.0.1]\n         at:                     /Users/kri/workspace/third_party/opencv3.1/opencv-3.1.0/3rdparty/ippicv/unpack/ippicv_osx\n    Use IPP Async:               NO\n    Use VA:                      NO\n    Use Intel VA-API/OpenCL:     NO\n    Use Eigen:                   YES (ver 3.2.9)\n    Use Cuda:                    NO\n    Use OpenCL:                  YES\n    Use custom HAL:              NO\n\n  OpenCL:\n    Version:                     static\n    libraries:                   -framework OpenCL\n    Use AMDFFT:                  NO\n    Use AMDBLAS:                 NO\n\n  Python 2:\n    Interpreter:                 /usr/local/bin/python2.7 (ver 2.7.12)\n\n  Python 3:\n    Interpreter:                 /usr/local/bin/python3 (ver 3.5.2)\n\n  Python (for build):            /usr/local/bin/python2.7\n\n  Java:\n    ant:                         NO\n    JNI:                         /System/Library/Frameworks/JavaVM.framework/Headers /System/Library/Frameworks/JavaVM.framework/Headers /System/Library/Frameworks/JavaVM.framework/Headers\n    Java wrappers:               NO\n    Java tests:                  NO\n\n  Matlab:                        Matlab not found or implicitly disabled\n\n  Documentation:\n    Doxygen:                     NO\n    PlantUML:                    NO\n\n  Tests and samples:\n    Tests:                       YES\n    Performance tests:           YES\n    C/C++ Examples:              NO\n\n  Install path:                  /Users/kri/workspace/third_party/opencv3.1/opencv-3.1.0/build\n\n  cvconfig.h is in:              /Users/kri/workspace/third_party/opencv3.1/opencv-3.1.0/build\n-----------------------------------------------------------------\n\n", "%s:%d: error: (%d) %s in function %s\n", "%s:%d: error: (%d) %s\n", "OPENCV_TEMP_PATH", "__opencv_temp.XXXXXX", "/data/local/tmp/__opencv_temp.XXXXXX", "status", "error", "No Error", "Backtrace", "Unspecified error", "Internal error", "Insufficient memory", "Bad argument", "Iterations do not converge", "Autotrace call", "Incorrect size of input array", "Null pointer", "Division by zero occured", "Image step is wrong", "Inplace operation is not supported", "Requested object was not found", "Input image depth is not supported by function", "Formats of input arguments do not match", "Sizes of input arguments do not match", "One of arguments' values is out of range", "Unsupported format or combination of formats", "Input COI is not supported", "Bad number of channels", "Bad flag (parameter or structure field)", "Bad parameter of type CvPoint", "Bad type of mask argument", "Parsing error", "The function/feature is not implemented", "Memory block has been corrupted", "Assertion failed", "No CUDA support", "Gpu API call", "No OpenGL support", "OpenGL API call", "Unknown %s code %d", "unknown function", "OpenCV Error: %s (%s) in %s, file %s, line %d", "cv::error()", "pthread_key_create(&tlsKey, NULL) == 0", "third-party/opencv/src/modules/core/src/system.cpp", "pthread_key_delete(tlsKey) == 0", "pthread_setspecific(tlsKey, pData) == 0", "key_ == -1", "%s:%d %s", "vector::reserve", "vector::_M_emplace_back_aux", "tlsSlots.size() > slotIdx", "tlsSlots.size() > slotIdx && pData != NULL", "/proc/self/auxv", "mapcount == 0", "third-party/opencv/src/modules/core/src/umatrix.cpp", "data == datastart", "allocated", "Exception: %s\n", "u->data != 0 && \"Error mapping of UMat to host memory.\"", "!u->deviceCopyObsolete() || u->copyOnMap()", "m.sameSize(*this) && m.type() == type()", "ssize.area() > 0", "third-party/opencv/src/modules/imgproc/src/imgwarp.cpp", "ksize <= MAX_ESIZE", "dstm1type == CV_16SC2 || dstm1type == CV_32FC1 || dstm1type == CV_32FC2", "Unsupported combination of input/output matrices", "(m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) || (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) || (m1type == CV_32FC1 && m2type == CV_32FC1) || (m1type == CV_32FC2 && m2->empty())", "matM.rows == 2 && matM.cols == 3", "src.checkVector(2, CV_32F) == 4 && dst.checkVector(2, CV_32F) == 4", "src.checkVector(2, CV_32F) == 3 && dst.checkVector(2, CV_32F) == 3", "M.size() == M0.size()", "_src.total() > 0", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 3 && M0.cols == 3", "src.type() == dst.type()", "Unknown/unsupported interpolation type", "Unknown interpolation method", "_map1.size().area() > 0", "_map2.empty() || (_map2.size() == _map1.size())", "nnfunc != 0", "ifunc != 0", "((map1.type() == CV_32FC2 || map1.type() == CV_16SC2) && map2.empty()) || (map1.type() == CV_32FC1 && map2.type() == CV_32FC1)", "src.type() == dst.type() && dst.size() == mapx.size()", "src.cols > 0 && src.rows > 0", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 2 && M0.cols == 3", "dsize.area() > 0", "func != 0 && cn <= 4", "dsize.area() > 0 || (inv_scale_x > 0 && inv_scale_y > 0)", "M should be >0", "cn == 4", "void* cv::OutOfMemoryError(size_t)", "cv::Mat::Mat(int, int, int, void*, size_t)", "void cv::convertAndUnrollScalar(const cv::Mat&, int, uchar*, size_t)", "void cv::binary_op(cv::InputArray, cv::InputArray, cv::OutputArray, cv::InputArray, void (* const*)(const uchar*, size_t, const uchar*, size_t, uchar*, size_t, int, int, void*), bool, int)", "void cvAnd(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvAndS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvOr(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvOrS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvXor(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvXorS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvNot(const CvArr*, CvArr*)", "void cvMaxS(const void*, double, void*)", "void cvMinS(const void*, double, void*)", "void cvMax(const void*, const void*, void*)", "void cvMin(const void*, const void*, void*)", "void cv::arithm_op(cv::InputArray, cv::InputArray, cv::OutputArray, cv::InputArray, int, void (**)(const uchar*, size_t, const uchar*, size_t, uchar*, size_t, int, int, void*), bool, void*, int)", "void cvAdd(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvAddS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvSub(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvSubRS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvAbsDiff(const CvArr*, const CvArr*, CvArr*)", "void cvAbsDiffS(const CvArr*, CvArr*, CvScalar)", "void cvMul(const CvArr*, const CvArr*, CvArr*, double)", "void cvDiv(const CvArr*, const CvArr*, CvArr*, double)", "void cvAddWeighted(const CvArr*, double, const CvArr*, double, double, CvArr*)", "void cv::inRange(cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray)", "void cvInRange(const void*, const void*, const void*, void*)", "void cvInRangeS(const void*, CvScalar, CvScalar, void*)", "void cv::compare(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "void cvCmp(const void*, const void*, void*, int)", "void cvCmpS(const void*, double, void*, int)", "void cv::convertScaleAbs(cv::InputArray, cv::OutputArray, double, double)", "void cv::Mat::convertTo(cv::OutputArray, int, double, double) const", "void cv::normalize(cv::InputArray, cv::InputOutputArray, double, double, int, int, cv::InputArray)", "void cvConvertScaleAbs(const void*, void*, double, double)", "void cvConvertScale(const void*, void*, double, double)", "void cvNormalize(const CvArr*, CvArr*, double, double, int, const CvArr*)", "void cv::split(const cv::Mat&, cv::Mat*)", "void cv::split(cv::InputArray, cv::OutputArrayOfArrays)", "void cv::mixChannels(const cv::Mat*, size_t, cv::Mat*, size_t, const int*, size_t)", "void cvSplit(const void*, void*, void*, void*, void*)", "void cv::merge(const cv::Mat*, size_t, cv::OutputArray)", "void cvMerge(const void*, const void*, const void*, const void*, void*)", "void cv::mixChannels(cv::InputArrayOfArrays, cv::InputOutputArrayOfArrays, const int*, size_t)", "void cv::mixChannels(cv::InputArrayOfArrays, cv::InputOutputArrayOfArrays, const std::vector<int>&)", "void cv::LUT(cv::InputArray, cv::InputArray, cv::OutputArray)", "void cvLUT(const void*, void*, const void*)", "void cv::extractChannel(cv::InputArray, cv::OutputArray, int)", "void cv::insertChannel(cv::InputArray, cv::InputOutputArray, int)", "void cv::Mat::copyTo(cv::OutputArray) const", "void cv::Mat::copyTo(cv::OutputArray, cv::InputArray) const", "void cv::repeat(cv::InputArray, int, int, cv::OutputArray)", "int cv::borderInterpolate(int, int, int)", "void cvCopy(const void*, void*, const void*)", "void cvRepeat(const CvArr*, CvArr*)", "cv::Mat& cv::Mat::setTo(cv::InputArray, cv::InputArray)", "void cv::flip(cv::InputArray, cv::OutputArray, int)", "void cvFlip(const CvArr*, CvArr*, int)", "void cv::copyMakeBorder(cv::InputArray, cv::OutputArray, int, int, int, int, int, const Scalar&)", "void throw_no_cuda()", "cv::cuda::GpuMat::GpuMat(const cv::cuda::GpuMat&, cv::Range, cv::Range)", "cv::cuda::GpuMat::GpuMat(const cv::cuda::GpuMat&, cv::Rect)", "cv::cuda::GpuMat cv::cuda::GpuMat::reshape(int, int) const", "void throw_no_cuda()", "cv::cuda::HostMem cv::cuda::HostMem::reshape(int, int) const", "void throw_no_cuda()", "void cv::DFT(const cv::Complex<_Tp>*, cv::Complex<_Tp>*, int, int, const int*, const int*, const cv::Complex<_Tp>*, int, const void*, cv::Complex<_Tp>*, int, double) [with T = double]", "void cv::mulSpectrums(cv::InputArray, cv::InputArray, cv::OutputArray, int, bool)", "0Y\r@:i\r", "PF SdF", " [@W:[", "void cv::dft(cv::InputArray, cv::OutputArray, int, int)", "void cvDFT(const CvArr*, CvArr*, int, int)", "void cv::dct(cv::InputArray, cv::OutputArray, int)", "?void cvDCT(const CvArr*, CvArr*, int)", "void* IntGetProcAddress(const char*)", "cv::Mat::Mat(int, int, int, void*, size_t)", "double cv::determinant(cv::InputArray)", "double cvDet(const CvArr*)", "bool cv::eigen(cv::InputArray, cv::OutputArray, cv::OutputArray)", "void cvEigenVV(CvArr*, CvArr*, CvArr*, double, int, int)", "static void cv::SVD::backSubst(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray)", "void cvSVBkSb(const CvArr*, const CvArr*, const CvArr*, const CvArr*, CvArr*, int)", "bool cv::solve(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "int cvSolve(const CvArr*, const CvArr*, CvArr*, int)", "void cv::_SVDcompute(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int)", "double cv::invert(cv::InputArray, cv::OutputArray, int)", "double cvInvert(const CvArr*, CvArr*, int)", "void cvSVD(CvArr*, CvArr*, CvArr*, CvArr*, int)", "void cv::magnitude(cv::InputArray, cv::InputArray, cv::OutputArray)", "void cv::exp(cv::InputArray, cv::OutputArray)", "void cv::log(cv::InputArray, cv::OutputArray)", "void cv::patchNaNs(cv::InputOutputArray, double)", "void cvExp(const CvArr*, CvArr*)", "void cvLog(const CvArr*, CvArr*)", "int cv::solveCubic(cv::InputArray, cv::OutputArray)", "int cvSolveCubic(const CvMat*, CvMat*)", "bool cv::checkRange(cv::InputArray, bool, cv::Point*, double, double)", "void cv::phase(cv::InputArray, cv::InputArray, cv::OutputArray, bool)", "void cv::cartToPolar(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool)", "void cvCartToPolar(const CvArr*, const CvArr*, CvArr*, CvArr*, int)", "void cv::polarToCart(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool)", "void cvPolarToCart(const CvArr*, const CvArr*, CvArr*, CvArr*, int)", "void cv::pow(cv::InputArray, double, cv::OutputArray)", "void cvPow(const CvArr*, CvArr*, double)", "double cv::solvePoly(cv::InputArray, cv::OutputArray, int)", "void cvSolvePoly(const CvMat*, CvMat*, int, int)", "cv::Mat::Mat(int, int, int, void*, size_t)", "void cv::scaleAdd(cv::InputArray, double, cv::InputArray, cv::OutputArray)", "double cv::Mat::dot(cv::InputArray) const", "void cvScaleAdd(const CvArr*, CvScalar, const CvArr*, CvArr*)", "void cvCalcPCA(const CvArr*, CvArr*, CvArr*, CvArr*, int)", "void cvProjectPCA(const CvArr*, const CvArr*, const CvArr*, CvArr*)", "void cvBackProjectPCA(const CvArr*, const CvArr*, const CvArr*, CvArr*)", "void cv::gemm(cv::InputArray, cv::InputArray, double, cv::InputArray, double, cv::OutputArray, int)", "void cv::mulTransposed(cv::InputArray, cv::OutputArray, bool, cv::InputArray, double, int)", "void cv::calcCovarMatrix(cv::InputArray, cv::OutputArray, cv::InputOutputArray, int, int)", "void cv::calcCovarMatrix(const cv::Mat*, int, cv::Mat&, cv::Mat&, int, int)", "void cvCalcCovarMatrix(const CvArr**, int, CvArr*, CvArr*, int)", "void cvGEMM(const CvArr*, const CvArr*, double, const CvArr*, double, CvArr*, int)", "void cv::transform(cv::InputArray, cv::OutputArray, cv::InputArray)", "void cvTransform(const CvArr*, CvArr*, const CvMat*, const CvMat*)", "void cv::perspectiveTransform(cv::InputArray, cv::OutputArray, cv::InputArray)", "void cvPerspectiveTransform(const CvArr*, CvArr*, const CvMat*)", "double cv::Mahalanobis(cv::InputArray, cv::InputArray, cv::InputArray)", "virtual void cv::MatOp_Bin::assign(const cv::MatExpr&, cv::Mat&, int) const", "virtual void cv::MatOp_Identity::assign(const cv::MatExpr&, cv::Mat&, int) const", "virtual void cv::MatOp_Initializer::assign(const cv::MatExpr&, cv::Mat&, int) const", "N2cv5MatOpE", "N2cv14MatOp_IdentityE", "N2cv11MatOp_AddExE", "N2cv9MatOp_BinE", "N2cv9MatOp_CmpE", "N2cv10MatOp_GEMME", "N2cv12MatOp_InvertE", "N2cv7MatOp_TE", "N2cv11MatOp_SolveE", "N2cv17MatOp_InitializerE", "N2cv20BufferPoolControllerE", "N2cv25DummyBufferPoolControllerE", "N2cv15StdMatAllocatorE", "virtual void cv::StdMatAllocator::deallocate(cv::UMatData*) const", "virtual cv::UMatData* cv::StdMatAllocator::allocate(int, const int*, int, void*, size_t*, int, cv::UMatUsageFlags) const", "void (* cv::getConvertElem(int, int))(const void*, void*, int)", "void (* cv::getConvertScaleElem(int, int))(const void*, void*, int, double, double)", "void cv::setSize(cv::Mat&, int, const int*, const size_t*, bool)", "cv::Mat::Mat(int, int, int, void*, size_t)", "cv::Mat::Mat(cv::Size, int, void*, size_t)", "void cv::Mat::create(int, const int*, int)", "cv::Mat::Mat(const cv::Mat&, const Rect&)", "cv::Mat::Mat(const cv::Mat&, const cv::Range*)", "cv::Mat cv::Mat::diag(int) const", "void cv::Mat::locateROI(cv::Size&, cv::Point&) const", "cv::Mat& cv::Mat::adjustROI(int, int, int, int)", "cv::Mat cv::Mat::reshape(int, int) const", "void cv::scalarToRawData(const Scalar&, void*, int, int)", "cv::cuda::GpuMat cv::_InputArray::getGpuMat() const", "cv::ogl::Buffer cv::_InputArray::getOGlBuffer() const", "cv::Size cv::_InputArray::size(int) const", "int cv::_InputArray::sizend(int*, int) const", "int cv::_InputArray::dims(int) const", "size_t cv::_InputArray::total(int) const", "int cv::_InputArray::type(int) const", "bool cv::_InputArray::empty() const", "bool cv::_InputArray::isContinuous(int) const", "bool cv::_InputArray::isSubmatrix(int) const", "size_t cv::_InputArray::offset(int) const", "size_t cv::_InputArray::step(int) const", "cv::Mat& cv::_OutputArray::getMatRef(int) const", "cv::UMat& cv::_OutputArray::getUMatRef(int) const", "cv::cuda::GpuMat& cv::_OutputArray::getGpuMatRef() const", "std::vector<cv::cuda::GpuMat>& cv::_OutputArray::getGpuMatVecRef() const", "cv::ogl::Buffer& cv::_OutputArray::getOGlBufferRef() const", "cv::cuda::HostMem& cv::_OutputArray::getHostMemRef() const", "CvArr* cvRange(CvArr*, double, double)", "void cv::NAryMatIterator::init(const cv::Mat**, cv::Mat*, uchar**, int)", "virtual void cv::MatAllocator::download(cv::UMatData*, void*, int, const size_t*, const size_t*, const size_t*, const size_t*) const", "virtual void cv::MatAllocator::upload(cv::UMatData*, const void*, int, const size_t*, const size_t*, const size_t*, const size_t*) const", "virtual void cv::MatAllocator::copy(cv::UMatData*, cv::UMatData*, int, const size_t*, const size_t*, const size_t*, const size_t*, const size_t*, bool) const", "void cv::MatConstIterator::pos(int*) const", "void cv::SparseMat::erase(int, int, size_t*)", "void cv::SparseMat::erase(int, int, int, size_t*)", "void cv::SparseMat::erase(const int*, size_t*)", "void cv::SparseMat::copyTo(cv::Mat&) const", "void cv::SparseMat::convertTo(cv::Mat&, int, double, double) const", "double cv::norm(const cv::SparseMat&, int)", "void cv::minMaxLoc(const cv::SparseMat&, double*, double*, int*, int*)", "cv::RotatedRect::RotatedRect(const Point2f&, const Point2f&, const Point2f&)", "_IplImage::_IplImage(const cv::Mat&)", "void cv::SparseMat::create(int, const int*, int)", "cv::Mat::Mat(const cv::Mat&, const cv::Range&, const cv::Range&)", "cv::Mat cv::_InputArray::getMat_(int) const", "cv::UMat cv::_InputArray::getUMat(int) const", "void cv::_OutputArray::assign(const cv::UMat&) const", "void cv::_OutputArray::assign(const cv::Mat&) const", "void cv::setIdentity(cv::InputOutputArray, const Scalar&)", "cv::Scalar cv::trace(cv::InputArray)", "void cv::completeSymm(cv::InputOutputArray, bool)", "cv::Mat cv::Mat::cross(cv::InputArray) const", "void cv::_OutputArray::setTo(const cv::_InputArray&, const cv::_InputArray&) const", "void cv::Mat::pop_back(size_t)", "void cv::Mat::reserve(size_t)", "void cv::Mat::resize(size_t)", "void cv::Mat::push_back(const cv::Mat&)", "cv::Mat cv::cvarrToMat(const CvArr*, bool, bool, int, cv::AutoBuffer<double>*)", "cv::Mat cv::iplImageToMat(const IplImage*, bool)", "int cvKMeans2(const CvArr*, int, CvArr*, CvTermCriteria, int, CvRNG*, int, CvArr*, double*)", "void cv::insertImageCOI(cv::InputArray, CvArr*, int)", "void cvCrossProduct(const CvArr*, const CvArr*, CvArr*)", "void cv::_InputArray::getMatVector(std::vector<cv::Mat>&) const", "void cv::_InputArray::getUMatVector(std::vector<cv::UMat>&) const", "void cv::_OutputArray::create(int, const int*, int, int, bool, int) const", "void cv::extractImageCOI(const CvArr*, cv::OutputArray, int)", "void cv::_OutputArray::create(cv::Size, int, int, bool, int) const", "void cv::_OutputArray::release() const", "void cv::_InputArray::copyTo(const cv::_OutputArray&) const", "void cv::_InputArray::copyTo(const cv::_OutputArray&, const cv::_InputArray&) const", "void cv::_OutputArray::clear() const", "void cv::sort(cv::InputArray, cv::OutputArray, int)", "void cv::sortIdx(cv::InputArray, cv::OutputArray, int)", "void cvSort(const CvArr*, CvArr*, CvArr*, int)", "void cv::_OutputArray::create(int, int, int, int, bool, int) const", "void cv::hconcat(const cv::Mat*, size_t, cv::OutputArray)", "void cv::vconcat(const cv::Mat*, size_t, cv::OutputArray)", "void cv::transpose(cv::InputArray, cv::OutputArray)", "static cv::Mat cv::Mat::diag(const cv::Mat&)", "void cvTranspose(const CvArr*, CvArr*)", "void cv::reduce(cv::InputArray, cv::OutputArray, int, int, int)", "void cvReduce(const CvArr*, CvArr*, int, int)", "cv::Mat cv::Mat::reshape(int, int, const int*) const", "uchar* cv::SparseMat::ptr(int, bool, size_t*)", "uchar* cv::SparseMat::ptr(int, int, bool, size_t*)", "uchar* cv::SparseMat::ptr(int, int, int, bool, size_t*)", "uchar* cv::SparseMat::ptr(const int*, bool, size_t*)", "void cv::SparseMat::convertTo(cv::SparseMat&, int, double) const", "void cv::normalize(const cv::SparseMat&, cv::SparseMat&, double, int)", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = unsigned char]", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = signed char]", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = short unsigned int]", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = short int]", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = int]", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = float]", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = double]", "N2cv12MatAllocatorE", "void {anonymous}::throw_no_ogl()", "cv::ocl::Context& cv::ogl::ocl::initializeContextFromGL()", "void cv::ogl::convertToGLTexture2D(cv::InputArray, cv::ogl::Texture2D&)", "void cv::ogl::convertFromGLTexture2D(const cv::ogl::Texture2D&, cv::OutputArray)", "cv::UMat cv::ogl::mapGLBuffer(const cv::ogl::Buffer&, int)", "void cv::ogl::unmapGLBuffer(cv::UMat&)", "void cv::ogl::Arrays::setVertexArray(cv::InputArray)", "void cv::ogl::Arrays::setColorArray(cv::InputArray)", "void cv::ogl::Arrays::setNormalArray(cv::InputArray)", "void cv::ogl::Arrays::setTexCoordArray(cv::InputArray)", "int cv::countNonZero(cv::InputArray)", "void cv::minMaxIdx(cv::InputArray, double*, double*, int*, int*, cv::InputArray)", "void cv::minMaxLoc(cv::InputArray, double*, double*, cv::Point*, cv::Point*, cv::InputArray)", "void cv::findNonZero(cv::InputArray, cv::OutputArray)", "double cv::norm(cv::InputArray, cv::InputArray, int, cv::InputArray)", "double cv::PSNR(cv::InputArray, cv::InputArray)", "void cv::meanStdDev(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::InputArray)", "cv::Scalar cv::sum(cv::InputArray)", "cv::Scalar cv::mean(cv::InputArray, cv::InputArray)", "void cv::batchDistance(cv::InputArray, cv::InputArray, cv::OutputArray, int, cv::OutputArray, int, int, cv::InputArray, int, bool)", "CvScalar cvSum(const CvArr*)", "CvScalar cvAvg(const void*, const void*)", "void cvAvgSdv(const CvArr*, CvScalar*, CvScalar*, const void*)", "cv::TlsAbstraction::TlsAbstraction()", "cv::TlsAbstraction::~TlsAbstraction()", "void cv::TlsAbstraction::SetData(void*)", "virtual cv::TLSDataContainer::~TLSDataContainer()", "void cv::TlsStorage::releaseSlot(size_t, std::vector<void*>&)", "void cv::TlsStorage::gather(size_t, std::vector<void*>&)", "void cv::TlsStorage::setData(size_t, void*)", "void* cv::TlsStorage::getData(size_t) const", "N2cv9ExceptionE", "N2cv16TLSDataContainerE", "void cv::setSize(cv::UMat&, int, const int*, const size_t*, bool)", "void cv::UMat::create(int, const int*, int, cv::UMatUsageFlags)", "cv::UMat::UMat(const cv::UMat&, const Rect&)", "cv::UMat cv::Mat::getUMat(int, cv::UMatUsageFlags) const", "cv::UMat::UMat(const cv::UMat&, const cv::Range*)", "cv::UMat cv::UMat::diag(int) const", "void cv::UMat::locateROI(cv::Size&, cv::Point&) const", "cv::UMat& cv::UMat::adjustROI(int, int, int, int)", "cv::UMat cv::UMat::reshape(int, int) const", "cv::Mat cv::UMat::getMat(int) const", "void* cv::UMat::handle(int) const", "void cv::UMat::copyTo(cv::OutputArray) const", "static cv::UMat cv::UMat::diag(const cv::UMat&)", "double cv::UMat::dot(cv::InputArray) const", "cv::UMat::UMat(const cv::UMat&, const cv::Range&, const cv::Range&)", "cv::UMat cv::UMat::reshape(int, int, const int*) const", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const Scalar&) [with CastOp = cv::FixedPtCast<int, unsigned char, 15>; VecOp = cv::RemapNoVec; AT = short int; cv::Scalar = cv::Scalar_<double>]", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const Scalar&) [with CastOp = cv::Cast<float, short unsigned int>; VecOp = cv::RemapNoVec; AT = float; cv::Scalar = cv::Scalar_<double>]", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const Scalar&) [with CastOp = cv::Cast<float, short int>; VecOp = cv::RemapNoVec; AT = float; cv::Scalar = cv::Scalar_<double>]", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const Scalar&) [with CastOp = cv::Cast<float, float>; VecOp = cv::RemapNoVec; AT = float; cv::Scalar = cv::Scalar_<double>]", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, const void*, int, const Scalar&) [with CastOp = cv::Cast<double, double>; VecOp = cv::RemapNoVec; AT = float; cv::Scalar = cv::Scalar_<double>]", "cv::Mat::Mat(int, int, int, void*, size_t)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<unsigned char, int, short int, 2048, cv::HResizeNoVec>; VResize = cv::VResizeLinear<unsigned char, int, short int, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = short int; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<short unsigned int, float, float, 1, cv::HResizeNoVec>; VResize = cv::VResizeLinear<short unsigned int, float, float, cv::Cast<float, short unsigned int>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<short int, float, float, 1, cv::HResizeNoVec>; VResize = cv::VResizeLinear<short int, float, float, cv::Cast<float, short int>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<float, float, float, 1, cv::HResizeNoVec>; VResize = cv::VResizeLinear<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<double, double, float, 1, cv::HResizeNoVec>; VResize = cv::VResizeLinear<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<unsigned char, int, short int>; VResize = cv::VResizeCubic<unsigned char, int, short int, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = short int; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<short unsigned int, float, float>; VResize = cv::VResizeCubic<short unsigned int, float, float, cv::Cast<float, short unsigned int>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<short int, float, float>; VResize = cv::VResizeCubic<short int, float, float, cv::Cast<float, short int>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<float, float, float>; VResize = cv::VResizeCubic<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<double, double, float>; VResize = cv::VResizeCubic<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<unsigned char, int, short int>; VResize = cv::VResizeLanczos4<unsigned char, int, short int, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = short int; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<short unsigned int, float, float>; VResize = cv::VResizeLanczos4<short unsigned int, float, float, cv::Cast<float, short unsigned int>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<short int, float, float>; VResize = cv::VResizeLanczos4<short int, float, float, cv::Cast<float, short int>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<float, float, float>; VResize = cv::VResizeLanczos4<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, const int*, const int*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<double, double, float>; VResize = cv::VResizeLanczos4<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>; cv::resizeGeneric_Invoker<HResize, VResize>::AT = float; cv::Size = cv::Size_<int>]", "void cv::convertMaps(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, int, bool)", "void cv::invertAffineTransform(cv::InputArray, cv::OutputArray)", "cv::Mat cv::getPerspectiveTransform(cv::InputArray, cv::InputArray)", "cv::Mat cv::getAffineTransform(cv::InputArray, cv::InputArray)", "CvMat* cv2DRotationMatrix(CvPoint2D32f, double, double, CvMat*)", "CvMat* cvGetPerspectiveTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)", "CvMat* cvGetAffineTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)", "cv::Mat::Mat(cv::Size, int, void*, size_t)", "void cv::warpPerspective(cv::InputArray, cv::OutputArray, cv::InputArray, cv::Size, int, int, const Scalar&)", "void cvWarpPerspective(const CvArr*, CvArr*, const CvMat*, int, CvScalar)", "const void* cv::initInterTab2D(int, bool)", "void cv::initInterTab1D(int, float*, int)", "void cv::remap(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, int, int, const Scalar&)", "void cvRemap(const CvArr*, CvArr*, const CvArr*, const CvArr*, int, CvScalar)", "void cv::warpAffine(cv::InputArray, cv::OutputArray, cv::InputArray, cv::Size, int, int, const Scalar&)", "void cvWarpAffine(const CvArr*, CvArr*, const CvMat*, int, CvScalar)", "void cv::resize(cv::InputArray, cv::OutputArray, cv::Size, double, double, int)", "void cvResize(const CvArr*, CvArr*, int)", "void cvLinearPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)", "void cvLogPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)", "int cv::ResizeAreaFastVec<T, SIMDVecOp>::operator()(const T*, T*, int) const [with T = short int; SIMDVecOp = cv::ResizeAreaFastNoVec<short int, short int>]", "int cv::ResizeAreaFastVec<T, SIMDVecOp>::operator()(const T*, T*, int) const [with T = short unsigned int; SIMDVecOp = cv::ResizeAreaFastNoVec<short unsigned int, short unsigned int>]", "int cv::ResizeAreaFastVec<T, SIMDVecOp>::operator()(const T*, T*, int) const [with T = unsigned char; SIMDVecOp = cv::ResizeAreaFastNoVec<unsigned char, unsigned char>]"], "stringidentifiers": ["ranges", "vector::_M_default_append", "OPENCV_TEMP_PATH", "status", "error", "Backtrace", "vector::reserve", "vector::_M_emplace_back_aux", "allocated", "N2cv5MatOpE", "N2cv14MatOp_IdentityE", "N2cv11MatOp_AddExE", "N2cv9MatOp_BinE", "N2cv9MatOp_CmpE", "N2cv10MatOp_GEMME", "N2cv12MatOp_InvertE", "N2cv7MatOp_TE", "N2cv11MatOp_SolveE", "N2cv17MatOp_InitializerE", "N2cv20BufferPoolControllerE", "N2cv25DummyBufferPoolControllerE", "N2cv15StdMatAllocatorE", "N2cv12MatAllocatorE", "N2cv9ExceptionE", "N2cv16TLSDataContainerE"], "debugstrings": ["GCC: (GNU) 4.9.x 20150123 (prerelease)"], "localsymbols": [""], "dependencies": ["liblog.so", "libdl.so", "libstdc++.so", "libm.so", "libgnustl_shared.so", "libc.so"], "elfname": "libopencv.so"}