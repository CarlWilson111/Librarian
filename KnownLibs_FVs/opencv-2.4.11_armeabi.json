{"globalvars": ["_ZTVN2cv8HOGCacheE", "_ZN2cv3ocl26arithm_absdiff_nonsaturateE", "clCreateSubBuffer_pfn", "_ZN2cv15BriskScaleSpace10basicSize_E", "_ZTIN2cv2EME", "_ZTCN2cv12StarDetectorE0_NS_15FeatureDetectorE", "_ZTSN7testing8internal17TestEventRepeaterE", "_ZTIN2cv19FastFeatureDetectorE", "_ZN2gl20GetUniformBlockIndexE", "_ZTVN2cv8superres15SuperResolutionE", "_TIFFwarningHandler", "_ZN2cv3ocl6device3hog15cblock_stride_xE", "_ZN2cv3ocl13imgproc_remapE", "_ZTVN2cv23BackgroundSubtractorGMGE", "_ZN7testing35FLAGS_gtest_also_run_disabled_testsE", "_ZTIN10__cxxabiv121__vmi_class_type_infoE", "_ZTCN2cv29PyramidAdaptedFeatureDetectorE0_NS_15FeatureDetectorE", "_ZN2gl19GetTexParameterIuivE", "_ZTSN2cv6detail15GainCompensatorE", "_ZN2cv11copyMaskTabE", "_ZN2gl14TexParameterivE", "_ZN2gl17GetAttribLocationE", "_ZTSN2cv17SelfSimDescriptorE", "_ZTVN2cv9videostab17TwoPassStabilizerE", "_ZN2gl12ClearStencilE", "_ZTSN7testing8UnitTestE", "_ZN2gl35GetFramebufferAttachmentParameterivE", "_ZTIN2cv20DenseFeatureDetectorE", "clCreateContextFromType_pfn", "_ZTI15CvOpenGlFuncTab", "_ZTIN3Imf13PizCompressorE", "_ZN2gl19GetFragDataLocationE", "_ZN7testing8internal18g_init_gtest_countE", "_ZTVN2cv4MSERE", "_ZTSN10__cxxabiv116__enum_type_infoE", "_ZTSN7testing8internal24HasNewFatalFailureHelperE", "_ZTSN3Imf11StdOFStreamE", "_ZN2cv3ocl21arithm_minMaxLoc_maskE", "_ZTCN2cv19FastFeatureDetectorE0_NS_15FeatureDetectorE", "_ZTSN2cv12HOGEvaluatorE", "_ZTSN2cv6detail23SphericalPortraitWarperE", "_ZN2cv3ocl21imgproc_copymakeboderE", "_ZN2gl18UniformMatrix4x3fvE", "_ZTS23CvNormalBayesClassifier", "_ZTIN2cv6detail15GainCompensatorE", "jpeg_std_message_table", "clEnqueueUnmapMemObject_pfn", "clGetProgramBuildInfo_pfn", "_ZTVN2cv24GenericDescriptorMatcherE", "_ZN2gl10Uniform2fvE", "_ZTVN2cv9videostab17OnePassStabilizerE", "clReleaseContext_pfn", "_ZTIN7testing32ScopedFakeTestPartResultReporterE", "_ZN2cv3ocl22arithm_add_scalar_maskE", "_ZTIN3Imf13RleCompressorE", "_ZTVN3Imf11StdOFStreamE", "_ZTSN2cv12MatOp_InvertE", "_ZN2gl9FrontFaceE", "_ZTVN2cv10PngDecoderE", "_ZN6cvtest2tsE", "_ZN2gl17VertexAttribI4usvE", "clCreateBuffer_pfn", "_ZN2gl17GetQueryObjectuivE", "_ZN22CameraWrapperConnector13pathLibFolderE", "clCreateSubDevices_pfn", "_ZTIN10__cxxabiv116__enum_type_infoE", "_ZTI10CvKNearest", "_ZN7testing18FLAGS_gtest_filterE", "clFinish_pfn", "_ZTV7CvDTree", "_ZN2gl22CheckFramebufferStatusE", "_ZTVN2cv12WMByteStreamE", "_ZTSN10__cxxabiv120__si_class_type_infoE", "_ZN7testing28FLAGS_gtest_break_on_failureE", "_ZTIN2cv5flann5IndexE", "_ZTSN2cv6OctreeE", "_ZN2gl12DeleteShaderE", "_ZTIN2cv25BOWImgDescriptorExtractorE", "jpc_mqctxs", "_ZN2gl16GetActiveUniformE", "_ZTSN2cv7MatOp_TE", "_ZN2gl23GetVertexAttribPointervE", "_ZTVN2cv12StarAdjusterE", "_ZTIN2cv14ChamferMatcher26SlidingWindowImageIteratorE", "_ZN2gl17CopyTexSubImage2DE", "_ZN2cv3ocl17brute_force_matchE", "_ZN2gl6FinishE", "_ZTIN2cv16FeatureEvaluatorE", "_ZTIN7testing8internal35DefaultGlobalTestPartResultReporterE", "_ZTVN10__cxxabiv115__forced_unwindE", "_ZTSN2cv9videostab16MotionFilterBaseE", "_ZTSN2cv9BFMatcherE", "_ZTS25CvBlobTrackPostProcKalman", "_ZN22CameraWrapperConnector17pApplyPropertiesCE", "_ZTSN4perf8TestBaseE", "_ZN2cv3ocl14imgproc_sobel3E", "_ZTCN2cv12StarAdjusterE0_NS_15FeatureDetectorE", "_ZTVN2cv15FeatureDetectorE", "_ZTSN2cv5FREAKE", "clEnqueueCopyBuffer_pfn", "_ZTIN2cv3ocl15CvSVMSolver_oclE", "_ZTSN3Imf17ScanLineInputFile4DataE", "_ZTI5RFace", "_ZTSN2cv10EigenfacesE", "_ZTVN2cv6detail17OrbFeaturesFinderE", "_ZTI16CvDTreeTrainData", "_ZTTN2cv29DynamicAdaptedFeatureDetectorE", "_ZTV21CvHomographyEstimator", "_ZTS21CvHomographyEstimator", "_ZTSN2cv16SunRasterDecoderE", "_ZTI8CvRTrees", "_ZTV8CvRTrees", "_ZTVN7testing8internal24XmlUnitTestResultPrinterE", "_ZTTN2cv32OpponentColorDescriptorExtractorE", "_ZTIN2cv10PngDecoderE", "_ZN2gl10Uniform1ivE", "_ZTI21CvHomographyEstimator", "_ZTSN2cv17MagnoRetinaFilterE", "_ZN2gl16PointParameterivE", "_ZN2gl13CreateProgramE", "_ZTSN2cv14MatOp_IdentityE", "_ZN2gl18UniformMatrix2x3fvE", "_ZN2cv3ocl12blend_linearE", "_ZTV5CvSVM", "_ZTVN2cv6detail21GraphCutSeamFinderGpuE", "_ZTSN3Imf13PizCompressorE", "_ZTVN2cv10PxMDecoderE", "_ZTVN2cv16ParallelLoopBodyE", "_ZN2gl12ShaderSourceE", "_ZTVN2cv9StereoVarE", "cblk", "_ZN7testing8internal18g_linked_ptr_mutexE", "_ZTIN2cv9videostab15MotionInpainterE", "_ZN2gl8ViewportE", "_ZN2gl9ColorMaskE", "_ZN2gl9Uniform2fE", "_ZN2cv7USE_AVXE", "_ZTVN2cv21FernDescriptorMatcherE", "_ZN2gl9TexBufferE", "_ZTTN2cv12SurfAdjusterE", "_ZTIN2cv9videostab27SparsePyrLkOptFlowEstimatorE", "_ZTVN7testing8internal38DefaultPerThreadTestPartResultReporterE", "clReleaseCommandQueue_pfn", "_ZN2cv3ocl6device3hog11qangle_typeE", "_ZTVN2cv11JpegDecoderE", "_ZTSN2cv13HOGDescriptorE", "_ZN2gl13BlendEquationE", "_ZN2cv3ocl18arithm_setidentityE", "_ZTVN2cv3ocl4MOG2E", "_ZN2cv3ocl6device3hog15cblock_stride_yE", "_ZTVN2cv26GridAdaptedFeatureDetectorE", "_ZTVN2cv23OneWayDescriptorMatcherE", "_ZTSSt13bad_exception", "_ZTS4Face", "_ZTIN2cv14MatOp_IdentityE", "_ZN2cv3ocl17imgproc_columnsumE", "_ZN2gl19StencilMaskSeparateE", "_ZN2gl17GetProgramInfoLogE", "_ZN2gl20CompressedTexImage2DE", "_ZTSN2cv11FisherfacesE", "_ZN2gl16VertexAttribI4svE", "_ZTIN2cv17ParvoRetinaFilterE", "_ZTIN2cv14FernClassifierE", "_ZN22CameraWrapperConnector16isConnectedToLibE", "_ZTSN2cv9videostab25ConsistentMosaicInpainterE", "_ZN2gl11Uniform1uivE", "_ZTIN2cv16GeneralizedHoughE", "_ZTS12FaceTemplate", "_ZTVN2cv6detail23SphericalPortraitWarperE", "_ZTVN2cv12HOGEvaluatorE", "_ZTSN2cv6RetinaE", "_ZN2cv3ocl15c_btvRegWeightsE", "_ZTS15CvOpenGlFuncTab", "_ZTSN2cv11TiffDecoderE", "_ZTIN2cv7linemod11DepthNormalE", "_ZTSN9IlmThread9SemaphoreE", "_ZN2gl16VertexAttribI4bvE", "_ZN2gl17BlendFuncSeparateE", "_ZTSN2cv12RMByteStreamE", "clEnqueueCopyBufferRect_pfn", "jpc_dec_mstab", "_ZTSN10__cxxabiv117__pbase_type_infoE", "_ZTV11CvBoostTree", "_ZTVN7testing8internal16ForkingDeathTestE", "_ZN22CameraWrapperConnector13pGetPropertyCE", "_ZN2gl16VertexAttribI2uiE", "_ZTVN2cv25BOWImgDescriptorExtractorE", "_ZN4perf8TestBase16timeLimitDefaultE", "_ZN2gl5OrthoE", "_ZN2gl10ClampColorE", "_ZN2gl16VertexAttribI1ivE", "_ZN2gl18DeleteVertexArraysE", "_ZN2cv3ocl20imgproc_integral_sumE", "_ZTS10CvKNearest", "_ZTIN2cv5FREAKE", "_ZN2gl15GenVertexArraysE", "_ZTSN7testing8internal35DefaultGlobalTestPartResultReporterE", "_ZN2cv3ocl5pyrlkE", "_ZN2gl14MapBufferRangeE", "_ZTS13CvFMEstimator", "_ZTI25CvBlobTrackPostProcKalman", "_ZTSN2cv3ocl3MOGE", "_ZTSN2cv11MatOp_AddExE", "clLinkProgram_pfn", "_ZN2gl20CompressedTexImage1DE", "_ZN2cv8USE_SSE2E", "_ZTSN2cv6detail17BundleAdjusterRayE", "_ZN2gl16VertexAttribI3ivE", "_ZN2gl15MultiDrawArraysE", "_ZTVN2cv12SurfAdjusterE", "hist_type", "_ZTVN3Imf15Pxr24CompressorE", "_ZTSN10__cxxabiv119__foreign_exceptionE", "clEnqueueFillImage_pfn", "_ZTSN2cv12FastAdjusterE", "_ZTSN2cv19DescriptorExtractorE", "_ZTVN2cv14ChamferMatcher26SlidingWindowImageIteratorE", "_ZTSN2cv9videostab17OnePassStabilizerE", "_ZTSN9IlmThread6ThreadE", "_ZTI13FaceDetection", "_ZTSN2cv4MSERE", "_ZTSN2cv10BOWTrainerE", "_ZN2gl21PrimitiveRestartIndexE", "_ZTIN2cv3ocl20BackgroundSubtractorE", "_ZTVN9IlmThread10ThreadPoolE", "_ZN2gl11GetBooleanvE", "_ZTI10CvVSModule", "_ZTSN7testing8internal13ExecDeathTestE", "_ZTI17CvERTreeTrainData", "_ZN2gl15PointParameterfE", "_ZN2gl16UniformMatrix2fvE", "clEnqueueReadBuffer_pfn", "_ZN2gl18GetTexParameterIivE", "_ZN2gl10ReadBufferE", "_ZTVN2cv3of29FabMapFBOE", "_ZN2gl25GetActiveUniformBlockNameE", "_ZTVN2cv11_InputArrayE", "_ZTVN4perf8TestBaseE", "_ZN8CvModule4lastE", "_ZN2gl10ReadPixelsE", "_ZTSN2cv3ocl9CvSVM_OCLE", "_ZTIN2cv12MatOp_InvertE", "_ZTIN2cv17SelfSimDescriptorE", "_ZTVN2cv6detail21BlocksGainCompensatorE", "_ZTVN2cv3of26FabMapE", "TIFFFaxBlackTable", "_ZN2cv5BRISK7scales_E", "_ZN2gl27GetTransformFeedbackVaryingE", "_ZTV16CvCapture_Images", "_ZTI17FaceDetectionList", "jpc_ft_qmfb2d", "_ZTSN2cv8superres11FrameSourceE", "_ZTIN2cv4MSERE", "_ZTVN2cv6detail18GraphCutSeamFinder4ImplE", "_ZTSN7testing4TestE", "_ZTVN2cv9ExceptionE", "_ZN2cv3ocl24kernel_stablesort_by_keyE", "clRetainEvent_pfn", "_ZN2cv3ocl10arithm_logE", "_ZTVN2cv20DenseFeatureDetectorE", "_ZTIN2cv9AlgorithmE", "_ZTVN2cv24BriefDescriptorExtractorE", "_ZTVN7testing8internal17TestEventRepeaterE", "_ZTV16CvDTreeTrainData", "_ZTV20CvBlobDetectorSimple", "_ZN2gl11GetShaderivE", "_ZTSN2cv16ParallelLoopBodyE", "_ZTSSt8bad_cast", "_ZTS17CvModelEstimator2", "_ZTIN2cv11FisherfacesE", "_ZN2gl11Uniform2uivE", "_ZN2cv3ocl6device3hog11cdescr_sizeE", "_ZTSN2cv6detail17OrbFeaturesFinderE", "_ZTSN6cvtest8BaseTestE", "_ZTSN2cv13BaseRowFilterE", "_ZTSN2cv32OpponentColorDescriptorExtractorE", "_ZTSN2cv10BmpDecoderE", "haar_type", "_ZTSN2cv3ocl17KNearestNeighbourE", "prgordtab", "_ZN2gl19UniformBlockBindingE", "clEnqueueFillBuffer_pfn", "_ZTS17MouthFaceTemplate", "_ZTVN2cv6detail18SurfFeaturesFinderE", "jp2_boxinfos", "jpc_ns_qmfb2d", "_ZTSN3Imf10OutputFile4DataE", "_ZN2gl19GetVertexAttribIuivE", "_ZN2gl14DeleteTexturesE", "_ZTIN4perf8TestBaseE", "_ZTVN2cv6detail7BlenderE", "_ZN4half5_eLutE", "_ZTVN2cv12RMByteStreamE", "_ZN2gl13DeleteProgramE", "_ZTIN2cv5BRISKE", "_ZTSN2cv17DescriptorMatcherE", "_ZTIN2cv10PxMDecoderE", "_ZTSN2cv6detail7BlenderE", "_ZTV17CvCapture_Android", "_ZTIN2cv12LBPEvaluatorE", "_ZTSN2cv13LevMarqSparseE", "_ZTIN2cv10ExrEncoderE", "_ZN2gl16VertexAttribI4ivE", "_ZTVN2cv2EME", "_ZN2gl17CopyTexSubImage3DE", "_ZN2cv3ocl8stereoBP13cl_con_structE", "_ZTVN2cv10ExrDecoderE", "_ZTIN3Imf15Pxr24CompressorE", "_ZTVN2cv10StereoSGBME", "_ZN2cv3ocl11ContextImpl14currentContextE", "_ZTIN2cv17DescriptorMatcherE", "_ZTSN2cv17MatOp_InitializerE", "clEnqueueCopyImage_pfn", "_ZTS5CvSVM", "_ZTSN9IlmThread4TaskE", "_ZTVN2cv17DescriptorMatcher20DescriptorCollectionE", "_ZN7testing8internal23kTestTypeIdInGoogleTestE", "_ZTSN2cv16GeneralizedHoughE", "_ZTSN2cv6detail21GraphCutSeamFinderGpuE", "_ZTVN2cv3ocl17KNearestNeighbourE", "clGetPlatformInfo_pfn", "_ZN6CvType5firstE", "_ZN2gl9LineWidthE", "_ZTVN6cvtest2TSE", "_ZTV5RFace", "_ZTSN2cv6detail20BundleAdjusterReprojE", "_ZTIN2cv14ChamferMatcher21LocationImageIteratorE", "_ZN2gl22BeginTransformFeedbackE", "clEnqueueTask_pfn", "clCreateSampler_pfn", "_ZTIN2cv11WBaseStreamE", "_ZTIN2cv11TiffDecoderE", "_ZTSN3Imf10CompressorE", "_ZN2gl13ClearBufferfiE", "_ZTSN2cv10PngDecoderE", "_ZN2cv3ocl24haarobjectdetect_scaled2E", "_ZN2gl17MultiDrawElementsE", "_ZN2cv3ocl12imgproc_gfttE", "_ZN2gl17CopyBufferSubDataE", "_ZTSN2cv11VideoWriterE", "_ZN2gl10GetDoublevE", "clCreateProgramWithBuiltInKernels_pfn", "_ZN2gl13TexParameteriE", "icv8x32fTab_cv", "_ZTV12CvForestTree", "_ZTS11CvSVMSolver", "clReleaseSampler_pfn", "_ZTVN2cv9videostab14ColorInpainterE", "_ZN2gl12DrawElementsE", "_ZN2gl10BufferDataE", "_ZTVN2cv9videostab21ColorAverageInpainterE", "_ZTSN2cv16BaseColumnFilterE", "_ZN2cv3ocl10arithm_expE", "decopts", "_ZN2gl10GenQueriesE", "_ZTTN2cv19FastFeatureDetectorE", "_ZN2gl13IsFramebufferE", "_ZTIN2cv20OneWayDescriptorBaseE", "_ZTVSt9exception", "_ZTI16CvBlobDetectorCC", "_ZTIN2cv16SunRasterDecoderE", "_ZTSN3Imf9InputFile4DataE", "_ZTIN2cv17MatOp_InitializerE", "_ZTVN2cv13Jpeg2KEncoderE", "_ZTV13FaceDetection", "_ZN2gl5FlushE", "_ZTSN3Imf15OpaqueAttributeE", "_ZTIN2cv9videostab20GaussianMotionFilterE", "_ZTSN3Imf14TiledInputFile4DataE", "_ZTVN2cv3ORBE", "_ZTVN2cv11FisherfacesE", "_ZTV13CvCalibFilter", "_ZTIN10__cxxabiv117__class_type_infoE", "_ZTIN10__cxxabiv123__fundamental_type_infoE", "_ZTVN2cv13LevMarqSparseE", "_ZTIN2cv16SunRasterEncoderE", "_ZTIN2cv13Jpeg2KEncoderE", "_ZN2cv16useOptimizedFlagE", "_ZTISt8bad_cast", "_ZTVN2cv9videostab27SparsePyrLkOptFlowEstimatorE", "_ZN2cv3ocl13objdetect_hogE", "_ZTSN2cv10BmpEncoderE", "_ZN2gl10Uniform4fvE", "_ZTSSt9bad_alloc", "_ZTIN3Imf7IStreamE", "_ZN2gl12ColorPointerE", "_ZTSN2cv10MatOp_GEMME", "_ZTIN3Imf9InputFile4DataE", "_ZTSSt9exception", "_ZTVN6cvtest8BaseTestE", "_ZN7cvflann20flann_distance_type_E", "_ZN2gl16TexParameterIuivE", "_ZTSSt10bad_typeid", "_ZN2gl25TransformFeedbackVaryingsE", "_ZTIN9IlmThread6ThreadE", "_ZN2cv3ocl9merge_matE", "clCreateImage2D_pfn", "_ZTSN2cv11JpegEncoderE", "clGetEventProfilingInfo_pfn", "_ZN2gl9DepthFuncE", "_ZN2gl9IsProgramE", "_ZTSN2cv12_OutputArrayE", "clEnqueueWaitForEvents_pfn", "_ZTVN7testing8internal13DeathTestImplE", "_ZN2gl9Uniform3fE", "_ZN22CameraWrapperConnector13pSetPropertyCE", "_ZTSN2cv29DynamicAdaptedFeatureDetectorE", "_ZN2cv3ocl11build_warpsE", "_ZTVN2cv6detail21BestOf2NearestMatcherE", "_ZTSN2cv9videostab27SparsePyrLkOptFlowEstimatorE", "_ZN2gl14ClearBufferuivE", "_ZTIN6cvtest8BaseTestE", "_ZN2gl11Uniform4uivE", "_ZN2gl17VertexAttribI4uivE", "clRetainProgram_pfn", "_ZTIN2cv6detail21GraphCutSeamFinderGpuE", "_ZTI11CvSVMKernel", "_ZTIN2cv12VideoCaptureE", "_ZTI23CvNormalBayesClassifier", "_ZTS21FaceDetectionListElem", "_ZTV17FaceDetectionList", "_ZN2cv3ocl23imgproc_warpPerspectiveE", "_ZTIN2cv19DescriptorExtractorE", "_ZTVN2cv3ocl15CvSVMSolver_oclE", "_ZTVN7testing8internal18OsStackTraceGetterE", "_ZN2gl10TexImage1DE", "jpc_zcctxnolut", "_ZN2cv3ocl18interpolate_framesE", "_ZN2cv3ocl10stereocsbpE", "_ZTV16CvBlobDetectorCC", "_ZTVN3Imf10OutputFile4DataE", "_ZTIN2cv12SurfAdjusterE", "_ZTVN3Imf9InputFileE", "_ZN2gl15GenFramebuffersE", "_ZN6CvType4lastE", "_ZN2gl20FramebufferTexture3DE", "_ZN2gl8IsBufferE", "_ZN2gl10DepthRangeE", "_ZTVN2cv12RLByteStreamE", "_ZTVN2cv29PyramidAdaptedFeatureDetectorE", "_ZN2gl7IsQueryE", "_ZTV9CvERTrees", "_ZN2gl22GetTexLevelParameterfvE", "seq_tree_type", "_ZTVN2cv17FlannBasedMatcherE", "_ZTVN2cv6detail16LKTrackerInvokerE", "_ZTSN2cv21ImageLogPolProjectionE", "_ZN2gl10Uniform3ivE", "_ZN2gl20BindFragDataLocationE", "_ZTSN2cv16BaseImageDecoderE", "_ZTIN2cv11TiffEncoderE", "_ZTI9CvGBTrees", "_ZTSN2cv5BRISKE", "_ZTI21FaceDetectionListElem", "_ZN7testing8internal35FLAGS_gtest_internal_run_death_testE", "_ZN2cv3ocl8stereobpE", "_ZN2gl20FramebufferTexture1DE", "_ZN2gl18DisableClientStateE", "_ZTSN3Imf17ScanLineInputFileE", "_ZTSN7testing8TestCaseE", "_ZTIN2cv6detail17OrbFeaturesFinderE", "_ZTSN2cv19FastFeatureDetectorE", "_ZN2gl17VertexAttribI1uivE", "_ZTVN2cv3of27FabMap2E", "_ZTSN6cvtest10BadArgTestE", "_ZTIN3Imf9InputFileE", "_ZTSN2cv14ChamferMatcher26LocationScaleImageIteratorE", "_ZTIN2cv17FlannBasedMatcherE", "_ZTVSt8bad_cast", "_ZTIN2cv22OneWayDescriptorObjectE", "_ZTSN2cv10ExrEncoderE", "_ZTIN2cv11MatOp_SolveE", "_ZN2cv3ocl15operator_setToME", "_ZTV7CvBoost", "_ZTVSt10bad_typeid", "_ZTSN2cv9MatOp_BinE", "_ZTVN2cv20OneWayDescriptorBaseE", "_ZTCN2cv32OpponentColorDescriptorExtractorE0_NS_19DescriptorExtractorE", "_ZN2cv3ocl17imgproc_thresholdE", "_ZTIN2cv6detail21BestOf2NearestMatcherE", "jpc_refnmsedec0", "_ZN2cv3ocl11convertC3C4E", "_ZTIN2cv9BFMatcherE", "_ZTVN2cv32OpponentColorDescriptorExtractorE", "_ZN2gl20EndConditionalRenderE", "_ZTSN9IlmThread5MutexE", "_ZN2cv5BRISK6n_rot_E", "_ZTVN3Imf13PizCompressorE", "_ZTSN2cv4LBPHE", "_ZN2gl18GetAttachedShadersE", "_ZTIN2cv10BaseFilterE", "_ZN2cv10USE_SSE4_2E", "_ZTSN2cv11RetinaColorE", "_ZN7testing29FLAGS_gtest_stack_trace_depthE", "_ZN2cv3ocl13_programCacheE", "_ZTVN2cv16SunRasterDecoderE", "_ZTS13CvBlobTracker", "_ZTVN7testing8UnitTestE", "_ZTIN2cv26GridAdaptedFeatureDetectorE", "_ZTIN3Imf10OutputFileE", "_ZN2cv3ocl19gDevMemTypeValueMapE", "_ZN2gl18DeleteFramebuffersE", "_ZTIN3Imf11StdIFStreamE", "_ZTVN2cv3ocl20BackgroundSubtractorE", "_ZTSN2cv14FaceRecognizerE", "_ZN7testing8internal18OsStackTraceGetter19kElidedFramesMarkerE", "_ZTIN2cv9videostab15VideoFileSourceE", "clCompileProgram_pfn", "_ZTIN2cv6OctreeE", "_ZTIN2cv6detail15SphericalWarperE", "_ZTSN2cv3ocl15CvSVMSolver_oclE", "TIFFFaxWhiteCodes", "clGetCommandQueueInfo_pfn", "_ZTVN9IlmThread9SemaphoreE", "_ZTSN2cv7linemod20ColorGradientPyramidE", "_ZTCN2cv12StarAdjusterE0_NS_15AdjusterAdapterE", "_ZTCN2cv3ORBE0_NS_9Feature2DE", "_ZTIN2cv16BOWKMeansTrainerE", "_ZTVN2cv9videostab15VideoFileSourceE", "_ZTVN2cv12WLByteStreamE", "clGetKernelInfo_pfn", "_ZN2cv3ocl16haarobjectdetectE", "_ZTIN2cv3of27FabMap1E", "_ZN7testing28FLAGS_gtest_throw_on_failureE", "_ZN2gl18BindAttribLocationE", "_ZTSN3Imf7OStreamE", "_ZTSN2cv9videostab18InpaintingPipelineE", "_ZTVN2cv25ForestTreeBestSplitFinderE", "clCreateImage_pfn", "_ZN2gl20CompressedTexImage3DE", "_ZN2gl15BindVertexArrayE", "_ZTSN2cv26GridAdaptedFeatureDetectorE", "_ZTTN2cv12FastAdjusterE", "_ZTVN3Iex7BaseExcE", "_ZTVN2cv17MatOp_InitializerE", "_ZTVN2cv5flann5IndexE", "_ZTV14CvBlobTrackSeq", "_ZTS12CvForestTree", "_ZN2cv3ocl12arithm_phaseE", "_ZN2gl9Uniform3iE", "_ZN2gl10BeginQueryE", "_ZTC14HarrisDetector0_N2cv12GFTTDetectorE", "_ZN2cv3ocl14arithm_bitwiseE", "_ZTS9CvANN_MLP", "_ZN2cv3ocl6device3hog17qangle_step_shiftE", "_ZTSN2cv6detail17VoronoiSeamFinderE", "_ZTVN2cv10BmpEncoderE", "clEnqueueWriteImage_pfn", "_ZTVN10__cxxabiv123__fundamental_type_infoE", "_ZN7testing22FLAGS_gtest_list_testsE", "_ZTSN10__cxxabiv115__forced_unwindE", "_ZTSN2cv14ChamferMatcher26SlidingWindowImageIteratorE", "_ZN2cv3ocl17imgproc_bilateralE", "_ZTVN2cv20PlanarObjectDetectorE", "clCreateImage3D_pfn", "_ZN2gl6EnableE", "_ZTSN2cv11RBaseStreamE", "clSetKernelArg_pfn", "_ZTIN7testing8internal17TestEventRepeaterE", "_ZTSN2cv6detail18GraphCutSeamFinder4ImplE", "_ZTVN2cv23VectorDescriptorMatcherE", "_ZN2cv3ocl18imgproc_warpAffineE", "_ZTVN3Imf9InputFile4DataE", "_ZTTN2cv12GFTTDetectorE", "_ZN2gl10DrawBufferE", "_ZN2cv3ocl28filtering_adaptive_bilateralE", "_ZN2gl11LinkProgramE", "_ZTS5RFace", "_ZTSN2cv12LBPEvaluatorE", "_ZTSN2cv9AlgorithmE", "_ZTVN2cv16GeneralizedHoughE", "_ZTVN7testing32ScopedFakeTestPartResultReporterE", "_ZTCN2cv18SimpleBlobDetectorE0_NS_15FeatureDetectorE", "_ZTIN2cv3of29FabMapLUTE", "_ZN2cv3ocl8bgfg_mogE", "_ZN2cv3ocl16arithm_transposeE", "_ZTCN2cv4MSERE0_NS_15FeatureDetectorE", "_ZN2gl15TexParameterIivE", "_ZN2gl17GetVertexAttribfvE", "_ZTSN7testing8internal13DeathTestImplE", "encopts", "_ZN2cv3ocl10arithm_powE", "_ZTVN2cv9videostab11LogToStdoutE", "_ZTVN2cv6detail16MultiBandBlenderE", "_ZTIN2cv20DTreeBestSplitFinderE", "_ZTI12CvForestTree", "_ZTSN2cv11JpegDecoderE", "_ZTVSt13bad_exception", "_ZTIN2cv12RLByteStreamE", "_ZTSN7testing32ScopedFakeTestPartResultReporterE", "_ZTSN2cv3ocl4MOG2E", "_ZTV21FaceDetectionListElem", "_ZTIN2cv16BaseImageDecoderE", "_ZTSN2cv9videostab26PyrLkRobustMotionEstimatorE", "_ZTIN10__cxxabiv119__foreign_exceptionE", "_ZN2gl11GenTexturesE", "_ZTVN2cv9videostab26PyrLkRobustMotionEstimatorE", "_ZN2cv3ocl12cl_constantsE", "_ZN2gl17GetTexParameterfvE", "_TIFFerrorHandler", "_ZTS17CvCamShiftTracker", "_ZTTN2cv19DescriptorExtractorE", "seq_graph_type", "_ZN2gl17GetVertexAttribdvE", "_ZN2gl15VertexAttribI4iE", "_ZTIN3Imf13ZipCompressorE", "_ZTVN2cv17Affine3DEstimatorE", "_ZTSN2cv21FernDescriptorMatcherE", "_ZN2cv3ocl13kmeans_kernelE", "_ZTI24CvBlobTrackPredictKalman", "_ZTSN2cv8superres15SuperResolutionE", "_ZTCN2cv20FastFeatureDetector2E0_NS_15FeatureDetectorE", "_ZTIN2cv5MatOpE", "_ZN2gl16UniformMatrix4fvE", "_ZN2gl11Uniform3uivE", "_ZN2gl13GetIntegeri_vE", "clGetEventInfo_pfn", "_ZN2cv3ocl18imgproc_calcHarrisE", "_ZTSN2cv6detail16MultiBandBlenderE", "_ZTVN2cv11TiffDecoderE", "jp2_boxinfo_unk", "_ZTIN2cv6detail16LKTrackerInvokerE", "_ZTS18CvBlobTrackerAuto1", "_ZTVN2cv14ChamferMatcher23SlidingWindowImageRangeE", "_ZTV8CvMLData", "_ZTIN2cv3of26FabMapE", "_ZTVN2cv7MatOp_TE", "_ZTVN2cv5BRISKE", "_ZTVN2cv12FastAdjusterE", "_ZTTN2cv12StarDetectorE", "_ZTCN2cv12GFTTDetectorE0_NS_15FeatureDetectorE", "_ZN4perf8TestBase22iterationsLimitDefaultE", "globaltime", "_ZTSN2cv7linemod13ColorGradientE", "_ZN7testing38FLAGS_gtest_show_internal_stack_framesE", "clEnqueueBarrier_pfn", "_ZTIN2cv10ExrDecoderE", "_ZTIN2cv9videostab11LogToStdoutE", "_ZTI17CvCamShiftTracker", "_ZTS20CvBlobDetectorSimple", "_ZTVN3Imf7OStreamE", "_ZTIN2cv14ChamferMatcher26LocationScaleImageIteratorE", "_ZTV23CvNormalBayesClassifier", "_ZTVN2cv6detail18GraphCutSeamFinderE", "_ZTSN7testing8internal24XmlUnitTestResultPrinterE", "_ZTIN2cv10StereoSGBME", "_ZTS16CvDTreeTrainData", "_ZN2cv3ocl14superres_btvl1E", "_ZTS13CvCalibFilter", "_ZTVN2cv20FastFeatureDetector2E", "_ZTSN7testing8internal38DefaultPerThreadTestPartResultReporterE", "_ZN2gl9Uniform4iE", "_ZTVN7testing8internal15NoExecDeathTestE", "_ZTSN2cv9videostab11LogToStdoutE", "_ZTVN3Imf17ScanLineInputFileE", "_ZTVN3Imf13RleCompressorE", "_ZTSN2cv6detail21BlocksGainCompensatorE", "_ZN2gl18GetVertexAttribIivE", "_ZTIN2cv11VideoWriterE", "_ZN14Tree_predictor8SumMutexE", "_ZN2gl16GetBufferSubDataE", "_ZTVN2cv14FernClassifierE", "_ZTSN2cv12StarAdjusterE", "_ZN2gl10Uniform2ivE", "_ZTSN2cv9ExceptionE", "_ZTIN2cv14ChamferMatcher23SlidingWindowImageRangeE", "_ZTSN22CvAdaptiveSkinDetector9HistogramE", "_ZTIN3Imf11StdOFStreamE", "_ZN2gl12AttachShaderE", "modetab", "_ZN7testing8internal17g_executable_pathE", "_ZTCN2cv5FREAKE0_NS_19DescriptorExtractorE", "_ZTV17MouthFaceTemplate", "_ZN2cv3ocl3svmE", "_ZN2gl9Uniform2iE", "_ZTC14HarrisDetector0_N2cv15FeatureDetectorE", "_ZTIN2cv3of27FabMap2E", "_ZN7testing22FLAGS_gtest_print_timeE", "_ZTVN2cv6detail12DpSeamFinderE", "_ZN2cv3ocl16arithm_magnitudeE", "_ZTIN2cv11RetinaColorE", "_ZN2gl15PointParameteriE", "_ZN2cv3ocl14imgproc_medianE", "_ZTIN2cv9MatOp_CmpE", "_ZTVN2cv4LBPHE", "_ZTIN2cv9StereoVarE", "_ZN2gl11PixelStorefE", "_ZTSN2cv23OneWayDescriptorMatcherE", "_ZN2gl8CullFaceE", "_ZTSN2cv10PngEncoderE", "ccblk", "_ZN2gl15GetActiveAttribE", "_ZTIN2cv13HaarEvaluatorE", "_ZTI14CvBlobTrackSeq", "_ZN2gl8EndQueryE", "_ZTS7CvBoost", "_ZTCN2cv12FastAdjusterE0_NS_15FeatureDetectorE", "_ZTV10CvKNearest", "_ZN2gl7DisableE", "_ZTSN2cv7linemod18DepthNormalPyramidE", "_ZTV17CvCamShiftTracker", "_ZTVN2cv10BmpDecoderE", "_ZTSN10__cxxabiv119__pointer_type_infoE", "_ZTV14CvForestERTree", "_ZTV11FaceFeature", "_ZN2gl11StencilFuncE", "_ZN2gl19StencilFuncSeparateE", "_ZTTN2cv20DenseFeatureDetectorE", "_ZN2gl7LogicOpE", "_ZTCN2cv12SurfAdjusterE0_NS_15FeatureDetectorE", "clRetainContext_pfn", "_ZN2gl9StencilOpE", "_ZN2gl11PolygonModeE", "clGetDeviceIDs_pfn", "_TIFFerrorHandlerExt", "_ZTVN2cv10MatOp_GEMME", "_ZN2gl4HintE", "_ZTVN10__cxxabiv119__pointer_type_infoE", "_ZN2gl10BlendColorE", "clBuildProgram_pfn", "_ZTV18CvBlobTrackerAuto1", "clGetSamplerInfo_pfn", "_ZN2cv3ocl8knearestE", "_ZTVN2cv6OctreeE", "_ZTI20CvBlobDetectorSimple", "_ZTI7CvDTree", "_ZN2gl17CopyTexSubImage1DE", "_ZN2gl15GetShaderSourceE", "_ZTS22CvAdaptiveSkinDetector", "_ZTSN2cv18SimpleBlobDetectorE", "_ZTIN7testing8internal18OsStackTraceGetterE", "_ZTIN7testing8internal23DefaultDeathTestFactoryE", "_ZTS8CvMLData", "_ZTIN2cv16BaseImageEncoderE", "_ZTSN2cv3of27FabMap1E", "_ZN2gl13GetUniformuivE", "_ZN2gl13VertexPointerE", "jpc_signmsedec", "_ZTVN3Imf13B44CompressorE", "_ZN2gl13TexSubImage2DE", "_ZTI12FaceTemplate", "_ZTSN2cv10PxMDecoderE", "_ZTTN2cv12StarAdjusterE", "_ZTCN2cv5BRISKE0_NS_15FeatureDetectorE", "_ZTSN2cv9videostab15VideoFileSourceE", "jpc_spblut", "_ZTSN2cv6detail15SphericalWarperE", "_ZN2cv5BRISK10basicSize_E", "_ZN2cv10g_8x32fTabE", "_ZN2gl17EnableClientStateE", "_ZTVN3Imf9AttributeE", "_ZN2cv3ocl14arithm_nonzeroE", "jpeg_natural_order", "_ZN2gl11GetTexImageE", "_ZTS14CvBlobTrackSeq", "_ZN2gl10TexImage2DE", "_ZN2gl7TexEnviE", "_ZTCN2cv3ORBE0_NS_15FeatureDetectorE", "_ZTSN2cv5flann5IndexE", "_ZTVN2cv5MatOpE", "_ZTS21DetectionBasedTracker", "_ZTVN3Imf14TiledInputFile4DataE", "_ZTVN7testing8TestCaseE", "_ZTIN2cv7MatOp_TE", "_ZN2cv3ocl12ProgramCache10mutexFilesE", "_ZTV4Face", "_ZTVN2cv3ocl9CvSVM_OCLE", "_ZTIN2cv9videostab17WeightingDeblurerE", "clGetSupportedImageFormats_pfn", "_ZTS14HarrisDetector", "_ZTS9CvERTrees", "_ZN2gl8DisableiE", "_ZN2gl17VertexAttribI2uivE", "_ZTSN7testing8internal18OsStackTraceGetterE", "_ZN2cv3ocl12gDeviceMemRWE", "_ZTTN2cv24BriefDescriptorExtractorE", "_ZTVN2cv17LatentSvmDetectorE", "_ZTVN7testing4TestE", "_ZTIN2cv20BackgroundSubtractorE", "_ZN2gl13DeleteQueriesE", "_ZTIN2cv8HOGCacheE", "_ZTSN2cv20BackgroundSubtractorE", "_ZTVN10__cxxabiv120__si_class_type_infoE", "_ZTIN3Imf17ScanLineInputFileE", "_ZN2cv15BriskScaleSpace13safetyFactor_E", "_ZN2gl8GetErrorE", "_ZTS14CameraActivity", "_ZTSN2cv6detail21BestOf2NearestMatcherE", "_ZN2gl23FramebufferRenderbufferE", "_ZTSN3Imf13ZipCompressorE", "_ZTSN2cv3of29FabMapLUTE", "_ZN2gl17StencilOpSeparateE", "image_type", "_ZN2gl13ActiveTextureE", "_ZTVN3Imf10OutputFileE", "_ZN2gl15g_initVariablesE", "_ZTIN2cv9MatOp_BinE", "_ZTSN2cv24GenericDescriptorMatcherE", "_ZTSN2cv3ORBE", "_ZTI17MouthFaceTemplate", "_ZTIN2cv12WLByteStreamE", "_ZTSN6cvtest9ArrayTestE", "_ZTVN9IlmThread6ThreadE", "_ZTIN2cv16ParallelLoopBodyE", "_ZN2gl9BlendFuncE", "_ZN2cv3ocl14operator_setToE", "_ZTSN2cv12VideoCaptureE", "clCreateKernelsInProgram_pfn", "jas_iccattrvalinfos", "_ZTSN2cv6detail12DpSeamFinderE", "_ZTVN2cv10PngEncoderE", "_ZN2gl21BlendEquationSeparateE", "TIFFFaxBlackCodes", "_ZTIN7testing8internal12UnitTestImplE", "_ZN2cv3ocl23imgproc_calcMinEigenValE", "_ZTIN2cv9videostab21ColorAverageInpainterE", "_ZN2gl11GetIntegervE", "_ZTVN2cv9videostab25ConsistentMosaicInpainterE", "_ZTSN2cv3of29FabMapFBOE", "_ZTVN7testing8internal27PrettyUnitTestResultPrinterE", "_ZN2gl9PointSizeE", "_ZN2cv15g_HersheyGlyphsE", "_ZTIN2cv17Affine3DEstimatorE", "_ZTIN2cv7linemod20ColorGradientPyramidE", "_ZTS24CvBlobTrackPredictKalman", "_ZN2cv3ocl8stereobmE", "_ZTVN2cv12_OutputArrayE", "_ZTSN2cv12FilterEngineE", "_ZTIN3Imf11StdOSStreamE", "_ZN2cv12g_Saturate8uE", "_ZTVN6cvtest10BadArgTestE", "_ZN2cv3ocl9cvt_colorE", "_ZTSN2cv25BOWImgDescriptorExtractorE", "_ZN2cv3ocl17imgproc_histogramE", "_ZTIN2cv25ForestTreeBestSplitFinderE", "_ZTVN10__cxxabiv117__class_type_infoE", "_ZTIN2cv18SimpleBlobDetectorE", "_ZN2gl16GetShaderInfoLogE", "_ZTIN2cv10BOWTrainerE", "_ZTIN2cv6detail21BlocksGainCompensatorE", "opencl_fn_ptrs", "TIFFFaxWhiteTable", "_ZN2cv3ocl9split_matE", "_ZTVN2cv6detail14FeatherBlenderE", "_ZTSN3Imf11StdIFStreamE", "_ZTISt13bad_exception", "_ZN2gl10Uniform4uiE", "_ZTIN2cv6detail14FeatherBlenderE", "_ZTSN2cv23BackgroundSubtractorMOGE", "_ZTSN2cv16SunRasterEncoderE", "_ZN2cv3ocl15filtering_morphE", "_ZTIN7testing8internal15NoExecDeathTestE", "jpc_ft_hpenergywts", "_ZN2gl13TexParameterfE", "opencl_fn_names", "_ZTVN2cv13HaarEvaluatorE", "_ZTSN2cv6detail18BundleAdjusterBaseE", "_ZN2gl15BlitFramebufferE", "_ZTSN10__cxxabiv117__class_type_infoE", "_ZTSN2cv6detail16LKTrackerInvokerE", "_ZTSN2cv14ChamferMatcher21LocationImageIteratorE", "_ZTV11CvSVMKernel", "_ZTS11FaceFeature", "_ZN2cv13g_8x16uSqrTabE", "_ZTV17CvERTreeTrainData", "_ZTV14CameraActivity", "_ZTVN2cv11TiffEncoderE", "clRetainDevice_pfn", "_ZTISt9bad_alloc", "_ZN2gl10ClearDepthE", "_ZN2cv3ocl16operator_copyToME", "_ZN2gl21DrawElementsInstancedE", "_ZTIN9IlmThread9SemaphoreE", "_ZTVN2cv9videostab16MotionFilterBaseE", "_ZN2gl16VertexAttribI1uiE", "_ZTI5CvSVM", "_ZN2gl16VertexAttribI4uiE", "_ZTSN2cv13HaarEvaluatorE", "_ZN4perf8TestBase15_timeadjustmentE", "_ZTSN6cvtest2TSE", "_ZN2gl13DeleteBuffersE", "_ZTI17CvCapture_Android", "_ZN2gl9GetFloatvE", "_ZN2gl20GetBufferParameterivE", "_ZTCN2cv5BRISKE0_NS_9Feature2DE", "_ZTIN2cv24BackgroundSubtractorMOG2E", "_ZTVN2cv10EigenfacesE", "_ZN2cv3ocl15btvWeights_sizeE", "_ZN2gl12CreateShaderE", "_ZTSN2cv20PlanarObjectDetectorE", "_ZN2cv3ocl16arithm_minMaxLocE", "_ZTIN7testing8internal16ForkingDeathTestE", "_ZN2gl10IsEnablediE", "_ZTVN2cv9MatOp_CmpE", "_ZTIN2cv6detail20BundleAdjusterReprojE", "_ZTIN7testing8UnitTestE", "_ZTVN22CvAdaptiveSkinDetector9HistogramE", "_ZN2cv3ocl14imgproc_resizeE", "_ZTSN2cv15FeatureDetectorE", "_ZTIN2cv6detail11PlaneWarperE", "_ZTVN2cv10ExrEncoderE", "clEnqueueCopyImageToBuffer_pfn", "_ZN2cv3ocl18arithm_addWeightedE", "_ZTIN3Iex7BaseExcE", "jpc_ns_lpenergywts", "_ZN2cv3ocl6device3hog13cdescr_heightE", "_ZTTN2cv5FREAKE", "_ZTVN3Imf13ZipCompressorE", "_ZTIN10__cxxabiv120__si_class_type_infoE", "clReleaseDevice_pfn", "_ZTVN2cv6detail15SphericalWarperE", "_ZTSN2cv14FernClassifierE", "clReleaseProgram_pfn", "_ZN2cv3ocl16imgproc_integralE", "_ZTIN2cv9videostab17OnePassStabilizerE", "_ZN2gl21GetCompressedTexImageE", "_ZTT14HarrisDetector", "_ZTSN2cv12StarDetectorE", "_ZN2cv3ocl24kernel_radix_sort_by_keyE", "_ZN2gl17VertexAttribI3uivE", "_ZTI21DetectionBasedTracker", "clGetContextInfo_pfn", "clEnqueueMarker_pfn", "_ZTSN3Imf13B44CompressorE", "_ZTSN7testing8internal23DefaultDeathTestFactoryE", "_ZTVN2cv6detail24HomographyBasedEstimatorE", "_ZTS17FaceDetectionList", "_ZN2gl17GetTexParameterivE", "_ZN2gl15BindBufferRangeE", "_ZN2gl20VertexAttribIPointerE", "_ZTIN2cv9videostab14ColorInpainterE", "_ZN2gl13PolygonOffsetE", "_ZTVN2cv16BaseColumnFilterE", "_ZTVN2cv6detail11PlaneWarperE", "_ZTIN2cv17CascadeClassifierE", "_ZTI11FaceFeature", "_ZTVN10__cxxabiv119__foreign_exceptionE", "_ZTIN2cv23BackgroundSubtractorGMGE", "_ZTI9CvERTrees", "_ZTVN2cv14MatOp_IdentityE", "icv8x32fSqrTab", "clEnqueueBarrierWithWaitList_pfn", "_ZTVN7testing8internal13ExecDeathTestE", "_ZN2gl9Uniform1fE", "_ZN2cv9pnpransac9PnPSolver9syncMutexE", "_ZTIN2cv6detail7BlenderE", "_ZTIN2cv11RBaseStreamE", "_ZTSN2cv3of27FabMap2E", "clEnqueueMigrateMemObjects_pfn", "_ZN2gl15VertexAttribI1iE", "_ZN2gl8IsShaderE", "_ZTIN2cv9videostab26PyrLkRobustMotionEstimatorE", "_ZTCN2cv5BRISKE4_NS_19DescriptorExtractorE", "_ZN2gl23CompressedTexSubImage1DE", "_ZTSN10__cxxabiv121__vmi_class_type_infoE", "_ZN2gl5ClearE", "_ZN2gl10Uniform3fvE", "_ZN2cv6Mesh3D7allzeroE", "_ZTIN2cv6detail18GraphCutSeamFinder4ImplE", "_ZTSN2cv3ocl20BackgroundSubtractorE", "_ZN2gl14SampleCoverageE", "clReleaseMemObject_pfn", "_ZTI14HarrisDetector", "_ZTVN2cv9MatOp_BinE", "_ZTVN2cv24BackgroundSubtractorMOG2E", "_ZN2gl9MapBufferE", "_ZTCN2cv20FastFeatureDetector2E0_NS_19FastFeatureDetectorE", "_ZN7testing18FLAGS_gtest_outputE", "_ZN2cv3ocl11btvWeights_E", "_ZTIN2cv6detail18GraphCutSeamFinderE", "_ZN7testing31FLAGS_gtest_death_test_use_forkE", "_ZTIN2cv17LatentSvmDetectorE", "_ZN4half8_toFloatE", "clFlush_pfn", "_ZN2gl9Uniform1iE", "_ZN2gl12GetUniformivE", "_ZTSN3Imf11StdOSStreamE", "_ZN2gl9IsTextureE", "_ZTVN2cv11VideoWriterE", "_ZN2cv3ocl13arithm_minMaxE", "_ZTCN2cv12FastAdjusterE0_NS_15AdjusterAdapterE", "_ZTIN2cv11MatOp_AddExE", "_ZN2cv3ocl14gDeviceMemTypeE", "_ZTVN2cv13BaseRowFilterE", "_ZTSN2cv12GFTTDetectorE", "clEnqueueNDRangeKernel_pfn", "_ZTSN2cv22OneWayDescriptorObjectE", "_ZN2gl19RenderbufferStorageE", "_ZTIN3Imf15OpaqueAttributeE", "_ZTIN2cv6detail18BundleAdjusterBaseE", "_ZTIN7testing8internal13ExecDeathTestE", "_ZN2gl15VertexAttribI2iE", "_ZTIN2cv3ocl9CvSVM_OCLE", "_ZN2gl13ClearBufferivE", "_ZTVN2cv3of213BOWMSCTrainerE", "_ZTIN2cv8superres11FrameSourceE", "_ZTVN2cv19FastFeatureDetectorE", "_ZTVN6cvtest9ArrayTestE", "_ZTIN2cv16BaseColumnFilterE", "_ZN2gl10ClearColorE", "_ZTIN2cv32OpponentColorDescriptorExtractorE", "_ZN2cv3ocl14filter_sep_colE", "_ZTV12FaceTemplate", "_ZN17CSMatrixGenerator9cs_phi_n_E", "_ZN22CameraWrapperConnector13pCloseCameraCE", "_ZTIN2cv3of29FabMapFBOE", "_ZTSN2cv13Jpeg2KDecoderE", "_ZN2gl10BindBufferE", "clGetPlatformIDs_pfn", "_ZTTN2cv20FastFeatureDetector2E", "_ZTVN2cv9videostab17WeightingDeblurerE", "_ZN17CSMatrixGenerator7cs_phi_E", "_ZTSN2cv12SurfAdjusterE", "_ZTSN3Imf10OutputFileE", "_ZTV10CvVSModule", "_ZN22CameraWrapperConnector12pInitCameraCE", "clGetKernelArgInfo_pfn", "_ZTTN2cv15FeatureDetectorE", "jpc_scctxnolut", "_ZTSN2cv6detail18PairwiseSeamFinderE", "_ZN2gl16UniformMatrix3fvE", "_ZTV25CvBlobTrackPostProcKalman", "_ZN2cv3ocl9meanShiftE", "_ZN2cv3ocl13imgproc_cannyE", "_ZN2cv3ocl22optical_flow_farnebackE", "_ZTIN6cvtest2TSE", "_ZTIN22CvAdaptiveSkinDetector9HistogramE", "_ZTVN2cv17ParvoRetinaFilterE", "_ZTVN2cv6detail18BundleAdjusterBaseE", "_ZN2gl22GetTexLevelParameterivE", "_ZTIN2cv10PxMEncoderE", "_ZTIN3Imf14TiledInputFile4DataE", "_ZN2gl19GetActiveUniformsivE", "_ZTVN3Imf17ScanLineInputFile4DataE", "_ZTSN2cv12WLByteStreamE", "_ZN10__cxxabiv120__unexpected_handlerE", "_ZTVN2cv7linemod13ColorGradientE", "_ZTVN7testing8internal12UnitTestImplE", "_ZTIN3Imf10OutputFile4DataE", "clEnqueueMarkerWithWaitList_pfn", "_ZN2gl17GetVertexAttribivE", "_ZTSN2cv11TiffEncoderE", "_ZN2gl13GetBooleani_vE", "clEnqueueMapBuffer_pfn", "_ZTSN2cv9MatOp_CmpE", "_ZTVN2cv9videostab18InpaintingPipelineE", "_ZTSN2cv7linemod11DepthNormalE", "_ZTSN2cv23BackgroundSubtractorGMGE", "_ZTIN2cv6detail12DpSeamFinderE", "_ZTIN2cv6detail23SphericalPortraitWarperE", "_ZTSN2cv5MatOpE", "matnd_type", "_ZTS11CvBoostTree", "_ZN2gl10ColorMaskiE", "_ZTSN10__cxxabiv123__fundamental_type_infoE", "_ZTSN2cv10PxMEncoderE", "_ZN2gl10Uniform3uiE", "_ZTV17CvModelEstimator2", "_ZTIN2cv6detail18PairwiseSeamFinderE", "_ZTIN2cv12WMByteStreamE", "_ZN2gl7Color3dE", "_ZTVN2cv11WBaseStreamE", "_ZTS8CvRTrees", "_ZTIN2cv7linemod13ColorGradientE", "_ZN7testing8internal9DeathTest24last_death_test_message_E", "_ZN2cv3ocl12ProgramCache10mutexCacheE", "_ZTIN2cv11JpegEncoderE", "_ZN2gl14CopyTexImage1DE", "_ZTVN2cv16BaseImageDecoderE", "_ZN2gl11DrawBuffersE", "_ZTSN2cv9videostab15MotionInpainterE", "_ZN10__cxxabiv119__terminate_handlerE", "_ZTVN2cv16FeatureEvaluatorE", "_ZN2gl10Uniform1uiE", "_ZSt7nothrow", "_ZTVN9IlmThread5MutexE", "_ZTSN9IlmThread10ThreadPoolE", "_ZN2gl20EndTransformFeedbackE", "_ZTVN7testing8internal23DefaultDeathTestFactoryE", "_ZTI16CvCapture_Images", "_ZTVN3Imf11StdIFStreamE", "_ZTI4Face", "_ZN2gl26GetRenderbufferParameterivE", "_ZTVN2cv5FREAKE", "clCreateContext_pfn", "_ZTS20CvVideoWriter_Images", "_ZTSN7testing8internal27PrettyUnitTestResultPrinterE", "_ZN2cv3ocl19commandQueueTLSDataE", "_ZN2gl17GetBufferPointervE", "clGetExtensionFunctionAddressForPlatform_pfn", "_ZTV22CvAdaptiveSkinDetector", "_ZTVN2cv14ChamferMatcher26LocationScaleImageIteratorE", "_ZTVN10__cxxabiv117__pbase_type_infoE", "_ZTIN2cv7linemod18DepthNormalPyramidE", "_ZTS11CvStatModel", "jas_iccprofdata_srgb", "_ZTVN2cv12VideoCaptureE", "_ZTSN2cv17LatentSvmDetectorE", "_ZN2cv3ocl6device3hog14cnblocks_win_xE", "_ZTI13CvFMEstimator", "_ZTIN2cv24BriefDescriptorExtractorE", "_ZTVN2cv10PxMEncoderE", "_ZTIN2cv9videostab18InpaintingPipelineE", "_ZTSN2cv11_InputArrayE", "_ZTIN2cv11_InputArrayE", "_ZN2cv3ocl6device3hog6cnbinsE", "_ZTSN2cv9videostab20GaussianMotionFilterE", "_ZTIN2cv9videostab17TwoPassStabilizerE", "_ZTVN2cv21ImageLogPolProjectionE", "_ZN2gl13ClearBufferfvE", "_ZTI22CvAdaptiveSkinDetector", "_ZN7testing8internal7g_argvsE", "_ZTSN2cv25ForestTreeBestSplitFinderE", "_ZTIN2cv12FastAdjusterE", "_ZTVN2cv12GFTTDetectorE", "clCreateProgramWithSource_pfn", "_ZN2cv21check_range_functionsE", "_ZN2cv3ocl18arithm_polarToCartE", "_ZTVN2cv11MatOp_AddExE", "_ZN2gl11GetPointervE", "_ZN2cv3ocl18kernel_sort_by_keyE", "_ZN7testing28FLAGS_gtest_stream_result_toE", "_ZN2cv3ocl31filtering_sep_filter_singlepassE", "_ZN2gl10UseProgramE", "clGetProgramInfo_pfn", "_ZTVN2cv14ChamferMatcher21LocationImageIteratorE", "_ZTVN2cv20DTreeBestSplitFinderE", "_ZTVN2cv8superres11FrameSourceE", "_ZN2gl30RenderbufferStorageMultisampleE", "_ZN7testing17FLAGS_gtest_colorE", "_ZTIN3Imf13B44CompressorE", "_ZTI18CvBlobTrackerAuto1", "_ZN2gl15VertexAttribI3iE", "_ZTVN2cv3of211ChowLiuTreeE", "_ZTVN2cv6detail17BundleAdjusterRayE", "_ZTIN2cv3ocl3MOGE", "_ZTV20CvVideoWriter_Images", "_ZTSN2cv2EME", "_ZTIN2cv9videostab25ConsistentMosaicInpainterE", "_ZTIN2cv20FastFeatureDetector2E", "clEnqueueWriteBufferRect_pfn", "_ZTSN2cv17CascadeClassifierE", "clEnqueueReadImage_pfn", "_ZTTN2cv18SimpleBlobDetectorE", "_ZTVN3Imf7IStreamE", "_ZN2cv3ocl14arithm_compareE", "_ZTSN2cv20DTreeBestSplitFinderE", "_ZTSN2cv16BOWKMeansTrainerE", "clWaitForEvents_pfn", "_ZTVN2cv6detail20BundleAdjusterReprojE", "_ZTVN2cv17CascadeClassifierE", "_ZTSN2cv16FeatureEvaluatorE", "_ZTIN7testing4TestE", "_ZTVN10__cxxabiv121__vmi_class_type_infoE", "_ZTI20CvVideoWriter_Images", "_ZTSN2cv6detail24HomographyBasedEstimatorE", "_ZTVN2cv12FilterEngineE", "_ZTSN21DetectionBasedTracker21SeparateDetectionWorkE", "_ZN2gl19VertexAttribPointerE", "_ZN2cv3ocl14filter_sep_rowE", "_ZTIN7testing8TestCaseE", "jas_iccprofdata_sgray", "_ZTSN2cv17DescriptorMatcher20DescriptorCollectionE", "_ZN2cv3ocl10arithm_addE", "_ZN2gl9DepthMaskE", "jpc_mqstates", "_ZN2cv3ocl16imgproc_convolveE", "_ZTIN2cv11FileStorageE", "clReleaseEvent_pfn", "_ZN2gl23CompressedTexSubImage2DE", "_ZN2cv3ocl18arithm_cartToPolarE", "_ZTI13CvBlobTracker", "_ZTIN3Imf9AttributeE", "_ZTVN7testing8internal24HasNewFatalFailureHelperE", "_ZTIN3Imf7OStreamE", "_ZTTN2cv4MSERE", "_ZN2cv3ocl11arithm_flipE", "_ZN2cv3ocl17arithm_add_scalarE", "_ZTIN2cv12_OutputArrayE", "_ZTS4CvEM", "_ZTSN2cv11FileStorageE", "_ZN2gl13TexSubImage1DE", "_ZN7testing28FLAGS_gtest_death_test_styleE", "_ZTSN2cv24BackgroundSubtractorMOG2E", "clEnqueueWriteBuffer_pfn", "clCreateUserEvent_pfn", "_ZTI8CvMLData", "_ZTV14HarrisDetector", "_ZTVN2cv11RetinaColorE", "_ZN2cv3ocl17gDevMemRWValueMapE", "_ZTSN2cv14ChamferMatcher23SlidingWindowImageRangeE", "_ZTV4CvEM", "_ZN2cv3ocl10arithm_sumE", "_ZN2gl16VertexAttribI2ivE", "clEnqueueNativeKernel_pfn", "_ZTS13FaceDetection", "clGetExtensionFunctionAddress_pfn", "_ZN7testing28FLAGS_gtest_catch_exceptionsE", "_ZTV9CvGBTrees", "_ZN2gl19DeleteRenderbuffersE", "_ZN2gl10GetStringiE", "_ZN2gl23CompressedTexSubImage3DE", "cxcore_module", "_ZTSN2cv17Affine3DEstimatorE", "jpc_ft_lpenergywts", "_ZN2gl16VertexAttribI3uiE", "_ZTIN2cv23BackgroundSubtractorMOGE", "_ZN2gl20GetActiveUniformNameE", "clSetEventCallback_pfn", "_ZN2gl14BindBufferBaseE", "_ZTVN2cv6detail17VoronoiSeamFinderE", "_ZTSN2cv24BriefDescriptorExtractorE", "_ZTVN2cv6detail18PairwiseSeamFinderE", "_ZTVN2cv17SelfSimDescriptorE", "_ZTI11CvStatModel", "_ZN2gl17GetUniformIndicesE", "_ZTCN2cv29DynamicAdaptedFeatureDetectorE0_NS_15FeatureDetectorE", "_ZN2gl9Uniform4fE", "_ZTSN2cv3of211ChowLiuTreeE", "_ZTIN2cv6RetinaE", "_ZTS17CvCapture_Android", "_ZN2gl13BufferSubDataE", "_ZN17CSMatrixGenerator9cs_phi_m_E", "_ZN2gl14CopyTexImage2DE", "_ZTI14CameraActivity", "_ZTVN2cv9videostab15MotionInpainterE", "_ZTIN2cv13Jpeg2KDecoderE", "_ZTVN2cv13Jpeg2KDecoderE", "_ZTSN2cv12WMByteStreamE", "_ZTIN3Imf17ScanLineInputFile4DataE", "_ZTSN2cv29PyramidAdaptedFeatureDetectorE", "_ZTVN2cv11JpegEncoderE", "_ZTIN7testing8internal24XmlUnitTestResultPrinterE", "_ZTI7CvBoost", "_ZTTN2cv26GridAdaptedFeatureDetectorE", "_ZN2cv3ocl6device3hog12cdescr_widthE", "_ZTIN2cv3ORBE", "clRetainMemObject_pfn", "_ZTVN2cv10BOWTrainerE", "_ZTIN2cv13LevMarqSparseE", "_ZTI11CvSVMSolver", "_ZTIN2cv24GenericDescriptorMatcherE", "TIFFFaxMainTable", "_ZN2gl16GenRenderbuffersE", "_ZTVN2cv22OneWayDescriptorObjectE", "_ZTVN2cv3of27FabMap1E", "_ZTSN2cv17ParvoRetinaFilterE", "_ZTIN2cv12StarDetectorE", "_ZTSN3Imf13RleCompressorE", "_ZTVN2cv7linemod18DepthNormalPyramidE", "clCreateCommandQueue_pfn", "_ZN2gl16GetQueryObjectivE", "_ZTSN2cv16BaseImageEncoderE", "_ZN2gl23EnableVertexAttribArrayE", "_TIFFBuiltinCODECS", "_ZTSN2cv10BaseFilterE", "_ZTIN2cv12RMByteStreamE", "_ZTSN7testing8internal12UnitTestImplE", "_ZTIN7testing8internal13DeathTestImplE", "_ZN2gl20FramebufferTexture2DE", "_ZN2cv3ocl15arithm_add_maskE", "_ZTIN6cvtest9ArrayTestE", "_ZTIN2cv14FaceRecognizerE", "clRetainSampler_pfn", "_ZTSN2cv11MatOp_SolveE", "_ZN2gl15ValidateProgramE", "_ZN2cv3ocl18filtering_filter2DE", "_ZN2cv3ocl6device3hog14cnblocks_win_yE", "_ZTVN2cv18SimpleBlobDetectorE", "_ZTIN21DetectionBasedTracker21SeparateDetectionWorkE", "_ZN2cv3ocl6device3hog16cblock_hist_sizeE", "_ZTI14CvForestERTree", "clUnloadCompiler_pfn", "_ZN2gl12GetUniformfvE", "_ZN7testing23FLAGS_gtest_random_seedE", "_ZTV9CvANN_MLP", "_ZN2cv3ocl18operator_convertToE", "clCreateKernel_pfn", "_ZN2gl23GetActiveUniformBlockivE", "_ZTV24CvBlobTrackPredictKalman", "_ZN2cv3ocl14match_templateE", "_ZTVN10__cxxabiv116__enum_type_infoE", "_ZTVN2cv9BFMatcherE", "_ZN2gl14IsRenderbufferE", "_ZTIN2cv12HOGEvaluatorE", "_ZTVN2cv11RBaseStreamE", "_ZN2gl18GetUniformLocationE", "clReleaseKernel_pfn", "_ZTIN2cv17DescriptorMatcher20DescriptorCollectionE", "_ZTIN2cv3ocl4MOG2E", "_ZN2gl14TexParameterfvE", "seq_type", "_ZTCN2cv20DenseFeatureDetectorE0_NS_15FeatureDetectorE", "_ZTIN2cv15FeatureDetectorE", "_ZTIN2cv21ImageLogPolProjectionE", "_ZN2gl8IndexubvE", "_ZTSN2cv6detail11PlaneWarperE", "_ZN2gl18UniformMatrix2x4fvE", "_ZTS16CvCapture_Images", "_ZTSN2cv13Jpeg2KEncoderE", "clRetainCommandQueue_pfn", "_ZTI11CvBoostTree", "clEnqueueReadBufferRect_pfn", "_ZTSN2cv9videostab17TwoPassStabilizerE", "_ZTCN2cv26GridAdaptedFeatureDetectorE0_NS_15FeatureDetectorE", "_ZTVN2cv13HOGDescriptorE", "_ZTI9CvANN_MLP", "_ZTSN2cv8HOGCacheE", "_ZTVN2cv12MatOp_InvertE", "_ZTV21DetectionBasedTracker", "_ZTIN2cv10BmpDecoderE", "_ZTV11CvSVMSolver", "_ZN2cv3ocl6pyr_upE", "_ZTIN2cv10BmpEncoderE", "_ZTISt9exception", "_ZTSN7testing8internal16ForkingDeathTestE", "_ZN2gl18UniformMatrix3x2fvE", "_ZTS7CvDTree", "_ZTSN2cv17FlannBasedMatcherE", "_ZTIN2cv17MagnoRetinaFilterE", "_ZTVN3Imf15OpaqueAttributeE", "jpc_refnmsedec", "_ZTVN2cv20BackgroundSubtractorE", "_ZN2gl13CompileShaderE", "_ZTSN2cv10ExrDecoderE", "_ZTTN2cv29PyramidAdaptedFeatureDetectorE", "_ZTIN7testing8internal24HasNewFatalFailureHelperE", "_ZTVN2cv11FileStorageE", "_ZN2cv3ocl8pyr_downE", "clCreateProgramWithBinary_pfn", "_ZTSN3Imf15Pxr24CompressorE", "_ZN2cv3ocl7momentsE", "_ZTIN2cv10MatOp_GEMME", "jpc_signmsedec0", "_ZTIN3Imf10CompressorE", "jas_iccprofdata_sgraylen", "_ZTSN2cv10StereoSGBME", "_ZN2gl16PointParameterfvE", "_ZN2gl22BeginConditionalRenderE", "_ZN2gl7ScissorE", "_ZTIN2cv10PngEncoderE", "clGetDeviceInfo_pfn", "_ZTV13CvFMEstimator", "_ZTVN2cv7linemod11DepthNormalE", "_ZTIN2cv9videostab16MotionFilterBaseE", "_ZN8CvModule5firstE", "_ZN2gl17DrawRangeElementsE", "_ZTSN2cv12RLByteStreamE", "clEnqueueMapImage_pfn", "_ZTSN2cv20FastFeatureDetector2E", "_ZTVN2cv6detail15GainCompensatorE", "_ZTVN2cv16BaseImageEncoderE", "_ZTVN2cv11MatOp_SolveE", "_ZTVN7testing8internal35DefaultGlobalTestPartResultReporterE", "_ZTIN9IlmThread10ThreadPoolE", "_ZN2gl11StencilMaskE", "_ZTIN3Imf14TiledInputFileE", "_ZN2gl23FramebufferTextureLayerE", "_ZTIN2cv8superres15SuperResolutionE", "_ZTVN2cv17MagnoRetinaFilterE", "_ZTSN2cv3of26FabMapE", "_ZTI17CvModelEstimator2", "_ZTVN2cv3ocl3MOGE", "_ZTSN3Imf7IStreamE", "_ZN2cv8hog_typeE", "_ZN2gl19DrawArraysInstancedE", "_ZTIN2cv3ocl17KNearestNeighbourE", "_ZN7testing19FLAGS_gtest_shuffleE", "_ZTVN2cv9videostab20GaussianMotionFilterE", "_ZTSN2cv6detail18GraphCutSeamFinderE", "clRetainKernel_pfn", "_ZTIN10__cxxabiv119__pointer_type_infoE", "_ZTVN2cv17DescriptorMatcherE", "_ZTVN2cv19DescriptorExtractorE", "_ZTIN2cv6detail24HomographyBasedEstimatorE", "_ZTVN9IlmThread4TaskE", "_ZN2gl10MatrixModeE", "mat_type", "_ZTSN7testing8internal15NoExecDeathTestE", "_ZN2gl13TexSubImage3DE", "_ZTVN3Imf10CompressorE", "clSetUserEventStatus_pfn", "_ZTIN2cv3of213BOWMSCTrainerE", "_ZTIN6cvtest10BadArgTestE", "_ZN2gl17VertexAttribI4ubvE", "_ZTSN2cv9videostab21ColorAverageInpainterE", "_ZN2cv3ocl4c_TBE", "_ZTSN2cv11WBaseStreamE", "_ZTIN9IlmThread4TaskE", "_ZTSN2cv6detail14FeatherBlenderE", "_ZTVN3Imf14TiledInputFileE", "_ZN7testing18FLAGS_gtest_repeatE", "jpc_ns_hpenergywts", "_ZTS10CvVSModule", "clUnloadPlatformCompiler_pfn", "_ZTTN2cv5BRISKE", "_ZN2gl9IsEnabledE", "_ZTS17CvERTreeTrainData", "_ZTSN2cv20DenseFeatureDetectorE", "_ZTIN2cv12GFTTDetectorE", "_ZTV11CvStatModel", "_ZTIN2cv6detail17VoronoiSeamFinderE", "_ZTIN2cv13HOGDescriptorE", "_ZTVN2cv3of29FabMapLUTE", "_ZTSN2cv23VectorDescriptorMatcherE", "_ZTIN2cv12StarAdjusterE", "_ZTIN2cv3of211ChowLiuTreeE", "_ZTCN2cv3ORBE4_NS_19DescriptorExtractorE", "_ZTIN9IlmThread5MutexE", "clEnqueueCopyBufferToImage_pfn", "_ZTTN2cv3ORBE", "_ZN2cv3ocl13imgproc_claheE", "_ZTS11CvSVMKernel", "_ZN2gl11UnmapBufferE", "_ZTIN2cv6detail17BundleAdjusterRayE", "_ZTIN2cv11JpegDecoderE", "_ZN2gl18UniformMatrix3x4fvE", "_ZTVN2cv23BackgroundSubtractorMOGE", "_ZN2gl10GenBuffersE", "jas_iccprofdata_srgblen", "_ZN2cv3ocl8tvl1flowE", "_ZTVN2cv12StarDetectorE", "_ZTIN10__cxxabiv117__pbase_type_infoE", "_ZN2gl10GetQueryivE", "_ZTIN2cv12FilterEngineE", "sparse_mat_type", "_ZN7testing8internal17kStackTraceMarkerE", "_ZTCN2cv12SurfAdjusterE0_NS_15AdjusterAdapterE", "_ZN2gl13NormalPointerE", "_ZN2gl10Uniform2uiE", "_ZN2gl16BindRenderbufferE", "_ZTIN2cv21FernDescriptorMatcherE", "_ZTVN2cv9AlgorithmE", "_ZN2cv5BRISK11scalerange_E", "_ZN2gl7EnableiE", "_ZTIN2cv13BaseRowFilterE", "_ZTIN2cv23VectorDescriptorMatcherE", "_ZTVN2cv10BaseFilterE", "_ZN2cv3ocl19filtering_boxFilterE", "_ZTIN2cv6detail16MultiBandBlenderE", "_ZTIN2cv29PyramidAdaptedFeatureDetectorE", "_ZN2gl7IndexubE", "_ZTIN2cv9ExceptionE", "_ZN2gl24DisableVertexAttribArrayE", "_ZTS9CvGBTrees", "_ZN2gl12LoadIdentityE", "_ZTSN3Imf9AttributeE", "clSetMemObjectDestructorCallback_pfn", "_ZTSN3Imf9InputFileE", "_ZN2gl10Uniform1fvE", "_ZTVN21DetectionBasedTracker21SeparateDetectionWorkE", "_ZN2gl15BindFramebufferE", "_ZTSN2cv3of213BOWMSCTrainerE", "_ZN2gl22FlushMappedBufferRangeE", "icvSaturate8u_cv", "_ZTVSt9bad_alloc", "_ZN2gl18UniformMatrix4x2fvE", "_ZTSN3Imf14TiledInputFileE", "_ZTSN2cv9videostab17WeightingDeblurerE", "_ZTI4CvEM", "_ZN2gl10Uniform4ivE", "_ZTVN2cv12LBPEvaluatorE", "clGetImageInfo_pfn", "_ZTIN7testing8internal27PrettyUnitTestResultPrinterE", "_ZTVN2cv16BOWKMeansTrainerE", "_ZTV13CvBlobTracker", "_ZTSN2cv9StereoVarE", "_ZTVN2cv7linemod20ColorGradientPyramidE", "_ZTIN2cv10EigenfacesE", "_ZTSN2cv20OneWayDescriptorBaseE", "_ZN2gl14GenerateMipmapE", "_ZTIN2cv23OneWayDescriptorMatcherE", "_ZN2gl15TexCoordPointerE", "_ZTSN3Iex7BaseExcE", "_ZTI13CvCalibFilter", "_ZTIN2cv29DynamicAdaptedFeatureDetectorE", "_ZN2gl10DrawArraysE", "_ZTVN2cv29DynamicAdaptedFeatureDetectorE", "_ZTVN2cv6RetinaE", "_ZTIN2cv20PlanarObjectDetectorE", "_TIFFwarningHandlerExt", "_ZTIN7testing8internal38DefaultPerThreadTestPartResultReporterE", "_ZN2gl12DetachShaderE", "_ZTIN2cv4LBPHE", "_ZTS14CvForestERTree", "jpc_magctxnolut", "_ZTISt10bad_typeid", "_ZTVN2cv16SunRasterEncoderE", "_ZN7testing8internal11g_help_flagE", "_ZN2cv3ocl10arithm_LUTE", "_ZTS16CvBlobDetectorCC", "_ZN2gl9GetStringE", "_ZN2gl13IsVertexArrayE", "clGetMemObjectInfo_pfn", "_ZN2gl11BindTextureE", "_ZTV15CvOpenGlFuncTab", "_ZTCN2cv24BriefDescriptorExtractorE0_NS_19DescriptorExtractorE", "_ZN2gl11PixelStoreiE", "clGetKernelWorkGroupInfo_pfn", "_ZN2gl12GetProgramivE", "_ZTSN2cv9videostab14ColorInpainterE", "_ZTVN2cv14FaceRecognizerE", "_ZTIN2cv6detail18SurfFeaturesFinderE", "_ZTVN3Imf11StdOSStreamE", "_ZTSN2cv6detail18SurfFeaturesFinderE", "_ZN7testing24FLAGS_gtest_param_filterE", "_ZTIN10__cxxabiv115__forced_unwindE", "_ZN2cv3ocl13depth_stringsE"], "importedglobals": ["_tolower_tab_", "_toupper_tab_", "environ", "__sF", "_ctype_"], "importedfunctions": ["btowc", "strcpy", "pthread_cond_broadcast", "pthread_key_create", "asin", "inflateInit_", "putwc", "longjmp", "towlower", "wcsftime", "snprintf", "fcntl", "strncmp", "tan", "strtoull", "pthread_create", "logf", "putchar", "memcmp", "connect", "mkstemp", "execve", "lrand48", "strncpy", "AndroidBitmap_getInfo", "fputs", "pthread_cond_signal", "free", "ungetwc", "lseek", "ungetc", "strstr", "__android_log_print", "memchr", "pthread_mutex_lock", "AndroidBitmap_unlockPixels", "floor", "dup", "hypot", "pthread_self", "cos", "crc32", "bsearch", "vfprintf", "gzopen", "atan", "iswctype", "readdir", "modf", "sem_trywait", "uncompress", "raise", "sem_wait", "inflateEnd", "closedir", "gettid", "close", "ioctl", "wcsxfrm", "fprintf", "mbrtowc", "strtol", "putc", "setlocale", "deflateInit_", "sinh", "waitpid", "clock_gettime", "log10", "wcsstr", "pipe", "sqrt", "wmemchr", "gai_strerror", "bsd_signal", "_exit", "deflateParams", "strcat", "pthread_once", "exit", "fseek", "wctype", "log", "strlen", "wmemmove", "fflush", "calloc", "sin", "fwrite", "printf", "open", "getwc", "vprintf", "write", "strftime", "time", "frexp", "pow", "sinf", "strtod", "ceilf", "unlink", "wmemset", "pthread_cond_wait", "atan2f", "gzclose", "strxfrm", "wcscmp", "strdup", "getcwd", "getaddrinfo", "strcmp", "localtime", "lrint", "deflateInit2_", "fstat", "compress", "memmove", "dladdr", "puts", "fputc", "munmap", "qsort", "sscanf", "rewind", "fopen", "syscall", "dup2", "pthread_join", "wmemcpy", "atoi", "strcasecmp", "opendir", "gzeof", "pthread_key_delete", "strchr", "cosh", "gmtime", "floorf", "sem_getvalue", "mkdir", "fgetc", "pthread_mutex_init", "pthread_mutex_destroy", "strerror", "gzputs", "clock", "inflateSync", "pthread_getspecific", "sem_post", "getc", "gzgets", "sqrtf", "wctob", "freeaddrinfo", "__errno", "cosf", "sprintf", "regfree", "pthread_mutex_trylock", "powf", "wcscoll", "fread", "ftell", "strcoll", "inflate", "memcpy", "pthread_cond_destroy", "fclose", "realloc", "acos", "regexec", "isatty", "acosf", "setjmp", "sem_init", "gzrewind", "regcomp", "towupper", "read", "socket", "AndroidBitmap_lockPixels", "sem_destroy", "atan2", "deflateEnd", "mmap", "strrchr", "pthread_mutex_unlock", "deflate", "fgets", "stat", "fdopen", "exp", "memset", "fork", "dlerror", "wcstombs", "vsprintf", "dlopen", "getenv", "mbstowcs", "strtok", "ceil", "inflateReset", "pthread_cond_init", "deflateReset", "remove", "malloc", "expf", "fscanf", "ctime", "dlsym", "vsnprintf", "wcslen", "gettimeofday", "sigaction", "abort", "chdir", "srand48", "tmpfile", "wcrtomb", "pthread_setspecific"], "exportedfunctions": ["png_set_error_fn", "_Z11_cvCalcEdgeP16CvVoronoiSiteIntP16CvVoronoiNodeIntP16CvVoronoiEdgeIntP19CvVoronoiDiagramInt", "Java_org_opencv_calib3d_Calib3d_findFundamentalMat_12", "png_write_iTXt", "_ZN2cv3ogl9Texture2D7releaseEv", "_ZN3Imf9InputFile10readPixelsEi", "Java_org_opencv_core_Mat_n_1isSubmatrix", "_ZN2cv3ocl21meanShiftSegmentationERKNS0_6oclMatERNS_3MatEiiiNS_12TermCriteriaE", "_ZNK2cv3ORB10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_ZNK7CvBoost10get_paramsEv", "_ZN6cvtest2TS14update_contextEPNS_8BaseTestEib", "cvGEMM", "_ZN2cv24BackgroundSubtractorMOG2C1Eifb", "_ZNK2cv3ORBclERKNS_11_InputArrayES3_RSt6vectorINS_8KeyPointESaIS5_EERKNS_12_OutputArrayEb", "png_get_channels", "cvEncodeImage", "png_set_keep_unknown_chunks", "_ZN2cv3ocl26BruteForceMatcher_OCL_base5clearEv", "_ZN3Imf8TimeCode11setUserDataEj", "_ZN14CameraActivity11getPropertyEi", "_ZN2cv9GlTextureC1ERKNS_11_InputArrayEb", "Java_org_opencv_core_Core_solve_10", "_ZN11CvSVMKernel9calc_polyEiiPPKfS1_Pf", "jas_image_sampcmpt", "_ZN2cv3ocl13HOGDescriptor22getPeopleDetector48x96Ev", "jpc_tagtree_dump", "_ZN4perf8TestBase10startTimerEv", "_ZN2cv15FeatureDetectorD2Ev", "Java_org_opencv_imgproc_Imgproc_blur_11", "_ZN2cv14RandomizedTree15savePosteriors2ESsb", "_ZN2cv10PCAComputeERKNS_11_InputArrayERKNS_12_OutputArrayES5_i", "_ZNK7CvDTree7predictEPK5CvMatS2_b", "_ZN7testing8internal14CmpHelperSTRNEEPKcS2_S2_S2_", "Java_org_opencv_ml_CvDTreeParams_set_1regression_1accuracy_10", "_ZNK7testing8internal8FilePath15RemoveExtensionEPKc", "_ZNK2cv8colormap8ColorMapclERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv3ocl12ProgramCache10addProgramERKSsP11_cl_program", "Java_org_opencv_imgproc_Imgproc_warpAffine_12", "cvChangeDetection", "_ZN2cv5writeERNS_11FileStorageERKSsRKSt6vectorINS_8KeyPointESaIS5_EE", "png_set_pCAL", "_ZN2cv22convertAndUnrollScalarERKNS_3MatEiPhj", "_ZN2cv9BFMatcher12knnMatchImplERKNS_3MatERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiRKS4_IS1_SaIS1_EEb", "_ZNK2cv13HOGDescriptor11getWinSigmaEv", "Java_org_opencv_imgproc_Imgproc_pyrUp_11", "Java_org_opencv_calib3d_Calib3d_reprojectImageTo3D_12", "Java_org_opencv_imgproc_Moments_set_1m20_10", "_ZN2cv11RNG_MT199377uniformEii", "_ZNK2cv14FernClassifier7getLeafEiRKNS_3MatE", "_ZNK2cv9MatOp_Bin6assignERKNS_7MatExprERNS_3MatEi", "_ZNK2cv3ocl6oclMat7reshapeEii", "_ZN2cv11FileStorage4openERKSsiS2_", "Java_org_opencv_core_Core_circle_12", "_ZN2cv21FernDescriptorMatcherD1Ev", "_ZN3Iex7BaseExcC2ERSt18basic_stringstreamIcSt11char_traitsIcESaIcEE", "_ZN13FaceDetection13CreateResultsEP5CvSeq", "jpc_mqdec_destroy", "cvCalcEigenObjects", "_ZNK3Imf8TimeCode7secondsEv", "_ZN7testing8internal18GetInjectableArgvsEv", "_ZN2cv3ocl13HOGDescriptor6detectERKNS0_6oclMatERSt6vectorINS_6Point_IiEESaIS7_EEdNS_5Size_IiEESC_", "png_handle_iTXt", "_ZN3Imf8TimeCode7setBgf2Eb", "TIFFRGBAImageEnd", "_ZN2cv10BOWTrainerD1Ev", "_ZNK3GMM14whichComponentEN2cv3VecIdLi3EEE", "_ZN2cv3ocl26BruteForceMatcher_OCL_base11radiusMatchERKNS0_6oclMatERSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEfRKS5_IS2_SaIS2_EEb", "_ZN13CvDTreeParamsC2EiifbiibbPKf", "_ZN3Imf9utcOffsetERKNS_6HeaderE", "_ZN4perf10Regression6verifyEN2cv8FileNodeERKNS1_11_InputArrayEdNS_10ERROR_TYPEE", "_ZN7testing8internal7PrintToEPKcPSo", "_ZN2cv15LogPolar_InterpD2Ev", "jas_image_encode", "_ZN2cv3LDA11reconstructERKNS_11_InputArrayE", "_ZN3Imf6Header5beginEv", "_ZNK7testing14KilledBySignalclEi", "_ZN3Imf10OutputFile4DataD1Ev", "_ZNK2cv14FernClassifierclERKNS_3MatENS_6Point_IfEERSt6vectorIfSaIfEE", "_ZThn4_NK2cv3ORB11computeImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZN2cv3of26FabMap8PzqGzpqLEibbb", "_ZN7testing8UnitTest3RunEv", "TIFFFindCODEC", "_ZN16EllipticKeyPointC1Ev", "_ZN2cv4LBPH4loadERKNS_11FileStorageE", "_ZTv0_n12_N2cv5FREAKD1Ev", "_ZNK3Imf11ChannelList6layersERSt3setISsSt4lessISsESaISsEE", "_ZTv0_n24_NK2cv3ORB4infoEv", "icvCreateConvertMatrVect", "Java_org_opencv_ml_CvDTreeParams_set_1use_11se_1rule_10", "_ZN2cv12WMByteStream7putWordEi", "_ZN2cv3ocl13HOGDescriptor14getDescriptorsERKNS0_6oclMatENS_5Size_IiEERS2_i", "_ZN3Imf16numLinesInBufferEPNS_10CompressorE", "__gnu_Unwind_Save_WMMXC", "_ZN13CvBlobTracker13GetConfidenceEiP6CvBlobP9_IplImageS3_", "png_handle_tIME", "_ZN2cv9videostab18FastMarchingMethod13heapRemoveMinEv", "_ZN8CvRTrees7get_rngEv", "png_set_write_status_fn", "_ZN2cv17SelfSimDescriptorC1ERKS0_", "_ZN2cv26createFisherFaceRecognizerEid", "_ZN2cv12LBPEvaluator7Feature4readERKNS_8FileNodeE", "_ZN2cv16CvFeatureTrackerD2Ev", "_ZNK2cv9LDetector15getMostStable2DERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EEiRKNS_14PatchGeneratorE", "_ZN17CvFuzzyControllerD1Ev", "jpeg_destroy", "_ZN2cv3MatC1EiPKiiPvPKj", "_ZN2cv3ocl24OpticalFlowDual_TVL1_OCL12procOneScaleERKNS0_6oclMatES4_RS2_S5_", "_ZN7testing8internal6Random8GenerateEj", "jpc_restore_t2state", "_ZN6cvtest14supportFeatureERKN2cv3gpu10DeviceInfoENS1_10FeatureSetE", "Java_org_opencv_ml_CvBoostParams_set_1weak_1count_10", "Java_org_opencv_ml_CvDTree_train_11", "_ZN2cv6KDTreeC1ERKNS_11_InputArrayEb", "_ZN2cv7linemod13ColorGradientC2Ev", "_ZN10__cxxabiv117__pbase_type_infoD1Ev", "_ZN3Imf10Compressor14uncompressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "cvGetSize", "cvInitFaceTracker", "_ZN6cvtest10BadArgTestD1Ev", "_ZN3Imf15Pxr24Compressor10uncompressEPKciiRS2_", "_ZN2cv10meanStdDevERKNS_11_InputArrayERKNS_12_OutputArrayES5_S2_", "_Z17cvTestSeqGetImagePv", "_ZN7testing8internal11CmpHelperGTEPKcS2_xx", "_ZN2cv19FastFeatureDetectorC1Eib", "_ZNK2cv7Momentscv9CvMomentsEv", "_ZN3Imf17timeCodeAttributeERKNS_6HeaderE", "_ZN2cv4flipERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN3Iex7BaseExcC2ERKS0_", "jas_tvparser_gettag", "cvFastArctan", "Java_org_opencv_imgproc_Imgproc_undistortPoints_11", "_Z29icvSingularValueDecompositioniiPdS_iS_iS_", "cvReleaseStructuringElement", "_ZNK14CameraActivity11isConnectedEv", "jpeg_set_defaults", "_TIFFgetMode", "cvPrevTreeNode", "_ZN2cv3of26FabMap7compareERKNS_3MatERKSt6vectorIS2_SaIS2_EERS5_INS0_6IMatchESaISA_EES4_", "icvStereoCalibration", "_ZN4perf8TestBase22getPerformanceStrategyEv", "_ZN2cv3ocl20FarnebackOpticalFlowclERKNS0_6oclMatES4_RS2_S5_", "Java_org_opencv_core_Mat_n_1depth", "_ZN16CvDTreeTrainDataC2EPK5CvMatiS2_S2_S2_S2_S2_RK13CvDTreeParamsbb", "_ZN2cv12VideoCapture3getEi", "_ZN4epnp19find_betas_approx_2EPK5CvMatS2_Pd", "_ZN2cv3ocl20BackgroundSubtractorD1Ev", "_ZN2cv21drawChessboardCornersERKNS_12_OutputArrayENS_5Size_IiEERKNS_11_InputArrayEb", "jpeg_CreateCompress", "_ZN2cv15NAryMatIterator4initEPPKNS_3MatEPS1_PPhi", "_ZN7testing8internal11ScopedTraceC1EPKciRKNS_7MessageE", "_ZN2cv12RetinaFilter19_setInitPeriodCountEv", "_ZN7testing8internal13CaptureStderrEv", "cvConvexityDefects", "_ZN7testing8UnitTest11GetInstanceEv", "png_convert_to_rfc1123", "Java_org_opencv_core_Core_convertScaleAbs_11", "_ZN2cv8GlArrays16setTexCoordArrayERKNS_11_InputArrayE", "_ZN2cv13BaseRowFilterD0Ev", "_ZNK2cv16BaseImageDecoder10newDecoderEv", "_ZN2cv20PlanarObjectDetectorD1Ev", "jpc_firstone", "_ZN3Imf14TypedAttributeINS_15TileDescriptionEE14staticTypeNameEv", "_ZN5CvSVM5trainERKN2cv3MatES3_S3_S3_11CvSVMParams", "Java_org_opencv_core_Core_PCACompute_11", "_ZN3Imf17timeCodeAttributeERNS_6HeaderE", "_ZN8CvMLDataD1Ev", "cvCreateTrackbar", "jpc_enc_tile_create", "_ZN10CvRTParamsC1EiifbiPKfbiifi", "_Z22Mat_to_vector_KeyPointRN2cv3MatERSt6vectorINS_8KeyPointESaIS3_EE", "jas_cleanup", "TIFFSetTagExtender", "_ZN2cv9Algorithm6setMatERKSsRKNS_3MatE", "_ZN7testing8TestInfoD2Ev", "_ZN2cv4gemmERKNS_11_InputArrayES2_dS2_dRKNS_12_OutputArrayEi", "_ZN2cv24GenericDescriptorMatcher18KeyPointCollectionC2ERKS1_", "_ZNK3Imf10OutputFile11frameBufferEv", "_ZN8CvMatrix5writeEP13CvFileStoragePKc", "png_destroy_info_struct", "_ZN21DetectionBasedTracker15InnerParametersC2Ev", "_ZN2cv17CascadeClassifier4loadERKSs", "jpc_ft_fwdlift_row", "_ZN2cv14ChamferMatcher8addMatchEfNS_6Point_IiEEPKNS0_8TemplateE", "_ZSt13set_terminatePFvvE", "_ZN2cv11_InputArrayC1ERKNS_3MatE", "_ZN2cv12RetinaFilter17runRGBToneMappingERKSt8valarrayIfERS2_bff", "png_write_tIME", "_ZNK2cv9SparseMatcvP11CvSparseMatEv", "_ZN7testing8internal8GTestLogC2ENS0_16GTestLogSeverityEPKci", "_ZN2cv16OneWayDescriptor13SetTransformsEPNS_12CvAffinePoseEPP5CvMat", "_ZN2cv6detail21GraphCutSeamFinderGpu4findERKSt6vectorINS_3MatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_", "_ZN6cvtest13MatComparatorC1Edi", "_ZN7testing8internal24HasNewFatalFailureHelperC1Ev", "_ZNK2cv14SpinImageModel16matchSpinToModelERKNS_3MatERSt6vectorIiSaIiEERS4_IfSaIfEEb", "png_set_bgr", "_Z28Mat_to_vector_vector_Point2fRN2cv3MatERSt6vectorIS2_INS_6Point_IfEESaIS4_EESaIS6_EE", "png_set_add_alpha", "jas_stream_copy", "_ZNK5Graph15doesVertexExistEj", "_ZN13FaceDetectionC1Ev", "_ZN6cvtest2TS6printfEiPKcz", "_ZN2cv11WBaseStreamD0Ev", "_ZN2cv3of26FabMapC1ERKNS_3MatEddii", "Java_org_opencv_ml_CvParamGrid_get_1step_10", "_ZN13CvCalibFilterC1Ev", "_ZN4perf10Regression12addKeypointsEPNS_8TestBaseERKSsRKSt6vectorIN2cv8KeyPointESaIS7_EEdNS_10ERROR_TYPEE", "TIFFGetMapFileProc", "_Unwind_VRS_Pop", "_ZN3Imf18longitudeAttributeERNS_6HeaderE", "__muldf3", "cvCbrt", "_Z5fft2dPfS_ii", "_ZN7testing8internal24XmlUnitTestResultPrinterC2EPKc", "png_set_tRNS", "_ZN11CvStatModelD1Ev", "__fixdfdi", "_Z22cvTestSeqGetObjectSizePviP12CvPoint2D32f", "_Z28vector_vector_Point3f_to_MatRSt6vectorIS_IN2cv7Point3_IfEESaIS2_EESaIS4_EERNS0_3MatE", "_ZN2cv7linemod18DepthNormalPyramidC2ERKNS_3MatES4_iiji", "Java_org_opencv_core_Core_PCAComputeVar_10", "_ZN2cv3of213BOWMSCTrainerD2Ev", "_ZN4epnpD2Ev", "_ZN17FaceDetectionListD2Ev", "_ZN2cv12_OutputArrayC2ERKNS_3ogl9Texture2DE", "_ZN2cv3ocl18meanShiftFilteringERKNS0_6oclMatERS1_iiNS_12TermCriteriaE", "_ZN10CvEMParamsC2Eiii14CvTermCriteriaPK5CvMatS3_S3_PS3_", "_ZN2cv3ocl26BruteForceMatcher_OCL_base14knnMatchSingleERKNS0_6oclMatES4_RS2_S5_S5_iS4_", "_ZNK7testing10TestResult16total_part_countEv", "cvDrawContours", "_ZN2cv7imwriteERKSsRKNS_11_InputArrayERKSt6vectorIiSaIiEE", "jpc_rct", "Java_org_opencv_imgproc_Imgproc_getAffineTransform_10", "_ZN3GMM9addSampleEiN2cv3VecIdLi3EEE", "_ZN7testing8internal7PrintToEPKwPSo", "_ZN2cv12RetinaFilter9runFilterERKSt8valarrayIfEbbbb", "_ZN12ocl_tvl1flow16centeredGradientERKN2cv3ocl6oclMatERS2_S5_", "jp2_cdef_lookup", "_ZN23CvNormalBayesClassifierC1EPK5CvMatS2_S2_S2_", "_ZN3Imf11hasXDensityERKNS_6HeaderE", "png_get_y_offset_inches", "_TIFFmemcpy", "_ZN4FaceC2EP12FaceTemplate", "jas_matrix_resize", "__gnu_Unwind_Restore_VFP_D", "_ZN3Imf15framesPerSecondERNS_6HeaderE", "Java_org_opencv_contrib_StereoVar_set_1poly_1sigma_10", "_ZN3Imf14TiledInputFileC1EPKci", "_ZN2cv11Fisherfaces5trainERKNS_11_InputArrayES3_", "jinit_memory_mgr", "cvRedirectError", "_ZN2cv6detail19createLaplacePyrGpuERKNS_3MatEiRSt6vectorIS1_SaIS1_EE", "_ZNK2cv5flann5Index11getDistanceEv", "_ZNK7testing10TestResult19test_property_countEv", "_ZN2cv5randuERKNS_12_OutputArrayERKNS_11_InputArrayES5_", "cvGetSeqElem", "_ZN10CvKNearestC1Ev", "Java_org_opencv_features2d_DescriptorMatcher_read_10", "_ZN2cv5flann17KDTreeIndexParamsC2Ei", "_ZN11CvFuzzyRuleD1Ev", "_ZN6cvtest3maxERKN2cv3MatES3_RS1_", "jpc_dec_lookahead", "_ZN7CvDTreeD1Ev", "_ZN7testing18TestEventListeners22SetDefaultXmlGeneratorEPNS_17TestEventListenerE", "_ZNK10CvKNearest9get_max_kEv", "_ZNK7testing8TestCase21successful_test_countEv", "_ZN2cv20OneWayDescriptorBase15InitializePosesEv", "_ZNK2cv16OneWayDescriptor15EstimatePosePCAEPvRiRfP5CvMatS5_", "_ZNK2cv13AlgorithmInfo4readEPNS_9AlgorithmERKNS_8FileNodeE", "_TIFFsetNString", "Java_org_opencv_video_Video_updateMotionHistory_10", "jpeg_set_marker_processor", "_ZN3Imf11floatToUintEf", "_ZN2cv3ocl23StereoBeliefPropagationC1Eiiiffffi", "_ZN2cv3PCAclERKNS_11_InputArrayES3_ii", "Java_org_opencv_objdetect_CascadeClassifier_detectMultiScale_13", "Java_org_opencv_highgui_VideoCapture_n_1getSupportedPreviewSizes", "_Z38DistanceTransformTwoDimensionalProblemPKfiiS0_PfPiS2_", "_Z10solve_deg3ddddRdS_S_", "_ZN2cv6Retina8getMagnoERSt8valarrayIfE", "_ZNK2cv2EM9isTrainedEv", "png_set_hIST", "_ZN2cv16SunRasterDecoderD0Ev", "png_set_sCAL_fixed", "icvGetCutPiece", "_ZN3Imf8TimeCodeC2ERKS0_", "Java_org_opencv_ml_CvANN_1MLP_create_10", "cvConvertScaleAbs", "_ZN2cv12KalmanFilter7correctERKNS_3MatE", "Java_org_opencv_core_Algorithm_setMat_10", "cvClipLine", "_ZN3Imf14TypedAttributeINS_8RationalEE14staticTypeNameEv", "_ZN3Imf11ChannelListixERKSs", "_ZN3Imf17ScanLineInputFile12rawPixelDataEiRPKcRi", "_ZN2cv9videostab17TwoPassStabilizer5setUpERNS_3MatE", "_ZNK3Imf11TileOffsets11isValidTileEiiii", "_ZN2cv11FileStorage19releaseAndGetStringEv", "_ZN2cv8internal6medianERKNS_3MatE", "png_set_sPLT", "_ZN2cv3ocl11bitwise_xorERKNS0_6oclMatES3_RS1_S3_", "_ZNK3Imf6Header9lineOrderEv", "TIFFStripSize", "_ZN2cv9videostab14StabilizerBase14stabilizeFrameERKNS_3MatE", "cvSet1D", "_ZNK3Imf14TiledInputFile10levelWidthEi", "_ZN2cv3of27FabMap1C2ERKNS_3MatEddii", "_ZNK2cv12_OutputArray6createENS_5Size_IiEEiibi", "Java_org_opencv_objdetect_HOGDescriptor_computeGradient_11", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRbbMS1_FivEMS1_FviERKSs", "cvSetTrackbarPos", "_ZN2cv18initCameraMatrix2DERKNS_11_InputArrayES2_NS_5Size_IiEEd", "_ZN9CvANN_MLP4readEP13CvFileStorageP10CvFileNode", "Java_org_opencv_imgproc_Imgproc_grabCut_11", "_ZN7testing11IsSubstringEPKcS1_RKSsS3_", "_ZN12CvForestTree15find_best_splitEP11CvDTreeNode", "png_do_quantize", "_ZN3Imf11FrameBuffer4findEPKc", "_ZN2cv20OneWayDescriptorBaseD2Ev", "_ZN6cvtest6getMatERKN2cv11_InputArrayE", "_ZN2cv3of29FabMapLUTC2ERKNS_3MatEddiii", "png_get_libpng_ver", "_ZN6cvtest7logicOpERKN2cv3MatES3_RS1_c", "_Z21icvBuildScanlineRightP9CvMatrix36CvSizePiS2_PfS2_", "_ZN2cv4normERKNS_11_InputArrayES2_iS2_", "_Z10solve_deg4dddddRdS_S_S_", "png_warning_parameter_unsigned", "_ZNK2cv11MatOp_AddEx3addERKNS_7MatExprERKNS_7Scalar_IdEERS1_", "Java_org_opencv_gpu_Gpu_printCudaDeviceInfo_10", "jpc_seglist_insert", "Java_org_opencv_gpu_DeviceInfo_sharedMemPerBlock_10", "_ZN2cv12_OutputArrayC1ERNS_3ogl9Texture2DE", "Java_org_opencv_imgproc_Subdiv2D_insert_10", "Java_org_opencv_video_Video_calcMotionGradient_11", "_ZN2cv3ocl26BruteForceMatcher_OCL_base17makeGpuCollectionERNS0_6oclMatES3_RKSt6vectorIS2_SaIS2_EE", "_Z23icvGetCrossEpilineFrame6CvSizePfPiS1_S1_S1_", "TIFFGetConfiguredCODECs", "png_do_packswap", "cvCreateSparseMat", "_ZN2cvngERKNS_3MatE", "_ZN2cv6Mesh3D11buildOctreeEv", "_ZN2cv23BackgroundSubtractorMOGclERKNS_11_InputArrayERKNS_12_OutputArrayEd", "_ZN2cv9GlTextureC2ENS_5Size_IiEEi", "_ZN2cv25getDefaultNewCameraMatrixERKNS_11_InputArrayENS_5Size_IiEEb", "_ZN2cv3ocl4flipERKNS0_6oclMatERS1_i", "Java_org_opencv_imgproc_Imgproc_integral3_11", "_ZN2cv3ocl15CvSVMSolver_ocl7get_rowEiPfRNS_3MatE", "_ZNK2cv20PlanarObjectDetectorclERKNS_3MatERS1_RSt6vectorINS_6Point_IfEESaIS7_EE", "_ZN2cv15BriskScaleSpace12getKeypointsEiRSt6vectorINS_8KeyPointESaIS2_EE", "Java_org_opencv_core_Core_max_10", "_ZN4perf8TestBase11getDataPathERKSs", "_ZN3Imf9multiViewERKNS_6HeaderE", "_ZN2cv6ScharrERKNS_11_InputArrayERKNS_12_OutputArrayEiiiddi", "Java_org_opencv_core_Mat_n_1diag__JI", "Java_org_opencv_imgproc_Subdiv2D_edgeOrg_11", "jpc_tagtree_setvalue", "_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EERS0_IiSaIiEEid", "_ZN2cv9crossCorrERKNS_3MatES2_RS0_NS_5Size_IiEEiNS_6Point_IiEEdi", "_ZN10CvVSModule11ParamUpdateEv", "_ZN2cv11RetinaColorD0Ev", "_Z28maxFunctionalScoreFixedLevelPPK18CvLSVMFilterObjectiPK20CvLSVMFeaturePyramidifiiPfPP7CvPointPiPS9_", "Java_org_opencv_core_Mat_nGetI", "_ZN2cv7linemod8Detector11addTemplateERKSt6vectorINS_3MatESaIS3_EERKSsRKS3_PNS_5Rect_IiEE", "_ZN3Imf17hasWhiteLuminanceERKNS_6HeaderE", "_ZNK11CvStatModel5writeEP13CvFileStoragePKc", "_ZNK2cv17LatentSvmDetector5emptyEv", "_ZNK3Imf6Header18hasTileDescriptionEv", "_ZN2cv7fisheye42estimateNewCameraMatrixForUndistortRectifyERKNS_11_InputArrayES3_RKNS_5Size_IiEES3_RKNS_12_OutputArrayEdS7_d", "_ZN4epnp28compute_A_and_b_gauss_newtonEPKdS1_S1_P5CvMatS3_", "png_XYZ_from_xy", "jpc_mqdec_setctxs", "_ZN10CvKNearestD0Ev", "png_do_gray_to_rgb", "cvCheckChessboard", "png_do_read_filler", "_ZNK3Imf14TiledInputFile9tileXSizeEv", "Java_org_opencv_calib3d_Calib3d_RQDecomp3x3_11", "_ZN11CvBoostTree13calc_node_dirEP11CvDTreeNode", "_ZN6cvtest2TSC2Ev", "cvUnDistortOnce", "_ZNK2cv11_InputArray12getGlTextureEv", "cvFilter2D", "png_get_y_pixels_per_inch", "cvCornerMinEigenVal", "_ZN2cv9AlgorithmD1Ev", "_ZN2cv8CamShiftERKNS_11_InputArrayERNS_5Rect_IiEENS_12TermCriteriaE", "_ZN2cv11RetinaColor27_getNormalizedContoursImageEPKfPf", "_ZN10CvKNearest5trainERKN2cv3MatES3_S3_bib", "_ZN6cvtest9getMaxValEi", "_ZN25CvBlobTrackPostProcKalman11ParamUpdateEv", "_ZN14CameraActivity14getFrameHeightEv", "_ZN2cv3ocl21StereoConstantSpaceBPC2Eiiiiffffii", "_ZN2cv3of27FabMap211addTrainingERKSt6vectorINS_3MatESaIS3_EE", "_ZN7testing8internal8FilePath11ConcatPathsERKS1_S3_", "_ZN8CvModuleD1Ev", "cvError", "_ZN7CvImage4showEPKc", "Java_org_opencv_video_BackgroundSubtractor_delete", "_Unwind_VRS_Get", "png_get_io_ptr", "jas_stream_setrwcount", "cvLatentSvmDetectObjects", "_TIFFsetShortArray", "_ZN2cv15convertScaleAbsERKNS_11_InputArrayERKNS_12_OutputArrayEdd", "_Z17cvWritebackLabelsPK5CvMatPS_S1_S2_S1_S2_S1_iS1_i", "_ZN2cv3ocl18openCLCreateBufferEPNS0_7ContextEjj", "_ZN2cv12RetinaFilterC1EjjbNS_26RETINA_COLORSAMPLINGMETHODEbdd", "cvNorm", "_ZThn324_N2cv9videostab17TwoPassStabilizer9nextFrameEv", "jpeg_idct_4x4", "_ZN2cv17adaptiveThresholdERKNS_11_InputArrayERKNS_12_OutputArrayEdiiid", "cvStartWriteStruct", "_ZN7testing8internal16WideStringToUtf8EPKwi", "_ZN2cv3PCAC2ERKNS_11_InputArrayES3_id", "_ZN2cv3ocl6oclMat5setToERKNS_7Scalar_IdEERKS1_", "_ZN2cv9videostab17WeightingDeblurerC1Ev", "Java_org_opencv_imgproc_Imgproc_initUndistortRectifyMap_10", "_ZN3Imf9InputFileC1EPKci", "_ZN13CvCalibFilterD0Ev", "Java_org_opencv_ml_CvBoostParams_CvBoostParams_10", "_ZN7testing8TestCaseD0Ev", "__gnu_Unwind_RaiseException", "cvClearGraph", "jas_stream_printf", "Java_org_opencv_ml_CvANN_1MLP_predict_10", "_ZN2cv23BackgroundSubtractorGMGD0Ev", "jas_stream_getc_func", "_Z17cvGetTrainSamplesPK5CvMatiS1_S1_PiS2_b", "cvCalcGlobalOrientation", "_ZN3Imf14TiledInputFileC1ERKNS_6HeaderEPNS_7IStreamEii", "cvEigenProjection", "_ZN2cv3ocl26BruteForceMatcher_OCL_base16knnMatch2ConvertERKNS_3MatES4_S4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "_ZNK3Imf6Header18screenWindowCenterEv", "_ZN7CvDTree5trainEP16CvDTreeTrainDataPK5CvMat", "_ZNK2cv12_OutputArray9getMatRefEi", "_ZN2cv13LevMarqSparseD2Ev", "png_read_update_info", "_ZN2cv17BasicRetinaFilter33_spatiotemporalLPfilter_IrregularEPKfPfj", "_ZNK2cv11Fisherfaces7predictERKNS_11_InputArrayE", "_ZN7CvBoost19update_weights_implEP11CvBoostTreePd", "_ZN2cv6detail26restoreImageFromLaplacePyrERSt6vectorINS_3MatESaIS2_EE", "_ZNK9IlmThread10ThreadPool10numThreadsEv", "Java_org_opencv_core_Core_fastAtan2_10", "_ZN9IlmThread4TaskC1EPNS_9TaskGroupE", "_ZNK3Imf11TileOffsetsclEiii", "jpc_qmfb_join_col", "_ZN4perf8TestBase15RunPerfTestBodyEv", "_ZN3GMMC1ERN2cv3MatE", "_ZN14CvForestERTree20find_split_cat_classEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN2cv20OneWayDescriptorBaseC2E6CvSizeiPKcS3_S3_S3_iii", "_ZN7testing8internal35DefaultGlobalTestPartResultReporter20ReportTestPartResultERKNS_14TestPartResultE", "_ZN2cv13LevMarqSparseC2EiiiiiRNS_3MatES2_S2_NS_12TermCriteriaEPFviiS2_S2_S2_S2_PvEPFviiS2_S2_S2_S4_ES4_PFbidS4_ES4_", "Java_org_opencv_calib3d_Calib3d_Rodrigues_10", "_ZN2cv17LogPolar_Adjacent11to_corticalERKNS_3MatE", "_ZN9IlmThread6ThreadD2Ev", "cvInitUndistortMap", "_ZN2cv16FileNodeIterator7readRawERKSsPhj", "_ZN2cv6OctreeD1Ev", "Java_org_opencv_imgproc_Subdiv2D_findNearest_11", "jas_image_copycmpt", "_ZN5CvSVM19optimize_linear_svmEv", "_ZNK3Imf7KeyCode11filmMfcCodeEv", "jpc_irct", "Java_org_opencv_ml_CvANN_1MLP_train_11", "_ZN2cv3ocl12StereoBM_OCLC1Ev", "cvSaveMemStoragePos", "_ZN2cv3ocl20FarnebackOpticalFlow21setGaussianBlurKernelEPKfi", "_ZN4perf8TestBase11warmup_implEN2cv3MatEi", "_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_9SparseMatERKNS_12_OutputArrayEPPKfdb", "_ZN2cv8GlCameraC1Ev", "_ZNK2cv8Subdiv2D8QuadEdge6isfreeEv", "_ZN2cv3ocl3powERKNS0_6oclMatEdRS1_", "jas_setdbglevel", "_ZN7testing8internal24ParseGoogleTestFlagsOnlyEPiPPw", "_ZNK3Imf11ChannelList15channelsInLayerERKSsRNS0_13ConstIteratorES4_", "_ZN2cv17DescriptorMatcherD0Ev", "_ZN2cv7linemod8DetectorC1ERKSt6vectorINS_3PtrINS0_8ModalityEEESaIS5_EERKS2_IiSaIiEE", "_ZNK2cv20OneWayDescriptorBase18SavePCADescriptorsEP13CvFileStorage", "_ZN2cv11WBaseStream4openERSt6vectorIhSaIhEE", "_TIFFNoTileEncode", "_Z23icvCvt_BGRA2RGBA_8u_C4RPKhiPhi6CvSize", "_ZN14CvBlobTrackSeq5ClearEv", "jpeg_stdio_src", "_ZN2cv8SVDecompERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_i", "png_set_palette_to_rgb", "_ZN2cv3ogl6Buffer14setAutoReleaseEb", "__gnu_Unwind_Save_VFP_D", "Java_org_opencv_calib3d_Calib3d_calibrationMatrixValues_10", "_TIFFNoSeek", "_ZN2cv3ocl26BruteForceMatcher_OCL_base8knnMatchERKNS0_6oclMatERSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEiRKS5_IS2_SaIS2_EEb", "_ZN2cv10BaseFilterD0Ev", "cvLinearContorModelFromVoronoiDiagram", "_ZN7testing8UnitTest13PopGTestTraceEv", "_ZN3Imf24framesPerSecondAttributeERKNS_6HeaderE", "_ZN2cv3ocl12KalmanFilter4initEiiii", "Java_org_opencv_imgproc_Imgproc_createHanningWindow_10", "png_get_text", "_ZNK2cv10PngEncoder17isFormatSupportedEi", "_ZN11FaceFeatureC1Ev", "Java_org_opencv_imgproc_Imgproc_undistortPoints_10", "_ZN2cv8GlArrays14setVertexArrayERKNS_11_InputArrayE", "Java_org_opencv_highgui_Highgui_imread_10", "Java_org_opencv_imgproc_Imgproc_moments_11", "_ZN9CvERTrees5trainEPK5CvMatiS2_S2_S2_S2_S2_10CvRTParams", "Java_org_opencv_core_Core_cartToPolar_11", "_ZNK7testing15AssertionResultntEv", "_ZN2cv25BOWImgDescriptorExtractorD2Ev", "_ZN2cv20BackgroundSubtractorD2Ev", "png_handle_zTXt", "_ZN7testing10TestResultC1Ev", "cvCreateSeq", "_ZN2cv3of27FabMap219getIndexLikelihoodsERKNS_3MatERSt6vectorIdSaIdEERSt3mapIiS5_IiSaIiEESt4lessIiESaISt4pairIKiSB_EEERS5_INS0_6IMatchESaISK_EE", "_ZN2cv5flann5IndexC1ERKNS_11_InputArrayERKNS0_11IndexParamsEN7cvflann16flann_distance_tE", "_ZN7CvBoost5clearEv", "_ZN2cv11mixChannelsERKSt6vectorINS_3MatESaIS1_EERS3_PKij", "Java_org_opencv_objdetect_HOGDescriptor_get_1gammaCorrection_10", "png_set_compression_strategy", "_ZN7testing8internal16ForkingDeathTestC1EPKcPKNS0_2REE", "_ZN2cv9SparseMat3Hdr5clearEv", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRNS_3PtrIS1_EEbMS1_FS6_vEMS1_FvRKS6_ERKSs", "_ZN2cv14RandomizedTree5trainERKSt6vectorINS_12BaseKeypointESaIS2_EERNS_3RNGEiiji", "Java_org_opencv_android_Utils_nMatToBitmap", "Java_org_opencv_core_Algorithm_setString_10", "cvRegisterModule", "_ZN14CameraActivity13onFrameBufferEPvi", "TIFFSetErrorHandlerExt", "_ZNK2cv9SparseMat6copyToERS0_", "_ZN2cv3ocl12KalmanFilterC1Eiiii", "Java_org_opencv_ml_CvParamGrid_CvParamGrid_10", "_ZN2cv3of211ChowLiuTree15extractChildrenERSt4listINS1_4infoESaIS3_EEi", "_ZN2cv8superres13convertToTypeERKNS_3ocl6oclMatEiRS2_S5_", "_ZN2cv10ExrEncoderD1Ev", "_ZN2cv21ImageLogPolProjectionC1EjjNS0_14PROJECTIONTYPEEb", "Java_org_opencv_imgproc_Imgproc_cornerMinEigenVal_11", "_ZNK3Imf13ZipCompressor12numScanLinesEv", "_ZN2cv5flann5IndexC2ERKNS_11_InputArrayERKNS0_11IndexParamsEN7cvflann16flann_distance_tE", "_ZN2cv8Subdiv2D8QuadEdgeC2Ev", "png_save_uint_16", "_ZN2cv15readPCAFeaturesERKNS_8FileNodeEPP5CvMatS5_PKc", "Java_org_opencv_imgproc_Imgproc_cvtColor_10", "_ZNK2cv12StarAdjuster5cloneEv", "_ZN2cv3ocl12morphologyExERKNS0_6oclMatERS1_iRKNS_3MatENS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZNK2cv17FlannBasedMatcher5writeERNS_11FileStorageE", "_ZN2cv16BaseColumnFilterD2Ev", "_ZN7CvDTree15split_node_dataEP11CvDTreeNode", "_ZN6cvtest2TS3ptrEv", "Java_org_opencv_features2d_GenericDescriptorMatcher_clone_10", "_ZN2cv7linemod13ColorGradientC1Ev", "cvBGCodeBookDiff", "jpc_pi_addpchg", "jas_image_addcmpt", "_ZN21CvANN_MLP_TrainParamsD2Ev", "_ZN2cv6detail18selectRandomSubsetEiiRSt6vectorIiSaIiEE", "_ZN3Imf11StdIFStream4readEPci", "Java_org_opencv_imgproc_Imgproc_HoughLinesP_10", "_ZN2cv3ocl11ContextImpl10getContextEv", "_ZN2cv11addWeightedERKNS_11_InputArrayEdS2_ddRKNS_12_OutputArrayEi", "cvClearHist", "png_handle_tRNS", "_ZN2cv3oclmlERKNS0_6oclMatES3_", "_ZN2cv9LDetectorC1Ev", "_ZN3Imf8addOwnerERNS_6HeaderERKSs", "_ZN11CvFuzzyRuleC1Ev", "_ZN3Imf14TypedAttributeINS_9LineOrderEE13readValueFromERNS_7IStreamEii", "_ZNK2cv11Fisherfaces4saveERNS_11FileStorageE", "_ZN6cvtest9ArrayTestC1Ev", "_ZN2cv5MutexD2Ev", "_ZN2cv16ParallelLoopBodyD2Ev", "_ZN3Imf8TimeCode14setBinaryGroupEii", "_ZN2cv3ocl12ProgramCacheC1Ev", "_ZNK2cv3ocl11ContextImpl15supportsFeatureENS0_12FEATURE_TYPEE", "_ZN2cv26GridAdaptedFeatureDetectorC2ERKNS_3PtrINS_15FeatureDetectorEEEiii", "_ZN2cv3ocl17openCLMallocPitchEPNS0_7ContextEPPvPjjj", "_ZN2cv6Retina8getParvoERNS_3MatE", "Java_org_opencv_video_Video_buildOpticalFlowPyramid_10", "_ZN2cv20PlanarObjectDetectorD0Ev", "Java_org_opencv_core_Core_multiply_10", "_ZN2cv3ocl20FarnebackOpticalFlow13releaseMemoryEv", "_ZN7Sampler8isinsideEii", "_Z24icvCvt_BGR2Gray_8u_C3C1RPKhiPhi6CvSizei", "_ZNK2cv13HOGDescriptor6detectERKNS_3MatERSt6vectorINS_6Point_IiEESaIS6_EERS4_IdSaIdEEdNS_5Size_IiEESE_RKS8_", "cvSetRemove", "_ZN3Imf6Header3endEv", "_ZN3Imf13B44Compressor12compressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN12CvFuzzyCurve9setCentreEd", "_ZN3Imf13RleCompressorD1Ev", "_ZN2cv16ParallelLoopBodyD1Ev", "_ZN2cv15RTreeClassifier21saveAllBytePosteriorsESs", "_ZN3Imf14TiledInputFile10initializeEv", "_ZN2cv3ocl11blendLinearERKNS0_6oclMatES3_S3_S3_RS1_", "_ZN7testing8internal17TestEventRepeaterD2Ev", "_ZN6cvtest11cmpUlpsInt_IiEEdPKT_S3_jijRj", "png_set_flush", "_ZN3Imf15Pxr24CompressorC1ERKNS_6HeaderEjj", "_ZN3Imf10numSamplesEiii", "jinit_c_prep_controller", "Java_org_opencv_objdetect_Objdetect_groupRectangles_10", "cvTrackFace", "Java_org_opencv_imgproc_Imgproc_goodFeaturesToTrack_10", "Java_org_opencv_imgproc_Imgproc_getDerivKernels_11", "cvRegisterType", "jpeg_read_raw_data", "_ZN2cv3ORBC1Eifiiiiii", "_ZN12CvFGDetectorC1Ev", "_ZNK3Imf15OpaqueAttribute8typeNameEv", "_ZNK9CvANN_MLP7predictERKN2cv3MatERS1_", "_ZN10CvKNearestC2Ev", "_ZNK3Imf7KeyCode5countEv", "TIFFInitCCITTFax4", "Java_org_opencv_core_Core_checkRange_10", "_ZN2cv6detail12DpSeamFinder12estimateSeamERKNS_3MatES4_NS_6Point_IiEES6_iS6_S6_RSt6vectorIS6_SaIS6_EERb", "Java_org_opencv_features2d_DescriptorMatcher_match_10", "cvXorS", "_ZN2cv9RodriguesERKNS_11_InputArrayERKNS_12_OutputArrayES5_", "Java_org_opencv_imgproc_Subdiv2D_initDelaunay_10", "__gnu_thumb1_case_uqi", "_ZN2cv14FernClassifier8finalizeERNS_3RNGE", "_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPS1_i", "jpc_putuint8", "_ZN2cv13getNumThreadsEv", "Java_org_opencv_imgproc_Imgproc_accumulate_10", "_ZN2cv10StereoSGBMD2Ev", "jas_image_getfmt", "Java_org_opencv_core_Mat_n_1setTo__JDDDD", "TIFFWarningExt", "_ZNK2cv12FilterEngine18remainingInputRowsEv", "_ZN4perf8TestBase8TearDownEv", "Java_org_opencv_core_Core_determinant_10", "_ZN8CvMLData19free_train_test_idxEv", "_ZN7testing8internal15UnitTestOptions17FilterMatchesTestERKSsS3_", "__truncdfsf2", "_ZN3Imf10OutputFile13breakScanLineEiiic", "Java_org_opencv_ml_CvSVM_get_1support_1vector_1count_10", "_ZN2cv17FlannBasedMatcher12knnMatchImplERKNS_3MatERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiRKS4_IS1_SaIS1_EEb", "_ZNK2cv24GenericDescriptorMatcher5emptyEv", "_ZN2cv8GlCamera19setProjectionMatrixERKNS_3MatEb", "png_set_unknown_chunk_location", "png_do_strip_channel", "_ZN2cv3ocl25openCLGetKernelFromSourceEPNS0_7ContextEPKNS0_12ProgramEntryESsiiPKc", "_ZNK8CvMLData10get_valuesEv", "_ZNK2cv17SelfSimDescriptor11getGridSizeENS_5Size_IiEES2_", "png_create_read_struct", "Java_org_opencv_imgproc_Imgproc_pyrUp_10", "_ZN2cv14SpinImageModelD1Ev", "_ZNK8CvRTrees14get_tree_countEv", "Java_org_opencv_ml_CvParamGrid_delete", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRybMS1_FyvEMS1_FvyERKSs", "jpc_ppxstabent_destroy", "Java_org_opencv_features2d_DescriptorMatcher_add_10", "jpeg_finish_compress", "png_read_png", "_ZNK2cv14FernClassifier16getSignatureSizeEv", "_ZN12CvFuzzyCurve9getCentreEv", "cvSeqPushMulti", "_ZN2cv17BasicRetinaFilter33_spatiotemporalLPfilter_IrregularEPfj", "_ZN2cv6detail21GraphCutSeamFinderGpu20setGraphWeightsColorERKNS_3MatES4_S4_S4_RS2_S5_S5_S5_S5_", "_ZN7CvBoostC2Ev", "_ZN3Imf18multiViewAttributeERNS_6HeaderE", "Java_org_opencv_contrib_StereoVar_set_1pyrScale_10", "_ZN2cv14SpinImageModel18selectRandomSubsetEf", "_ZN2cv9videostab17OnePassStabilizerC2Ev", "_ZNK2cv7MatExpr3colEi", "_ZN2cv15BriskScaleSpaceC1Ei", "_ZN9IlmThread9TaskGroup4DataC2Ev", "cvSeqInsert", "_ZN6cvtest5typesEiiii", "_ZN2cv3ocl11polarToCartERKNS0_6oclMatES3_RS1_S4_b", "_TIFFSetDefaultCompressionState", "Java_org_opencv_core_Core_pow_10", "_ZN6cvtest10randomSizeERN2cv3RNGEd", "_ZN7testing8internal17GetCapturedStdoutEv", "cvDestroyAllWindows", "_ZN3Imf14TypedAttributeISt6vectorISsSaISsEEE13readValueFromERNS_7IStreamEii", "_ZN17CvCapture_Android11getPropertyEi", "_ZNK3Imf11TileOffsets7writeToERNS_7OStreamE", "_ZN2cv3PCA10computeVarERKNS_11_InputArrayES3_id", "_ZNK2cv8Subdiv2D9getVertexEiPi", "_ZN21DetectionBasedTracker21SeparateDetectionWork4stopEv", "png_set_benign_errors", "_ZN11CvSVMKernelC2EPK11CvSVMParamsMS_FviiPPKfS4_PfE", "_ZN2cv15preCornerDetectERKNS_11_InputArrayERKNS_12_OutputArrayEii", "Java_org_opencv_imgproc_Moments_get_1mu11_10", "_ZN4perf10RegressionC1Ev", "_ZNK2cv7linemod8Detector12numTemplatesERKSs", "cvNextNArraySlice", "_ZNK2cv19FastFeatureDetector4infoEv", "_ZN9CvGBTrees5trainERKN2cv3MatEiS3_S3_S3_S3_S3_15CvGBTreesParamsb", "_ZN2cv18CvMeanShiftTracker17getTrackingWindowEv", "_ZNK17CirclesGridFinder8getHolesERSt6vectorIN2cv6Point_IfEESaIS3_EE", "_Z16freeFilterObjectPP18CvLSVMFilterObject", "png_set_longjmp_fn", "_ZNK2cv29PyramidAdaptedFeatureDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_ZN3Imf16keyCodeAttributeERNS_6HeaderE", "_ZN3Imf8TimeCode13setFieldPhaseEb", "rateallocate", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1train_1method_10", "png_write_sRGB", "_ZN2cv12VideoCaptureC2Ev", "cvComputeCorrespondEpilines", "_ZN2cv16GeneralizedHough6detectERKNS_11_InputArrayERKNS_12_OutputArrayES6_i", "_ZN9IlmThread5MutexC1Ev", "png_get_chunk_malloc_max", "_ZN2cvdvEdRKNS_7MatExprE", "_ZNK3Imf17ScanLineInputFile7versionEv", "_ZN2cv9videostab15VideoFileSourceC1ERKSsb", "png_set_unknown_chunks", "_ZN7testing8internal10AlwaysTrueEv", "jinit_2pass_quantizer", "_ZNK10CvKNearest21find_neighbors_directEPK5CvMatiiiPfPPKfS3_", "_Z3fftPfS_ii", "_ZN3Imf21hasRenderingTransformERKNS_6HeaderE", "_ZN2cv13getRectSubPixERKNS_11_InputArrayENS_5Size_IiEENS_6Point_IfEERKNS_12_OutputArrayEi", "_ZN24CvBlobTrackPredictKalmanD2Ev", "_ZN17CirclesGridFinder12getDirectionEN2cv6Point_IfEES2_S2_", "_ZN3Imf9InputFileD1Ev", "_ZNK3Imf14TiledInputFile10isCompleteEv", "__gnu_Unwind_Backtrace", "Java_org_opencv_ml_CvBoost_train_11", "_ZN3Imf13B44Compressor14uncompressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN2cvmiERKNS_7MatExprERKNS_3MatE", "cvFindFundamentalMatrix", "_ZN2cv17LatentSvmDetectorC2ERKSt6vectorISsSaISsEES5_", "jinit_master_decompress", "_ZN2cv10ExrDecoderD0Ev", "_ZN7testing8internal18StringFromGTestEnvEPKcS2_", "_ZN3Imf7IStreamD0Ev", "_ZN3Imf7OStreamD0Ev", "_ZN2cv3of26FabMapC2ERKNS_3MatEddii", "_ZN2cv3ocl8CannyBuf7releaseEv", "_ZN8CvMLDataD0Ev", "Java_org_opencv_features2d_DescriptorMatcher_match_13", "_ZN15CvOpenGlFuncTabD2Ev", "Java_org_opencv_ml_CvGBTreesParams_get_1weak_1count_10", "_ZN2cvneEdRKNS_3MatE", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEERKS1_", "_ZN2cv8Subdiv2D6VertexC2Ev", "png_write_info_before_PLTE", "_ZN2cv9Algorithm3setERKSsb", "_ZN2cv3ocl24buildWarpCylindricalMapsENS_5Size_IiEENS_5Rect_IiEERKNS_3MatES7_fRNS0_6oclMatES9_", "_ZNK2cv23OneWayDescriptorMatcher5writeERNS_11FileStorageE", "_ZNK2cv9Algorithm4nameEv", "_ZN3Imf6HeaderixERKSs", "_ZN2cv11RNG_MT199377uniformEdd", "_ZN2cv17DescriptorMatcher15isPossibleMatchERKNS_3MatEii", "_ZN8CvRTrees5trainEP8CvMLData10CvRTParams", "_ZN2cv23OneWayDescriptorMatcher15isMaskSupportedEv", "_Z19vector_Vec6f_to_MatRSt6vectorIN2cv3VecIfLi6EEESaIS2_EERNS0_3MatE", "_ZNK3Imf14TiledInputFile10numXLevelsEv", "_ZNK9IlmThread5Mutex6unlockEv", "TIFFCurrentStrip", "_ZN3Imf14TypedAttributeINS_11ChannelListEE13readValueFromERNS_7IStreamEii", "_ZN2cv22estimateRigidTransformERKNS_11_InputArrayES2_b", "_ZN2cv9polylinesERNS_3MatEPPKNS_6Point_IiEEPKiibRKNS_7Scalar_IdEEiii", "_ZN7CvDTree15read_tree_nodesEP13CvFileStorageP10CvFileNode", "_ZN3Imf5ownerERNS_6HeaderE", "_ZNK2cv7MatExpr3dotERKNS_3MatE", "_Z16getOppositePoint7CvPointiifiPS_", "_ZNK2cv3ogl9Texture2D6copyToERKNS_12_OutputArrayEib", "_ZN3Imf11ChannelListixEPKc", "_TIFFDefaultTileSize", "_ZN11CvSVMSolver18select_working_setERiS0_", "_ZN3Imf23offsetInLineBufferTableERKSt6vectorIjSaIjEEiRS2_", "Java_org_opencv_core_Core_subtract_15", "Java_org_opencv_core_Core_kmeans_11", "_Z13FillColorRow1PhS_iP12PaletteEntry", "_ZN2cv17LogPolar_AdjacentD1Ev", "_ZNK2cv8FileNode7readObjEv", "cvGraphRemoveVtxByPtr", "icvGetSymPoint3D", "jpc_mqenc_flush", "_ZNK3Imf11FrameBuffer9findSliceERKSs", "cvLogPolar", "_ZN2cv6detail21GraphCutSeamFinderGpu24setGraphWeightsColorGradERKNS_3MatES4_S4_S4_S4_S4_S4_S4_RS2_S5_S5_S5_S5_", "jas_matrix_divpow2", "_ZNK2cv20PlanarObjectDetector5writeERNS_11FileStorageERKSs", "_ZN2cv3of213BOWMSCTrainerC2Ed", "_ZNK2cv11Fisherfaces7predictERKNS_11_InputArrayERiRd", "_ZN2cv6Retina3runERKNS_3MatE", "_ZN2cvmiERKNS_7MatExprES2_", "Java_org_opencv_objdetect_CascadeClassifier_detectMultiScale_11", "_ZN5CvSVMD0Ev", "_ZN2cv6resizeERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi", "TIFFReadEncodedStrip", "_ZN2cv9videostab15MotionInpainter7inpaintEiRNS_3MatES3_", "Java_org_opencv_ml_CvBoost_prune_10", "_ZN2cv3ocl8__ModuleD1Ev", "png_get_header_ver", "Java_org_opencv_gpu_Gpu_deviceSupports_10", "_ZN2cv15NAryMatIteratorC2EPPKNS_3MatEPPhi", "_ZN2cv9SparseMat6createEiPKii", "_ZN2cvmlERKNS_3MatES2_", "_ZN2cv6Octree9buildTreeERKSt6vectorINS_7Point3_IfEESaIS3_EEii", "_ZN2cv5flann17KMeansIndexParamsC2EiiN7cvflann20flann_centers_init_tEf", "_ZN2cv3ocl12PlatformInfoD2Ev", "png_get_sBIT", "Java_org_opencv_imgproc_Moments_get_1m02_10", "png_do_compose", "_ZNK2cv3gpu6GpuMat9locateROIERNS_5Size_IiEERNS_6Point_IiEE", "_ZN2cv6detail7Blender7prepareERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_5Size_IiEESaISA_EE", "jpc_getscctxno", "_ZNK2cv3Mat6copyToERKNS_12_OutputArrayERKNS_11_InputArrayE", "_ZN2cv15AdjusterAdapter6createERKSs", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow28getResizeAttribsInnerDensityERiS1_S1_S1_", "Java_org_opencv_calib3d_StereoSGBM_set_1P1_10", "Java_org_opencv_imgproc_Moments_get_1m30_10", "_ZN3Imf9InputFile10readPixelsEii", "jpc_seg_alloc", "Java_org_opencv_ml_CvBoost_predict_11", "Java_org_opencv_core_Core_idft_11", "_ZN2cv5FASTXERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS4_EEibi", "jinit_c_main_controller", "Java_org_opencv_core_Core_subtract_13", "_ZN4CvEM5clearEv", "_ZNK7testing8internal12UnitTestImpl30reportable_disabled_test_countEv", "_ZN2cv8GlBuffer7releaseEv", "_ZN2cv3of27FabMap1C1ERKNS_3MatEddii", "_ZN2cv7toUtf16ERKSs", "_ZN3Imf5SliceC2ENS_9PixelTypeEPcjjiidbb", "png_read_chunk_header", "_ZN2cv10ExrDecoder8UpSampleEPhiiii", "_ZNK3Imf14TiledInputFile6headerEv", "_ZN17MouthFaceTemplateD1Ev", "TIFFCurrentTile", "_ZN2cv3ocl20getOpenCLErrorStringEi", "_ZN2cv3ocl5CannyERKNS0_6oclMatERS1_ddib", "_Z22GetPointOfIntersectionPKfffiiPf", "_ZN9IlmThread6Thread5startEv", "cvGraphAddVtx", "Java_org_opencv_core_Mat_n_1zeros__III", "_ZN2cv17LatentSvmDetectorD2Ev", "TIFFSetErrorHandler", "_ZNK3Imf14TiledInputFile17dataWindowForTileEiiii", "_ZN2cv8internal15IntrinsicParamsC2ENS_3VecIdLi2EEES3_NS2_IdLi4EEEd", "Java_org_opencv_imgproc_Imgproc_erode_12", "_ZN7testing8UnitTestD2Ev", "Java_org_opencv_imgproc_Imgproc_grabCut_10", "_ZN3Imf20setGlobalThreadCountEi", "_ZN2cv9Algorithm3setERKSsi", "Java_org_opencv_imgproc_Imgproc_remap_11", "_ZN11CvBoostTree15calc_node_valueEP11CvDTreeNode", "_ZN2cv3of211ChowLiuTree2JPEibib", "_ZNK2cv9TickMeter10getCounterEv", "_ZNK2cv3ocl10oclMatExprcvNS0_6oclMatEEv", "TIFFReadEncodedTile", "_ZN7CvDTree8get_dataEv", "_ZN2cv18CvMeanShiftTrackerC2ENS_24CvMeanShiftTrackerParamsE", "_ZN2cv3ocl12KalmanFilterC2Ev", "jpeg_mem_available", "png_set_filter_heuristics", "_ZN3Imf14TypedAttributeINS_7KeyCodeEE14staticTypeNameEv", "_ZNK3Imf11FrameBufferixERKSs", "png_warning_parameter", "_ZN16EllipticKeyPointC2ERKN2cv6Point_IfEERKNS0_7Scalar_IdEE", "_ZN2cv11cartToPolarERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_b", "XYZtoRGB24", "_ZNK2cv14PatchGenerator23generateRandomTransformENS_6Point_IfEES2_RNS_3MatERNS_3RNGEb", "_ZN2cv16TLSDataContainerC1Ev", "_ZN7testing8internal17Int32FromEnvOrDieEPKci", "_ZNK7testing8internal8FilePath15IsRootDirectoryEv", "png_set_user_transform_info", "_ZNK2cv7MatExprclERKNS_5Rect_IiEE", "_ZN2cv6detail12CameraParamsC2ERKS1_", "png_set_invalid", "_ZN2cv3Mat5zerosEiPKii", "png_check_chunk_name", "cvCalcOpticalFlowFarneback", "_ZN3Imf7keyCodeERKNS_6HeaderE", "_ZN2cv8Stitcher17estimateTransformERKNS_11_InputArrayE", "_ZNK7testing8UnitTest21reportable_test_countEv", "_TIFFmemcmp", "_ZN3Imf8timeCodeERKNS_6HeaderE", "TIFFInitCCITTFax3", "_ZN11CvFuzzyRule7setRuleEP12CvFuzzyCurveS1_S1_", "_ZN2cv9SparseMat5clearEv", "_ZN3Imf14TypedAttributeIN5Imath8Matrix33IfEEE14staticTypeNameEv", "_ZN2cv7compareERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "_ZN2cv3of26FabMap11addTrainingERKSt6vectorINS_3MatESaIS3_EE", "Java_org_opencv_highgui_Highgui_imencode_10", "_ZNK2cv16OneWayDescriptor16ProjectPCASampleEP9_IplImageP5CvMatS4_S4_", "_Z25icvCvt_CMYK2Gray_8u_C4C1RPKhiPhi6CvSize", "_Z16cvCheckTrainDataPK5CvMatiS1_PiS2_", "jas_cmprof_copy", "jpc_mct_getsynweight", "_ZN13CvBlobTrackerC1Ev", "cvPtr1D", "TIFFReadRawTile", "_ZN2cv12LineIteratorC2ERKNS_3MatENS_6Point_IiEES5_ib", "Java_org_opencv_calib3d_StereoSGBM_get_1disp12MaxDiff_10", "_ZN17btv_l1_device_ocl21calcBtvRegularizationERKN2cv3ocl6oclMatERS2_i", "_ZN4perf10Regression4InitERKSsS2_", "_ZN3Imf11FrameBuffer6insertERKSsRKNS_5SliceE", "cvPointPolygonTest", "_ZN2cv22SparseMatConstIteratorppEv", "_ZNK4perf8TestBase17getTotalInputSizeEv", "_ZN3Imf10OutputFileC1ERNS_7OStreamERKNS_6HeaderEi", "_ZN8CvMLData22mix_train_and_test_idxEv", "_ZN16CvCapture_Images11getPropertyEi", "_ZN2cv3ocl6device3hog15normalize_histsEiiiiiRNS0_6oclMatEf", "_ZN21DetectionBasedTracker14detectInRegionERKN2cv3MatERKNS0_5Rect_IiEERSt6vectorIS5_SaIS5_EE", "_ZN7testing8TestCase18GetMutableTestInfoEi", "_ZN7testing8internal12UnitTestImplD2Ev", "Java_org_opencv_core_Core_solveCubic_10", "_ZN2cv2EM5eStepEv", "_ZN7CvBoostC1ERKN2cv3MatEiS3_S3_S3_S3_S3_13CvBoostParams", "cvSetErrStatus", "Java_org_opencv_objdetect_CascadeClassifier_CascadeClassifier_11", "_ZN2cv10PngDecoderD1Ev", "png_do_write_interlace", "_ZN2cv9Algorithm3setERKSsd", "Java_org_opencv_features2d_DescriptorExtractor_read_10", "_ZNK13CvCalibFilter15GetStereoParamsEv", "_ZN2cv9Algorithm6setIntERKSsi", "Java_org_opencv_imgproc_Subdiv2D_locate_10", "_ZN16CvDTreeTrainData15free_train_dataEv", "_ZN2cv24BackgroundSubtractorMOG2D0Ev", "_ZNK3Imf15Pxr24Compressor12numScanLinesEv", "_ZN3Imf14lineBufferMaxYEiii", "_ZNSt8bad_castD2Ev", "_ZN3Imf17ScanLineInputFile4DataD2Ev", "_ZN2cv3ocl3MOGclERKNS0_6oclMatERS2_f", "_ZN3Imf12PreviewImageC1ERKS0_", "jas_iccprof_load", "_ZNK2cv6KDTree4dimsEv", "_ZN2cv12FastAdjusterC2Eibii", "png_write_rows", "_ZN2cv3ocl11interpolate12memsetKernelEfRNS0_6oclMatEii", "_ZN3Imf13PizCompressor10uncompressEPKciiRS2_", "_ZN2cv21FernDescriptorMatcher6ParamsC2EiiiiiiiRKNS_14PatchGeneratorE", "_ZNK2cv3ORB11computeImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZN3Imf19worldToNDCAttributeERNS_6HeaderE", "_ZN2cv3ocl26BruteForceMatcher_OCL_base18radiusMatchConvertERKNS_3MatES4_S4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "_ZNK2cv3ORB14descriptorSizeEv", "Java_org_opencv_imgproc_Imgproc_GaussianBlur_10", "_Z34cvOptimizeLevenbergMarquardtBundlePP5CvMatS1_S1_iS1_S0_id", "jpc_streamlist_create", "_ZN5CvSVMD1Ev", "_ZN22CameraWrapperConnector12connectToLibEv", "_ZN3Imf19addLookModTransformERNS_6HeaderERKSs", "_ZN2cv3ocl20openCLExecuteKernel2EPNS0_7ContextEPKNS0_12ProgramEntryESsPjS6_RSt6vectorISt4pairIjPKvESaISB_EEiiPcNS0_10FLUSH_MODEE", "_ZN21DetectionBasedTrackerC2ERKSsRKNS_10ParametersE", "_ZN3Imf13ZipCompressor10uncompressEPKciiRS2_", "_ZN16CvDTreeTrainData11read_paramsEP13CvFileStorageP10CvFileNode", "Java_org_opencv_ml_CvSVM_predict_10", "_ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKPi", "_ZNK7CvBoost12write_paramsEP13CvFileStorage", "_ZN2cv14SpinImageModel9setLoggerEPSo", "_ZN3Imf8TimeCodeaSERKS0_", "_ZN7testing8internal16BoolFromGTestEnvEPKcb", "_ZN2cv17CommandLineParser12analyzeValueIfEET_RKSsb", "_ZN22CvAdaptiveSkinDetector9HistogramD1Ev", "Java_org_opencv_core_Core_patchNaNs_10", "_ZN2cv10BriskLayerC2ERKS0_i", "_ZN6cvtest8filter2DERKN2cv3MatERS1_iS3_NS0_6Point_IiEEdiRKNS0_7Scalar_IdEE", "Java_org_opencv_features2d_DescriptorExtractor_compute_11", "cvResizeWindow", "_ZNK2cv9Algorithm5writeERNS_11FileStorageE", "_ZN2cv16FileNodeIteratorC2EPK13CvFileStoragePK10CvFileNodej", "_ZN15CvFuzzyFunctionD2Ev", "_ZN11CvSVMKernel8calc_rbfEiiPPKfS1_Pf", "cvStereoCalibrate", "png_set_text_compression_window_bits", "TIFFWriteDirectory", "jas_tvparser_next", "_ZN10CvVSModule12IsModuleNameEPKc", "png_do_unshift", "png_set_gAMA_fixed", "_ZN2cv11JpegEncoderD1Ev", "_ZN3Imf14TypedAttributeIN5Imath8Matrix33IfEEE13readValueFromERNS_7IStreamEii", "Java_org_opencv_features2d_FeatureDetector_detect_11", "_ZNK5Graph9getDegreeEj", "_ZN2cv17CommandLineParser12analyzeValueIjEET_RKSsb", "_ZN17CvCapture_AndroidC2Ei", "jpeg_write_marker", "_ZN5RFaceD0Ev", "Java_org_opencv_video_Video_meanShift_10", "cvReleaseBGStatModel", "cvGet1D", "_ZN9IlmThread6ThreadD1Ev", "_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_", "cvCalcOpticalFlowHS", "_ZN2cv17ParvoRetinaFilterC1Ejj", "_ZN2cv16estimateAffine3DERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_dd", "_ZN2cv10BriskLayerC2ERKNS_3MatEff", "Java_org_opencv_ml_CvBoost_delete", "_ZN7testing32ScopedFakeTestPartResultReporter4InitEv", "jpc_putuint16", "_ZN17CvCapture_Android14convertYUV2BGREiiPKhRN2cv3MatEbb", "_ZN24CirclesGridClusterFinder18parsePatternPointsERKSt6vectorIN2cv6Point_IfEESaIS3_EES7_RS5_", "Java_org_opencv_ml_CvBoostParams_get_1boost_1type_10", "TIFFWriteEncodedTile", "_ZN2cv20OneWayDescriptorBaseC2E6CvSizeiRKSsS3_S3_fffiii", "_ZN2cv3ocl19matchTemplate_CCORRERKNS0_6oclMatES3_RS1_RNS0_16MatchTemplateBufE", "_ZN7testing8TestCaseD1Ev", "cvGetErrInfo", "Java_org_opencv_ml_CvRTrees_predict_1prob_10", "_ZN2cv3ocl19getLinearFilter_GPUEiiRKNS_3MatERKNS_5Size_IiEERKNS_6Point_IiEEi", "_ZN2cv17BasicRetinaFilter37_localLuminanceAdaptationPosNegValuesEPKfS2_Pf", "jpc_bitstream_outalign", "_ZN13CvFaceElement10MergeRectsEi", "_ZN2cv11RetinaColor33_interpolateSingleChannelImage111EPf", "_ZN2cv9Directory13GetListFilesRERKSsS2_b", "cvGetTickFrequency", "Java_org_opencv_contrib_StereoVar_get_1nIt_10", "_ZN16CvDTreeTrainDataC1Ev", "_ZNK2cv13AlgorithmInfo3getEPKNS_9AlgorithmEPKciPv", "TIFFFillStrip", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1rp_1dw_1plus_10", "_ZN2cv10BaseFilterC1Ev", "jpc_bitstream_getbits", "_ZN2cv3ocl6device3hog16set_up_constantsEiiiii", "_ZNK2cv3Mat9convertToERKNS_12_OutputArrayEidd", "jpc_atoaf", "Java_org_opencv_calib3d_Calib3d_estimateAffine3D_11", "Java_org_opencv_core_Core_PCACompute_10", "TIFFSetSubDirectory", "_ZN2cv12_OutputArrayC2ERKNS_3gpu6GpuMatE", "_ZN3Imf18utcOffsetAttributeERKNS_6HeaderE", "_ZN2cv3gpu6GpuMatC2ERKNS_3MatE", "_ZN2cv3MatC1ERKS0_RKNS_5RangeES5_", "_ZN2cv11compareHistERKNS_9SparseMatES2_i", "_ZN14CvBlobTrackSeqC1Ei", "_ZN2cv12WLByteStreamD1Ev", "_ZN2cv11RetinaColor18_initColorSamplingEv", "_ZN2cv3Mat10push_back_EPKv", "Java_org_opencv_ml_CvNormalBayesClassifier_clear_10", "_ZN3Imf14TiledInputFile4DataD1Ev", "_Z27icvCvt_BGR5652Gray_8u_C2C1RPKhiPhi6CvSize", "_ZN13CvCalibFilterD2Ev", "_ZN3Imf13RleCompressor10uncompressEPKciiRS2_", "_ZNK9CvGBTrees12problem_typeEv", "_ZN2cv5flann5IndexC2Ev", "jas_stream_fillbuf", "png_set_PLTE", "_ZNK2cv13HOGDescriptor15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS3_EERS1_IdSaIdEEid", "jas_image_writecmpt2", "_ZN2cv25computeCorrespondEpilinesERKNS_11_InputArrayEiS2_RKNS_12_OutputArrayE", "_ZN10CvVSModule8AddParamEPKcPS1_", "_ZN2cv3ocl8filter2DERKNS0_6oclMatERS1_iRKNS_3MatENS_6Point_IiEEdi", "cvGraphRemoveEdgeByPtr", "_ZN2cv3ocl3MOG7releaseEv", "_ZN2cv3MatC2ERKS0_RKNS_5RangeES5_", "png_get_filter_type", "png_write_zTXt", "_ZN11CvSVMKernelC2Ev", "jpc_getmagctxno", "_ZN3Iex7BaseExc6appendERSt18basic_stringstreamIcSt11char_traitsIcESaIcEE", "_Z18Mat_to_vector_charRN2cv3MatERSt6vectorIcSaIcEE", "_ZN17FaceDetectionListD0Ev", "_ZN2cv3ocl20openCLExecuteKernel_EPNS0_7ContextEPKNS0_12ProgramEntryESsPjS6_RSt6vectorISt4pairIjPKvESaISB_EEiiPKc", "_ZN3Imf11hasCommentsERKNS_6HeaderE", "_ZN10CvVSModule8AddParamEPKcPf", "_ZN2cv11FileStorageC2EP13CvFileStorage", "cvPyrDown", "_ZN6cvtest8TSParamsC2Ev", "Java_org_opencv_core_Core_dct_10", "Java_org_opencv_core_Core_getThreadNum_10", "Java_org_opencv_imgproc_Imgproc_copyMakeBorder_11", "_ZN11CvSVMSolverD2Ev", "_ZN2cv9meanShiftERKNS_11_InputArrayERNS_5Rect_IiEENS_12TermCriteriaE", "_ZN2cv8Subdiv2DC1Ev", "png_create_info_struct", "_ZN2cv3ocl8__ModuleC2Ev", "_ZNK2cv3ogl9Texture2D4bindEv", "_ZN2cv16OneWayDescriptor19InitializePCACoeffsEP5CvMatS2_", "cvMean_StdDev", "_ZN2cv9LDetectorC2Ev", "_ZNK2cv8FileNode4nameEv", "_ZNK2cv11JpegDecoder10newDecoderEv", "_ZN7CvDTree18find_split_cat_regEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN3Imf11addAltitudeERNS_6HeaderERKf", "_ZNK4CvEM9get_meansEv", "_ZN6cvtest9crossCorrERKN2cv3MatES3_", "_ZN14CameraActivity13getFrameWidthEv", "_ZN6cvtest8BaseTest11read_paramsEP13CvFileStorage", "_ZN2cv3minERKNS_3MatES2_RS0_", "Java_org_opencv_imgproc_Imgproc_adaptiveThreshold_10", "_ZN2cv3MatC1EPK7CvMatNDb", "_ZN2cv9videostab14StabilizerBase19nextStabilizedFrameEv", "_Z15icvGetStartEnd2P9CvMatrix36CvSizePfS2_", "_ZN2cv6detail11MatchesInfoC2ERKS1_", "_ZN2cv15calcPCAFeaturesERSt6vectorIP9_IplImageSaIS2_EERNS_11FileStorageEPKcPP5CvMatSC_", "_ZN2cv9videostab18FastMarchingMethod8heapDownEi", "_ZN6cvtest21assertKeyPointsEqualsEPKcS1_RSt6vectorIN2cv8KeyPointESaIS4_EES7_", "_ZNK8CvRTrees5writeEP13CvFileStoragePKc", "_ZN2cv14FaceRecognizer13setLabelsInfoERKSt3mapIiSsSt4lessIiESaISt4pairIKiSsEEE", "icvGetCrossPieceDirect", "cvHoughLinesSDiv", "_ZNK4CvEM12getNClustersEv", "TIFFRasterScanlineSize", "cvDeleteMoire", "_ZN2cv8superres11FrameSourceD2Ev", "Java_org_opencv_core_Core_setNumThreads_10", "_ZN7testing8UnitTest14RecordPropertyERKSsS2_", "_cvConstructLCMEdge", "Java_org_opencv_imgproc_Imgproc_pointPolygonTest_10", "_ZN2cv17BasicRetinaFilter25_localLuminanceAdaptationEPfPKf", "_ZN3Imf12PreviewImageC2EjjPKNS_11PreviewRgbaE", "_ZN8CvMLData20set_train_test_splitEPK16CvTrainTestSplit", "_ZN16CvDTreeTrainData14subsample_dataEPK5CvMat", "_ZN2cv3of211ChowLiuTreeD0Ev", "Java_org_opencv_ml_CvNormalBayesClassifier_predict_11", "Java_org_opencv_imgproc_Imgproc_HuMoments_10", "_ZN2cv14getGaborKernelENS_5Size_IiEEdddddi", "_ZN22CameraWrapperConnector16getSymbolFromLibEPvPKcPS0_", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection12getKeypointsEv", "_ZN2cv3of211ChowLiuTree12recAddToTreeERNS_3MatEiiRSt4listINS1_4infoESaIS5_EE", "_ZN6cvtest10BadArgTestC2Ev", "_ZNK3Imf14TiledInputFile10numYLevelsEv", "_ZN6cvtest9randomMatEN2cv5Size_IiEEidd", "cvClearSet", "Java_org_opencv_core_Core_divide_12", "Java_org_opencv_features2d_DescriptorMatcher_match_12", "cvSeqSlice", "_ZNK2cv6Mesh3D11writeAsVrmlERKSsRKSt6vectorINS_7Scalar_IdEESaIS5_EE", "_ZN2cv6renderERKSsRKNS_3PtrINS_6GlFontEEENS_7Scalar_IdEENS_6Point_IdEE", "Java_org_opencv_core_Mat_n_1adjustROI", "_ZTv0_n24_NK2cv4MSER4infoEv", "_ZN2cv3ocl15CvSVMSolver_oclC1EPK11CvSVMParams", "_ZN2cv12WMByteStreamD0Ev", "cvReleaseLatentSvmDetector", "_ZN2cv3ocl21StereoConstantSpaceBPclERKNS0_6oclMatES4_RS2_", "_ZN2cv3ogl6BufferC1ERKNS_11_InputArrayENS1_6TargetEb", "_ZN2cv11WBaseStream8isOpenedEv", "_ZN2cv3gpu16createContinuousEiiiRNS0_6GpuMatE", "_ZNK7CvBoost5writeEP13CvFileStoragePKc", "cvDeInterlace", "_ZN2cv12FilterEngine5startERKNS_3MatERKNS_5Rect_IiEEbi", "png_get_tIME", "_ZN2cv29PyramidAdaptedFeatureDetectorC2ERKNS_3PtrINS_15FeatureDetectorEEEi", "_ZN3Imf16expTimeAttributeERNS_6HeaderE", "cvPolyLineAA", "_ZN3Imf7OStreamD2Ev", "_ZN2cv11TiffEncoderD2Ev", "_ZN2cv3ocl20matchTemplate_SQDIFFERKNS0_6oclMatES3_RS1_RNS0_16MatchTemplateBufE", "_ZN3Imf11TileOffsetsclEiii", "cvCheckTermCriteria", "_ZN2cv3ocleoERKNS0_6oclMatES3_", "cvContourFromContourTree", "Java_org_opencv_imgproc_Imgproc_cornerHarris_11", "_ZN2cv16SunRasterEncoderC2Ev", "_ZN2cv12FastAdjusterC1Eibii", "_ZTv0_n24_NK2cv24BriefDescriptorExtractor4infoEv", "_Z11_cvCalcEdgeP16CvVoronoiSiteIntS0_P16CvVoronoiEdgeIntP19CvVoronoiDiagramInt", "_ZN2cv6detail21BestOf2NearestMatcher14collectGarbageEv", "_ZN2cv5flann14LshIndexParamsC2Eiii", "_ZN2cv15LogPolar_InterpC2EiiNS_6Point_IiEEidiiii", "_TIFFUInt64ToDouble", "_ZN2cv12SurfAdjuster6tooFewEii", "_ZN16CvBlobDetectorCCC1Ev", "_ZN2cv15BriskScaleSpaceC2Ei", "_ZN2cv17DescriptorMatcher20DescriptorCollectionC2Ev", "_ZN2cv8internal21EstimateUncertaintiesERKNS_11_InputArrayES3_RKNS0_15IntrinsicParamsES3_S3_RS4_RNS_3VecIdLi2EEEdiRd", "_ZN17CvModelEstimator29getSubsetEPK5CvMatS2_PS0_S3_i", "_ZN12CvForestTree5trainEPK5CvMatiS2_S2_S2_S2_S2_13CvDTreeParams", "_ZN2cv23BackgroundSubtractorMOGD1Ev", "jinit_merged_upsampler", "_ZNK3Imf14TypedAttributeINS_12PreviewImageEE12writeValueToERNS_7OStreamEi", "Java_org_opencv_core_Core_perspectiveTransform_10", "_ZN2cv9StereoVarC1Eidiiiidffiii", "_ZN2cv20PlanarObjectDetectorC1ERKSt6vectorINS_3MatESaIS2_EEiiiiiRKNS_9LDetectorERKNS_14PatchGeneratorE", "_ZNK3Imf14TypedAttributeISsE12writeValueToERNS_7OStreamEi", "_ZN3Imf10hasKeyCodeERKNS_6HeaderE", "Java_org_opencv_objdetect_HOGDescriptor_HOGDescriptor_12", "_ZN2cv3PtrI12CvMemStorageE10delete_objEv", "png_read_finish_row", "jas_image_clearfmts", "_ZN2cv6detail16LKTrackerInvokerC2ERKNS_3MatES4_S4_PKNS_6Point_IfEEPS6_PhPfNS_5Size_IiEENS_12TermCriteriaEiiif", "png_handle_unknown", "_ZN2cv9Algorithm12setMatVectorEPKcRKSt6vectorINS_3MatESaIS4_EE", "_ZN3Imf14TypedAttributeINS_8RationalEE13readValueFromERNS_7IStreamEii", "Java_org_opencv_calib3d_StereoSGBM_set_1uniquenessRatio_10", "_ZN13CvCalibFilterD1Ev", "_ZN4epnp14solve_for_signEv", "_ZN2cv3ocl21createDerivFilter_GPUEiiiiiiNS_5Size_IiEE", "_ZN13FaceDetectionC2Ev", "png_write_chunk_data", "_ZN7testing8internal8FilePath9NormalizeEv", "Java_org_opencv_core_Algorithm_setMatVector_10", "png_set_oFFs", "_ZN7testing8internal32FormatEpochTimeInMillisAsIso8601Ex", "_ZNK2cv20FastFeatureDetector24infoEv", "_ZNK2cv10Eigenfaces4saveERNS_11FileStorageE", "cvbRand", "_ZNK9CvGBTrees7predictERKN2cv3MatES3_RKNS0_5RangeEi", "_ZN17CvCapture_AndroidD1Ev", "__udivsi3", "_ZN2cv20LogPolar_Overlapping10create_mapEiiiid", "cvGetWindowProperty", "_ZN4epnpC1ERKN2cv3MatES3_S3_", "_ZN2cv8Subdiv2D6locateENS_6Point_IfEERiS3_", "_ZN12CvFuzzyCurve8getValueEv", "_Z13cvWriteStructP13CvFileStoragePKcPvS2_i", "_ZNK2cv14FernClassifier12getPatchSizeEv", "___Unwind_RaiseException", "_ZN2cv18SimpleBlobDetector6ParamsC2Ev", "cvEndScanGraph", "_ZNK3Imf14TiledInputFile11levelHeightEi", "_ZN9CvGBTrees9GetLeavesEPK7CvDTreeRi", "png_write_IEND", "_ZN2cv16SunRasterEncoderC1Ev", "Java_org_opencv_core_Core_setIdentity_11", "_ZN7testing4TestD1Ev", "_ZThn4_N2cv5BRISKD1Ev", "_Z10fftInversePfS_ii", "_ZN2cv7sortIdxERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv6detail18PairwiseSeamFinder3runEv", "_ZN2cv2EMC2EiiRKNS_12TermCriteriaE", "_ZN2cv10BOWTrainerD0Ev", "cvComputePerspectiveMap", "_ZN2cv3ocl6device3mog8mog2_oclERKNS0_6oclMatEiRS3_S6_S6_S6_S6_ffbi", "png_gamma_8bit_correct", "Java_org_opencv_features2d_Features2d_drawKeypoints_10", "jas_cmxform_create", "_ZN2cv17LatentSvmDetectorC1ERKSt6vectorISsSaISsEES5_", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1rp_1dw_1minus_10", "Java_org_opencv_features2d_GenericDescriptorMatcher_isMaskSupported_10", "_ZNK5CvSVM5writeEP13CvFileStoragePKc", "Java_org_opencv_core_Core_repeat_10", "_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE", "_ZN2cv6KDTreeC2Ev", "cvCreateStructuringElementEx", "_ZNK3Imf6Header4findEPKc", "_ZNK2cv7linemod8Detector5matchERKSt6vectorINS_3MatESaIS3_EEfRS2_INS0_5MatchESaIS8_EERKS2_ISsSaISsEERKNS_12_OutputArrayES7_", "_ZN2cv9videostab17TwoPassStabilizer14stabilizeFrameEv", "jas_matrix_clip", "_ZN2cv2EMD0Ev", "cvCheckArr", "_ZN2cv17LatentSvmDetectorD0Ev", "png_write_PLTE", "_Z42cvCreateModuleBlobTrackPostProcTimeAverExpv", "_ZN2cv3ocl12ProgramCache10getProgramEPKNS0_7ContextEPKNS0_12ProgramEntryEPKc", "_ZN7testing8internal17TestEventRepeater15OnTestCaseStartERKNS_8TestCaseE", "_ZN10CvKNearestC1ERKN2cv3MatES3_S3_bi", "_ZN3Imf10wav2DecodeEPtiiiit", "_ZN13FaceDetection13FindCandidatsEv", "_ZN2cv3ocl8convolveERKNS0_6oclMatES3_RS1_", "_ZN2cv12_OutputArrayC1ERKNS_3ogl9Texture2DE", "Java_org_opencv_core_Core_normalize_12", "Java_org_opencv_core_Mat_n_1Mat__JII", "_ZN8CvRTreesD2Ev", "_ZN2cv14ChamferMatcher8Matching8getAngleESt4pairIiiES3_RiS4_", "_ZN2cv15FeatureDetector6createERKSs", "_ZNK2cv3ocl6oclMat8downloadERNS_3MatE", "_ZN2cv23OneWayDescriptorMatcherD2Ev", "_ZN17CSMatrixGeneratorD1Ev", "_ZN2cv5flann14LshIndexParamsC1Eiii", "_ZN2cv9StereoVarC1Ev", "_ZN3Imf14whiteLuminanceERKNS_6HeaderE", "_ZN7testing8internal9DeathTestC1Ev", "Java_org_opencv_imgproc_Imgproc_drawContours_12", "__fixdfsi", "_ZNK2cv24BriefDescriptorExtractor14descriptorTypeEv", "_ZN17CvCamShiftTrackerD2Ev", "_ZNK2cv24BriefDescriptorExtractor11computeImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZN3Iex7BaseExcC1ERKSs", "LogLuv32toXYZ", "_ZN2cv2EMD2Ev", "__gnu_Unwind_Save_WMMXD", "_ZN16CvDTreeTrainData18get_sample_indicesEP11CvDTreeNodePi", "_Z15addNullableBarsPfiiS_ii", "jas_tvparser_create", "Java_org_opencv_contrib_StereoVar_set_1cycle_10", "_ZNK2cv9GlTexture4bindEv", "_ZN6cvtest10BadArgTestD0Ev", "_ZN2cv3ogl9Texture2DC1ENS_5Size_IiEENS1_6FormatEb", "_ZN2cv16FeatureEvaluatorD0Ev", "_ZN3Imf16keyCodeAttributeERKNS_6HeaderE", "_ZN2cv8Stitcher15composePanoramaERKNS_12_OutputArrayE", "Java_org_opencv_imgproc_Imgproc_drawContours_10", "_ZN10__cxxabiv117__class_type_infoD1Ev", "_ZNK2cv3LDA4saveERNS_11FileStorageE", "_ZNSt9exceptionD2Ev", "_ZN2cv15RTreeClassifier4readEPKc", "_ZN2cv5writeERNS_11FileStorageERKSsRKNS_9SparseMatE", "_ZN2cv3ocl16PyrLKOpticalFlow6sparseERKNS0_6oclMatES4_S4_RS2_S5_PS2_", "_ZN2cv3ogl6BufferC2ENS_5Size_IiEEijb", "_ZN3Iex7BaseExcC2EPKc", "_ZN2cv5flann16SavedIndexParamsC2ERKSs", "_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EERS0_IiSaIiEERS0_IdSaIdEEid", "_ZN2cv9videostab14calcBlurrinessERKNS_3MatE", "_ZNK2cv11FileStorage8isOpenedEv", "_ZN2cv15KeyPointsFilter15runByPixelsMaskERSt6vectorINS_8KeyPointESaIS2_EERKNS_3MatE", "_ZN9CvGBTreesC2ERKN2cv3MatEiS3_S3_S3_S3_S3_15CvGBTreesParams", "_ZN2cv23BackgroundSubtractorMOGD0Ev", "jpeg_abort_decompress", "_ZNK2cv11_InputArray6getMatEi", "cvSeqPopMulti", "_ZN2cv7fisheye13projectPointsERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_7Affine3IdEES3_S3_dS6_", "_ZNK2cv6detail17BundleAdjusterRay25obtainRefinedCameraParamsERSt6vectorINS0_12CameraParamsESaIS3_EE", "_ZNK7testing19TestPartResultArray4sizeEv", "png_get_x_offset_microns", "cvGraphRemoveVtx", "jinit_d_main_controller", "_ZNK2cv3Mat4diagEi", "Java_org_opencv_imgproc_Imgproc_Canny_10", "_ZN2cv8superres15SuperResolutionC1Ev", "_ZNK7testing8UnitTest16total_test_countEv", "Java_org_opencv_core_Core_divide_16", "_ZN2cv4readERKNS_8FileNodeERSt6vectorINS_8KeyPointESaIS4_EE", "cvPtr2D", "_ZN7testing14KilledBySignalC1Ei", "Java_org_opencv_core_Core_split_10", "_ZN9IlmThread10ThreadPool16globalThreadPoolEv", "cvCalibrateCamera", "_ZN2cv8HOGCacheC2Ev", "cvGuiBoxReport", "_ZN2cv11RBaseStream8allocateEv", "_Z37cvCreateModuleBlobTrackAnalysisHistPVv", "_ZN2cv20loadWindowParametersERKSs", "_ZNK2cv11_InputArray12getMatVectorERSt6vectorINS_3MatESaIS2_EE", "jpc_pptstabwrite", "_ZN4perf9readImageERKSsi", "Java_org_opencv_contrib_StereoVar_get_1pyrScale_10", "png_data_freer", "_ZN2cv11FileStorageC2Ev", "_ZN10CvVSModule8GetParamEPKc", "_ZN4perf13printCudaInfoEv", "_ZN3Imf10halfToUintE4half", "_ZN2cv16FileNodeIteratorC1EPK13CvFileStoragePK10CvFileNodej", "png_ascii_from_fp", "_ZN15CvFuzzyFunction9calcValueEv", "_ZN2cv17BasicRetinaFilter31_squaringHorizontalCausalFilterEPKfPfjj", "_ZNK3Imf8TimeCode5hoursEv", "_ZN3Imf14TiledInputFileC1ERNS_7IStreamEi", "Java_org_opencv_core_Core_n_1minMaxLocManual", "_ZN12CvFuzzyCurve8setValueEd", "_ZN2cv6renderERKNS_8GlArraysEiNS_7Scalar_IdEE", "_ZNK2cv3gpu6GpuMat6copyToERS1_RKS1_", "_ZNK4CvEM7predictEPK5CvMatPS0_", "Java_org_opencv_ml_CvDTree_delete", "_ZN17CirclesGridFinder15addHolesByGraphERKSt6vectorI5GraphSaIS1_EEbN2cv6Point_IfEE", "_ZN2cv17BasicRetinaFilter6resizeEjj", "_ZN2cv9BFMatcherC1Eib", "cvCreateGraphScanner", "_ZNK2cv3ocl7Context19getOpenCLContextPtrEv", "Java_org_opencv_imgproc_Subdiv2D_edgeDst_11", "_ZN2cv20initWideAngleProjMapERKNS_11_InputArrayES2_NS_5Size_IiEEiiRKNS_12_OutputArrayES7_id", "_ZNK2cv8HOGCache9getWindowENS_5Size_IiEES2_i", "_ZN3Imf10OutputFile4DataC1Ebi", "_ZN2cv16OneWayDescriptor10ReadByNameERKNS_8FileNodeEPKc", "_ZN16CvBlobDetectorCCD2Ev", "_ZN2cv6detail11MatchesInfoC2Ev", "_ZN2cv8scaleAddERKNS_11_InputArrayEdS2_RKNS_12_OutputArrayE", "_ZN3Imf15Pxr24Compressor14uncompressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN2cv3ogl6Buffer7releaseEv", "cvFindFundamentalMat", "_ZN3Imf22calculateBytesPerPixelERKNS_6HeaderE", "_ZN3Imf17bytesPerLineTableERKNS_6HeaderERSt6vectorIjSaIjEE", "cvSetSeqBlockSize", "_ZNK10CvKNearest12find_nearestERKN2cv3MatEiRS1_S4_S4_", "_ZN2cv8superres11FrameSourceD0Ev", "_ZN3Imf14TypedAttributeINS_11CompressionEE13readValueFromERNS_7IStreamEii", "_ZN4perf19performance_metricsC2Ev", "Java_org_opencv_core_Algorithm_getBool_10", "cvCreateMatND", "TIFFReadDirectory", "_ZN25CvBlobTrackPostProcKalmanC1Ev", "_Z20vector_double_to_MatRSt6vectorIdSaIdEERN2cv3MatE", "_ZN3Imf10hasExpTimeERKNS_6HeaderE", "_ZN3Imf14convertInPlaceERPcRPKcNS_9PixelTypeEj", "_ZN2cv9watershedERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv3ocl9LaplacianERKNS0_6oclMatERS1_iiddi", "_ZN9IlmThread9TaskGroupC1Ev", "Java_org_opencv_ml_CvStatModel_load_10", "_ZN6cvtest8readSeedEPKc", "_ZN3Imf6Header17screenWindowWidthEv", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_delete", "_ZN16EllipticKeyPoint14calcProjectionERKSt6vectorIS_SaIS_EERKN2cv4Mat_IdEERS2_", "_ZNK4CvEM5writeEP13CvFileStoragePKc", "_ZN2cv4meanERKNS_11_InputArrayES2_", "Java_org_opencv_imgproc_Moments_get_1nu12_10", "_ZNK2cv8Subdiv2D7getEdgeEii", "_ZN12CvForestTree5trainEP16CvDTreeTrainDataPK5CvMatP8CvRTrees", "_ZNK2cv8HOGCache14windowsInImageENS_5Size_IiEES2_", "_ZN3Imf5focusERNS_6HeaderE", "_ZN2cv17destroyAllWindowsEv", "_ZN2cv3ocl10DeviceInfoC1Ev", "_ZN2cv20PlanarObjectDetectorC1Ev", "Java_org_opencv_imgproc_Moments_set_1mu21_10", "jas_stream_tell", "png_set_chunk_malloc_max", "_ZN2cv9videostab17OnePassStabilizerC1Ev", "_ZN7testing14IsNotSubstringEPKcS1_RKSsS3_", "_ZN2cv9videostab18InpaintingPipeline23setStabilizationMotionsERKSt6vectorINS_3MatESaIS3_EE", "_ZN12CvForestTree4readEP13CvFileStorageP10CvFileNodeP16CvDTreeTrainData", "_ZN2cv3ocl23OclCascadeClassifierBuf7releaseEv", "cvFitLine", "_ZN2cv19drawDataMatrixCodesERKNS_12_OutputArrayERKSt6vectorISsSaISsEERKNS_11_InputArrayE", "Java_org_opencv_imgproc_Imgproc_Sobel_10", "Java_org_opencv_core_Core_bitwise_1xor_11", "_ZN2cv3ocl8multiplyEdRKNS0_6oclMatERS1_", "_ZNK2cv3ORB4infoEv", "_ZN6cvtest13readImageTypeERKSsi", "_Z13FillColorRow4PhS_iP12PaletteEntry", "_ZN2cv3of211ChowLiuTreeD2Ev", "_Z9printBitsPcf", "png_check_keyword", "png_destroy_struct", "_ZN4perf8TestBase6warmupERKN2cv12_OutputArrayEi", "_ZN2cv12StarAdjusterC2Eddd", "_Z19vector_float_to_MatRSt6vectorIfSaIfEERN2cv3MatE", "cvLinearPolar", "_ZN2cv17Affine3DEstimator9runKernelEPK5CvMatS3_PS1_", "_ZN2cv13HaarEvaluatorD0Ev", "_ZN2cv7MomentsC1Edddddddddd", "_ZN2cv3ocl6oclMatmIERKS1_", "Java_org_opencv_core_Core_add_12", "Java_org_opencv_calib3d_StereoSGBM_set_1numberOfDisparities_10", "_ZN2cv4sortERKNS_11_InputArrayERKNS_12_OutputArrayEi", "TIFFFreeDirectory", "_ZN3Imf10OutputFileC2EPKcRKNS_6HeaderEi", "cvFlushSeqWriter", "cvRandGaussMixture", "_ZN2cv14correctMatchesERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayES5_", "Java_org_opencv_core_Mat_n_1setTo__JDDDDJ", "Java_org_opencv_imgproc_Moments_set_1m12_10", "_ZN2cv11FileStorage8writeRawERKSsPKhj", "_ZN5RFace10CreateFaceEPv", "jpc_tsfb_analyze2", "_ZN8CvMatrixC1EiiiP12CvMemStorageb", "_ZN3Imf17ScanLineInputFileC2ERKNS_6HeaderEPNS_7IStreamEi", "_ZNK2cv20PlanarObjectDetector14getModelPointsEv", "_ZN2cv17BasicRetinaFilter27_local_verticalCausalFilterEPfjjPKj", "_ZN2cv13LevMarqSparseC1EiiiiiRNS_3MatES2_S2_NS_12TermCriteriaEPFviiS2_S2_S2_S2_PvEPFviiS2_S2_S2_S4_ES4_PFbidS4_ES4_", "Java_org_opencv_objdetect_HOGDescriptor_save_11", "_ZN2cv8internal15IntrinsicParamsC1ENS_3VecIdLi2EEES3_NS2_IdLi4EEEd", "_ZN2cv9StereoVar10autoParamsEv", "_ZNK4CvEM8getProbsEv", "_ZN9IlmThread10ThreadPool4DataD1Ev", "Java_org_opencv_features2d_GenericDescriptorMatcher_clear_10", "icvGetCrossPiecePiece", "_ZN7testing8internal13GetTestTypeIdEv", "_Z20vector_DMatch_to_MatRSt6vectorIN2cv6DMatchESaIS1_EERNS0_3MatE", "_ZN2cv3of27FabMap114getLikelihoodsERKNS_3MatERKSt6vectorIS2_SaIS2_EERS5_INS0_6IMatchESaISA_EE", "_Z26icvCvt_BGR5552BGR_8u_C2C3RPKhiPhi6CvSize", "png_set_sCAL_s", "_ZN3Imf21fillChannelWithZeroesERPcNS_10Compressor6FormatENS_9PixelTypeEj", "_ZN3Imf9levelSizeEiiiNS_17LevelRoundingModeE", "_ZN2cv12RMByteStream7getWordEv", "cvReleaseSparseMat", "Java_org_opencv_imgproc_Imgproc_sepFilter2D_12", "_ZNK2cv13HOGDescriptor4saveERKSsS2_", "_ZSt18uncaught_exceptionv", "_ZN2cv7linemod18hysteresisGradientERNS_3MatES2_S2_f", "_Z16CvtPaletteToGrayPK12PaletteEntryPhi", "_ZN4perf7PrintToERKNS_12CvtColorInfoEPSo", "_ZN13CvFaceElement9FindRectsEP9_IplImageS1_ii", "png_read_sig", "cvHaveImageWriter", "_ZN9CvGBTrees12do_subsampleEv", "_ZN5GraphC1Ej", "_ZN2cv3ocl11bindTextureERKNS0_6oclMatE", "_ZN2cv7fisheye23initUndistortRectifyMapERKNS_11_InputArrayES3_S3_S3_RKNS_5Size_IiEEiRKNS_12_OutputArrayESA_", "_ZNK2cv7linemod8Detector10writeClassERKSsRNS_11FileStorageE", "_ZN2cv8fastFreeEPv", "Java_org_opencv_ml_CvDTreeParams_set_1cv_1folds_10", "cvAnd", "_ZN11CvSVMSolver12solve_nu_svcEiiPPKfPaP12CvMemStorageP11CvSVMKernelPdR17CvSVMSolutionInfo", "_ZN2cv10ExrDecoder5closeEv", "Java_org_opencv_features2d_GenericDescriptorMatcher_classify_10", "_ZN2cv10PngDecoderD0Ev", "_ZN2cv17CascadeClassifierD1Ev", "TIFFWarning", "_ZN17CvModelEstimator2D2Ev", "_ZN7testing8internal23GetLastErrnoDescriptionEv", "_ZN2cvanERKNS_7Scalar_IdEERKNS_3MatE", "_ZN2cv12KalmanFilterC2Eiiii", "_ZN3Imf14TiledInputFile8readTileEiiii", "Java_org_opencv_features2d_FeatureDetector_detect_13", "Java_org_opencv_imgproc_Imgproc_boxFilter_12", "_ZN2cv11cornerScoreILi16EEEiPKhPKii", "_ZN2cv11WBaseStreamD2Ev", "_ZNK4CvEM7getCovsERSt6vectorIN2cv3MatESaIS2_EE", "jpc_ft_fwdlift_colgrp", "Java_org_opencv_contrib_StereoVar_get_1penalization_10", "_ZNK2cv24GenericDescriptorMatcher5writeERNS_11FileStorageE", "_ZNK23CvNormalBayesClassifier7predictERKN2cv3MatEPS1_", "_ZNK2cv23VectorDescriptorMatcher5writeERNS_11FileStorageE", "_Z24icvCvt_BGRA2RGBA_16u_C4RPKtiPti6CvSize", "_ZNK2cv9TickMeter12getTimeTicksEv", "jpc_getuint16", "_ZN2cvdvERKNS_3MatERKNS_7MatExprE", "_ZN13FaceDetection12FindContoursEP9_IplImage", "cvSort", "_ZNK2cv11TiffDecoder14checkSignatureERKSs", "Java_org_opencv_gpu_DeviceInfo_queryMemory_10", "Java_org_opencv_core_Mat_nPutS", "_ZN7testing7MessageC1Ev", "_ZN2cv14FernClassifierC2Ev", "_ZN6CvTypeD2Ev", "_ZN2cv14RandomizedTree4readEPKci", "_ZN2cv12_OutputArrayC2ERKNS_3MatE", "_Z17computeBorderSizeiiPiS_", "_ZN9CvLevMarq4initEii14CvTermCriteriab", "_ZN2cv8superres27createFrameSource_Video_GPUERKSs", "_ZNK3GMMclEiN2cv3VecIdLi3EEE", "Java_org_opencv_objdetect_HOGDescriptor_compute_10", "_ZNK2cv9MatOp_Bin8multiplyERKNS_7MatExprEdRS1_", "_ZN2cv3of27FabMap2D0Ev", "_ZN7testing8internal24HasNewFatalFailureHelperD2Ev", "_ZN2cv3ocl6oclMatmLERKS1_", "_ZN21CvANN_MLP_TrainParamsD1Ev", "_ZN2cv3ocl12StereoBM_OCLC1Eiii", "_ZN10CvRTParamsC1Ev", "png_default_write_data", "jas_realloc", "_ZN7testing4TestD2Ev", "_ZN2cv8Subdiv2D19getVoronoiFacetListERKSt6vectorIiSaIiEERS1_IS1_INS_6Point_IfEESaIS7_EESaIS9_EERS9_", "Java_org_opencv_contrib_StereoVar_set_1maxDisp_10", "cvFree_", "TIFFRawStripSize", "Java_org_opencv_ml_CvANN_1MLP_train_10", "_ZN3Imf10OutputFile4DataD0Ev", "Java_org_opencv_ml_EM_trainM_10", "_ZN10CvVSModule8SetParamEPKcd", "cvRawDataToScalar", "cvReleaseCapture", "_ZN8CvRTrees19get_active_var_maskEv", "_ZN2cv3ocl26BruteForceMatcher_OCL_base17knnMatch2DownloadERKNS0_6oclMatES4_S4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "_ZN2cv2EMD1Ev", "_ZN7cvflann17set_distance_typeENS_16flann_distance_tEi", "_ZN2cv3ocl9CvSVM_OCL13create_solverEv", "cvGetRootFileNode", "_ZN2cv10PngEncoder14writeDataToBufEPvPhj", "_ZNK17CirclesGridFinder17getCornerSegmentsERKSt6vectorIS0_IjSaIjEESaIS2_EERS0_IS0_INS_7SegmentESaIS7_EESaIS9_EERS0_IN2cv6Point_IiEESaISF_EESI_SI_", "_ZNK2cv5MatOp6divideEdRKNS_7MatExprERS1_", "png_get_chunk_cache_max", "Java_org_opencv_core_Core_rectangle_10", "_ZN17CvERTreeTrainData14subsample_dataEPK5CvMat", "Java_org_opencv_core_Core_fillConvexPoly_11", "_ZN2cv3maxERKNS_3MatES2_RS0_", "_ZN2cv3of26FabMap7compareERKNS_3MatERSt6vectorINS0_6IMatchESaIS6_EEbS4_", "_Z21vector_Point3d_to_MatRSt6vectorIN2cv7Point3_IdEESaIS2_EERNS0_3MatE", "_ZThn4_NK2cv5BRISK14descriptorSizeEv", "Java_org_opencv_core_Core_norm_11", "png_set_expand_gray_1_2_4_to_8", "_ZN6cvtest4copyERKN2cv3MatERS1_S3_b", "png_get_y_offset_inches_fixed", "png_handle_hIST", "jpc_ns_fwdlift_row", "_ZN2cv10BmpDecoderC1Ev", "_ZN2cv6Retina10outputSizeEv", "jpc_enc_create", "Java_org_opencv_highgui_VideoCapture_n_1isOpened", "_ZN10CvVSModule11GetNickNameEv", "_ZN9IlmThread10ThreadPoolC1Ej", "Java_org_opencv_imgproc_Imgproc_morphologyEx_12", "_ZNK3Imf11ChannelList4findERKSs", "_ZN2cv3Mat5zerosEiii", "_ZN3Imf14TypedAttributeIN5Imath4Vec3IdEEE14staticTypeNameEv", "cvSetMouseCallback", "_ZN13CvCalibFilter9UndistortEPP9_IplImageS2_", "_ZNK7testing14ExitedWithCodeclEi", "_ZN2cv13PCAComputeVarERKNS_11_InputArrayERKNS_12_OutputArrayES5_d", "_ZN2cv9SparseMat5eraseEiiPj", "_TIFFNoRowDecode", "icvGetPieceLength3D", "Java_org_opencv_core_Core_norm_12", "_ZN2cv9normalizeERKNS_9SparseMatERS0_di", "_ZN3Imf8hasOwnerERKNS_6HeaderE", "Java_org_opencv_core_Mat_n_1zeros__DDI", "_ZN2cv3ocl13HOGDescriptorC1ENS_5Size_IiEES3_S3_S3_iddbi", "_ZN2cv3ocl19openCLMallocPitchExEPNS0_7ContextEPPvPjjjNS0_8DevMemRWENS0_10DevMemTypeE", "_ZN13CvBlobTracker11GetBlobByIDEi", "_ZN4perf8TestBase14_declareHelperC1EPS0_", "cvLoadImageM", "png_create_write_struct_2", "cvProjectPointsSimple", "jas_malloc", "_ZN2cv6detail12DpSeamFinder16resolveConflictsERKNS_3MatES4_NS_6Point_IiEES6_RS2_S7_", "_ZN3Imf6HeaderD1Ev", "_ZN2cv14FaceRecognizer4loadERKSs", "_ZN2cv9videostab17TwoPassStabilizerC1Ev", "Java_org_opencv_imgproc_Imgproc_integral2_10", "cvSetIPLAllocators", "_ZN7testing8internal12UnitTestImpl19PostFlagParsingInitEv", "_ZN6cvtest4meanERKN2cv3MatES3_", "_ZN2cv8cubeRootEf", "cvGetRawData", "cvGetAffineTransform", "_ZTv0_n16_NK2cv32OpponentColorDescriptorExtractor5writeERNS_11FileStorageE", "cvConvexHull2", "_ZN2cv29DynamicAdaptedFeatureDetectorC2ERKNS_3PtrINS_15AdjusterAdapterEEEiii", "createFeaturePyramidWithBorder", "_ZN2cv14SpinImageModelD2Ev", "cvCalcImageHomography", "_ZN3Imf11TileOffsetsC2ENS_9LevelModeEiiPKiS3_", "_ZN6cvtest10BadArgTestC1Ev", "_ZN2cv11_InputArrayC1ERKNS_7MatExprE", "_ZN16EllipticKeyPoint7convertERKSt6vectorIS_SaIS_EERS0_IN2cv8KeyPointESaIS6_EE", "_ZN2cv3ocl21StereoConstantSpaceBPC2Eiiiii", "Java_org_opencv_core_Core_kmeans_10", "_ZN2cv2EM19clusterTrainSamplesEv", "_ZN22CvAdaptiveSkinDetector9HistogramD2Ev", "_ZN2cv3of213BOWMSCTrainerD1Ev", "_ZTv0_n20_N2cv18SimpleBlobDetector4readERKNS_8FileNodeE", "_ZN2cv13Jpeg2KDecoderC1Ev", "_ZN13CvBlobTracker17GetConfidenceListEP9CvBlobSeqP9_IplImageS3_", "_ZN2cv10StereoSGBMC2Ev", "_ZN2cv3ocl5canny12getEdges_gpuERNS0_6oclMatES3_ii", "Java_org_opencv_calib3d_StereoBM_StereoBM_12", "_ZN2cv13matchTemplateERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "_ZN2cv6Retina10printSetupEv", "Java_org_opencv_ml_CvANN_1MLP_CvANN_1MLP_12", "jas_taginfo_nonull", "_ZN5CvSVM4readEP13CvFileStorageP10CvFileNode", "_ZN4CvEMC2Ev", "_ZN2cv5ParamC2Ev", "jas_stream_close", "_Z28icvReconstructPoints4DStatusPP5CvMatS1_S1_S0_iS1_", "_ZN3Imf17globalThreadCountEv", "_ZN2cv10PxMEncoderD0Ev", "cvCreateButton", "_ZN2cv5FREAK12buildPatternEv", "_ZN4epnp11compute_pcsEv", "_ZN2cv17MagnoRetinaFilter6resizeEjj", "_ZNK2cv24GenericDescriptorMatcher17getTrainKeypointsEv", "_ZN2cv20PlanarObjectDetector5trainERKSt6vectorINS_3MatESaIS2_EEiiiiiRKNS_9LDetectorERKNS_14PatchGeneratorE", "_ZNK2cv32OpponentColorDescriptorExtractor5emptyEv", "cvFindFeatures", "Java_org_opencv_core_Core_dft_11", "_ZN2cv3PtrINS_3ogl9Texture2D4ImplEE10delete_objEv", "png_do_pack", "_ZN7testing8internal12UnitTestImpl11GetTestCaseEPKcS3_PFvvES5_", "_ZN2cv17BasicRetinaFilter44setProgressiveFilterConstants_CustomAccuracyEfffRKSt8valarrayIfEj", "Java_org_opencv_core_Core_arrowedLine_10", "_ZN2cv10BmpEncoderD1Ev", "_ZN2cv16SunRasterEncoderD0Ev", "Java_org_opencv_ml_CvDTree_getVarImportance_10", "_ZNK3Imf14TiledInputFile17levelRoundingModeEv", "_ZN2cv23BackgroundSubtractorGMG7releaseEv", "_ZN4perf13sortKeyPointsERSt6vectorIN2cv8KeyPointESaIS2_EERKNS1_12_OutputArrayE", "jpc_save_t2state", "_ZN6cvtest8TestInfoC1Ev", "_ZN2cv12_OutputArrayC2ERKNS_3ogl6BufferE", "_ZN3Imf12addUtcOffsetERNS_6HeaderERKf", "cvSeqRemoveSlice", "_ZN3Imf14TypedAttributeIN5Imath4Vec3IdEEE13readValueFromERNS_7IStreamEii", "Java_org_opencv_gpu_TargetArchs_builtWith_10", "_ZN2cv14RandomizedTree14freePosteriorsEi", "_ZN5RFace9ShowIdealEP9_IplImage", "_ZN4perf19performance_metricsC1Ev", "_ZN2cv3ogl9Texture2DC2ENS_5Size_IiEENS1_6FormatEb", "cvStdErrReport", "_ZN2cv3ocl6device3hog22compute_gradients_8UC4EiiRKNS0_6oclMatEfRS3_S6_b", "_ZN17btv_l1_device_ocl7upscaleERKN2cv3ocl6oclMatERS2_i", "Java_org_opencv_imgproc_Imgproc_accumulateWeighted_11", "_ZN3Imf11StdOFStreamD1Ev", "jpc_ft_invlift_col", "_ZN4perf10Regression5writeEv", "_ZN2cv5flann20CompositeIndexParamsC2EiiiN7cvflann20flann_centers_init_tEf", "_ZN2cv17SelfSimDescriptoraSERKS0_", "_ZN2cv11_InputArrayC2ERKNS_8GlBufferE", "_ZN2cv9videostab15MotionInpainterC2Ev", "_ZN2cv3PCAC1ERKNS_11_InputArrayES3_id", "cvInitSubdivDelaunay2D", "_ZN2cv6detail12DpSeamFinder21updateLabelsUsingSeamEiiRKSt6vectorINS_6Point_IiEESaIS4_EEb", "_ZN7testing8internal18CmpHelperSTRCASENEEPKcS2_S2_S2_", "cvReduce", "png_write_hIST", "_ZN2cv9BFMatcher15radiusMatchImplERKNS_3MatERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfRKS4_IS1_SaIS1_EEb", "_ZN2cv3of27FabMap2D1Ev", "_ZN2cv8internal3dABERKNS_11_InputArrayES3_RKNS_12_OutputArrayES6_", "_ZN2cv6detail17OrbFeaturesFinderC1ENS_5Size_IiEEifi", "_ZN2cv20OneWayDescriptorBase8AllocateEi", "Java_org_opencv_imgproc_Subdiv2D_Subdiv2D_10", "_ZN6cvtest6dilateERKN2cv3MatERS1_S3_NS0_6Point_IiEEiRKNS0_7Scalar_IdEE", "_ZSt15set_new_handlerPFvvE", "_ZN2cv3ocl12StereoBM_OCLC2Eiii", "_ZN3Imf8altitudeERNS_6HeaderE", "_ZN11CvStatModelD2Ev", "_ZN2cv3of27FabMap1D0Ev", "jpc_mqenc_destroy", "_ZN3Imf8xDensityERKNS_6HeaderE", "_ZN7CvDTree5trainEPK5CvMatiS2_S2_S2_S2_S2_13CvDTreeParams", "jas_stream_read", "_ZNK3Imf14TypedAttributeINS_14ChromaticitiesEE12writeValueToERNS_7OStreamEi", "_ZN16CvDTreeTrainData14free_node_dataEP11CvDTreeNode", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1rp_1dw_1plus_10", "_ZN14CvForestERTree18find_split_cat_regEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN3Iex14setStackTracerEPFSsvE", "_ZNK3Imf11ChannelList5beginEv", "Java_org_opencv_imgproc_Imgproc_filter2D_10", "_ZNK8CvMLData11get_miss_chEv", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_CvANN_1MLP_1TrainParams_10", "_ZN21DetectionBasedTrackerD0Ev", "cvCloneGraph", "_ZNK7testing8internal12UnitTestImpl26successful_test_case_countEv", "_ZN2cv16CvFeatureTrackerC2ENS_22CvFeatureTrackerParamsE", "_ZN2cv3ocl22getLinearRowFilter_GPUEiiRKNS_3MatEii", "_ZN2cv22OneWayDescriptorObjectD0Ev", "_ZN2cv4FASTERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS4_EEib", "_ZNK9CvANN_MLP7predictEPK5CvMatPS0_", "_ZN2cv9videostab27SparsePyrLkOptFlowEstimator3runERKNS_11_InputArrayES4_S4_RKNS_12_OutputArrayES7_S7_", "_ZN2cv6kmeansERKNS_11_InputArrayEiRKNS_12_OutputArrayENS_12TermCriteriaEiiS5_", "cvHaarDetectObjects", "_ZN2cv17SelfSimDescriptorC1Eiiiii", "_ZN2cv6detail17OrbFeaturesFinder4findERKNS_3MatERNS0_13ImageFeaturesE", "_ZN3Imf9InputFile4Data18deleteCachedBufferEv", "TIFFTileSize64", "cvReleasePyramid", "_ZNK2cv7linemod8Detector12writeClassesERKSs", "_ZNK2cv24GenericDescriptorMatcher8knnMatchERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_S8_RS4_IS4_INS_6DMatchESaIS9_EESaISB_EEiS3_b", "_ZN2cv19generatePCAFeaturesEPKcS1_RNS_11FileStorageES1_6CvSizePP5CvMatS7_", "_ZN2cv17CommandLineParser9getStringERKSs", "_Z19cvPreprocessVarTypePK5CvMatS1_iPi", "_ZN17CvModelEstimator27setSeedEx", "_ZN2cv12_OutputArrayC2ERNS_3ogl9Texture2DE", "_ZN3Imf23chromaticitiesAttributeERKNS_6HeaderE", "_ZN2cv7linemod8Detector4readERKNS_8FileNodeE", "_ZN2cvltERKNS_3MatEd", "_ZN2cv3ocl11setIdentityERNS0_6oclMatERKNS_7Scalar_IdEE", "Java_org_opencv_imgproc_Subdiv2D_rotateEdge_10", "_ZN7testing8internal24HasNewFatalFailureHelperD0Ev", "jpc_ppxstab_insert", "_ZN6cvtest10typeByNameEPKc", "_ZN2cv10TLSStorageD1Ev", "_Z31icvGenerateRandomClusterCentersiPK5CvMatiPS_", "_ZN2cv7linemod20ColorGradientPyramid7pyrDownEv", "_Z10icvPoints8PiS_iPd", "TIFFSwabArrayOfTriples", "_ZN20CvBlobDetectorSimpleD0Ev", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow15initDepthValuesEP9_IplImageS2_", "_ZN3Imf14TypedAttributeIN5Imath4Vec2IdEEE14staticTypeNameEv", "TIFFReadTile", "cvPow", "_ZN10CvVSModule8AddParamEPKcPd", "_ZN2cv3gpu6GpuMatC2ERKS1_NS_5RangeES4_", "_ZN11CvSVMSolver25select_working_set_nu_svmERiS0_", "_ZN2cv14ChamferMatcher8Matching21findFirstContourPointERNS_3MatERSt4pairIiiE", "jpc_enc_cp_destroy", "cvDecodeImageM", "cvUndistort2", "_ZN2cvgtEdRKNS_3MatE", "TIFFUnsetField", "Java_org_opencv_core_Core_sortIdx_10", "_ZN9CvERTrees11grow_forestE14CvTermCriteria", "_ZN16CvDTreeTrainData17get_ord_responsesEP11CvDTreeNodePfPi", "_ZN22CvAdaptiveSkinDetectorC1Eii", "_ZN17CSMatrixGeneratorD2Ev", "_ZN7testing10TestResultC2Ev", "_ZN2cv12WMByteStreamD1Ev", "_ZN16CvTrainTestSplitC2Efb", "_ZN2cv16CvFeatureTrackerD1Ev", "Java_org_opencv_core_Mat_nGetF", "_ZN2cv9Algorithm7setBoolERKSsb", "cvMinS", "cvReleaseVoronoiStorage", "__divsf3", "_ZN7testing8internal11CmpHelperLEEPKcS2_xx", "__clzsi2", "_ZN2cv3PtrI9CvCaptureE10delete_objEv", "cvGetTickCount", "_ZN2cv6detail12DisjointSets9mergeSetsEii", "png_set_text_compression_mem_level", "_ZN17CvCamShiftTrackerD0Ev", "_ZNK4perf8TestBase18getTotalOutputSizeEv", "_ZN6cvtest5erodeERKN2cv3MatERS1_S3_NS0_6Point_IiEEiRKNS0_7Scalar_IdEE", "_ZN2cv4normERKNS_9SparseMatEi", "_ZN2cv6OctreeC2Ev", "__lesf2", "cvCalcMatMulDeriv", "_Z24icvGetCoefficientDefaultP9CvMatrix36CvSizePiS2_S2_", "Java_org_opencv_core_Core_inRange_10", "_ZN6cvtest7convertERKN2cv3MatERS1_idd", "_ZN2cv7linemod7Feature4readERKNS_8FileNodeE", "_Z20cvReleaseBlobTrackerPP13CvBlobTracker", "_ZN2cv14findHomographyERKNS_11_InputArrayES2_RKNS_12_OutputArrayEid", "_ZN2cv6detail14PlaneWarperGpu9buildMapsENS_5Size_IiEERKNS_3MatES6_RNS_3gpu6GpuMatES9_", "_ZN3Imf7KeyCode13setPerfOffsetEi", "cvGetRealND", "_ZN2cv3ocl12CommandQueue6createEPNS0_11ContextImplE", "Java_org_opencv_imgproc_Imgproc_convexHull_11", "_ZN2cv6Retina28_convertValarrayBuffer2cvMatERKSt8valarrayIfEjjbRNS_3MatE", "_ZN2cv6detail15GainCompensator5applyEiNS_6Point_IiEERNS_3MatERKS4_", "_ZN2cv12RMByteStream8getDWordEv", "_ZN2cv11bitwise_xorERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZN2cv6detail14FeatherBlender5blendERNS_3MatES3_", "_ZN2cv3ocl15CvSVMKernel_oclC2EPK11CvSVMParamsMS1_FviiPfRNS_3MatEEM11CvSVMKernelFviiPPKfSC_S5_E", "_ZNK2cv5MatOp6divideERKNS_7MatExprES3_RS1_d", "_ZN3Imf9InputFile4DataC2Ebi", "_ZN2cv6formatEPKcz", "_ZN2cv9LDetectorC2Eiiiidd", "uv_decode", "Java_org_opencv_core_Core_phase_11", "cvUndistortPoints", "png_get_io_chunk_type", "_ZNK2cv8GlCamera21setupProjectionMatrixEv", "_ZNK2cv7linemod11DepthNormal4nameEv", "_ZN2cv3ocl5canny11calcMap_gpuERNS0_6oclMatES3_S3_S3_iiff", "_ZNK2cv10BmpEncoder10newEncoderEv", "_ZNK2cv8Subdiv2D8nextEdgeEi", "TIFFReadEXIFDirectory", "_Z27icvCvt_BGR5552Gray_8u_C2C1RPKhiPhi6CvSize", "_ZN23CvNormalBayesClassifier5trainERKN2cv3MatES3_S3_S3_b", "_ZN2cv3ocl15CvSVMKernel_ocl8calc_rbfEiiPfRNS_3MatE", "_ZN2cv8superres27createSuperResolution_BTVL1Ev", "_ZN2cv3ogl6Buffer9unmapHostEv", "_Znaj", "_ZN2cv17MagnoRetinaFilter15clearAllBuffersEv", "_ZN7testing8internal12UnitTestImplD1Ev", "_ZN3Imf6Header16pixelAspectRatioEv", "Java_org_opencv_ml_CvParamGrid_get_1min_1val_10", "_ZN2cv20fastNlMeansDenoisingERKNS_11_InputArrayERKNS_12_OutputArrayEfii", "_Z24VResizeLinearVec_32f_avxPPKhPhS0_i", "_ZN2cv3ocl17KNearestNeighbourD0Ev", "_ZN7testing18TestEventListeners6AppendEPNS_17TestEventListenerE", "_ZN2cv9videostab17OnePassStabilizer14estimateMotionEv", "jas_image_strtofmt", "jpc_qmfb_join_row", "_ZN2cv7putTextERNS_3MatERKSsNS_6Point_IiEEidNS_7Scalar_IdEEiib", "_ZN2cv3of211ChowLiuTree3addERKSt6vectorINS_3MatESaIS3_EE", "_ZN2cv3LUTERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "Java_org_opencv_imgproc_Imgproc_dilate_11", "_ZN2cv6Mesh3DC2ERKSt6vectorINS_7Point3_IfEESaIS3_EE", "_Z21vector_Point3i_to_MatRSt6vectorIN2cv7Point3_IiEESaIS2_EERNS0_3MatE", "_ZN2cv6detail18SurfFeaturesFinderC1Ediiii", "_ZN2cv11_InputArrayC2ERKNS_9GlTextureE", "png_malloc_warn", "_ZNK3Imf15OpaqueAttribute4copyEv", "jpc_bitstream_inalign", "TIFFCIELabToXYZ", "_ZNK2cv8Subdiv2D11checkSubdivEv", "_ZN7testing8internal13CaptureStdoutEv", "cvNextTreeNode", "__addsf3", "_ZN2cv20DTreeBestSplitFinderC2EP7CvDTreeP11CvDTreeNode", "_ZNK5Graph13floydWarshallERN2cv3MatEi", "_ZN2cv12HOGEvaluatorD1Ev", "_ZN3Imf13B44Compressor10uncompressEPKciiRS2_", "_ZN2cv9ExceptionD1Ev", "_ZN2cv3gpu6GpuMatC1EiiiPvj", "_ZN7testing8internal12AssertHelperC1ENS_14TestPartResult4TypeEPKciS5_", "_ZN2cv3ocl22buildWarpSphericalMapsENS_5Size_IiEENS_5Rect_IiEERKNS_3MatES7_fRNS0_6oclMatES9_", "_ZN2cv20OneWayDescriptorBaseD1Ev", "_ZN2cv9videostab15VideoFileSource9nextFrameEv", "_ZN3Imf14TypedAttributeINS_9LineOrderEE14staticTypeNameEv", "_TIFFSwab64BitData", "_ZN2cv10BriskLayerC1ERKNS_3MatEff", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1bp_1moment_1scale_10", "_ZN2cv9videostab15MotionInpainterC1Ev", "_ZN2cv14RandomizedTreeD2Ev", "Java_org_opencv_features2d_GenericDescriptorMatcher_knnMatch_10", "_ZNK2cv15FeatureDetector6detectERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "cvFloodFill", "_ZN10__cxxabiv119__pointer_type_infoD0Ev", "_ZN2cv3ocl12StereoBM_OCL24checkIfGpuCallReasonableEv", "_ZN2cv9FormattedC1ERKNS_3MatEPKNS_9FormatterEPKi", "_ZNK3Imf6Header5beginEv", "Java_org_opencv_calib3d_Calib3d_decomposeProjectionMatrix_10", "_ZN15CvFuzzyFunction8newCurveEv", "_ZNK7testing8internal8FilePath19RemoveDirectoryNameEv", "_ZN2cv3MatC1EPK5CvMatb", "_Z13resize_opencvP9_IplImagef", "_ZN2cv3ocl6divideEdRKNS0_6oclMatERS1_", "_Z26icvCvt_BGRA2Gray_16u_CnC1RPKtiPti6CvSizeii", "Java_org_opencv_imgproc_Subdiv2D_getVertex_10", "Java_org_opencv_ml_CvRTParams_delete", "_ZN2cv14pointCloudShowERKSsRKNS_8GlCameraERKNS_8GlArraysE", "Java_org_opencv_features2d_GenericDescriptorMatcher_getTrainKeypoints_10", "_Z30icvGetQuadrangleSubPix_32f_C1RPKfi6CvSizePfiS1_S0_", "jpc_tagtree_encode", "_ZN2cv25BOWImgDescriptorExtractorC1ERKNS_3PtrINS_19DescriptorExtractorEEERKNS1_INS_17DescriptorMatcherEEE", "_ZN7CvBoost5trainEP8CvMLData13CvBoostParamsb", "_ZNK2cv3ocl7Context20getOpenCLDeviceIDPtrEv", "_ZN2cv3ocl8subtractERKNS0_6oclMatERKNS_7Scalar_IdEERS1_S3_", "_ZNK2cv23VectorDescriptorMatcher5cloneEb", "jpc_putdata", "jpeg_idct_1x1", "Java_org_opencv_contrib_FaceRecognizer_load_10", "_ZN3Imf7KeyCodeC1ERKS0_", "_ZN6cvtest8TSParamsC1Ev", "Java_org_opencv_core_Core_PCAProject_10", "cvBoundingRect", "_ZN7testing8internal20SingleFailureCheckerC1EPKNS_19TestPartResultArrayENS_14TestPartResult4TypeERKSs", "_ZN2cv25groupRectangles_meanshiftERSt6vectorINS_5Rect_IiEESaIS2_EERS0_IdSaIdEES8_dNS_5Size_IiEE", "_ZN3Imf13PizCompressorC1ERKNS_6HeaderEjj", "_ZN2cv23OneWayDescriptorMatcherC1ERKNS0_6ParamsE", "_ZN7testing32ScopedFakeTestPartResultReporterC1ENS0_13InterceptModeEPNS_19TestPartResultArrayE", "_ZN2cv11writeScalarERNS_11FileStorageEd", "_ZN2cv3ocl6oclMat8createExENS_5Size_IiEEiNS0_8DevMemRWENS0_10DevMemTypeE", "_ZN7testing8UnitTest18GetMutableTestCaseEi", "png_get_PLTE", "_ZNK2cv10Eigenfaces4infoEv", "_ZN22CameraWrapperConnector16setPathLibFolderERKSs", "_ZN3Imf6Header11compressionEv", "_ZN2cv3ogl9Texture2DC1EiiNS1_6FormatEb", "_ZN2cv9Algorithm3setEPKci", "jpc_ppxstab_grow", "_ZN2cv3ocl11interpolate17forwardWarpKernelERKNS0_6oclMatERS2_S4_S4_fii", "icvProjectPointToDirect", "_ZN6cvtest8BaseTest21validate_test_resultsEi", "jpc_cod_gettsfb", "_ZN2cv7PrintToERKNS_5Size_IiEEPSo", "jpc_tagtree_reset", "_ZNK2cv10ExrDecoder4typeEv", "_ZN6cvtest16printVersionInfoEb", "_ZNK2cv5MatOp3roiERKNS_7MatExprERKNS_5RangeES6_RS1_", "_ZN2cv13Jpeg2KEncoderD1Ev", "_ZN7SamplerC1EP5CvMat7CvPointS2_S2_", "_ZN2cv16CvFeatureTrackerC1ENS_22CvFeatureTrackerParamsE", "Java_org_opencv_ml_EM_train_10", "_ZNK3Imf11FrameBuffer5beginEv", "cvFindNearestPoint2D", "_ZN3Imf18longitudeAttributeERKNS_6HeaderE", "_ZNK9CvGBTrees7get_lenEPK5CvMat", "icvCreateIsometricImage", "_ZN8CvRTrees15get_train_errorEv", "_ZN6cvtest12smoothBorderERN2cv3MatERKNS0_7Scalar_IdEEi", "_ZN2cv21FernDescriptorMatcher6ParamsC1EiiiiiiiRKNS_14PatchGeneratorE", "_ZN2cv2EM22computeLogWeightDivDetEv", "_ZN2cv3ocl4MOG210initializeENS_5Size_IiEEi", "__mulsf3", "_ZN7testing8UnitTestD0Ev", "_ZN7testing4Test18HasNonfatalFailureEv", "_ZN2cv6detail18GraphCutSeamFinderC2Eiff", "_ZN11CvStatModel4readEP13CvFileStorageP10CvFileNode", "_ZN9CvANN_MLPC1ERKN2cv3MatEidd", "_ZN2cv17CommandLineParser3hasERKSs", "_ZN2cv6Mesh3D11clearOctreeEv", "png_get_gAMA_fixed", "cvSeqSort", "_ZN24CirclesGridClusterFinder16getSortedCornersERKSt6vectorIN2cv6Point_IfEESaIS3_EES7_S7_RS5_", "_ZN2cv7linemod18DepthNormalPyramidC1ERKNS_3MatES4_iiji", "_ZN2cv15CvHybridTrackerD2Ev", "_ZN2cv8internal22ComputeExtrinsicRefineERKNS_3MatES3_RS1_S4_S4_iRKNS0_15IntrinsicParamsEd", "_ZN2cv16GeneralizedHough11setTemplateERKNS_11_InputArrayEiNS_6Point_IiEE", "_ZNK2cv19DescriptorExtractor7computeERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZN2cv17LogPolar_AdjacentC2EiiNS_6Point_IiEEiddiii", "_ZN6cvtest21getMatchedPointsCountERSt6vectorIN2cv8KeyPointESaIS2_EES5_", "cvCloneMat", "png_crc_error", "jpc_ns_analyze", "Java_org_opencv_calib3d_Calib3d_correctMatches_10", "_ZN2cv17DescriptorMatcher11isMaskedOutERKSt6vectorINS_3MatESaIS2_EEi", "_ZN7CvDTree9read_nodeEP13CvFileStorageP10CvFileNodeP11CvDTreeNode", "Java_org_opencv_ml_CvERTrees_train_10", "_ZN2cv9magnitudeEPKfS1_Pfi", "_ZN2cv6detail16MultiBandBlender4feedERKNS_3MatES4_NS_6Point_IiEE", "jp2_validate", "cvCrossProduct", "_ZN2cvplERKNS_7MatExprERKNS_3MatE", "_ZN2cv3ocl11addWeightedERKNS0_6oclMatEdS3_ddRS1_", "Java_org_opencv_gpu_Gpu_resetDevice_10", "_ZN9IlmThread9SemaphoreD2Ev", "Java_org_opencv_core_Core_bitwise_1and_11", "_ZNK2cv3of26FabMap25getTrainingImgDescriptorsEv", "cvReprojectImageTo3D", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRNS_3MatEbMS1_FS5_vEMS1_FvRKS5_ERKSs", "_ZN7CvDTree8prune_cvEv", "_ZN3Imf8TimeCode15setTimeAndFlagsEjNS0_7PackingE", "_ZN2cv17CascadeClassifier16setMaskGeneratorENS_3PtrINS0_13MaskGeneratorEEE", "Java_org_opencv_imgproc_Imgproc_intersectConvexConvex_11", "_ZN2cv6detail21BestOf2NearestMatcherC1Ebfii", "cvReadRawDataSlice", "_ZN3Imf11StdIFStreamD1Ev", "_ZNK2cv11_InputArray5totalEi", "_ZNK2cv12StarDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_ZN17CirclesGridFinder23filterOutliersByDensityERKSt6vectorIN2cv6Point_IfEESaIS3_EERS5_", "cvFindRuns", "_ZN2cv16FileNodeIteratorC2Ev", "cvGetGLCMDescriptorStatistics", "_ZNK3Imf14TypedAttributeINS_11CompressionEE12writeValueToERNS_7OStreamEi", "_ZNK2cv10MatOp_GEMM8subtractERKNS_7MatExprES3_RS1_", "_ZN3Imf13newCompressorENS_11CompressionEjRKNS_6HeaderE", "_ZN2cv15LogPolar_Interp10create_mapEiiiid", "_ZNK2cv3ORBclERKNS_11_InputArrayES3_RSt6vectorINS_8KeyPointESaIS5_EE", "_ZN2cv8GlArrays14setNormalArrayERKNS_11_InputArrayE", "cvDistTransform", "cvReleaseGLCM", "_ZN2cv3ocl18createFilter2D_GPUENS_3PtrINS0_14BaseFilter_GPUEEE", "_ZN2cv23BackgroundSubtractorMOG10initializeENS_5Size_IiEEi", "cvLSHQuery", "_Z15icvGetStartEnd1P9CvMatrix36CvSizePfS2_", "_ZNK2cv5flann5Index4saveERKSs", "_ZN10__cxxabiv123__fundamental_type_infoD1Ev", "_ZN2cv3ORBC2Eifiiiiii", "Java_org_opencv_video_KalmanFilter_KalmanFilter_12", "_ZN2cv8superres15SuperResolution9nextFrameERKNS_12_OutputArrayE", "Java_org_opencv_imgproc_Moments_set_1nu11_10", "cvFlip", "dump_passes", "_ZN2cv17LogPolar_Adjacent12to_cartesianERKNS_3MatE", "cvWriteFileNode", "_ZN13CvCalibFilterC2Ev", "Java_org_opencv_contrib_Contrib_applyColorMap_10", "cvMeanShift", "JNI_OnLoad", "_ZN7testing8internal17TestEventRepeater16OnTestProgramEndERKNS_8UnitTestE", "png_get_x_offset_pixels", "_ZN3Imf9InputFileC1ERNS_7IStreamEi", "_ZNK2cv18SimpleBlobDetector6Params5writeERNS_11FileStorageE", "_ZN17CvERTreeTrainData8set_dataEPK5CvMatiS2_S2_S2_S2_S2_RK13CvDTreeParamsbbb", "Java_org_opencv_core_Core_setErrorVerbosity_10", "_ZN2cv17FlannBasedMatcher5clearEv", "_ZN3Imf7ChannelC1ENS_9PixelTypeEiib", "_ZN2cv3ogl6BufferC2Ev", "jas_iccattrval_allowmodify", "_ZN9IlmThread6ThreadC1Ev", "_ZN2cv15FeatureDetector19removeInvalidPointsERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EE", "_ZN2cv7linemod8DetectorC1Ev", "_ZN15CvGBTreesParamsC1Eiiffib", "Java_org_opencv_core_Core_add_11", "_ZN2cv19DescriptorExtractor21removeBorderKeypointsERSt6vectorINS_8KeyPointESaIS2_EENS_5Size_IiEEi", "jpc_mqdec_mpsexchrenormd", "_Z28icvReconstructPointsFor3ViewP5CvMatS0_S0_S0_S0_S0_S0_", "_ZN11CvBoostTree14try_split_nodeEP11CvDTreeNode", "Java_org_opencv_imgproc_Moments_set_1nu02_10", "_ZN2cv17Affine3DEstimator18computeReprojErrorEPK5CvMatS3_S3_PS1_", "png_set_compression_window_bits", "_ZN2cv8clipLineENS_5Size_IiEERNS_6Point_IiEES4_", "_ZN16CvDTreeTrainDataD1Ev", "Java_org_opencv_core_Mat_n_1type", "_ZN3Imf15envmapAttributeERKNS_6HeaderE", "cvSURFParams", "Java_org_opencv_ml_CvSVM_predict_11", "cvGetElemType", "_ZN9CvANN_MLPD2Ev", "jpc_tagtree_create", "_ZN2cv6detail12CameraParamsC1Ev", "_ZN2cv3ocl12fft_teardownEv", "_ZNK2cv8FileNodeixEi", "_ZN2cv20PlanarObjectDetector10setVerboseEb", "_ZN2cv11JpegEncoderD2Ev", "_Z43cvCreateModuleBlobTrackPostProcTimeAverRectv", "Java_org_opencv_core_Mat_n_1mul__JJ", "_ZN7CvBoost11read_paramsEP13CvFileStorageP10CvFileNode", "_ZN16CvObjectDetectorC1EPKc", "_ZN2cv6detail14PlaneWarperGpu4warpERKNS_3gpu6GpuMatERKNS_3MatES8_S8_iiRS3_", "_ZN2cv8subtractERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "_ZN2cv16SunRasterDecoder8readDataERNS_3MatE", "_ZN11CvBoostTree5trainEPK5CvMatiS2_S2_S2_S2_S2_13CvDTreeParams", "Java_org_opencv_core_Core_getCPUTickCount_10", "_ZN2cv6detail21BestOf2NearestMatcher5matchERKNS0_13ImageFeaturesES4_RNS0_11MatchesInfoE", "_Z12freeFFTImagePP14CvLSVMFftImage", "cvGetCaptureDomain", "_ZN2cv6detail21BlocksGainCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_3MatESaIS9_EERKS2_ISt4pairIS9_hESaISF_EE", "png_write_sPLT", "_Z9nextFramePvjS_", "_Unwind_Resume_or_Rethrow", "_ZN2cv6detail11PlaneWarper15detectResultRoiENS_5Size_IiEERNS_6Point_IiEES6_", "_ZN2cvlsERSoRKNS_9TickMeterE", "_ZN11CvSVMSolver13solve_genericER17CvSVMSolutionInfo", "png_write_tEXt", "_ZN11CvFuzzyRule14getOutputCurveEv", "cvSolve", "_ZNK7testing8TestCase17failed_test_countEv", "_ZN21FaceDetectionListElemD2Ev", "_ZN2cv14PatchGeneratorC2Edddbdddddd", "_ZN9IlmThread10ThreadPool4DataC2Ev", "_ZN2cv16ParallelLoopBodyD0Ev", "_ZN7testing19TestPartResultArray6AppendERKNS_14TestPartResultE", "cvDecomposeProjectionMatrix", "_Z9printBitsRSo4half", "_ZN2cv18WriteStructContextD1Ev", "Java_org_opencv_core_Core_transform_10", "Java_org_opencv_core_Core_findNonZero_10", "_ZN2cv10ExrEncoderC2Ev", "_TIFFCheckMalloc", "Java_org_opencv_imgproc_Imgproc_getGaborKernel_10", "Java_org_opencv_core_Core_divide_11", "_TIFFNoRowEncode", "_ZNK5CvSVM7predictEPKfib", "_ZN2cv14getTrackbarPosERKSsS1_", "cvSetOpenGlContext", "_ZN2cv8GlBuffer8copyFromERKNS_11_InputArrayE", "_ZN9CvANN_MLPC2ERKN2cv3MatEidd", "_ZN2cvleERKNS_3MatES2_", "_ZN2cv11MahalonobisERKNS_11_InputArrayES2_S2_", "_ZN2cv8tempfileEPKc", "_ZN7testing8internal27FormatTimeInMillisAsSecondsEx", "_ZN7testing8internal24XmlUnitTestResultPrinter18OnTestIterationEndERKNS_8UnitTestEi", "_ZN4epnp21choose_control_pointsEv", "__fixunsdfdi", "_ZN2cv3ocl11ContextImpl17initializeContextEPvS2_S2_", "_ZN2cv24BackgroundSubtractorMOG2C2Ev", "_ZN17CvFuzzyControllerC1Ev", "cvCreateSpillTree", "_ZNK2cv8GlCamera20setupModelViewMatrixEv", "_ZN3Imf13ZipCompressorD1Ev", "Java_org_opencv_core_Core_calcCovarMatrix_10", "Java_org_opencv_imgproc_Imgproc_isContourConvex_10", "_ZN14CvBlobTrackSeq16GetBlobTrackByIDEi", "Java_org_opencv_core_Core_arrowedLine_11", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1rp_1dw_1min_10", "cvRandInit", "_ZN14CvBlobTrackSeqD1Ev", "_ZN2cv3ocl14bindTexturePtrERKNS0_6oclMatE", "_ZN24CirclesGridClusterFinder8findGridESt6vectorIN2cv6Point_IfEESaIS3_EENS1_5Size_IiEERS5_", "_ZNK3Imf14TypedAttributeINS_15TileDescriptionEE12writeValueToERNS_7OStreamEi", "cvThreshold", "_ZNK2cv20FastFeatureDetector210detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "__ltsf2", "png_get_uint_31", "cvMixChannels", "_ZNK7testing8UnitTest6FailedEv", "_Z17addNullableBorderP16CvLSVMFeatureMapii", "_ZN2cv9Algorithm9setDoubleEPKcd", "Java_org_opencv_video_Video_buildOpticalFlowPyramid_11", "_ZN7CvDTree15find_best_splitEP11CvDTreeNode", "Java_org_opencv_core_Core_sumElems_10", "_ZNK17CirclesGridFinder18getAsymmetricHolesERSt6vectorIN2cv6Point_IfEESaIS3_EE", "_ZN2cv25ForestTreeBestSplitFinderC2ERKS0_NS_5SplitE", "Java_org_opencv_core_Mat_n_1convertTo__JJIDD", "_ZNK17CirclesGridFinder15drawBasisGraphsERKSt6vectorI5GraphSaIS1_EERN2cv3MatEbb", "Java_org_opencv_ml_CvDTreeParams_set_1max_1categories_10", "jas_iccattrval_destroy", "_ZNK2cv5MatOp11augAssignOrERKNS_7MatExprERNS_3MatE", "Java_org_opencv_ml_CvDTreeParams_get_1use_11se_1rule_10", "jpc_ns_invlift_colres", "_ZN2cv11MahalanobisERKNS_11_InputArrayES2_S2_", "_ZN2cv10ExrDecoderC2Ev", "_ZN2cv14SpinImageModel13defaultParamsEv", "_ZN2cv3PtrI7CvMatNDE10delete_objEv", "_ZN3Imf18hasFramesPerSecondERKNS_6HeaderE", "_ZN2cv3ocl12KalmanFilterC1Ev", "_ZN2cv3RNG4fillERKNS_12_OutputArrayEiRKNS_11_InputArrayES6_b", "_ZNK2cv20OneWayDescriptorBase14FindDescriptorEP9_IplImageiRSt6vectorIiSaIiEES6_RS3_IfSaIfEES9_Pf", "Java_org_opencv_imgproc_Moments_set_1mu03_10", "_ZNK2cv14FernClassifierclERKNS_3MatERSt6vectorIfSaIfEE", "_ZNK17CirclesGridFinder10computeRNGER5GraphRSt6vectorIN2cv6Point_IfEESaIS5_EEPNS3_3MatE", "_ZN7CvDTree10read_splitEP13CvFileStorageP10CvFileNode", "_ZNK3Imf14TiledInputFile12isValidLevelEii", "_ZN2cv5flann11IndexParams7setBoolERKSsb", "_ZN2cv17CascadeClassifierC1Ev", "_ZN2cv3ocl20FarnebackOpticalFlow22polynomialExpansionOclERKNS0_6oclMatEiRS2_", "_ZN2cv8Subdiv2D6VertexC1Ev", "_ZNK7testing8internal12UnitTestImpl17failed_test_countEv", "Java_org_opencv_features2d_GenericDescriptorMatcher_radiusMatch_11", "cvRandMVNormal", "_ZN2cv17LogPolar_Adjacent6get_uvEddRiS1_", "_ZNK2cv15FeatureDetector6detectERKSt6vectorINS_3MatESaIS2_EERS1_IS1_INS_8KeyPointESaIS7_EESaIS9_EES6_", "_ZN2cv17DescriptorMatcher20DescriptorCollection5clearEv", "_ZN9IlmThread9Semaphore4postEv", "_ZN6cvtest9minMaxLocERKN2cv3MatEPdS4_PSt6vectorIiSaIiEES8_S3_", "_ZNK2cv12_OutputArray6createEiiiibi", "_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEPPKfdb", "_ZN7CvDTree18cluster_categoriesEPKiiiPiiS2_", "_ZN2cv6detail14FeatherBlender7prepareENS_5Rect_IiEE", "_ZN2cv7fisheye14undistortImageERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_S3_RKNS_5Size_IiEE", "_Z21Mat_to_vector_Point2dRN2cv3MatERSt6vectorINS_6Point_IdEESaIS4_EE", "_ZN2cv10BmpEncoderC1Ev", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEEPv", "_ZNK2cv9Algorithm9paramTypeEPKc", "_ZN2cv8KeyPoint7convertERKSt6vectorIS0_SaIS0_EERS1_INS_6Point_IfEESaIS7_EERKS1_IiSaIiEE", "_ZN21DetectionBasedTracker13setParametersERKNS_10ParametersE", "Java_org_opencv_core_Core_multiply_14", "_ZN16CvCapture_Images11setPropertyEid", "_ZN6cvtest13MatComparatorC2Edi", "cvbCartToPolar", "_ZN7testing8internal27PrettyUnitTestResultPrinter16PrintFailedTestsERKNS_8UnitTestE", "_ZN6cvtest8BaseTest19can_do_fast_forwardEv", "_ZN2cv11FileStorageD2Ev", "_ZNK2cv7linemod13ColorGradient5writeERNS_11FileStorageE", "_ZN7testing8internal31GetCurrentOsStackTraceExceptTopEPNS_8UnitTestEi", "_ZNK2cv6Retina8getParvoEv", "_ZN2cv8superres23createOptFlow_PyrLK_OCLEv", "__nesf2", "cvEndFindContours", "_ZN7testing8internal27PrettyUnitTestResultPrinter16OnTestPartResultERKNS_14TestPartResultE", "Java_org_opencv_imgproc_Imgproc_preCornerDetect_10", "png_handle_IHDR", "_ZN2cv16SunRasterDecoder10readHeaderEv", "_TIFFGetFields", "_ZNK2cv3ocl13HOGDescriptor17checkDetectorSizeEv", "cvOpenFileStorage", "_ZN2cv6detail11PlaneWarper4warpERKNS_3MatES4_S4_S4_iiRS2_", "_ZN3Imf19hasLookModTransformERKNS_6HeaderE", "_ZN6cvtest13DeviceManager8instanceEv", "_ZN2cv10StereoSGBMC1Eiiiiiiiiiib", "_ZN2cv11WBaseStream10writeBlockEv", "_ZThn4_NK2cv3ORB14descriptorSizeEv", "Java_org_opencv_ml_CvRTrees_train_11", "_ZN2cv7linemod13ColorGradient4readERKNS_8FileNodeE", "Java_org_opencv_features2d_GenericDescriptorMatcher_read_10", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRSt6vectorINS_3MatESaIS6_EEbMS1_FS8_vEMS1_FvRKS8_ERKSs", "_ZN2cv9videostab21ColorAverageInpainter7inpaintEiRNS_3MatES3_", "_ZN3Imf14ownerAttributeERNS_6HeaderE", "_ZN7testing8internal11ScopedTraceD2Ev", "_ZN17CvCamShiftTrackerC1Ev", "_ZN2cv3ocl8integralERKNS0_6oclMatERS1_S4_", "_ZN13CvCalibFilter10FindEtalonEPP9_IplImage", "_ZN16CvDTreeTrainData8new_nodeEP11CvDTreeNodeiii", "_ZN2cv21intersectConvexConvexERKNS_11_InputArrayES2_RKNS_12_OutputArrayEb", "jinit_color_converter", "_ZN10__cxxabiv120__si_class_type_infoD1Ev", "Java_org_opencv_imgproc_Imgproc_resize_10", "_ZN2cv5Mutex6unlockEv", "_ZNK7testing8internal12UnitTestImpl16total_test_countEv", "_ZN2cv3MatC1ERKS0_RKNS_5Rect_IiEE", "jas_matrix_destroy", "Java_org_opencv_ml_CvGBTreesParams_set_1weak_1count_10", "_ZN20CvBlobDetectorSimpleD2Ev", "_ZNK2cv5MatOp11elementWiseERKNS_7MatExprE", "_ZN7testing8internal15CodePointToUtf8Ej", "_ZN14CvForestERTree18find_split_ord_regEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN3Imf13PizCompressor8compressEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN17CvModelEstimator2C1Ei6CvSizei", "_ZN7testing8internal24XmlUnitTestResultPrinter16PrintXmlUnitTestEPSoRKNS_8UnitTestE", "_TIFFsetByteArray", "cvWriteComment", "_ZN2cv8Stitcher13createDefaultEb", "_ZN12CvFuzzyCurve7betweenEddd", "_ZN2cv8superres23createFrameSource_EmptyEv", "_ZN3Imf8TimeCodeC2EjjNS0_7PackingE", "png_set_sBIT", "_ZNK3Imf6Header4findERKSs", "_ZN14CvBlobTrackSeq12AddBlobTrackEii", "_ZNK2cv2EM4infoEv", "_ZNK2cv6KDTree14findOrthoRangeERKNS_11_InputArrayES3_RKNS_12_OutputArrayES6_S6_", "_ZN17CSMatrixGenerator11getCSMatrixEiiNS_14PHI_DISTR_TYPEE", "cvUniformImgSegm", "_ZN2cv11RBaseStream6setPosEi", "_ZNK2cv16TLSDataContainer7getDataEv", "cvUnDistortInit", "cvErode", "_ZN2cv16FileNodeIteratorppEi", "_ZN2cv6detail14PlaneWarperGpu4warpERKNS_3gpu6GpuMatERKNS_3MatES8_iiRS3_", "_ZN3Imf10OutputFile4DataC2Ebi", "_ZN7CvBoost5trainEPK5CvMatiS2_S2_S2_S2_S2_13CvBoostParamsb", "_ZN2cv10bitwise_orERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZN2cv15RTreeClassifierC2Ev", "_ZN23CvNormalBayesClassifierC2ERKN2cv3MatES3_S3_S3_", "_ZN2cv12VideoCapture4openEi", "_ZN3Imf11StdOFStreamC2EPKc", "Java_org_opencv_core_Mat_nPutB", "_ZN7testing8UnitTest17AddTestPartResultENS_14TestPartResult4TypeEPKciRKSsS6_", "_ZN2cv11JpegDecoderD2Ev", "_ZNK2cv7linemod8Detector8classIdsEv", "getthebyte", "_ZN7CvBoost15get_active_varsEb", "_ZNK2cv24BriefDescriptorExtractor14descriptorSizeEv", "cvRandSetRange", "_ZN2cv4readERKNS_8FileNodeERNS_9SparseMatERKS3_", "cvFitEllipse2", "_ZN2cv5flann12SearchParamsC1Eifb", "_ZNK2cv5MatOp9transposeERKNS_7MatExprERS1_", "jpc_cstate_create", "_ZN2cv17CascadeClassifier8setImageERKNS_3MatE", "_ZN3Imf7IStream16readMemoryMappedEi", "_ZN3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IiEEEEE13readValueFromERNS_7IStreamEii", "jpc_bitstream_close", "_ZN2cv3ogl6Buffer9mapDeviceEv", "_ZN9CvGBTrees13find_gradientEi", "cvWriteReal", "_ZN2cv16CvFeatureTracker17setTrackingWindowENS_5Rect_IiEE", "Java_org_opencv_core_Core_exp_10", "Java_org_opencv_core_Core_addWeighted_10", "_ZN7testing8internal12UnitTestImplC1EPNS_8UnitTestE", "jpeg_has_multiple_scans", "JPC_SEGPASSCNT", "_ZN2cv10BOWTrainerC2Ev", "_ZN3Imf11TileOffsetsC1ENS_9LevelModeEiiPKiS3_", "jpeg_get_small", "_ZNK2cv11MatOp_AddEx8subtractERKNS_7Scalar_IdEERKNS_7MatExprERS5_", "_ZN3Imf13pixelTypeSizeENS_9PixelTypeE", "_ZN2cv9videostab18FastMarchingMethod7heapAddERKNS1_3DXYE", "jpc_bitstream_putbit_func", "_ZNK3Imf8TimeCode8userDataEv", "_ZNK2cv3ogl6Buffer6copyToERKNS_12_OutputArrayENS1_6TargetEb", "Java_org_opencv_core_Mat_n_1clone", "png_start_read_image", "Java_org_opencv_highgui_VideoCapture_n_1get", "_ZN2cv3ocl15supportsFeatureENS0_12FEATURE_TYPEE", "_ZN2cv9ExceptionC1Ev", "cvRQDecomp3x3", "_ZN7testing8internal8FilePath12MakeFileNameERKS1_S3_iPKc", "_ZN2cv9SparseMat3ptrEibPj", "_ZN2cv7normL1_EPKhS1_i", "Java_org_opencv_calib3d_StereoSGBM_get_1P1_10", "_ZN2cv3ocl6device3hog14classify_histsEiiiiiiiiRKNS0_6oclMatES5_ffRS3_", "_ZNK2cv20DenseFeatureDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "Java_org_opencv_core_Mat_n_1checkVector__JIIZ", "Java_org_opencv_video_Video_CamShift_10", "cvFitLine3D", "TIFFSetField", "_ZN13CvBlobTrackerC2Ev", "cvCheckHardwareSupport", "_ZN2cv9SparseMat5eraseEPKiPj", "_ZN2cv3ocl13HOGDescriptor11init_bufferERKNS0_6oclMatENS_5Size_IiEE", "_ZNK2cv24GenericDescriptorMatcher8classifyERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_S8_", "_ZN2cv3ocl18queryWaveFrontSizeEP10_cl_kernel", "_ZN2cv6detail16MultiBandBlender5blendERNS_3MatES3_", "Java_org_opencv_calib3d_Calib3d_decomposeProjectionMatrix_11", "jpc_tsfb_analyze", "Java_org_opencv_imgproc_Imgproc_morphologyEx_10", "Java_org_opencv_core_Core_clipLine_10", "_ZN2cv3ocl3MOGC1Ei", "png_get_uint_16", "cvCanny", "_Z23icvComputeProjectMatrixP5CvMatS0_S0_", "jpc_dec_pi_create", "_Z8icvMinorPdii", "png_ascii_from_fixed", "Java_org_opencv_core_Core_LUT_11", "_ZN2cv9Exception13formatMessageEv", "cvNormalizeHist", "Java_org_opencv_core_Core_checkRange_11", "cvInitLineIterator", "_ZN7testing8UnitTest14PushGTestTraceERKNS_8internal9TraceInfoE", "Java_org_opencv_core_Core_randShuffle_10", "_ZN7testing8internal26GoogleTestFailureExceptionC1ERKNS_14TestPartResultE", "cvSliceLength", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1rp_1dw0_10", "jpc_ict", "_ZN2cv3ocl11bitwise_andERKNS0_6oclMatERKNS_7Scalar_IdEERS1_S3_", "_ZN2cv17startWindowThreadEv", "_ZN3Imf14adoptedNeutralERNS_6HeaderE", "_ZN7CvDTree15calc_node_valueEP11CvDTreeNode", "icvConvertPointSystem", "_ZN2cv6detail19findMaxSpanningTreeEiRKSt6vectorINS0_11MatchesInfoESaIS2_EERNS0_5GraphERS1_IiSaIiEE", "TIFFDefaultStripSize", "_ZNK3Imf8TimeCode10colorFrameEv", "_ZN2cv12VideoCapture8retrieveERNS_3MatEi", "_ZNK17CirclesGridFinder14getFirstCornerERSt6vectorIN2cv6Point_IiEESaIS3_EES6_S6_S6_", "_ZN6cvtest7extractERKN2cv3MatERS1_i", "Java_org_opencv_features2d_DescriptorExtractor_delete", "_ZN2cv10PxMDecoder8readDataERNS_3MatE", "_ZN2cv11mixChannelsERKNS_11_InputArrayES2_RKSt6vectorIiSaIiEE", "_ZN2cv15NAryMatIteratorC2Ev", "_ZN7testing8internal18OsStackTraceGetter16UponLeavingGTestEv", "_ZN3Imf8altitudeERKNS_6HeaderE", "_Z30GetGoodReduceFundamMatrFromTwoP5CvMatS0_S0_", "_ZN2cv10BOWTrainer5clearEv", "jpc_mqenc_dump", "Java_org_opencv_core_Mat_n_1reshape__JII", "_ZN2cv17borderInterpolateEiii", "_ZNK8CvRTrees7getNameEv", "Java_org_opencv_contrib_StereoVar_set_1penalization_10", "_ZN2cv9StereoVarD2Ev", "_ZN3Imf11StdOFStreamC2ERSt14basic_ofstreamIcSt11char_traitsIcEEPKc", "TIFFGetMode", "_ZN2cv3ocl20FarnebackOpticalFlowC1Ev", "_ZN2cv3ocl11sepFilter2DERKNS0_6oclMatERS1_iRKNS_3MatES7_NS_6Point_IiEEdi", "_ZN2cv17DescriptorMatcher20DescriptorCollectionD1Ev", "_ZN3Imf14TypedAttributeIN5Imath4Vec3IfEEE14staticTypeNameEv", "_ZN13CvBlobTracker13GetBlobHypNumEi", "_ZNK3Imf13PizCompressor12numScanLinesEv", "png_get_user_height_max", "_ZNK2cv9Algorithm9paramHelpERKSs", "Java_org_opencv_core_Core_Mahalanobis_10", "_ZNK2cv19DescriptorExtractor5emptyEv", "_ZN2cv23adaptiveBilateralFilterERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddNS_6Point_IiEEi", "_ZN2cv12cornerSubPixERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEES7_NS_12TermCriteriaE", "cvCalcAffineFlowPyrLK", "_ZN2cv17BasicRetinaFilter25_verticalAnticausalFilterEPfjj", "_ZN2cv3gpu10DeviceInfo5queryEv", "_ZNK2cv16BaseImageEncoder10newEncoderEv", "_Z23cvCreateBlobTrackerListPFP16CvBlobTrackerOnevE", "_ZN6cvtest8BaseTest17prepare_test_caseEi", "_ZN3Imf8timeCodeERNS_6HeaderE", "_ZN2cv8GlBufferC2EiiiNS0_5UsageE", "_ZN2cv14RandomizedTree4readERSii", "_Z38DistanceTransformOneDimensionalProblemPKfiffPfPi", "_ZN3Imf13PizCompressor14uncompressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN2cv10PxMDecoder5closeEv", "_Z18icvRank2ConstraintPd", "_ZN9IlmThread10ThreadPool4Data4stopEv", "_ZN3Imf8apertureERKNS_6HeaderE", "Java_org_opencv_core_Core_min_10", "cvSeqElemIdx", "_ZN2cv9seqRemoveEP5CvSeqi", "png_do_unpack", "_ZN11CvSVMSolver12get_row_baseEiPb", "_ZN2cv3LDA4loadERKSs", "_ZN13CvBlobTracker11DelBlobByIDEi", "_ZN2cv6detail12DpSeamFinderC1ENS1_12CostFunctionE", "_ZN21DetectionBasedTrackerD2Ev", "_ZN2cv8GlBufferC1ERKNS_11_InputArrayENS0_5UsageE", "_ZN7testing8internal13ExecDeathTest10AssumeRoleEv", "TIFFIsUpSampled", "_ZN21CvANN_MLP_TrainParamsC2Ev", "_ZN2cv21FernDescriptorMatcherC1ERKNS0_6ParamsE", "_ZN2cv10BaseFilter5resetEv", "_ZN3Imf17addAdoptedNeutralERNS_6HeaderERKN5Imath4Vec2IfEE", "TIFFFillTile", "Java_org_opencv_ml_CvBoostParams_get_1weak_1count_10", "Java_org_opencv_features2d_GenericDescriptorMatcher_delete", "jas_image_getcmptbytype", "jpc_ns_synthesize", "_ZNKSt8bad_cast4whatEv", "_ZNK2cv5MatOp12augAssignAddERKNS_7MatExprERNS_3MatE", "_ZN7testing14KilledBySignalC2Ei", "Java_org_opencv_ml_CvNormalBayesClassifier_CvNormalBayesClassifier_12", "TIFFFlushData", "_ZNK3Imf11FrameBuffer4findEPKc", "_ZN3Imf8latitudeERKNS_6HeaderE", "Java_org_opencv_objdetect_CascadeClassifier_detectMultiScale_12", "Java_org_opencv_imgproc_Moments_set_1m21_10", "_ZN2cv12GFTTDetectorC2Eiddibd", "_ZN2cv9videostab15VideoFileSource5resetEv", "png_write_cHRM_fixed", "_ZN2cv3gpu9getDeviceEv", "jpc_bitstream_pending", "_ZN2cv8internal17ComputeHomographyENS_3MatES1_", "_ZN2cv8Stitcher11matchImagesEv", "TIFFWriteBufferSetup", "_ZNK4CvEM11get_weightsEv", "Java_org_opencv_video_KalmanFilter_correct_10", "_ZN10__cxxabiv119__foreign_exceptionD1Ev", "TIFFSetClientdata", "jas_stream_pad", "_ZN11CvSVMKernel17calc_non_rbf_baseEiiPPKfS1_Pfdd", "_ZN2cv3ocl24OpticalFlowDual_TVL1_OCLC2Ev", "_ZN3Imf6HeaderixEPKc", "_ZN2cv3ocl5errorEPKcS2_iS2_", "_ZNSt10bad_typeidD1Ev", "Java_org_opencv_video_KalmanFilter_KalmanFilter_10", "Java_org_opencv_gpu_DeviceInfo_deviceID_10", "_ZN2cv11RNG_MT19937clEj", "_ZN2cv12KalmanFilterC1Ev", "TIFFTileSize", "_ZN2cv25ForestTreeBestSplitFinderclERKNS_12BlockedRangeE", "_ZN2cv6detail14FeatherBlender16createWeightMapsERKSt6vectorINS_3MatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_", "_ZN3Imf6Header14setMaxTileSizeEii", "_ZN3Imf7IStreamD2Ev", "Java_org_opencv_objdetect_HOGDescriptor_get_1cellSize_10", "_ZN3Imf23adoptedNeutralAttributeERKNS_6HeaderE", "_ZN11CvBoostTreeD2Ev", "_ZN2cv16FeatureEvaluator9setWindowENS_6Point_IiEE", "_ZN6cvtest3setERN2cv3MatERKNS0_7Scalar_IdEERKS1_", "_ZN2cv9GlTexture6createEiii", "png_calculate_crc", "_ZN2cv3gpu6GpuMat9adjustROIEiiii", "_ZlsRSo4half", "__gcc_personality_v0", "_ZN2cv10normL2Sqr_EPKfS1_i", "_ZN2cv3of213BOWMSCTrainerC1Ed", "_ZN2cv14ChamferMatcher26LocationScaleImageIterator4nextEv", "_ZNK7testing8TestCase11GetTestInfoEi", "TIFFInitPixarLog", "_ZNK2cv5flann11IndexParams6getAllERSt6vectorISsSaISsEERS2_IiSaIiEES5_RS2_IdSaIdEE", "_ZN2cv3ocl16getOpenCLDevicesERSt6vectorIPKNS0_10DeviceInfoESaIS4_EEiPKNS0_12PlatformInfoE", "cvCalcEMD", "_ZN2cv23VectorDescriptorMatcher5trainEv", "_ZN7testing10TestResultD1Ev", "_ZN2cv8Subdiv2D8QuadEdgeC2Ei", "_ZN2cv3ocl15CvSVMKernel_ocl4calcEiiPfRNS_3MatE", "_ZNK2cv7MatOp_T9transposeERKNS_7MatExprERS1_", "_ZNK3Imf14TypedAttributeINS_11ChannelListEE12writeValueToERNS_7OStreamEi", "_ZN3Imf7OStreamC1EPKc", "jpc_ms_create", "_ZSt14set_unexpectedPFvvE", "_ZN9IlmThread5MutexC2Ev", "_ZN4perf8TestBase12declareArrayERSt6vectorISt4pairIiN2cv5Size_IiEEESaIS6_EERKNS3_12_OutputArrayEi", "Java_org_opencv_calib3d_Calib3d_matMulDeriv_10", "_ZNK2cv11FileStorageixEPKc", "Java_org_opencv_core_Core_normalize_11", "_ZN2cv24BackgroundSubtractorMOG210initializeENS_5Size_IiEEi", "cvCalcArrBackProjectPatch", "jpeg_write_raw_data", "_ZN7CvDTree17complete_node_dirEP11CvDTreeNode", "_ZNK2cv13AlgorithmInfo9paramHelpEPKc", "_ZN9CvLevMarqC2Eii14CvTermCriteriab", "_ZN2cv20PlanarObjectDetector5trainERKSt6vectorINS_3MatESaIS2_EERKS1_INS_8KeyPointESaIS7_EEiiiiRKNS_9LDetectorERKNS_14PatchGeneratorE", "_ZN2cv20OneWayDescriptorBase10SetPCAHighEP5CvMatS2_", "cvGraphAddEdgeByPtr", "_ZN13FaceDetectionD1Ev", "_ZNSt8bad_castD1Ev", "_ZN13CvBoostParamsC2Ev", "_Z12FillGrayRow1PhS_iS_", "cvReleaseFeatureTree", "_ZNK3Imf17ScanLineInputFile6headerEv", "_ZN2cv3ocl12KalmanFilterC2Eiiii", "_ZN7testing8internal6String13CStringEqualsEPKcS3_", "_ZN3Imf15Pxr24CompressorD2Ev", "_ZN2cv3of29FabMapLUTD1Ev", "_ZN2cv11_InputArrayC1ERKNS_9GlTextureE", "Java_org_opencv_core_Core_mixChannels_10", "_ZN2cv25getOptimalNewCameraMatrixERKNS_11_InputArrayES2_NS_5Size_IiEEdS4_PNS_5Rect_IiEEb", "_ZN2cv12seqPushFrontEP5CvSeqPKv", "_ZN2cv23OneWayDescriptorMatcher12knnMatchImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEiRKS4_IS1_SaIS1_EEb", "_ZNK2cv14FernClassifier13getClassCountEv", "_ZN22CvAdaptiveSkinDetectorD0Ev", "_Z18icvAnalyticPoints8PdiS_", "_ZN3Imf18isValidCompressionENS_11CompressionE", "_ZN8CvMLData13get_responsesEv", "jpeg_resync_to_restart", "cvCreateSubdiv2D", "_ZN2cv22createMorphologyFilterEiiRKNS_11_InputArrayENS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv14ChamferMatcher21LocationImageIteratorC2ERKSt6vectorINS_6Point_IiEESaIS4_EEiff", "_ZN2cv3ocl20BackgroundSubtractorD2Ev", "_ZN2cv10PxMEncoderC1Ev", "_Z23cvCreateBlobTrackerMSPFv", "_ZNK10__cxxabiv117__pbase_type_info10__do_catchEPKSt9type_infoPPvj", "_ZN2cv22OneWayDescriptorObjectD2Ev", "cvScaleAdd", "_ZN3Imf11StdOSStream5seekpEy", "Java_org_opencv_video_BackgroundSubtractorMOG_BackgroundSubtractorMOG_11", "_ZN2cv3of26FabMap20compareImgDescriptorERKNS_3MatEiRKSt6vectorIS2_SaIS2_EERS5_INS0_6IMatchESaISA_EE", "cvFitEllipse", "_ZN2cv23getPerspectiveTransformERKNS_11_InputArrayES2_", "_ZN6cvtest13MatComparatorclEPKcS2_RKN2cv3MatES6_", "TIFFRegisterCODEC", "_ZN2cv8Subdiv2D11calcVoronoiEv", "_Z19Mat_to_vector_PointRN2cv3MatERSt6vectorINS_6Point_IiEESaIS4_EE", "png_set_mem_fn", "_ZNK2cv10PxMEncoder10newEncoderEv", "Java_org_opencv_imgproc_Imgproc_distanceTransformWithLabels_11", "_ZN2cv8fillPolyERKNS_12_OutputArrayERKNS_11_InputArrayERKNS_7Scalar_IdEEiiNS_6Point_IiEE", "jas_tvparser_getval", "_ZN22CameraWrapperConnector23getDefaultPathLibFolderEv", "_ZN2cv17MagnoRetinaFilterD2Ev", "_ZNK2cv5flann5Index12getAlgorithmEv", "_ZN2cv3ocl11ContextImpl14cleanupContextEv", "_ZN6cvtest8TestInfoC2Ev", "cvConvertMaps", "png_get_uint_32", "icvGetPieceLength", "_ZN2cv6detail10overlapRoiENS_6Point_IiEES2_NS_5Size_IiEES4_RNS_5Rect_IiEE", "_ZN16EllipticKeyPoint22getSecondMomentsMatrixERKN2cv7Scalar_IdEE", "Java_org_opencv_contrib_StereoVar_set_1levels_10", "_ZN2cv6detail14PlaneWarperGpu9buildMapsENS_5Size_IiEERKNS_3MatES6_S6_RNS_3gpu6GpuMatES9_", "jas_init", "_ZN2cv16OneWayDescriptor10ReadByNameEP13CvFileStorageP10CvFileNodePKc", "_ZN7CvDTreeD0Ev", "_ZNK2cv3ocl13HOGDescriptor21getBlockHistogramSizeEv", "_ZN3Imf14TiledInputFile4DataD2Ev", "_ZN2cv6detail12DpSeamFinder18hasOnlyOneNeighborEi", "_ZN2cv3ocl16PyrLKOpticalFlow5denseERKNS0_6oclMatES4_RS2_S5_PS2_", "_ZNK7CvDTree11write_splitEP13CvFileStorageP12CvDTreeSplit", "_ZN7testing8UnitTest27parameterized_test_registryEv", "_ZNK2cv13AlgorithmInfo3setEPNS_9AlgorithmEPKciPKvb", "_ZN20CvVideoWriter_Images10writeFrameEPK9_IplImage", "_ZN2cv18reprojectImageTo3DERKNS_11_InputArrayERKNS_12_OutputArrayES2_bi", "_ZN2cv16setMouseCallbackERKSsPFviiiiPvES2_", "_ZN2cv6detail11MatchesInfoC1Ev", "Java_org_opencv_core_Core_mulTransposed_12", "cvDotProduct", "_ZNK2cv13AlgorithmInfo9getParamsERSt6vectorISsSaISsEE", "png_zalloc", "_ZN2cvorERKNS_3MatES2_", "_ZN2cv6Mesh3D14computeNormalsEfi", "TIFFGetBitRevTable", "_ZN2cv5writeERNS_11FileStorageERKSsi", "_ZN10CvVSModuleD0Ev", "_Z21vector_Point2f_to_MatRSt6vectorIN2cv6Point_IfEESaIS2_EERNS0_3MatE", "_ZN2cv18getLinearRowFilterEiiRKNS_11_InputArrayEii", "_ZN2cv3ocl23getMorphologyFilter_GPUEiiRKNS_3MatERKNS_5Size_IiEENS_6Point_IiEE", "png_do_read_invert_alpha", "_ZN2cv17DescriptorMatcher20DescriptorCollectionC1ERKS1_", "_ZN3Imf11FrameBuffer4findERKSs", "_ZN17CvCapture_Android18prepareCacheForYUVEii", "_ZN2cv17DescriptorMatcher20DescriptorCollectionC1Ev", "Java_org_opencv_objdetect_HOGDescriptor_delete", "_ZN8CvMatrix4loadEPKcS1_i", "TIFFGetSeekProc", "cvProjectPCA", "_ZN2cv3of26FabMapD2Ev", "_ZN14CvForestERTree15split_node_dataEP11CvDTreeNode", "cvNot", "_ZN12CvForestTreeC1Ev", "Java_org_opencv_objdetect_HOGDescriptor_setSVMDetector_10", "_ZN2cv17DescriptorMatcher6createERKSs", "png_get_pCAL", "_Z21Mat_to_vector_Point3iRN2cv3MatERSt6vectorINS_7Point3_IiEESaIS4_EE", "_ZNK7testing8internal8FilePath28CreateDirectoriesRecursivelyEv", "_ZN2cv12HOGEvaluator9setWindowENS_6Point_IiEE", "_ZN3Imf18utcOffsetAttributeERNS_6HeaderE", "_ZN2cv2EM5clearEv", "_ZN8CvRTreesD0Ev", "_ZN2cv12KalmanFilterC2Ev", "_ZN3Imf6Header9lineOrderEv", "_ZN2cv3ogl6Arrays14setAutoReleaseEb", "_ZN2cv12VideoCapture4grabEv", "_ZN4perf8TestBase14_declareHelper3outERKN2cv12_OutputArrayEi", "_ZN2cv6detail11MatchesInfoaSERKS1_", "jas_iccprof_getattr", "_ZN7testing8internal30GetBoolAssertionFailureMessageERKNS_15AssertionResultEPKcS5_S5_", "png_handle_oFFs", "_ZN2cv17SelfSimDescriptorD1Ev", "Java_org_opencv_calib3d_Calib3d_stereoRectify_11", "_ZN7testing8internal24XmlUnitTestResultPrinter9EscapeXmlERKSsb", "Java_org_opencv_ml_CvBoostParams_set_1split_1criteria_10", "_Z20icvSepConvSmall3_32fPfiS_i6CvSizePKfS2_S_", "_ZN2cv17DescriptorMatcher5clearEv", "cvCreateObsInfo", "_ZNK2cv16BOWKMeansTrainer7clusterEv", "_ZN2cv6detail20BundleAdjusterReproj12calcJacobianERNS_3MatE", "_ZN9CvGBTreesC2EPK5CvMatiS2_S2_S2_S2_S2_15CvGBTreesParams", "Java_org_opencv_calib3d_Calib3d_projectPoints_10", "_ZN2cv3of27FabMap1D1Ev", "cvCalcArrBackProject", "_ZN2cv6detail18GraphCutSeamFinder4Impl24setGraphWeightsColorGradERKNS_3MatES5_S5_S5_S5_S5_S5_S5_R7GCGraphIfE", "TIFFWriteEncodedStrip", "_Z15icvGetStartEnd4P9CvMatrix36CvSizePfS2_", "_ZN2cvmiERKNS_16MatConstIteratorES2_", "cvSetRealND", "Java_org_opencv_calib3d_Calib3d_stereoCalibrate_11", "_ZN2cv17CascadeClassifier16detectMultiScaleERKNS_3MatERSt6vectorINS_5Rect_IiEESaIS6_EEdiiNS_5Size_IiEESB_", "_ZN14CvBlobTrackSeq15GetBlobTrackNumEv", "_ZN2cv6GlFont3getERKSsiNS0_6WeightENS0_5StyleE", "Java_org_opencv_core_Core_add_10", "_ZN2cv11TiffEncoderD0Ev", "_ZN3Imf10OutputFile14setFrameBufferERKNS_11FrameBufferE", "_ZN2cveoERKNS_7Scalar_IdEERKNS_3MatE", "_ZN3Imf13ZipCompressor8compressEPKciiRS2_", "_Z19showRootFilterBoxesP9_IplImagePK18CvLSVMFilterObjectP7CvPointPii8CvScalariii", "_Z19cvReleaseFGDetectorPP12CvFGDetector", "_ZN3Imf17ScanLineInputFile10readPixelsEii", "Java_org_opencv_ml_CvGBTrees_predict_11", "_ZN2cv13HOGDescriptor4loadERKSsS2_", "_ZN2cv12VideoCaptureD1Ev", "_ZN2cv25stereoRectifyUncalibratedERKNS_11_InputArrayES2_S2_NS_5Size_IiEERKNS_12_OutputArrayES7_d", "_ZN2cv5BRISKD0Ev", "_Z20icvFindClusterLabelsPK5CvMatffS1_", "_ZN2cv19goodFeaturesToTrackERKNS_11_InputArrayERKNS_12_OutputArrayEiddS2_ibd", "Java_org_opencv_gpu_TargetArchs_hasEqualOrGreater_10", "_TIFFFindOrRegisterField", "_ZN3Imf11addApertureERNS_6HeaderERKf", "_ZN7testing8internal15NoExecDeathTest10AssumeRoleEv", "_ZNK2cv8HOGCache23normalizeBlockHistogramEPf", "_ZN2cv11RetinaColorC2EjjNS_26RETINA_COLORSAMPLINGMETHODE", "_ZNK2cv3Mat3invEi", "_ZN2cv20saveWindowParametersERKSs", "_ZN2cv3ogl6ArraysC1Ev", "_ZN7testing8internal9DeathTest27set_last_death_test_messageERKSs", "_ZN2cv14PatchGeneratorC1Ev", "_ZN12ocl_tvl1flow9estimateUERN2cv3ocl6oclMatES3_S3_S3_S3_S3_S3_S3_S3_S3_S3_ffc", "_ZN2cv3ocl10DeviceInfoD1Ev", "_ZN7CvBoostC1Ev", "jpc_getuint32", "_ZNK2cv32OpponentColorDescriptorExtractor14descriptorTypeEv", "cvSplit", "_ZNK2cv11MatOp_AddEx3absERKNS_7MatExprERS1_", "TIFFRGBAImageBegin", "_ZN2cv5writeERNS_11FileStorageERKSsf", "_ZN11CvFuzzyRuleD2Ev", "_ZN7testing8internal2RED2Ev", "jas_iccattrval_dump", "cvGetGLCMDescriptor", "cvLSHRemove", "_ZN2cv5splitERKNS_11_InputArrayERKNS_12_OutputArrayE", "Java_org_opencv_ml_CvSVM_delete", "cvUpdateWindow", "Java_org_opencv_imgproc_Imgproc_convertMaps_11", "_ZN2cv11TiffEncoderC1Ev", "_ZN2cv8Subdiv2D8newPointENS_6Point_IfEEbi", "_ZN2cv10cvarrToMatEPKvbbi", "_ZN2cv6detail17BundleAdjusterRay9calcErrorERNS_3MatE", "_ZN9CvANN_MLP5clearEv", "png_read_rows", "_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv", "png_get_signature", "png_do_read_intrapixel", "_TIFFrealloc", "_ZNK2cv24BackgroundSubtractorMOG24infoEv", "_ZNK2cv20DenseFeatureDetector4infoEv", "_ZN2cv3of29FabMapFBO14getLikelihoodsERKNS_3MatERKSt6vectorIS2_SaIS2_EERS5_INS0_6IMatchESaISA_EE", "_ZN2cv3ocl3MOG10initializeENS_5Size_IiEEi", "_ZNK7testing8internal12UnitTestImpl17test_to_run_countEv", "cvMaxS", "jas_taginfos_lookup", "_ZN2cv11seqPopFrontEP5CvSeqPv", "_ZN9IlmThread5MutexD1Ev", "_ZN2cv9videostab25ensureInclusionConstraintERKNS_3MatENS_5Size_IiEEf", "_ZN2cv23BackgroundSubtractorGMGD2Ev", "_ZNK2cv11_InputArray11getGlBufferEv", "_ZNK2cv3ogl6Buffer5cloneENS1_6TargetEb", "png_benign_error", "_ZN3Imf9wrapmodesERNS_6HeaderE", "_Z23cvCreateBlobTrackerMSFGv", "_ZN2cv7ellipseERNS_3MatENS_6Point_IiEENS_5Size_IiEEdddRKNS_7Scalar_IdEEiii", "_ZN12CvForestTree4readEP13CvFileStorageP10CvFileNode", "_ZN11CvSVMSolver17get_row_one_classEiPfS0_b", "_ZN2cv3gpu6GpuMatC1ERKNS_3MatE", "jpc_mqenc_codemps2", "_ZN6cvtest4normERKN2cv3MatEiS3_", "_ZN22CvAdaptiveSkinDetectorC2Eii", "calcrdslopes", "Java_org_opencv_features2d_DescriptorMatcher_clone_10", "_ZNK3Imf11TileOffsets20anyOffsetsAreInvalidEv", "Java_org_opencv_core_Mat_nPutI", "_ZN9CvANN_MLP5trainERKN2cv3MatES3_S3_S3_21CvANN_MLP_TrainParamsi", "_Z38cvCreateModuleBlobTrackAnalysisHistPVSv", "jpc_mqdec_dump", "__divdi3", "cvRectangleR", "_ZN2cv11FileStorageC1ERKSsiS2_", "Java_org_opencv_core_Mat_nDump", "Java_org_opencv_ml_CvRTrees_predict_11", "_ZN2cv3ocl12StereoBM_OCLC2Ev", "_ZTv0_n20_N2cv24BriefDescriptorExtractor4readERKNS_8FileNodeE", "_ZN2cv3of211ChowLiuTree4makeEd", "_ZN2cv3of29FabMapFBO14limitbisectionEdd", "_ZN2cv15KeyPointsFilter16runByImageBorderERSt6vectorINS_8KeyPointESaIS2_EENS_5Size_IiEEi", "_ZN4epnp11compute_rhoEPd", "cvSeqPopFront", "_ZNK16CvDTreeTrainData12get_var_typeEi", "_ZN2cv11findNonZeroERKNS_11_InputArrayERKNS_12_OutputArrayE", "_Z22TransposeCycleElementsPfPii", "_Z17cvTestSeqFrameNumPv", "_ZN2cv7MomentsC2Ev", "TIFFSwabArrayOfLong", "Java_org_opencv_ml_CvSVMParams_get_1degree_10", "_ZN2cv7linemod16QuantizedPyramid23selectScatteredFeaturesERKSt6vectorINS1_9CandidateESaIS3_EERS2_INS0_7FeatureESaIS8_EEjf", "_Z27Mat_to_vector_vector_DMatchRN2cv3MatERSt6vectorIS2_INS_6DMatchESaIS3_EESaIS5_EE", "cvSetIdentity", "_ZN2cv14ChamferMatcher21LocationImageIteratorC1ERKSt6vectorINS_6Point_IiEESaIS4_EEiff", "_ZN11CvSVMParamsC2EiiddddddP5CvMat14CvTermCriteria", "_ZN2cvmiERKNS_3MatERKNS_7Scalar_IdEE", "_ZNK2cv12_OutputArray6neededEv", "_ZNK2cv5BRISK4infoEv", "_ZN2cv12RLByteStream8getBytesEPvi", "cvCreateGLCMImage", "_ZN7testing32ScopedFakeTestPartResultReporterC2EPNS_19TestPartResultArrayE", "png_set_cHRM_XYZ_fixed", "_ZN2cv14phaseCorrelateERKNS_11_InputArrayES2_S2_", "cvSubdiv2DLocate", "_ZN2cv17BasicRetinaFilter25_localLuminanceAdaptationEPKfS2_Pfb", "_ZN2cv17BasicRetinaFilter33_local_horizontalAnticausalFilterEPfjjPKj", "_ZN2cv25BOWImgDescriptorExtractorD1Ev", "_Z29vector_vector_KeyPoint_to_MatRSt6vectorIS_IN2cv8KeyPointESaIS1_EESaIS3_EERNS0_3MatE", "_ZN2cv3ocl11ocl_momentsERNS0_6oclMatEb", "_ZN2cv20windowedMatchingMaskERKSt6vectorINS_8KeyPointESaIS1_EES5_ff", "_ZN3Imf14TypedAttributeIN5Imath8Matrix33IdEEE14staticTypeNameEv", "_Z32icvComputeProjectMatricesNPointsP5CvMatS0_S0_S0_S0_S0_ddS0_S0_", "_ZN9IlmThread10ThreadPool13addGlobalTaskEPNS_4TaskE", "_ZN2cv16BOWKMeansTrainerD2Ev", "Java_org_opencv_core_Mat_n_1copyTo__JJJ", "Java_org_opencv_contrib_StereoVar_get_1minDisp_10", "Java_org_opencv_core_Core_add_13", "TIFFFileno", "_Z32icvGetQuadrangleSubPix_8u32f_C1RPKhi6CvSizePfiS1_PKf", "_ZN7CvDTree13calc_node_dirEP11CvDTreeNode", "_ZN2cv12LineIteratorC1ERKNS_3MatENS_6Point_IiEES5_ib", "_ZN2cv16FileNodeIteratormIEi", "_ZN7testing8TestCase12ShuffleTestsEPNS_8internal6RandomE", "Java_org_opencv_photo_Photo_fastNlMeansDenoisingColoredMulti_10", "Java_org_opencv_features2d_GenericDescriptorMatcher_knnMatch_11", "_ZN4epnpC2ERKN2cv3MatES3_S3_", "_ZNK2cv9BFMatcher5cloneEb", "_ZN17CvModelEstimator2D1Ev", "_ZNK2cv13Jpeg2KEncoder10newEncoderEv", "Java_org_opencv_imgproc_Imgproc_pyrDown_10", "png_set_sCAL", "_ZN2cv6GlFontC2ERKSsiNS0_6WeightENS0_5StyleE", "png_write_chunk_end", "_ZN2cv21ImageLogPolProjectionD0Ev", "_ZN2cv13BaseRowFilterC1Ev", "_ZN3Imf17ScanLineInputFile4DataC1EPNS_7IStreamEi", "_ZN2cv3gpu7PrintToERKNS0_10DeviceInfoEPSo", "Java_org_opencv_core_Core_hconcat_10", "_ZNK2cv22OneWayDescriptorObject19_GetLabeledFeaturesEv", "png_set_read_fn", "_ZN7testing32ScopedFakeTestPartResultReporterD1Ev", "cvFillPoly", "_ZN2cv12RMByteStreamD0Ev", "_ZN2cv3sumERKNS_11_InputArrayE", "_Z10solve_deg2dddRdS_", "_ZN15CvFuzzyFunctionC1Ev", "_ZN13FaceDetectionD2Ev", "_ZNK2cv20OneWayDescriptorBase14FindDescriptorEP9_IplImageRiS3_RfPfS5_", "jas_stream_fopen", "TIFFCIELabToRGBInit", "jpc_mqenc_getstate", "_ZN2cv11TiffDecoderD0Ev", "cvStartWindowThread", "_ZN9IlmThread5MutexD0Ev", "_ZN3Imf14TypedAttributeIN5Imath8Matrix44IfEEE13readValueFromERNS_7IStreamEii", "_ZN10__cxxabiv116__enum_type_infoD0Ev", "Java_org_opencv_ml_CvERTrees_CvERTrees_10", "cvMorphologyEx", "_Z34thresholdFunctionalScoreFixedLevelPPK18CvLSVMFilterObjectiPK20CvLSVMFeaturePyramidifiifPPfPP7CvPointPiPSA_", "cvCreateGLCMDescriptors", "cvCheckContourConvexity", "cvCvtSeqToArray", "_ZN7testing9internal220PrintBytesInObjectToEPKhjPSo", "jas_matrix_copy", "_ZN2cv3LDA3ldaERKNS_11_InputArrayES3_", "_ZN7testing8internal24XmlUnitTestResultPrinterC1EPKc", "_ZN2cv10PxMEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "_ZNK2cv12StarDetector4infoEv", "_ZNK4CvEM9get_probsEv", "png_set_text_2", "_ZN10__cxxabiv115__forced_unwindD1Ev", "_ZN7testing11IsSubstringEPKcS1_S1_S1_", "cvRunningAvg", "_ZN7testing8internal17TestEventRepeater24OnEnvironmentsSetUpStartERKNS_8UnitTestE", "_ZN10__cxxabiv117__class_type_infoD0Ev", "_ZNK2cv11_InputArray9getGpuMatEv", "Java_org_opencv_contrib_FaceRecognizer_save_10", "_Z27vector_vector_DMatch_to_MatRSt6vectorIS_IN2cv6DMatchESaIS1_EESaIS3_EERNS0_3MatE", "_ZN2cv9videostab9getMotionEiiPKNS_3MatEi", "_ZN3Imf14TiledInputFileC2ERKNS_6HeaderEPNS_7IStreamEii", "_ZN2cv3ocl12ProgramCacheD2Ev", "_ZN3Imf14TiledInputFile9readTilesEiiiii", "cvReleaseImage", "jpc_seq_norm", "jpeg_free_small", "_ZN3Imf6HeaderC2EiiRKN5Imath3BoxINS1_4Vec2IiEEEEfRKNS3_IfEEfNS_9LineOrderENS_11CompressionE", "__gnu_thumb1_case_uhi", "png_check_IHDR", "Java_org_opencv_video_KalmanFilter_predict_10", "_ZN7testing4TestD0Ev", "_ZNK7testing8UnitTest11random_seedEv", "_ZN9CvANN_MLPC1Ev", "_ZN2cv10Eigenfaces5trainERKNS_11_InputArrayES3_", "Java_org_opencv_calib3d_StereoSGBM_set_1fullDP_10", "_ZNK2cv3ocl9CvSVM_OCL7predictERKNS_3MatEb", "_ZN11FaceFeatureD0Ev", "cvClearMemStorage", "_ZN2cv14FernClassifierC1ERKSt6vectorIS1_INS_6Point_IfEESaIS3_EESaIS5_EERKS1_INS_3MatESaISA_EERKS1_IS1_IiSaIiEESaISG_EEiiiiiiiRKNS_14PatchGeneratorE", "_ZN7testing8internal8GTestLogC1ENS0_16GTestLogSeverityEPKci", "jas_calloc", "_ZN3Imf14TypedAttributeINS_12PreviewImageEE13readValueFromERNS_7IStreamEii", "_ZN7testing8internal24GetCurrentExecutableNameEv", "_ZN2cv16OneWayDescriptor8AllocateEi6CvSizei", "_ZN2cv12findContoursERKNS_12_OutputArrayES2_iiNS_6Point_IiEE", "Java_org_opencv_photo_Photo_fastNlMeansDenoisingColored_11", "_ZN2cv18getAffineTransformERKNS_11_InputArrayES2_", "icvGetCoefForPiece", "_ZN2cv6Mesh3DD2Ev", "_ZNK2cv17SelfSimDescriptor17getDescriptorSizeEv", "_ZN3Imf14ChromaticitiesC1ERKN5Imath4Vec2IfEES5_S5_S5_", "Java_org_opencv_imgproc_Imgproc_Sobel_11", "_ZN2cv11VideoWriterD1Ev", "_ZN3Imf16lookModTransformERNS_6HeaderE", "jpeg_suppress_tables", "Java_org_opencv_imgproc_Imgproc_calcHist_10", "_ZN2cv16MatConstIterator4seekEib", "_ZN2cv6Retina5setupESsb", "_ZN2cv3ocl23extractFirstChannel_32FERKNS0_6oclMatERS1_", "Java_org_opencv_imgproc_Moments_get_1nu02_10", "_ZN2cv3of29FabMapLUTD2Ev", "_ZN11FaceFeatureD1Ev", "_ZN2cv17getWindowPropertyERKSsi", "_ZN6cvtest3addERKN2cv3MatEdS3_dNS0_7Scalar_IdEERS1_ib", "Java_org_opencv_core_Core_phase_10", "_ZN21FaceDetectionListElemC2Ev", "_ZNK3Imf11ChannelList18channelsWithPrefixERKSsRNS0_13ConstIteratorES4_", "Java_org_opencv_imgproc_Imgproc_getPerspectiveTransform_10", "_ZN2cv15getCPUTickCountEv", "cvKalmanCorrect", "_ZN9CvGBTreesC1EPK5CvMatiS2_S2_S2_S2_S2_15CvGBTreesParams", "_ZN9IlmThread10ThreadPool4DataD2Ev", "_ZN15CvFuzzyFunction8addCurveEP12CvFuzzyCurved", "_ZNKSt10bad_typeid4whatEv", "_Unwind_ForcedUnwind", "_ZN2cv4readERKNS_8FileNodeERNS_3MatERKS3_", "cvHaveImageReader", "_ZN2cv3ocl4MOG2C2Ei", "Java_org_opencv_features2d_GenericDescriptorMatcher_clone_11", "_ZN3Imf11FrameBufferixERKSs", "jinit_input_controller", "_Z26cvCreateBlobDetectorSimplev", "_ZN7testing8internal13DeathTestImpl26ReadAndInterpretStatusByteEv", "Java_org_opencv_imgproc_Imgproc_warpAffine_10", "cvSaveWindowParameters", "_ZN7testing8internal12AssertHelperC2ENS_14TestPartResult4TypeEPKciS5_", "Java_org_opencv_imgproc_CLAHE_delete", "Java_org_opencv_calib3d_Calib3d_stereoCalibrate_10", "_ZN25CvBlobTrackPostProcKalmanD1Ev", "_ZN13CvDTreeParamsC1EiifbiibbPKf", "_TIFFFillStriles", "_ZN2cv6detail11waveCorrectERSt6vectorINS_3MatESaIS2_EENS0_15WaveCorrectKindE", "TIFFWriteRawTile", "_Unwind_GetRegionStart", "cvMakeSeqHeaderForArray", "_Z18cvReadStructByNameP13CvFileStorageP10CvFileNodePKcPvS4_", "_ZN3Imf18wrapmodesAttributeERNS_6HeaderE", "_ZNK2cv32OpponentColorDescriptorExtractor11computeImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZNK2cv5BRISK29computeKeypointsNoOrientationERKNS_11_InputArrayES3_RSt6vectorINS_8KeyPointESaIS5_EE", "_ZN3Imf10OutputFile10copyPixelsERNS_9InputFileE", "_ZNK7testing19TestPartResultArray17GetTestPartResultEi", "Java_org_opencv_imgproc_Imgproc_HoughLines_10", "cvEigenVV", "_ZNK3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IfEEEEE12writeValueToERNS_7OStreamEi", "_ZN2cv6detail8resultTlERKSt6vectorINS_6Point_IiEESaIS3_EE", "Java_org_opencv_calib3d_StereoSGBM_StereoSGBM_12", "_Unwind_Backtrace", "_ZN13CvCalibFilter15GetLatestPointsEiPP12CvPoint2D32fPiPb", "_ZN2cv3ocl7absdiffERKNS0_6oclMatES3_RS1_", "Java_org_opencv_gpu_TargetArchs_has_10", "jas_stream_memopen", "_ZNK3Imf8TimeCode12timeAndFlagsENS0_7PackingE", "cvSetReal2D", "_ZN2cv9videostab18InpaintingPipeline19setStabilizedFramesERKSt6vectorINS_3MatESaIS3_EE", "png_write_tRNS", "_ZN2cv17CascadeClassifier5runAtERNS_3PtrINS_16FeatureEvaluatorEEENS_6Point_IiEERd", "_ZN2cv13HaarEvaluatorD1Ev", "_ZNK2cv24GenericDescriptorMatcher11radiusMatchERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_S8_RS4_IS4_INS_6DMatchESaIS9_EESaISB_EEfS3_b", "_ZN2cv26GridAdaptedFeatureDetectorC1ERKNS_3PtrINS_15FeatureDetectorEEEiii", "_ZN7testing8TestCase3RunEv", "png_read_start_row", "_ZN9IlmThread9SemaphoreC2Ej", "_ZN10CvVSModule23TransferParamsFromChildEPS_PKc", "_ZN4FaceD0Ev", "Java_org_opencv_ml_CvRTParams_set_1calc_1var_1importance_10", "Java_org_opencv_imgproc_Moments_get_1mu30_10", "_ZN5CvSVMD2Ev", "_ZN7testing14IsNotSubstringEPKcS1_S1_S1_", "LogLuv32fromXYZ", "_cvConstructLCMSimpleNode", "_ZN2cv11TiffEncoderC2Ev", "_ZN2cv3of211ChowLiuTreeC1Ev", "_ZN7testing10TestResult17AddTestPartResultERKNS_14TestPartResultE", "_ZN11CvSVMSolverC1Ev", "cvReleasePOSITObject", "_ZN6cvtest9ArrayTestD0Ev", "Java_org_opencv_ml_CvStatModel_save_10", "_ZN2cv5solveERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi", "_ZN7CvBoost5trainERKN2cv3MatEiS3_S3_S3_S3_S3_13CvBoostParamsb", "_ZN2cv16CvFeatureTracker17newTrackingWindowENS_3MatENS_5Rect_IiEE", "Java_org_opencv_ml_CvRTrees_getVarImportance_10", "_ZN2cv3logERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv3ocl3expERKNS0_6oclMatERS1_", "jpeg_alloc_quant_table", "_ZN2cv6RetinaD2Ev", "_ZN3Imf15OpaqueAttributeC2EPKc", "_ZN2cv6detail16LKTrackerInvokerC1ERKNS_3MatES4_S4_PKNS_6Point_IfEEPS6_PhPfNS_5Size_IiEENS_12TermCriteriaEiiif", "cvSubdivDelaunay2DInsert", "_ZN2cv20OneWayDescriptorBaseC1E6CvSizeiPKcS3_S3_S3_iii", "_ZN2cv10PngDecoder10readHeaderEv", "_ZN13FaceDetection8FindFaceEP9_IplImage", "_ZN2cv23calibrationMatrixValuesERKNS_11_InputArrayENS_5Size_IiEEddRdS5_S5_RNS_6Point_IdEES5_", "_ZNK2cv5FREAK13meanIntensityERKNS_3MatES3_ffjjj", "_ZNK2cv29PyramidAdaptedFeatureDetector5emptyEv", "_ZN2cv2EM7doTrainEiRKNS_12_OutputArrayES3_S3_", "Java_org_opencv_core_Core_ellipse_14", "cvSet3D", "_ZN2cv15CvHybridTrackerD1Ev", "_ZN2cv6Retina18setColorSaturationEbf", "jas_stream_write", "_ZN2cv3ocl26matchTemplate_CCOFF_NORMEDERKNS0_6oclMatES3_RS1_RNS0_16MatchTemplateBufE", "_ZN2cv13Jpeg2KEncoderD0Ev", "_ZN2cv11compareHistERKNS_11_InputArrayES2_i", "_ZN3Imf8commentsERKNS_6HeaderE", "_ZN2cv9Directory12GetListFilesERKSsS2_b", "_ZN2cv16OneWayDescriptor15GenerateSamplesEiP9_IplImagei", "jpeg_set_linear_quality", "_ZN2cv15createBoxFilterEiiNS_5Size_IiEENS_6Point_IiEEbi", "_ZN13FaceDetectionD0Ev", "_ZN2cv3ocl4normERKNS0_6oclMatEi", "_Z22filterDispositionLevelPK18CvLSVMFilterObjectPK16CvLSVMFeatureMapPPfPPiS8_", "Java_org_opencv_calib3d_Calib3d_solvePnP_11", "_ZN2cv6detail20CylindricalWarperGpu9buildMapsENS_5Size_IiEERKNS_3MatES6_RNS_3gpu6GpuMatES9_", "_ZN3Imf17xDensityAttributeERNS_6HeaderE", "_ZN4epnp3dotEPKdS1_", "_ZN2cv3minEdRKNS_3MatE", "Java_org_opencv_calib3d_Calib3d_findCirclesGridDefault_11", "_ZN5RFaceC1EP12FaceTemplate", "_ZNSt9exceptionD1Ev", "cvGraphVtxDegreeByPtr", "TIFFFdOpen", "_ZN3Imf6Header15setMaxImageSizeEii", "_ZN2cv14SpinImageModel9setSubsetERKSt6vectorIiSaIiEE", "_ZN2cv3ocl3LUTERKNS0_6oclMatES3_RS1_", "_ZN10CvVSModule13GetModuleNameEv", "_ZN2cv5mergeERKNS_11_InputArrayERKNS_12_OutputArrayE", "jas_stream_flush", "jpc_ns_fwdlift_colgrp", "cvCalcProbDensity", "Java_org_opencv_photo_Photo_fastNlMeansDenoising_11", "_ZN2cv11minAreaRectERKNS_11_InputArrayE", "png_get_tRNS", "_ZN2cv6detail17VoronoiSeamFinder10findInPairEjjNS_5Rect_IiEE", "_ZN7testing7MessagelsEPw", "_ZN4perf7GpuPerf12targetDeviceEv", "_ZN22CvAdaptiveSkinDetectorD1Ev", "Java_org_opencv_core_Core_insertChannel_10", "Java_org_opencv_core_Core_fillConvexPoly_10", "_ZSt10unexpectedv", "_ZN24CvBlobTrackPredictKalman11ParamUpdateEv", "Java_org_opencv_imgproc_Imgproc_accumulateSquare_10", "_ZN2cv8GlBufferC2ERKNS_11_InputArrayENS0_5UsageE", "_ZN2cv6detail7Blender13createDefaultEib", "_ZN2cv11TiffDecoderD1Ev", "_ZN2cv24GenericDescriptorMatcherC1Ev", "_ZN2cv11_InputArrayC2ERKNS_7MatExprE", "_ZN2cv13LevMarqSparseC2Ev", "_ZN14CvBlobTrackSeq12DelBlobTrackEi", "jpc_pi_create0", "Java_org_opencv_imgproc_Imgproc_getDefaultNewCameraMatrix_10", "__gtdf2", "_ZN2cv7vconcatERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv10ExrDecoderC1Ev", "_ZN2cv3MatC2EPK9_IplImageb", "_ZN2cv9Algorithm7_createERKSs", "_ZN2cv16BaseImageDecoder9setSourceERKSs", "_ZNK2cv16BaseImageDecoder14checkSignatureERKSs", "_ZN9IlmThread10ThreadPoolD1Ev", "Java_org_opencv_imgproc_Moments_set_1nu30_10", "_ZN2cv3ocl14openCLMemcpy2DEPNS0_7ContextEPvjPKvjjjNS0_16openCLMemcpyKindEi", "_ZN2cv3of29FabMapFBOD0Ev", "jpc_ft_analyze", "_ZN6cvtest8BaseTestD0Ev", "_ZN2cv11bitwise_notERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "png_get_pixel_aspect_ratio_fixed", "_ZN2cv17FlannBasedMatcher15radiusMatchImplERKNS_3MatERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfRKS4_IS1_SaIS1_EEb", "png_handle_gAMA", "_ZN2cv24GenericDescriptorMatcher18KeyPointCollectionC2Ev", "_ZN5CvSVM16get_default_gridEi", "_ZN10CvRTParamsC2Ev", "_ZN2cv11RNG_MT19937C2Ev", "_ZN2cv8superres15SuperResolution8setInputERKNS_3PtrINS0_11FrameSourceEEE", "jpeg_get_large", "_ZN3Imf14TypedAttributeIN5Imath8Matrix44IdEEE14staticTypeNameEv", "_ZN2cv3ocl13load_constantEP11_cl_contextP17_cl_command_queuePKvj", "_ZN2cv16accumulateSquareERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN22CvAdaptiveSkinDetector9HistogramC2Ev", "Java_org_opencv_features2d_GenericDescriptorMatcher_getTrainImages_10", "jas_cmprof_destroy", "__dynamic_cast", "cvCalcCovarMatrix", "_ZN7CvDTreeC2Ev", "_ZNK2cv16FeatureEvaluator7calcCatEi", "_ZN2cv3ocl13HOGDescriptorC2ENS_5Size_IiEES3_S3_S3_iddbi", "_ZN3Imf14TiledInputFile4DataC2Ebi", "_ZN21CvHomographyEstimator9runKernelEPK5CvMatS2_PS0_", "_ZN2cv16FileNodeIteratormmEi", "_ZN2cv13HaarEvaluatorC2Ev", "_ZN2cv14RandomizedTree4initEiiRNS_3RNGE", "_ZN2cv9GlTextureC1ENS_5Size_IiEEi", "_ZN2cv3ocl20FarnebackOpticalFlow20updateFlow_boxFilterERKNS0_6oclMatES4_RS2_S5_S5_S5_ib", "Java_org_opencv_imgproc_Imgproc_undistort_10", "_ZN2cv17setWindowPropertyERKSsid", "png_gamma_16bit_correct", "_ZN2cv16BaseImageEncoderC1Ev", "_Z24cvComputeEssentialMatrixPfS_S_", "_ZN3Imf11StdIFStreamC2EPKc", "_ZN4perf8TestBase4nextEv", "_ZNK4CvEM8getMeansEv", "_ZN2cv23BackgroundSubtractorMOGC2Eiidd", "Java_org_opencv_highgui_VideoCapture_n_1read", "Java_org_opencv_calib3d_Calib3d_filterSpeckles_11", "_ZN3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IfEEEEE13readValueFromERNS_7IStreamEii", "_ZN2cv17CascadeClassifier8setImageERNS_3PtrINS_16FeatureEvaluatorEEERKNS_3MatE", "Java_org_opencv_objdetect_HOGDescriptor_detect_11", "_ZN9CvANN_MLP12init_weightsEv", "_ZNK2cv13HOGDescriptor17getDescriptorSizeEv", "_ZN2cv3ogl9Texture2D14setAutoReleaseEb", "_ZN2cvmlERKNS_7MatExprES2_", "cvSolveCubic", "_ZN2cv15LogPolar_Interp11to_corticalERKNS_3MatE", "_ZN16CvObjectDetector6DetectEPKvP9CvBlobSeq", "_ZN2cv18WriteStructContextC1ERNS_11FileStorageERKSsiS4_", "Java_org_opencv_calib3d_Calib3d_findChessboardCorners_11", "_ZN2cv12HOGEvaluator7Feature4readERKNS_8FileNodeE", "_ZN2cv13LevMarqSparseC1Ev", "_ZN11CvStatModel4loadEPKcS1_", "_ZNK2cv7MatExpr1tEv", "_TIFFsetLong8Array", "_TIFFSwab32BitData", "Java_org_opencv_imgproc_Imgproc_GaussianBlur_12", "cvGetFileNodeName", "_ZN17CirclesGridFinder8addPointEN2cv6Point_IfEERSt6vectorIjSaIjEE", "_ZN2cvgeERKNS_3MatES2_", "_ZN2cv18SimpleBlobDetectorC1ERKNS0_6ParamsE", "_ZNK2cv3ocl4MOG218getBackgroundImageERNS0_6oclMatE", "_ZN2cv9rectangleERNS_3MatENS_5Rect_IiEERKNS_7Scalar_IdEEiii", "Java_org_opencv_core_Core_divide_17", "_ZTv0_n24_NK2cv12StarDetector4infoEv", "_ZN10CvVSModule9FreeParamEPP10CvDefParam", "jas_strdup", "_ZN3Imf15Pxr24CompressorD1Ev", "_ZNK2cv17CascadeClassifier21getOriginalWindowSizeEv", "cvStartFindContours", "_ZN2cv3maxERKNS_3MatES2_", "png_write_iCCP", "Java_org_opencv_imgproc_Imgproc_fitEllipse_10", "_ZN3p3p10jacobi_4x4EPdS0_S0_", "cvReleaseData", "_TIFFFax3fillruns", "_ZN17CirclesGridFinder13areCentersNewERKSt6vectorIjSaIjEERKS0_IS2_SaIS2_EE", "_ZNK2cv8Subdiv2D7edgeOrgEiPNS_6Point_IfEE", "_ZN2cv15NAryMatIteratorppEi", "_ZN17CvModelEstimator29runRANSACEPK5CvMatS2_PS0_S3_ddi", "_ZN2cv9Algorithm3setERKSsRKNS_3MatE", "cvMul", "_ZN3Iex11stackTracerEv", "Java_org_opencv_imgproc_Imgproc_calcHist_11", "cvSaveImage", "_ZN2cv10PngDecoder5closeEv", "_ZN2cv11writeScalarERNS_11FileStorageEi", "_ZN2cv6Mesh3DC1ERKSt6vectorINS_7Point3_IfEESaIS3_EE", "_ZN3Imf7expTimeERNS_6HeaderE", "TIFFUnlinkDirectory", "cvCreateBGCodeBookModel", "jpc_bitstream_fillbuf", "Java_org_opencv_imgproc_Imgproc_resize_11", "cvReleaseHist", "_ZN2cv12WMByteStreamD2Ev", "_ZNK2cv17FlannBasedMatcher15isMaskSupportedEv", "_ZN2cv10StereoSGBMD1Ev", "_ZN2cv10PxMEncoderD1Ev", "Java_org_opencv_core_Core_ellipse_15", "_ZN2cvleERKNS_3MatEd", "_ZN2cv3oclmiERKNS0_6oclMatES3_", "_ZN3Imf15Pxr24CompressorC2ERKNS_6HeaderEjj", "Java_org_opencv_gpu_DeviceInfo_DeviceInfo_10", "Java_org_opencv_imgproc_Imgproc_accumulate_11", "_ZN2cv8Subdiv2D8QuadEdgeC1Ev", "_ZNK2cv9Algorithm9getParamsERSt6vectorISsSaISsEE", "_ZN2cv22getMorphologyRowFilterEiiii", "_ZNK2cv3ocl26BruteForceMatcher_OCL_base19getTrainDescriptorsEv", "Java_org_opencv_android_Utils_nMatToBitmap2", "_ZN2cv10ExrEncoderD0Ev", "_ZNK8CvRTrees8get_treeEi", "_ZN2cv3ocl17KNearestNeighbour5trainERKNS_3MatERS2_S5_bib", "cvKalmanPredict", "TIFFUnRegisterCODEC", "_ZN2cv11WBaseStream7releaseEv", "_ZN7testing8internal24HasNewFatalFailureHelperD1Ev", "__udivdi3", "cvMixSegmL2", "_ZN2cv6detail23normalizeUsingWeightMapERKNS_3MatERS1_", "_ZNK7testing8internal12UnitTestImpl21reportable_test_countEv", "_ZN2cv10BmpEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "_ZN2cv11RetinaColor20runColorMultiplexingERKSt8valarrayIfERS2_", "_ZN2cv3ocl17KNearestNeighbourC2Ev", "_ZNK2cv11_InputArray5depthEi", "_ZN2cv22createOptFlow_DualTVL1Ev", "Java_org_opencv_ml_CvDTreeParams_get_1min_1sample_1count_10", "_ZNK2cv13HOGDescriptor15computeGradientERKNS_3MatERS1_S4_NS_5Size_IiEES6_", "cvRange", "jpc_streamlist_insert", "_ZN2cv24GenericDescriptorMatcher8knnMatchERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEiRKS4_IS1_SaIS1_EEb", "cvMakeScanlines", "png_chunk_unknown_handling", "Java_org_opencv_video_KalmanFilter_KalmanFilter_11", "Java_org_opencv_imgproc_Imgproc_cornerMinEigenVal_12", "_ZN2cv24CvMeanShiftTrackerParamsC1Ei14CvTermCriteria", "_ZN2cv10ExrEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "_ZN2cv12HOGEvaluatorC2Ev", "_ZN2cv13Jpeg2KDecoder10readHeaderEv", "Java_org_opencv_ml_CvSVMParams_set_1nu_10", "_ZN6CvTypeC1EPKcPFiPKvEPFvPPvEPFS6_P13CvFileStorageP10CvFileNodeEPFvSB_S1_S3_10CvAttrListEPFS6_S3_E", "Java_org_opencv_features2d_DescriptorMatcher_clear_10", "Java_org_opencv_imgproc_Moments_set_1nu20_10", "_ZN2cv8GlBuffer6createEiiiNS0_5UsageE", "_ZN2cv24GenericDescriptorMatcherD1Ev", "_Z9printBitsPc4half", "_ZN2cv3ocl9thresholdERKNS0_6oclMatERS1_ddi", "_ZThn4_N2cv8superres15SuperResolution9nextFrameERKNS_12_OutputArrayE", "_ZN2cv21FernDescriptorMatcherC2ERKNS0_6ParamsE", "Java_org_opencv_calib3d_StereoSGBM_set_1disp12MaxDiff_10", "cvAvgSdv", "_ZN2cv9LDetector4readERKNS_8FileNodeE", "_ZN2cv6detail9resultRoiERKSt6vectorINS_6Point_IiEESaIS3_EERKS1_INS_3MatESaIS8_EE", "png_write_row", "png_create_struct", "_ZN2cv14RandomizedTree30estimateQuantPercForPosteriorsEPf", "_Z18maxFunctionalScorePPK18CvLSVMFilterObjectiPK20CvLSVMFeaturePyramidfiiPfPP7CvPointPPiSA_PS9_", "png_format_number", "_ZN2cv14fillConvexPolyERKNS_12_OutputArrayERKNS_11_InputArrayERKNS_7Scalar_IdEEii", "_ZNK2cv5BRISK14descriptorSizeEv", "_ZN2cv3of211ChowLiuTree2CPEibib", "_ZN2cv17BasicRetinaFilter36_horizontalAnticausalFilter_multGainEPfjj", "_ZN9IlmThread9SemaphoreD1Ev", "_ZN2cv6Retina32activateMovingContoursProcessingEb", "cvReleaseLinearContorModelStorage", "_ZN2cv15KeyPointsFilter17runByKeypointSizeERSt6vectorINS_8KeyPointESaIS2_EEff", "_ZNK3Imf9InputFile7versionEv", "_ZNK2cv8KeyPoint4hashEv", "Java_org_opencv_core_Core_addWeighted_11", "Java_org_opencv_core_Mat_n_1ones__DDI", "_Z19showPartFilterBoxesP9_IplImagePPK18CvLSVMFilterObjectiPP7CvPointPii8CvScalariii", "Java_org_opencv_imgproc_Imgproc_drawContours_11", "_ZN2cvneERKNS_3MatEd", "cvGetErrStatus", "_ZN13CvFMEstimatorC1Ei", "Java_org_opencv_imgproc_Imgproc_warpPerspective_12", "_ZN2cv12_OutputArrayC1ERNS_3gpu6GpuMatE", "TIFFIsByteSwapped", "_ZNK3Imf6Header15hasPreviewImageEv", "_ZN3Imf8TimeCodeC1Eiiiibbbbbbiiiiiiii", "_ZN21DetectionBasedTracker20updateTrackedObjectsERKSt6vectorIN2cv5Rect_IiEESaIS3_EE", "_ZN3Imf7IStreamD1Ev", "Java_org_opencv_core_Mat_n_1reshape__JI", "_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EEid", "jinit_c_master_control", "Java_org_opencv_core_Core_multiply_15", "_ZN23CvNormalBayesClassifierD0Ev", "_ZN2cv14displayOverlayERKSsS1_i", "_ZN3Imf11floatToHalfEf", "_Z23icvApproximateChainTC89P7CvChainiP12CvMemStoragei", "cvSegmentImage", "_ZN2cv22OneWayDescriptorObjectD1Ev", "_ZN2cv3ocl12getOclMatRefERKNS_11_InputArrayE", "jas_matrix_asl", "_ZNK2cv6Retina8getMagnoEv", "Java_org_opencv_ml_CvStatModel_load_11", "_ZN2cv3gpu19printCudaDeviceInfoEi", "png_get_rowbytes", "_ZN2cv5flann5Index7releaseEv", "png_handle_tEXt", "cvMin", "_ZN2cv3ocl9CvSVM_OCLC1Ev", "_ZN2cv17BasicRetinaFilter42_horizontalCausalFilter_Irregular_addInputEPKfPfjj", "_ZN22CameraWrapperConnector7connectEiP14CameraActivityPPv", "_ZN3Imf11StdOFStream5seekpEy", "_ZN2cv17SelfSimDescriptorC2ERKS0_", "_Z25icvCvt_BGRA2Gray_8u_C4C1RPKhiPhi6CvSizei", "Java_org_opencv_core_Mat_n_1create__JIII", "_ZN2cv9Algorithm3setERKSsRKSt6vectorINS_3MatESaIS4_EE", "_ZN2cv18CvMeanShiftTracker22getHistogramProjectionEi", "_ZN7testing8UnitTest9listenersEv", "Java_org_opencv_ml_CvSVM_predict_1all_10", "cvAdd", "_ZN17btv_l1_device_ocl15buildMotionMapsERKN2cv3ocl6oclMatES4_S4_S4_RS2_S5_S5_S5_", "_ZNK2cv16FeatureEvaluator14getFeatureTypeEv", "_ZN2cv3minERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "jpc_enc_dump", "_ZN2cv3gpu11TargetArchs20hasEqualOrGreaterBinEii", "_ZNK9IlmThread5Mutex4lockEv", "Java_org_opencv_highgui_Highgui_imencode_11", "_ZN7testing8TestInfo3RunEv", "_ZN3Imf8isoSpeedERKNS_6HeaderE", "cvReadChainPoint", "cvCopy", "_ZN3Imf11FrameBufferixEPKc", "_ZN11FaceFeatureD2Ev", "jas_eprintf", "_ZNK2cv9TickMeter10getTimeSecEv", "Java_org_opencv_core_Core_compare_11", "_ZN2cv3absERKNS_7MatExprE", "_ZNK3Imf7KeyCode6prefixEv", "_ZN9CvLevMarqD1Ev", "_ZN2cv14FaceRecognizer17getLabelsByStringERKSs", "_ZN2cv14pointCloudShowERKSsRKNS_8GlCameraERKNS_11_InputArrayES7_", "_ZN2cv12findContoursERKNS_12_OutputArrayES2_S2_iiNS_6Point_IiEE", "_ZN2cv3PtrI12CvDTreeSplitE10delete_objEv", "cvSVD", "_ZN8CvMLData5clearEv", "_ZN2cv3ocl19matchTemplate_CCOFFERKNS0_6oclMatES3_RS1_RNS0_16MatchTemplateBufE", "_ZN2cv10BmpDecoderD2Ev", "Java_org_opencv_imgproc_Imgproc_getGaussianKernel_11", "Java_org_opencv_imgproc_Imgproc_bilateralFilter_10", "jpc_mqdec_setctx", "_ZN15CvFuzzyFunction11resetValuesEv", "_ZN3Imf6HeaderD2Ev", "_ZNK2cv3gpu10DeviceInfo17sharedMemPerBlockEv", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow7setSizeEiiii", "_ZN2cv12_OutputArrayC1ERKSt6vectorINS_3MatESaIS2_EE", "_ZN2cv6detail17BundleAdjusterRay24setUpInitialCameraParamsERKSt6vectorINS0_12CameraParamsESaIS3_EE", "_ZN2cv20PlanarObjectDetectorC1ERKNS_8FileNodeE", "_ZN7testing4TestC1Ev", "Java_org_opencv_imgproc_Imgproc_undistort_11", "_ZN7testing16AssertionFailureERKNS_7MessageE", "_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE", "_ZN2cv8superres23createOptFlow_FarnebackEv", "_ZN3Imf9AttributeC2Ev", "_ZN2cv3Mat6resizeEjRKNS_7Scalar_IdEE", "_Z17vector_Mat_to_MatRSt6vectorIN2cv3MatESaIS1_EERS1_", "_ZN2cv3ocldvERKNS0_6oclMatES3_", "_ZNK3Imf14TiledInputFile7versionEv", "TIFFReverseBits", "_ZN2cv5MutexC1Ev", "_ZN3Imf23adoptedNeutralAttributeERNS_6HeaderE", "_ZN2cv8Subdiv2D7newEdgeEv", "_ZNK2cv11MatOp_AddEx6assignERKNS_7MatExprERNS_3MatEi", "__muldi3", "_ZN2cveoERKNS_3MatES2_", "png_do_shift", "_ZN2cv22OneWayDescriptorObject8AllocateEii", "_ZN2cv10PxMDecoderC1Ev", "_ZN2cv18SimpleBlobDetector4readERKNS_8FileNodeE", "_ZN2cv18CvMeanShiftTracker17setTrackingWindowENS_5Rect_IiEE", "_ZNK2cv7MatExpr4typeEv", "_ZN2cv7linemod8Template4readERKNS_8FileNodeE", "_ZN11CvSVMSolver15calc_rho_nu_svmERdS0_", "_ZN2cv3ogl6Arrays14setVertexArrayERKNS_11_InputArrayE", "_ZNK3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IiEEEEE12writeValueToERNS_7OStreamEi", "_ZN9IlmThread10ThreadPool13setNumThreadsEi", "_ZNK2cv3Mat9locateROIERNS_5Size_IiEERNS_6Point_IiEE", "_ZN2cv12WLByteStreamD2Ev", "jas_clrspc_numchans", "cvGetSubRect", "cvGetNormalizedCentralMoment", "_ZN2cv18SimpleBlobDetector6ParamsC1Ev", "Java_org_opencv_imgproc_Imgproc_minAreaRect_10", "_ZNK2cv3gpu6GpuMat9convertToERS1_idd", "_ZNK2cv4MSER10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "icvGetDirectionForPoint", "Java_org_opencv_video_BackgroundSubtractor_apply_10", "png_get_sCAL_fixed", "_ZNK2cv18SimpleBlobDetector5writeERNS_11FileStorageE", "cvSeqSearch", "jas_image_decode", "jas_image_readcmptsample", "_ZN7testing8internal23MakeAndRegisterTestInfoEPKcS2_S2_S2_PKvPFvvES6_PNS0_15TestFactoryBaseE", "TIFFVTileSize", "_ZN3Imf15framesPerSecondERKNS_6HeaderE", "_ZN2cv3gpu15allocMatFromBufEiiiRNS0_6GpuMatE", "_ZN11CvSVMSolver6createEiiPPKfPaiPdddP12CvMemStorageP11CvSVMKernelMS_FPfiS9_S9_bEMS_FbRiSC_EMS_FvRdSF_E", "jpeg_write_scanlines", "_ZNK5Graph19areVerticesAdjacentEjj", "_ZNK2cv7linemod8Detector5writeERNS_11FileStorageE", "cvNamedWindow", "JPC_NOMINALGAIN", "_ZNK11CvStatModel4saveEPKcS1_", "_ZN6CvTypeC2EPKcPFiPKvEPFvPPvEPFS6_P13CvFileStorageP10CvFileNodeEPFvSB_S1_S3_10CvAttrListEPFS6_S3_E", "_ZN2cv6detail9resultRoiERKSt6vectorINS_6Point_IiEESaIS3_EERKS1_INS_5Size_IiEESaIS9_EE", "_ZN9IlmThread4TaskD1Ev", "_ZN3Imf14TypedAttributeISsE13readValueFromERNS_7IStreamEii", "_ZN11CvBoostTree24find_surrogate_split_catEP11CvDTreeNodeiPh", "_ZN2cv11JpegDecoderD0Ev", "Java_org_opencv_imgproc_Imgproc_getGaborKernel_11", "_ZN2cv3ocl11bitwise_notERKNS0_6oclMatERS1_", "png_get_pixels_per_meter", "_ZN2cv8imencodeERKSsRKNS_11_InputArrayERSt6vectorIhSaIhEERKS5_IiSaIiEE", "png_chunk_warning", "_ZN2cv10PngEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "_ZN2cv20BackgroundSubtractorD1Ev", "jinit_upsampler", "_ZN2cv11RetinaColor28_interpolateBayerRGBchannelsEPf", "_ZNK2cv5MatOp6invertERKNS_7MatExprEiRS1_", "Java_org_opencv_objdetect_HOGDescriptor_get_1derivAperture_10", "_ZN9CvANN_MLP14set_activ_funcEidd", "png_build_grayscale_palette", "_ZN2cv11RNG_MT19937cviEv", "_ZN3Imf6HeaderC1EiiRKN5Imath3BoxINS1_4Vec2IiEEEEfRKNS3_IfEEfNS_9LineOrderENS_11CompressionE", "_ZNK2cv12_OutputArray6createEiPKiiibi", "png_get_compression_type", "_ZN2cv16BaseImageEncoder14setDestinationERKSs", "_ZNK2cv3Mat3dotERKNS_11_InputArrayE", "_ZN2cv7linemod11DepthNormal4readERKNS_8FileNodeE", "_ZN2cv3ocl3addERKNS0_6oclMatERKNS_7Scalar_IdEERS1_S3_", "_ZN9CvGBTreesD2Ev", "_ZN3Imf7OStreamD1Ev", "cvEigenDecomposite", "_ZN6cvtest10BadArgTest13run_test_caseEiRKSs", "_ZN2cv11RNG_MT19937C2Ej", "Java_org_opencv_core_Core_mulTransposed_10", "_ZN3Imf11ChannelList6insertERKSsRKNS_7ChannelE", "_ZNK2cv12SurfAdjuster10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "Java_org_opencv_imgproc_Moments_get_1nu30_10", "jpc_ft_invlift_colgrp", "jpc_ns_fwdlift_colres", "_ZN3Imf22worldToCameraAttributeERKNS_6HeaderE", "Java_org_opencv_core_Mat_n_1setTo__JJ", "cvSeqPartition", "_ZN2cv3ocl12KalmanFilter7predictERKNS0_6oclMatE", "__gnu_Unwind_Restore_VFP", "Java_org_opencv_core_Core_add_14", "TIFFCurrentRow", "_ZN7testing8internal7PrintToEhPSo", "_ZN2cv21CvHybridTrackerParamsC2EffNS_22CvFeatureTrackerParamsENS_24CvMeanShiftTrackerParamsENS_13CvMotionModelE", "_ZN3Imf9InputFile11rawTileDataERiS1_S1_S1_RPKcS1_", "_ZN18CvBlobTrackerAuto1C2EP23CvBlobTrackerAutoParam1", "icvDefinePointPosition", "Java_org_opencv_core_Mat_nGet", "jpc_pchglist_create", "_ZN3Imf7ChannelC2ENS_9PixelTypeEiib", "_cvTreatExeptionalCase", "Java_org_opencv_imgproc_Imgproc_phaseCorrelate_11", "cvProject3D", "_ZNK2cv17SelfSimDescriptor3SSDERKNS_3MatENS_6Point_IiEERS1_", "_ZN2cv7fisheye13projectPointsERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_S3_S3_dS6_", "Java_org_opencv_imgproc_Moments_get_1m00_10", "_ZNK2cv7linemod20ColorGradientPyramid8quantizeERNS_3MatE", "TIFFVStripSize", "Java_org_opencv_core_Mat_n_1Mat__DDIDDDD", "cvBoxPoints", "_ZN2cv6detail19ExposureCompensator13createDefaultEi", "icvGetAngleLine", "_ZN6cvtest17calcSobelKernel2DEiiii", "_TIFFNoPreCode", "cvCreateSet", "jpc_mqenc_create", "_ZN2cv14ChamferMatcher8Template7rescaleEf", "_ZN9CvLevMarq4stepEv", "_ZN3Imf14TypedAttributeINS_6EnvmapEE14staticTypeNameEv", "cvDestroyWindow", "TIFFScanlineSize64", "_ZNK9CvGBTrees12write_paramsEP13CvFileStorage", "png_get_sRGB", "jpc_streamlist_remove", "Java_org_opencv_calib3d_Calib3d_projectPoints_11", "_ZN3Imf10CompressorC1ERKNS_6HeaderE", "Java_org_opencv_imgproc_Subdiv2D_edgeOrg_10", "_ZN2cv3ocl12convolve_32FERKNS0_6oclMatES3_RS1_RNS0_16MatchTemplateBufE", "_ZNK7testing8UnitTest15start_timestampEv", "cvAbsDiff", "_ZN3Imf8isoSpeedERNS_6HeaderE", "_ZN2cv11RetinaColor35_interpolateImageDemultiplexedImageEPf", "_ZN3Imf17hasChromaticitiesERKNS_6HeaderE", "_ZNK2cv7MatExpr5crossERKNS_3MatE", "_ZN8CvMLData8read_csvEPKc", "_ZN2cv24GenericDescriptorMatcher6createERKSsS2_", "_ZN2cv11FileStorageD1Ev", "cvCompleteSymm", "Java_org_opencv_features2d_FeatureDetector_create_10", "Java_org_opencv_imgproc_Imgproc_distanceTransform_10", "_ZN2cv13HOGDescriptor4readERNS_8FileNodeE", "_ZN2cv11RetinaColorC1EjjNS_26RETINA_COLORSAMPLINGMETHODE", "_ZNK2cv7MatOp_T6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRfbMS1_FfvEMS1_FvfERKSs", "_ZN2cv3ocl26BruteForceMatcher_OCL_base11matchSingleERKNS0_6oclMatES4_RS2_S5_S4_", "_ZN2cv17BasicRetinaFilter21_verticalCausalFilterEPfjj", "Java_org_opencv_ml_CvKNearest_CvKNearest_10", "_ZN9CvANN_MLPD0Ev", "_ZN2cv6Retina13getParametersEv", "_ZN2cv3ocl24createGaussianFilter_GPUEiNS_5Size_IiEEddiS2_", "Java_org_opencv_features2d_DescriptorMatcher_radiusMatch_10", "_ZN18CvBlobTrackerAuto1D2Ev", "jpc_streamlist_numstreams", "_ZN7testing8internal6String15FormatIntWidth2Ei", "jp2_box_create", "_ZNK3Imf6Header12previewImageEv", "Java_org_opencv_ml_CvSVMParams_get_1C_10", "_ZN2cv3ocl13HOGDescriptor22computeBlockHistogramsERKNS0_6oclMatE", "_ZNK2cv3PCA7projectERKNS_11_InputArrayE", "_ZN2cv23BackgroundSubtractorGMG10initializeENS_5Size_IiEEdd", "cvReshape", "_ZN17CirclesGridFinder7SegmentC1EN2cv6Point_IfEES3_", "icvGetDistanceFromPointToDirect", "_ZNK2cv6Retina5writeERNS_11FileStorageE", "_ZN3Imf5SliceC1ENS_9PixelTypeEPcjjiidbb", "_ZNK2cv13Jpeg2KDecoder10newDecoderEv", "_ZN2cv15calibrateCameraERKNS_11_InputArrayES2_NS_5Size_IiEERKNS_12_OutputArrayES7_S7_S7_iNS_12TermCriteriaE", "_ZN2cv20LogPolar_Overlapping11to_corticalERKNS_3MatE", "_ZNK2cv4LBPH4infoEv", "_ZN12CvFuzzyCurve9calcValueEd", "_ZN20CvBlobDetectorSimpleC2Ev", "_TIFFmemset", "jpc_ns_invlift_col", "cvEstimateRigidTransform", "Java_org_opencv_core_Core_polylines_12", "_Z9TransposePfii", "_ZN2cv14RandomizedTree11createNodesEiRNS_3RNGE", "_ZN14CameraActivity16setPathLibFolderEPKc", "_ZNK2cv7linemod13ColorGradient11processImplERKNS_3MatES4_", "Java_org_opencv_imgproc_Imgproc_initWideAngleProjMap_10", "_ZN17CvCamShiftTrackerD1Ev", "_ZN2cv6OctreeC1Ev", "png_do_read_transformations", "_ZN2cv9SparseMat10removeNodeEjjj", "_ZN2cv23BackgroundSubtractorMOGD2Ev", "_ZN2cv20OneWayDescriptorBase18LoadPCADescriptorsERKNS_8FileNodeE", "Java_org_opencv_ml_CvBoostParams_set_1boost_1type_10", "cvCalibrateCamera2", "_ZN2cv22OneWayDescriptorObjectC1E6CvSizeiPKcS3_S3_S3_i", "_ZN2cv3ocl11bitwise_xorERKNS0_6oclMatERKNS_7Scalar_IdEERS1_S3_", "Java_org_opencv_imgproc_Imgproc_contourArea_10", "jas_matrix_asr", "_ZN3Imf6HeaderC2EiifRKN5Imath4Vec2IfEEfNS_9LineOrderENS_11CompressionE", "_ZN3Imf11ChannelList18channelsWithPrefixERKSsRNS0_8IteratorES4_", "_ZN2cv9Algorithm3setEPKcd", "cvWriteInt", "_ZN2cv9thresholdERKNS_11_InputArrayERKNS_12_OutputArrayEddi", "_ZN9IlmThread9SemaphoreC1Ej", "Java_org_opencv_core_Core_randu_10", "cvMatchContourTrees", "_ZN2cv10PngDecoder8readDataERNS_3MatE", "Java_org_opencv_imgproc_Moments_get_1nu21_10", "_ZN2cv8internal13projectPointsERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_RKNS0_15IntrinsicParamsES6_", "_ZN2cv3ocl5remapERKNS0_6oclMatERS1_S4_S4_iiRKNS_7Scalar_IdEE", "_ZN6cvtest9ArrayTestD2Ev", "_ZN3Imf17newTileCompressorENS_11CompressionEjjRKNS_6HeaderE", "_ZN2cv9videostab18InpaintingPipeline9setRadiusEi", "_ZN2cv6detail18PairwiseSeamFinder4findERKSt6vectorINS_3MatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_", "_ZNK2cv4LBPH4saveERNS_11FileStorageE", "_ZN17CirclesGridFinderC2EN2cv5Size_IiEERKSt6vectorINS0_6Point_IfEESaIS5_EERK27CirclesGridFinderParameters", "_ZNK2cv15FeatureDetector5emptyEv", "_ZN2cv3gpu6GpuMat6createEiii", "_ZN4epnp6fill_MEP5CvMatiPKddd", "png_get_hIST", "_ZN2cv17BasicRetinaFilter44_verticalAnticausalFilter_Irregular_multGainEPfjj", "_ZN7testing8internal24HasNewFatalFailureHelper20ReportTestPartResultERKNS_14TestPartResultE", "_ZN2cv12_OutputArrayC2ERKSt6vectorINS_3MatESaIS2_EE", "_ZN2cv17BasicRetinaFilter27_horizontalAnticausalFilterEPfjj", "_ZNK2cv16OneWayDescriptor14GetFeatureNameEv", "_ZN2cv20PlanarObjectDetector4readERKNS_8FileNodeE", "_ZNK2cv5flann11IndexParams9getDoubleERKSsd", "_ZN16CvDTreeTrainData17do_responses_copyEv", "Java_org_opencv_video_Video_calcOpticalFlowSF_10", "_ZN3Imf11hufCompressEPKtiPc", "_ZN5RFace14CalculateErrorEP8FaceData", "png_set_pHYs", "_ZN2cv16GeneralizedHoughD1Ev", "_ZNK3Imf14TiledInputFile17dataWindowForTileEiii", "Java_org_opencv_calib3d_Calib3d_stereoRectifyUncalibrated_10", "_ZN7testing8DoubleLEEPKcS1_dd", "_ZNK2cv12MatOp_Invert6assignERKNS_7MatExprERNS_3MatEi", "jinit_d_post_controller", "_ZNK2cv5MatOp17augAssignSubtractERKNS_7MatExprERNS_3MatE", "_ZN17CirclesGridFinder11rectifyGridEN2cv5Size_IiEERKSt6vectorINS0_6Point_IfEESaIS5_EES9_RS7_", "_ZN3Imf11StdOSStream5tellpEv", "_ZN17CvCapture_Android15convertYUV2GreyEiiPKhRN2cv3MatE", "_ZNK2cv3of213BOWMSCTrainer7clusterERKNS_3MatE", "_ZN7testing32ScopedFakeTestPartResultReporter20ReportTestPartResultERKNS_14TestPartResultE", "Java_org_opencv_core_Core_batchDistance_10", "_ZN2cv6repeatERKNS_11_InputArrayEiiRKNS_12_OutputArrayE", "_ZNK10CvKNearest16get_sample_countEv", "_ZN2cv12_OutputArrayC1ERKNS_3ogl6BufferE", "_ZN2cv13HaarEvaluator4readERKNS_8FileNodeE", "_ZN10__cxxabiv116__enum_type_infoD2Ev", "_ZN3Imf7IStream5clearEv", "_ZN3Imf23chromaticitiesAttributeERNS_6HeaderE", "_ZN2cv17accumulateProductERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZN2cv7linemod13ColorGradientC2Efjf", "Java_org_opencv_core_Mat_n_1create__JDDI", "_ZN9CvLevMarq9updateAltERPK5CvMatRPS0_S5_RPd", "_TIFFNoPostDecode", "_ZN3Imf11ChannelList4findEPKc", "_ZN2cv11SVBackSubstERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayE", "Java_org_opencv_features2d_FeatureDetector_read_10", "Java_org_opencv_ml_CvStatModel_save_11", "_ZN2cv5flann20AutotunedIndexParamsC1Effff", "_ZN2cv6Mesh3D14computeNormalsERKSt6vectorIiSaIiEEfi", "__subdf3", "_ZN12CvForestTreeC2Ev", "_ZN16CvCapture_Images5closeEv", "_ZN2cv9fastAtan2EPKfS1_Pfib", "Java_org_opencv_core_Core_gemm_11", "_ZN7testing8internal17TestEventRepeater25OnEnvironmentsTearDownEndERKNS_8UnitTestE", "_ZN2cv15readPCAFeaturesEPKcPP5CvMatS4_S1_", "_ZN2cv17BasicRetinaFilter33_horizontalCausalFilter_IrregularEPfjj", "icvGetMiddleAnglePoint", "jpeg_destroy_compress", "png_get_header_version", "TIFFRewriteDirectory", "_ZN7testing8internal2RE12PartialMatchEPKcRKS1_", "_ZN3Imf15Pxr24Compressor8compressEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN3Imf20precalculateTileInfoERKNS_15TileDescriptionEiiiiRPiS4_RiS5_", "_ZN2cv3ocl18buildWarpPlaneMapsENS_5Size_IiEENS_5Rect_IiEERKNS_3MatES7_S7_fRNS0_6oclMatES9_", "png_do_write_invert_alpha", "_ZN4perf8TestBase5SetUpEv", "_Z14PCAFeatureMapsP16CvLSVMFeatureMap", "_ZN2cv17CommandLineParser11printParamsEv", "Java_org_opencv_features2d_DescriptorMatcher_write_10", "Java_org_opencv_ml_CvParamGrid_set_1min_1val_10", "png_combine_row", "_ZN2cv11_InputArrayC2ERKNS_3ogl6BufferE", "_ZN2cv12KalmanFilter4initEiiii", "_Z24icvCvt_BGRA2BGR_8u_C4C3RPKhiPhi6CvSizei", "_ZN13CvFMEstimator9run8PointEPK5CvMatS2_PS0_", "TIFFGetSizeProc", "_ZN2cv15CvHybridTrackerC2ENS_21CvHybridTrackerParamsE", "_ZN10CvEMParamsC1Eiii14CvTermCriteriaPK5CvMatS3_S3_PS3_", "_ZN2cv19getConvertScaleElemEii", "_ZN2cv6detail7Blender5blendERNS_3MatES3_", "_Z6icvDetPd", "jinit_phuff_encoder", "_ZN3Imf13RleCompressorD2Ev", "cvPyrMeanShiftFiltering", "_ZN2cv3ocl20FarnebackOpticalFlowC2Ev", "jp2_box_dump", "cvFindStereoCorrespondenceBM", "cvMultiplyAcc", "_ZNK2cv3gpu10DeviceInfo11totalMemoryEv", "_ZN4perf10RegressionC2Ev", "_ZN2cv3ocl6divideERKNS0_6oclMatES3_RS1_d", "_ZN2cv13Jpeg2KDecoder8readDataERNS_3MatE", "_ZN2cv10BmpDecoder8readDataERNS_3MatE", "_ZN2cv8Subdiv2DC2Ev", "jpc_putms", "_ZN2cv3of211ChowLiuTree15createBaseEdgesERSt4listINS1_4infoESaIS3_EEd", "_ZN11CvSVMSolver11solve_c_svcEiiPPKfPaddP12CvMemStorageP11CvSVMKernelPdR17CvSVMSolutionInfo", "_ZN2cv15bilateralFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiddi", "jas_image_destroy", "_ZN2cv12createButtonERKSsPFviPvES2_ib", "_ZN2cv3ocl24matchTemplateNaive_CCORRERKNS0_6oclMatES3_RS1_i", "_ZN3p3pC1EN2cv3MatE", "_ZNK2cv10MatOp_GEMM8multiplyERKNS_7MatExprEdRS1_", "_ZN7testing11IsSubstringEPKcS1_PKwS3_", "_ZN2cv14SpinImageModelC2ERKNS_6Mesh3DE", "_ZN3Imf7keyCodeERNS_6HeaderE", "cvInvert", "_ZN3Imf9AttributeD0Ev", "_ZN23CvNormalBayesClassifierC1Ev", "_ZN2cv5eigenERKNS_11_InputArrayEbRKNS_12_OutputArrayES5_", "Java_org_opencv_highgui_VideoCapture_n_1grab", "_ZN10CvVSModule8DelParamEPKc", "_ZN2cv16FeatureEvaluator6createEi", "Java_org_opencv_core_Core_polylines_11", "_ZN4perf10Regression5writeEN2cv3MatE", "_ZN2cv17eigenvector2imageEP5CvMatP9_IplImage", "Java_org_opencv_core_Mat_n_1setTo__JJJ", "_ZNK2cv29DynamicAdaptedFeatureDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "png_handle_bKGD", "_ZNK3Imf11FrameBuffer3endEv", "_ZN2cv3of26FabMap7PzqGzpqEibb", "Java_org_opencv_highgui_VideoCapture_n_1VideoCapture__I", "_ZN2cv3ocl13HOGDescriptor14numPartsWithinENS_5Size_IiEES3_S3_", "_Z13FillColorRow8PhS_iP12PaletteEntry", "_ZdlPvj", "jas_getversion", "jpeg_new_colormap", "_ZN21CvHomographyEstimator18computeReprojErrorEPK5CvMatS2_S2_PS0_", "_ZN2cv5flann5IndexD0Ev", "_ZNK2cv6detail12CameraParams1KEv", "_ZN22CvAdaptiveSkinDetector9Histogram19findCurveThresholdsERiS1_d", "_ZN7testing8internal30ReportFailureInUnknownLocationENS_14TestPartResult4TypeERKSs", "cvCmpS", "_ZN2cv3ocl24OpticalFlowDual_TVL1_OCLC1Ev", "_ZN2cv14RandomizedTree15makePosteriors2Ei", "Java_org_opencv_ml_CvKNearest_CvKNearest_11", "_ZN7CvImage4readEP13CvFileStoragePKci", "jpeg_alloc_huff_table", "_ZN2cv3gpu6GpuMatC2ERKS1_NS_5Rect_IiEE", "_ZN3Imf17addWhiteLuminanceERNS_6HeaderERKf", "_ZN2cv12_OutputArrayC1ERSt6vectorINS_3MatESaIS2_EE", "jas_iccattrtab_dump", "_ZN3Imf8TimeCode8setHoursEi", "_ZN6cvtest7randUniERN2cv3RNGERNS0_3MatERKNS0_7Scalar_IdEES8_", "_ZN2cv7absdiffERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN4CvEM12set_mat_hdrsEv", "_ZNK2cv3Mat5crossERKNS_11_InputArrayE", "cvInitUndistortRectifyMap", "jpc_ppxstab_destroy", "_ZN3Imf11FrameBuffer9findSliceEPKc", "__gnu_uldivmod_helper", "_ZN3Imf11TileOffsets8readFromERNS_7IStreamERb", "Java_org_opencv_core_Mat_nGetS", "_ZNK7testing10TestResult6FailedEv", "_ZN2cv13BaseRowFilterD1Ev", "_ZN21CvHomographyEstimatorC2Ei", "_ZN2cv7linemod11DepthNormalC2Eiiji", "_ZN2cv3ocl5erodeERKNS0_6oclMatERS1_RKNS_3MatENS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN7testing4TestC2Ev", "Java_org_opencv_ml_CvRTParams_set_1nactive_1vars_10", "_ZNK2cv12FastAdjuster5cloneEv", "_ZN2cv14FernClassifier5trainERKSt6vectorIS1_INS_6Point_IfEESaIS3_EESaIS5_EERKS1_INS_3MatESaISA_EERKS1_IS1_IiSaIiEESaISG_EEiiiiiiiRKNS_14PatchGeneratorE", "TIFFDataWidth", "Java_org_opencv_features2d_GenericDescriptorMatcher_classify_11", "_ZN2cv8GlCamera8setScaleENS_7Point3_IdEE", "_ZN7testing8internal17TestEventRepeater20OnTestIterationStartERKNS_8UnitTestEi", "cvAttrValue", "_ZN3Imf8TimeCodeC1Ev", "Java_org_opencv_core_Core_multiply_13", "Java_org_opencv_ml_CvSVMParams_get_1nu_10", "cvSubRS", "TIFFIsTiled", "_ZN2cv10ExrDecoder9UpSampleXEPfii", "_ZN2cv8internal16JRodriguesMatlabERKNS_3MatERS1_", "_ZN3p3pC1Edddd", "_ZN2cv8superres24createFrameSource_CameraEi", "_ZN7testing8internal6IsTrueEb", "_ZN9CvGBTreesC1ERKN2cv3MatEiS3_S3_S3_S3_S3_15CvGBTreesParams", "_ZN2cv3ogl9Texture2DC1ENS_5Size_IiEENS1_6FormatEjb", "_ZN4perf8TestBase10_calibrateEv", "_ZN2cvmiERKNS_7Scalar_IdEERKNS_7MatExprE", "_ZN4CvEMC1EPK5CvMatS2_10CvEMParamsPS0_", "_ZN2cv3oclcoERKNS0_6oclMatE", "Java_org_opencv_ml_CvBoost_CvBoost_11", "_ZN2cv3gpu9setDeviceEi", "_ZN2cv32OpponentColorDescriptorExtractor4readERKNS_8FileNodeE", "_ZN6cvtest9ArrayTest11read_paramsEP13CvFileStorage", "_ZN2cv10ExrEncoderD2Ev", "Java_org_opencv_ml_CvSVM_get_1var_1count_10", "_Z21cvTestSeqGetObjectPosPviP12CvPoint2D32f", "_ZNK5Graph16getVerticesCountEv", "_ZN3Imf17ScanLineInputFile14setFrameBufferERKNS_11FrameBufferE", "_ZN2cv6Retina26setupOPLandIPLParvoChannelEbbfffffff", "_ZN2cv21FernDescriptorMatcher4readERKNS_8FileNodeE", "jpc_getsignmsedec_func", "_ZN2cv17MagnoRetinaFilter23_amacrineCellsComputingEPKfS2_", "_ZN2cv16OneWayDescriptor4SaveEPKc", "_ZN22CameraWrapperConnector16getPathLibFolderEv", "_ZN7testing8internal10SkipPrefixEPKcPS2_", "_ZNK2cv17DescriptorMatcher20DescriptorCollection11getLocalIdxEiRiS2_", "_ZN2cv3ocl24buildWarpPerspectiveMapsERKNS_3MatEbNS_5Size_IiEERNS0_6oclMatES7_", "cvGetNumThreads", "jpeg_finish_decompress", "cvReleaseHaarClassifierCascade", "_ZNK2cv13HOGDescriptor7computeERKNS_3MatERSt6vectorIfSaIfEENS_5Size_IiEES9_RKS4_INS_6Point_IiEESaISB_EE", "_ZN2cv11_InputArrayC2ERKd", "_ZN7testing8internal16InDeathTestChildEv", "_ZN7testing8internal25ReportInvalidTestCaseTypeEPKcS2_i", "cvGetFileNodeByName", "cvCountNonZero", "png_handle_sRGB", "_ZN4perf8TestBase4InitEiPKPKc", "jinit_huff_decoder", "_ZNK21DetectionBasedTracker31calcTrackedObjectPositionToShowEi", "Java_org_opencv_core_Core_mean_10", "cvCreateMatNDHeader", "_ZN2cv11JpegDecoderC2Ev", "_ZN6cvtest9getMinValEi", "_ZN2cv6theRNGEv", "_ZN3Imf9InputFile4DataC1Ebi", "_ZNK3Imf11FrameBuffer4findERKSs", "_Z11_cvCalcEdgeP16CvVoronoiNodeIntP16CvVoronoiSiteIntP16CvVoronoiEdgeIntP19CvVoronoiDiagramInt", "Java_org_opencv_objdetect_CascadeClassifier_detectMultiScale_10", "_ZN2cv13parallel_for_ERKNS_5RangeERKNS_16ParallelLoopBodyEd", "_ZN2cv17DescriptorMatcherD2Ev", "_ZN2cv9videostab17WeightingDeblurerC2Ev", "_ZN2cv20FastFeatureDetector2C1Eib", "Java_org_opencv_ml_EM_trainE_11", "_ZN3Imf10uintToHalfEj", "_ZN2cv6detail18SurfFeaturesFinderC2Ediiii", "_ZN2cv24BackgroundSubtractorMOG2D1Ev", "_ZNK2cv16BaseImageEncoder14getDescriptionEv", "_ZN3Imf11ChannelList11findChannelEPKc", "_ZN2cv3ocl6oclMataSERKNS_7Scalar_IdEE", "_ZN2cv17MagnoRetinaFilterD1Ev", "cvCalibrateCamera_64d", "_ZN2cv14ChamferMatcher8TemplateC1ERNS_3MatEf", "_ZN11CvSVMKernelD0Ev", "_ZN2cv12_OutputArrayC2ERSt6vectorINS_3MatESaIS2_EE", "png_default_flush", "Java_org_opencv_imgproc_Subdiv2D_nextEdge_10", "_ZN16CvDTreeTrainData10set_paramsERK13CvDTreeParams", "_ZN11FaceFeatureC2Ev", "Java_org_opencv_calib3d_Calib3d_convertPointsFromHomogeneous_10", "jpc_init_t2state", "_ZN3Imf24framesPerSecondAttributeERNS_6HeaderE", "_ZN2cv3ogl6BufferC1ENS_5Size_IiEEiNS1_6TargetEb", "Java_org_opencv_core_Core_vconcat_10", "Java_org_opencv_gpu_Gpu_setDevice_10", "jas_alloc3", "cvRemoveNodeFromTree", "_ZN2cv20getValidDisparityROIENS_5Rect_IiEES1_iii", "_ZN3Imf27renderingTransformAttributeERKNS_6HeaderE", "png_set_scale_16", "_ZN2cv16FeatureEvaluator4readERKNS_8FileNodeE", "_ZN3Imf11addTimeCodeERNS_6HeaderERKNS_8TimeCodeE", "_ZN2cv20FindOneWayDescriptorEiPKNS_16OneWayDescriptorEP9_IplImageRiS5_RfP5CvMatS8_", "_ZN2cv12GaussianBlurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi", "_ZN2cv3ocl17KNearestNeighbourD2Ev", "_ZN13FaceDetection17ThresholdingParamEP9_IplImageiRiS2_S2_", "_ZN7testing8internal7PrintToEaPSo", "_ZN7CvDTree14try_split_nodeEP11CvDTreeNode", "_ZNK2cv7MatExpr4diagEi", "_ZN9CvLevMarqC1Eii14CvTermCriteriab", "_ZN2cv9videostab18FastMarchingMethod6heapUpEi", "__subsf3", "_ZNK16CvDTreeTrainData15get_num_classesEv", "cvCreateMemStorage", "jpeg_finish_output", "_ZNK2cv26GridAdaptedFeatureDetector4infoEv", "_ZN2cv8Stitcher20estimateCameraParamsEv", "png_get_pixel_aspect_ratio", "_ZNK2cv5FREAK4infoEv", "_ZN2cv8GlBufferC2ENS0_5UsageE", "_ZN3Imf8XYZtoRGBENS_14ChromaticitiesEf", "_ZN2cv12RetinaFilter31_processRetinaParvoMagnoMappingEv", "cvFindFeaturesBoxed", "_ZN14CameraActivityC2Ev", "Java_org_opencv_core_Core_solvePoly_10", "_ZN6cvtest7PrintToERKNS_7InverseEPSo", "_ZN2cv16GeneralizedHough11setTemplateERKNS_11_InputArrayES3_S3_NS_6Point_IiEE", "Java_org_opencv_highgui_VideoCapture_n_1retrieve__JJ", "_ZN2cvgtERKNS_3MatES2_", "_ZN2cv20PlanarObjectDetectorC2ERKNS_8FileNodeE", "_ZN2cv9Formatter10setDefaultEPKS0_", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection9getImagesEv", "_ZN2cv6detail16MultiBandBlenderC2Eiii", "_ZNK4CvEM7predictERKN2cv3MatEPS1_", "_ZN2cv8internal19CalibrateExtrinsicsERKNS_11_InputArrayES3_RKNS0_15IntrinsicParamsEidRKNS_12_OutputArrayES9_", "png_read_image", "jpeg_write_tables", "_ZN7testing8UnitTestC1Ev", "_ZN2cv6OctreeC2ERKSt6vectorINS_7Point3_IfEESaIS3_EEii", "_ZN4epnp12gauss_newtonEPK5CvMatS2_Pd", "_TIFFNoTileDecode", "_ZN2cv3gpu6GpuMataSERKS1_", "_ZN11CvSVMKernel12calc_sigmoidEiiPPKfS1_Pf", "_ZNK2cv5MatOp8multiplyERKNS_7MatExprEdRS1_", "jpeg_fill_bit_buffer", "_ZNK2cv8GlArrays6unbindEv", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_i", "_ZN13CvFMEstimator9runKernelEPK5CvMatS2_PS0_", "png_set_invert_alpha", "_ZN2cv6reduceERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "_ZN2cv6detail18GraphCutSeamFinderD2Ev", "png_write_IDAT", "Java_org_opencv_core_Core_polarToCart_11", "Java_org_opencv_imgproc_Moments_get_1m12_10", "Java_org_opencv_core_Algorithm_getMatVector_10", "Java_org_opencv_calib3d_Calib3d_drawChessboardCorners_10", "_ZN3Imf14TypedAttributeINS_11CompressionEE14staticTypeNameEv", "_ZN2cv3ocl12equalizeHistERKNS0_6oclMatERS1_", "_ZN2cv15getDerivKernelsERKNS_12_OutputArrayES2_iiibi", "_ZN7testing8internal27PrettyUnitTestResultPrinter20OnTestIterationStartERKNS_8UnitTestEi", "_ZN3Imf14TiledInputFileC2ERNS_7IStreamEi", "_ZNK10CvKNearest12find_nearestERKN2cv3MatEiPS1_PPKfS4_S4_", "Java_org_opencv_core_Core_line_10", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEE", "_ZNK2cv22OneWayDescriptorObject17GetDescriptorPartEi", "_ZN2cv6detail11PlaneWarper9warpPointERKNS_6Point_IfEERKNS_3MatES8_S8_", "png_write_image", "_ZN12CvFuzzyCurve5clearEv", "png_chunk_error", "_ZN7CvDTree8cut_treeEiid", "jas_matrix_setall", "_ZN11CvBoostTree20find_split_ord_classEP11CvDTreeNodeifP12CvDTreeSplitPh", "__gtsf2", "png_set_interlace_handling", "_ZNK2cv7MatExpr3mulERKS0_d", "cvMinAreaRect2", "_ZN21DetectionBasedTracker13getParametersEv", "Java_org_opencv_imgproc_Imgproc_GaussianBlur_11", "_ZN2cv18CvMeanShiftTrackerD2Ev", "_ZN7testing8internal17TestEventRepeater6AppendEPNS_17TestEventListenerE", "_ZN6cvtest4normERKN2cv3MatES3_iS3_", "_ZN2cv3MatC2EPK5CvMatb", "_ZN2cv5FREAKC2EbbfiRKSt6vectorIiSaIiEE", "_ZN2cv6Retina8getParvoERSt8valarrayIfE", "_ZN2cv7fisheye15stereoCalibrateERKNS_11_InputArrayES3_S3_RKNS_12_OutputArrayES6_S6_S6_NS_5Size_IiEES6_S6_iNS_12TermCriteriaE", "_ZN2cv11VideoWriterlsERKNS_3MatE", "_ZN2cv8internal15IntrinsicParamsC2Ev", "_ZNK9CvANN_MLP11scale_inputEPK5CvMatPS0_", "_Z17allocFilterObjectPP18CvLSVMFilterObjectiii", "cvSetND", "_ZN9CvERTreesD0Ev", "_ZN2cv3ocl7absdiffERKNS0_6oclMatERKNS_7Scalar_IdEERS1_", "png_set_compression_buffer_size", "_TIFFGetExifFields", "_ZN7testing8internal27PrettyUnitTestResultPrinter13OnTestCaseEndERKNS_8TestCaseE", "_ZN11CvBoostTree5clearEv", "Java_org_opencv_core_Core_randShuffle_11", "Java_org_opencv_features2d_Features2d_drawMatches_11", "_ZN2cv6detail18GraphCutSeamFinderD1Ev", "_ZNK2cv11_InputArray15getOGlTexture2DEv", "Java_org_opencv_calib3d_Calib3d_initCameraMatrix2D_10", "_ZN9IlmThread10ThreadPool7addTaskEPNS_4TaskE", "_ZN3Imf25lookModTransformAttributeERNS_6HeaderE", "cvFindExtrinsicCameraParams", "_ZNK2cv5BRISKclERKNS_11_InputArrayES3_RSt6vectorINS_8KeyPointESaIS5_EE", "_ZN6cvtest9randomMatERN2cv3RNGENS0_5Size_IiEEiddb", "_ZN11FaceFeatureC1EdPvb", "_ZN2cv16FileNodeIteratorC2ERKS0_", "_ZNK2cv14SpinImageModel21packRandomScaledSpinsEbjj", "png_check_fp_string", "Java_org_opencv_imgproc_CLAHE_apply_10", "_ZN16CvBlobDetectorCC13DetectNewBlobEP9_IplImageS1_P9CvBlobSeqS3_", "_ZN2cv5CannyERKNS_11_InputArrayERKNS_12_OutputArrayEddib", "_Z7icvSortPdi", "_ZN7testing8internal12UnitTestImpl41GetTestPartResultReporterForCurrentThreadEv", "_ZN4perf8TestBase14_declareHelper4timeEd", "_ZNK2cv8Subdiv2D6Vertex6isfreeEv", "_ZN7testing8internal27PrettyUnitTestResultPrinter27OnEnvironmentsTearDownStartERKNS_8UnitTestE", "_ZN2cv3ocl18openCLVerifyKernelEPKNS0_7ContextEP10_cl_kernelPj", "_ZN6cvtest7compareERKN2cv3MatEdRS1_i", "_ZN7testing8internal12UnitTestImpl11FilterTestsENS1_18ReactionToShardingE", "_ZN7Sampler7extractEv", "_ZN2cv3ocl19createBoxFilter_GPUEiiRKNS_5Size_IiEERKNS_6Point_IiEEi", "_ZN2cv7vconcatEPKNS_3MatEjRKNS_12_OutputArrayE", "_ZN2cv5flann5Index12radiusSearchERKNS_11_InputArrayERKNS_12_OutputArrayES7_diRKNS0_12SearchParamsE", "_ZN3Imf17commentsAttributeERNS_6HeaderE", "_Z17_cvStretchingWorkP12CvPoint2D32fS0_", "Java_org_opencv_gpu_Gpu_getDevice_10", "_ZN2cv17phaseCorrelateResERKNS_11_InputArrayES2_S2_Pd", "cvSeqPop", "_ZNK2cv12_OutputArray18getOGlTexture2DRefEv", "_ZN2cv9SparseMat3HdrC1EiPKii", "_ZN2cv3PCAC1Ev", "_Z9icvMedianPiS_iPd", "_ZN2cv3ocl6ScharrERKNS0_6oclMatERS1_iiiddi", "_Z17cvTestSeqSetFramePvi", "_ZN2cv6renderERKNS_9GlTextureENS_5Rect_IdEES4_", "_ZNK2cv5MatOp17augAssignMultiplyERKNS_7MatExprERNS_3MatE", "_ZN2cv3ocl26BruteForceMatcher_OCL_base12matchConvertERKNS_3MatES4_S4_RSt6vectorINS_6DMatchESaIS6_EE", "_ZN14CvBlobTrackSeqC2Ei", "_ZNK7testing8internal12UnitTestImpl22failed_test_case_countEv", "_Z26icvGetRectSubPix_8u32f_C1RPKhi6CvSizePfiS1_12CvPoint2D32f", "_ZNK2cv3ogl6Buffer4bindENS1_6TargetE", "_ZN3Imf12PreviewImageC1EjjPKNS_11PreviewRgbaE", "Java_org_opencv_features2d_GenericDescriptorMatcher_create_10", "_ZN10__cxxabiv123__fundamental_type_infoD2Ev", "Java_org_opencv_core_Core_rectangle_12", "_ZNK2cv12FastAdjuster4goodEv", "_Z18icvIntersectLines3PdS_S_S_S_S_P12CvPoint2D32f", "_ZN2cv8KeyPoint7overlapERKS0_S2_", "_ZN2cv4LBPH5trainERKNS_11_InputArrayES3_", "cvCornerEigenValsAndVecs", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection11getLocalIdxEiRiS2_", "_ZN2cv16initModule_videoEv", "_ZN2cv6detail5Graph7addEdgeEiif", "jpc_initctxs", "_ZN3Imf9InputFile10initializeEv", "_ZN2cv7polyfitERKNS_3MatES2_RS0_i", "_ZN7testing8internal9DeathTestC2Ev", "_ZN6cvtest7logicOpERKN2cv3MatERKNS0_7Scalar_IdEERS1_c", "_ZN2cv17BasicRetinaFilter41_verticalAnticausalFilter_returnMeanValueEPfjj", "_ZN3Imf8TimeCodeC1EjjNS0_7PackingE", "_ZNK2cv20PlanarObjectDetectorclERKSt6vectorINS_3MatESaIS2_EERKS1_INS_8KeyPointESaIS7_EERS2_RS1_INS_6Point_IfEESaISE_EEPS1_IiSaIiEE", "_ZN7testing8internal20SingleFailureCheckerD2Ev", "_ZN5CvSVM13create_solverEv", "Java_org_opencv_calib3d_StereoBM_delete", "_ZN2cv2EM12setTrainDataEiRKNS_3MatEPS2_S4_PKSt6vectorIS1_SaIS1_EES4_", "cvClearSubdivVoronoi2D", "_ZN23CvFuzzyMeanShiftTracker12FuzzyResizerC1Ev", "_ZNK2cv10PngEncoder10newEncoderEv", "_ZN2cv3of27FabMap2C2ERKNS_3MatEddi", "_ZN2cv3ocl23StereoBeliefPropagation25estimateRecommendedParamsEiiRiS2_S2_", "_ZNK2cv16SunRasterEncoder10newEncoderEv", "cvMatchTemplate", "cvReleaseImageHeader", "_ZN2cv10ExrEncoderC1Ev", "jpc_getuint8", "_ZN3Imf9longitudeERNS_6HeaderE", "cvCamShift", "cvCopyHist", "_ZN2cv3of27FabMap214getLikelihoodsERKNS_3MatERKSt6vectorIS2_SaIS2_EERS5_INS0_6IMatchESaISA_EE", "_ZN20CvVideoWriter_Images4openEPKc", "_ZN17FaceDetectionListD1Ev", "cvPreCornerDetect", "_ZTv0_n12_N2cv5FREAKD0Ev", "_ZN2cv17ParvoRetinaFilterD1Ev", "_ZN16CvCapture_Images4openEPKc", "Java_org_opencv_core_Core_compare_10", "jpeg_start_output", "_ZN3Imf15OpaqueAttributeC2ERKS0_", "_ZN7testing8internal13DeathTestImpl5AbortENS0_9DeathTest11AbortReasonE", "_ZN2cv21setOpenGlDrawCallbackERKSsPFvPvES2_", "_Z37cvCreateModuleBlobTrackAnalysisHistSSv", "Java_org_opencv_objdetect_CascadeClassifier_CascadeClassifier_10", "_ZN2cv2EM4readERKNS_8FileNodeE", "_ZN3Iex7BaseExcC1EPKc", "_ZN2cv29DynamicAdaptedFeatureDetectorC1ERKNS_3PtrINS_15AdjusterAdapterEEEiii", "_ZN2cv8Subdiv2D9swapEdgesEi", "_ZN2cv3ocl5canny24edgesHysteresisLocal_gpuERNS0_6oclMatES3_S3_ii", "png_get_io_state", "_ZN2cv17CascadeClassifier4Data4readERKNS_8FileNodeE", "cvSetSeqReaderPos", "png_write_oFFs", "jpc_ft_invlift_colres", "_ZN2cv12morphologyExERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "cvCalcMotionGradient", "_ZN2cv3ocl6finishEv", "_Z19vector_Vec4i_to_MatRSt6vectorIN2cv3VecIiLi4EEESaIS2_EERNS0_3MatE", "cvDilate", "_ZN2cv15savePCAFeaturesERNS_11FileStorageEPKcP5CvMatS5_", "_ZN7CvBoost19get_subtree_weightsEv", "_ZN2cv9LDetectorC1Eiiiidd", "Java_org_opencv_imgproc_Imgproc_dilate_12", "_ZN5CvSVMC1EPK5CvMatS2_S2_S2_11CvSVMParams", "_ZN2cv17BasicRetinaFilterC2Ejjjb", "_ZN2cv8Subdiv2D12connectEdgesEii", "_ZN2cv18preprocess2DKernelERKNS_3MatERSt6vectorINS_6Point_IiEESaIS5_EERS3_IhSaIhEE", "_ZN7CvDTreeC1Ev", "TIFFPredictorInit", "jpc_bitstream_needalign", "_ZN2cv4lineERNS_3MatENS_6Point_IiEES3_RKNS_7Scalar_IdEEiii", "Java_org_opencv_core_Core_subtract_10", "_ZN3Imf18dataWindowForLevelERKNS_15TileDescriptionEiiiiii", "TIFFWriteScanline", "jas_stream_puts", "_ZN2cv5flann5IndexD2Ev", "Java_org_opencv_features2d_Features2d_drawKeypoints_11", "_ZN2cv9magnitudeERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "Java_org_opencv_objdetect_HOGDescriptor_HOGDescriptor_11", "_ZN3Imf11StdOSStream5writeEPKci", "_ZN10__cxxabiv117__pbase_type_infoD2Ev", "png_handle_IEND", "_ZN7testing32ScopedFakeTestPartResultReporterC2ENS0_13InterceptModeEPNS_19TestPartResultArrayE", "_ZN2cv3gpu11TargetArchs17hasEqualOrLessPtxEii", "_ZN2cv24createLBPHFaceRecognizerEiiiid", "Java_org_opencv_imgproc_Imgproc_blur_10", "TIFFVTileSize64", "_ZNK2cv9videostab16MotionFilterBase9stabilizeEPKNS_3MatEiPS2_", "jpeg_default_colorspace", "_ZN2cvgtERKNS_3MatEd", "icvGetNormalDirect", "_ZN2cv3MatC1EPK9_IplImageb", "_ZN2cv3gpu6GpuMatC1ERKS1_NS_5RangeES4_", "TIFFYCbCrToRGBInit", "_ZN7testing8internal17TestEventRepeaterD1Ev", "_ZN2cv6detail18GraphCutSeamFinder4Impl4findERKSt6vectorINS_3MatESaIS4_EERKS3_INS_6Point_IiEESaISA_EERS6_", "_ZN2cv3ogl9Texture2DC2ENS_5Size_IiEENS1_6FormatEjb", "_ZN7testing8internal12UnitTestImpl18ConfigureXmlOutputEv", "jpc_iict", "_ZN2cv3ocl26BruteForceMatcher_OCL_base19radiusMatchDownloadERKNS0_6oclMatES4_S4_S4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "_ZN2cv3ocl20BackgroundSubtractorclERKNS0_6oclMatERS2_f", "Java_org_opencv_ml_CvBoost_clear_10", "_ZN2cv24GenericDescriptorMatcher8classifyERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EE", "_ZN23CvFuzzyMeanShiftTracker12SearchWindowD2Ev", "_ZN2cv10PxMDecoderC2Ev", "_ZN2cv3ocl23StereoBeliefPropagationclERKNS0_6oclMatES4_RS2_", "_ZN2cv3ocl11interpolate15normalizeKernelERNS0_6oclMatEiii", "jas_alloc2", "_ZN2cv11VideoWriterD2Ev", "jinit_c_coef_controller", "_ZN11CvBoostTree20find_split_cat_classEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN13CvCalibFilter9SetFramesEi", "Java_org_opencv_imgproc_Imgproc_goodFeaturesToTrack_11", "_ZN2cv6imreadERKSsi", "_ZN2cv14RandomizedTreeD1Ev", "_ZN9CvANN_MLP16prepare_to_trainEPK5CvMatS2_S2_S2_P9CvVectorsS4_PPdi", "_ZN2cv3ocl11ocl_momentsERKNS_11_InputArrayE", "_ZNK2cv11FileStorage4rootEi", "_ZN2cv8internal15NormalizePixelsERKNS_3MatERKNS0_15IntrinsicParamsE", "_ZN9CvLevMarqD2Ev", "_ZN2cv13AlgorithmInfoC1ERKSsPFPNS_9AlgorithmEvE", "_ZN11CvBoostTree5trainEP16CvDTreeTrainDataPK5CvMatP7CvBoost", "_Z25vector_vector_char_to_MatRSt6vectorIS_IcSaIcEESaIS1_EERN2cv3MatE", "_ZN3Imf11StdOFStreamD0Ev", "_ZN2cv6Mesh3D18estimateResolutionEf", "jzero_far", "_ZN2cv3of26FabMap21normaliseDistributionERSt6vectorINS0_6IMatchESaIS3_EE", "cvCalcBayesianProb", "Java_org_opencv_ml_CvSVM_train_1auto_10", "cvCreatePOSITObject", "_ZN2cv6invertERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv3ocl11cartToPolarERKNS0_6oclMatES3_RS1_S4_b", "Java_org_opencv_core_Mat_locateROI_10", "_ZNK13CvCalibFilter15GetCameraParamsEi", "TIFFFileName", "Java_org_opencv_imgproc_Imgproc_accumulateProduct_10", "_ZN11CvStatModel5clearEv", "_Z9icvPoint7PiS_PdS_", "_ZN9CvANN_MLPC1EPK5CvMatidd", "_ZN10CvKNearestC2ERKN2cv3MatES3_S3_bi", "_ZNK16CvObjectDetector16GetMinWindowSizeEv", "_ZN10__cxxabiv121__vmi_class_type_infoD0Ev", "_ZN2cv14SpinImageModelC1Ev", "_ZNK2cv5MatOp15augAssignDivideERKNS_7MatExprERNS_3MatE", "_ZN2cv20calcOpticalFlowPyrLKERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayES5_S5_NS_5Size_IiEEiNS_12TermCriteriaEid", "_ZN2cv17BasicRetinaFilter25runFilter_LocalAdapdationERKSt8valarrayIfES4_", "_ZN2cv3ocl9columnSumERKNS0_6oclMatERS1_", "_ZN2cvanERKNS_3MatES2_", "_ZN7testing4Test14RecordPropertyERKSsS2_", "_ZN3Imf13PizCompressorD2Ev", "_ZNK2cv11MatOp_AddEx9transposeERKNS_7MatExprERS1_", "jpc_pi_next", "_ZNK2cv3of26FabMap21getTestImgDescriptorsEv", "jpeg_consume_input", "cvGetCols", "_Z33GetProjMatrFromReducedFundamentalP5CvMatS0_", "Java_org_opencv_ml_CvSVMParams_get_1kernel_1type_10", "icvComputeeInfiniteProject2", "Java_org_opencv_imgproc_Imgproc_HoughCircles_11", "_ZNSt13bad_exceptionD0Ev", "_ZN2cv15getNumberOfCPUsEv", "_ZN2cv16CvFeatureTracker17getTrackingWindowEv", "_ZN7testing8internal17TestEventRepeater13OnTestCaseEndERKNS_8TestCaseE", "_ZN2cv17setErrorVerbosityEb", "Java_org_opencv_core_Core_log_10", "_TIFFsetLongArray", "jp2_boxinfolookup", "_ZN2cv5traceERKNS_11_InputArrayE", "_ZN6cvtest4gemmERKN2cv3MatES3_dS3_dRS1_i", "Java_org_opencv_ml_CvSVM_train_10", "_ZN2cv17BasicRetinaFilter36runFilter_LocalAdapdation_autonomousERKSt8valarrayIfE", "cvPostWarpImage", "png_muldiv", "_ZNK2cv9Algorithm9getDoubleERKSs", "_Z16_cvWorkSouthEastiiPP8__CvWorkP12CvPoint2D32fS3_", "_ZN2cv12RetinaFilter10checkInputERKSt8valarrayIfEb", "_ZN13CvBlobTracker6UpdateEP9_IplImageS1_", "_ZNK7testing8UnitTest12elapsed_timeEv", "_ZN2cv11_InputArrayC1ERKd", "_ZN2cv11WBaseStream5closeEv", "_ZN2cv11determinantERKNS_11_InputArrayE", "_ZN9__gnu_cxx27__verbose_terminate_handlerEv", "jpc_enc_encpkts", "_ZN2cv17ParvoRetinaFilter9runFilterERKSt8valarrayIfEb", "png_reciprocal", "TIFFCreateEXIFDirectory", "_ZN2cv13LevMarqSparseD1Ev", "_ZN2cv14ChamferMatcher8Matching23computeEdgeOrientationsERNS_3MatES3_", "_ZN16CvTrainTestSplitC1Eib", "_ZN8CvMLData13set_var_typesEPKc", "_ZN2cv13Jpeg2KEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "jpeg_idct_2x2", "Java_org_opencv_highgui_Highgui_imdecode_10", "jpc_pchglist_numpchgs", "_ZN3Imf13RleCompressorC2ERKNS_6HeaderEj", "_ZN25CvBlobTrackPostProcKalman7ReleaseEv", "_ZN2cv20OneWayDescriptorBase21InitializeDescriptorsEP9_IplImageRKSt6vectorINS_8KeyPointESaIS4_EEPKci", "_ZdlPvRKSt9nothrow_t", "cvCalcOpticalFlowLK", "jpc_enc_encpkt", "_ZN2cv3ocl23StereoBeliefPropagationC2Eiiii", "_ZN2cv6RetinaD1Ev", "_Z26cvCreateVideoWriter_ImagesPKc", "TIFFSetMode", "jas_image_addfmt", "_ZN2cv13segmentMotionERKNS_11_InputArrayERKNS_12_OutputArrayERSt6vectorINS_5Rect_IiEESaIS8_EEdd", "cvRetrieveFrame", "cvFindCornerSubPix", "_ZN2cv17CascadeClassifierC2ERKSs", "Java_org_opencv_calib3d_Calib3d_composeRT_10", "png_sig_cmp", "_ZNK8CvMLData20get_class_labels_mapEv", "_ZN2cv8superres19initModule_superresEv", "_ZN16CvDTreeTrainData9free_nodeEP11CvDTreeNode", "_ZN2cv6detail16MultiBandBlender7prepareENS_5Rect_IiEE", "Java_org_opencv_core_Algorithm_delete", "_ZN2cv3ocl15CvSVMKernel_ocl9calc_polyEiiPfRNS_3MatE", "Java_org_opencv_features2d_Features2d_drawMatches2_10", "_Z11_cvWorkEastiiPP8__CvWorkP12CvPoint2D32fS3_", "_ZN6cvtest2TSD1Ev", "cvEllipseAA", "_ZN7testing8internal11CmpHelperNEEPKcS2_xx", "Java_org_opencv_imgproc_Imgproc_cornerEigenValsAndVecs_11", "png_write_chunk", "cvPolyLine", "Java_org_opencv_core_Core_LUT_10", "_ZN17CvModelEstimator211findInliersEPK5CvMatS2_S2_PS0_S3_d", "jpc_putuint32", "_ZN12CvFuzzyPointC1Edd", "_Z8cvTsZeroP5CvMatPKS_", "_ZNK2cv17DescriptorMatcher10checkMasksERKSt6vectorINS_3MatESaIS2_EEi", "png_set_read_user_chunk_fn", "Java_org_opencv_core_Mat_n_1rows", "png_read_destroy", "_ZN2cv5flann11IndexParams8setFloatERKSsf", "_ZN15CvGBTreesParamsC2Eiiffib", "_ZN4perf8TestBase11calcMetricsEv", "_ZN7testing14IsNotSubstringEPKcS1_PKwS3_", "_ZNK7testing8UnitTest21successful_test_countEv", "_Z15icvGetStartEnd3P9CvMatrix36CvSizePfS2_", "TIFFSetWarningHandlerExt", "png_do_chop", "Java_org_opencv_calib3d_Calib3d_composeRT_11", "_ZNK2cv10BmpDecoder10newDecoderEv", "_ZN3Imf12addLongitudeERNS_6HeaderERKf", "Java_org_opencv_imgproc_Imgproc_HoughLines_11", "_ZN2cv9polylinesERKNS_12_OutputArrayERKNS_11_InputArrayEbRKNS_7Scalar_IdEEiii", "_ZN3Imf11StdIFStreamD0Ev", "Java_org_opencv_calib3d_Calib3d_validateDisparity_11", "Java_org_opencv_features2d_GenericDescriptorMatcher_match_11", "_ZNK9CvGBTrees14predict_serialEPK5CvMatS2_PS0_7CvSlicei", "_ZN9IlmThread9Semaphore7tryWaitEv", "_ZNK2cv17DescriptorMatcher11radiusMatchERKNS_3MatES3_RSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfS3_b", "LSHSize", "_ZN2cv3ocl26BruteForceMatcher_OCL_base11radiusMatchERKNS0_6oclMatES4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEfS4_b", "_ZN2cv3ocl6minMaxERKNS0_6oclMatEPdS4_S3_", "_ZN11CvSVMKernel5clearEv", "_ZN3Imf7expTimeERKNS_6HeaderE", "_ZN2cv3ocl20FarnebackOpticalFlow16gaussianBlur5OclERKNS0_6oclMatEiRS2_", "_ZTv0_n24_NK14HarrisDetector4infoEv", "_ZNK2cv3gpu10DeviceInfo8supportsENS0_10FeatureSetE", "Java_org_opencv_video_Video_calcOpticalFlowFarneback_10", "_ZN5CvSVM10set_paramsERK11CvSVMParams", "Java_org_opencv_core_Core_norm_14", "_ZN4CvEMC2ERKN2cv3MatES3_10CvEMParams", "_ZN2cv25ForestTreeBestSplitFinderC1ERKS0_NS_5SplitE", "_ZN2cv11TiffDecoder5closeEv", "_Z23getFFTImageFilterObjectPK18CvLSVMFilterObjectiiPP14CvLSVMFftImage", "_ZN2cv23buildOpticalFlowPyramidERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEibiib", "_ZNK2cv10Eigenfaces7predictERKNS_11_InputArrayE", "jpeg_fdct_islow", "cvMinEnclosingCircle", "_ZNK2cv3ocl26BruteForceMatcher_OCL_base15isMaskSupportedEv", "_ZN2cv3ocl9magnitudeERKNS0_6oclMatES3_RS1_", "_ZN2cv6detail17OrbFeaturesFinderC2ENS_5Size_IiEEifi", "_ZN2cv3ocl8CannyBufC1ERKNS0_6oclMatES4_", "_ZTv0_n16_NK2cv18SimpleBlobDetector5writeERNS_11FileStorageE", "_ZNK2cv11_InputArray8channelsEi", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection11getKeyPointEi", "cvCvtColor", "_ZN23CvFuzzyMeanShiftTrackerD1Ev", "_ZNK2cv32OpponentColorDescriptorExtractor5writeERNS_11FileStorageE", "_ZN2cv11RNG_MT19937clEv", "_Z19vector_uchar_to_MatRSt6vectorIhSaIhEERN2cv3MatE", "_ZN23CvFuzzyMeanShiftTrackerC1Ev", "_ZN17CvCapture_Android9grabFrameEv", "_ZN18CvBlobTrackerAuto1C1EP23CvBlobTrackerAutoParam1", "_ZN9CvLevMarq6updateERPK5CvMatRPS0_S5_", "_ZN4epnp18reprojection_errorEPA3_KdPS0_", "_ZN3Imf14focusAttributeERKNS_6HeaderE", "cvGetReal2D", "_ZN2cv17CascadeClassifierD0Ev", "_ZN2cv17BasicRetinaFilter40_local_verticalAnticausalFilter_multGainEPfjjPKj", "_Z29icvGetQuadrangleSubPix_8u_C1RPKhi6CvSizePhiS1_PKf", "Java_org_opencv_core_Core_setIdentity_10", "_ZN10CvKNearestD1Ev", "_ZN2cv24GenericDescriptorMatcher5matchERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_INS_6DMatchESaIS9_EERKS4_IS1_SaIS1_EE", "_ZN3Imf13B44CompressorD1Ev", "_ZN2cv4idftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv5MutexC1ERKS0_", "_ZN4CvEMC1ERKN2cv3MatES3_10CvEMParams", "_ZN7testing16AssertionSuccessEv", "_ZNK3Imf14TypedAttributeINS_7KeyCodeEE12writeValueToERNS_7OStreamEi", "_ZN3Imf11StdIFStreamC2ERSt14basic_ifstreamIcSt11char_traitsIcEEPKc", "_ZN2cv5randnERKNS_12_OutputArrayERKNS_11_InputArrayES5_", "_Z24cvCreateBlobTrackerAuto1P23CvBlobTrackerAutoParam1", "_ZNK2cv6detail16LKTrackerInvokerclERKNS_5RangeE", "_ZN10CvRTParamsC2EiifbiPKfbiifi", "_ZN2cv9SparseMatC2EPK11CvSparseMat", "_ZN2cv18SimpleBlobDetectorC2ERKNS0_6ParamsE", "JPC_ISTERMINATED", "_ZN3Imf7IStreamC1EPKc", "_ZTv0_n20_N2cv32OpponentColorDescriptorExtractor4readERKNS_8FileNodeE", "_ZN2cv23OneWayDescriptorMatcher15radiusMatchImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEfRKS4_IS1_SaIS1_EEb", "_ZN6cvtest12randomScalarEdd", "_ZNK2cv6KDTree9getPointsERKNS_11_InputArrayERKNS_12_OutputArrayES6_", "_ZN2cv12FilterEngineC2Ev", "Java_org_opencv_core_Core_rectangle_11", "Java_org_opencv_ml_CvNormalBayesClassifier_CvNormalBayesClassifier_11", "_ZNK2cv13HOGDescriptor6detectERKNS_3MatERSt6vectorINS_6Point_IiEESaIS6_EEdNS_5Size_IiEESB_RKS8_", "_ZN2cv7hconcatEPKNS_3MatEjRKNS_12_OutputArrayE", "_ZN11CvSVMParamsC1Ev", "_ZN2cv23VectorDescriptorMatcher4readERKNS_8FileNodeE", "cvBackProjectPCA", "_ZN27CirclesGridFinderParametersC1Ev", "_ZN2cv3of26FabMapD1Ev", "_ZN3Imf9AttributeC1Ev", "_ZN2cv6KDTree5buildERKNS_11_InputArrayES3_b", "cvPOSIT", "_ZN2cv3MatC2ERKS0_PKNS_5RangeE", "_ZN2cv3PtrI14_IplConvKernelE10delete_objEv", "cvGetPerspectiveTransform", "_ZN2cv10BmpDecoderC2Ev", "_ZN2cv8StereoBM4initEiii", "_ZN21CvHomographyEstimatorC1Ei", "_ZN2cv8HOGCache8getBlockENS_6Point_IiEEPf", "Java_org_opencv_core_Algorithm_setBool_10", "_ZN2cv24BriefDescriptorExtractorC2Ei", "_ZN22CvAdaptiveSkinDetector9HistogramC1Ev", "_Z18CompareContourRectPKvS0_Pv", "cvShowImage", "_ZN2cv6detail24HomographyBasedEstimator8estimateERKSt6vectorINS0_13ImageFeaturesESaIS3_EERKS2_INS0_11MatchesInfoESaIS8_EERS2_INS0_12CameraParamsESaISD_EE", "png_get_rgb_to_gray_status", "_Z15FillGrayPaletteP12PaletteEntryib", "Java_org_opencv_imgproc_Imgproc_phaseCorrelate_10", "Java_org_opencv_ml_CvGBTreesParams_get_1shrinkage_10", "_ZNK3Imf7KeyCode10perfOffsetEv", "_ZNK2cv3gpu10DeviceInfo11queryMemoryERjS2_", "jpc_ns_invlift_colgrp", "_ZN2cv17SelfSimDescriptorD0Ev", "_ZNK2cv6detail20BundleAdjusterReproj25obtainRefinedCameraParamsERSt6vectorINS0_12CameraParamsESaIS3_EE", "cvGetMat", "cvGetTextSize", "_ZN2cv3ocl5canny20calcSobelRowPass_gpuERKNS0_6oclMatERS2_S5_ii", "_ZN7CvBoost11get_weightsEv", "_TIFFsetDoubleArray", "_ZN2cvmlERKNS_3MatERKNS_7MatExprE", "Java_org_opencv_contrib_StereoVar_get_1flags_10", "png_handle_pCAL", "_ZN7CvDTree20find_split_cat_classEP11CvDTreeNodeifP12CvDTreeSplitPh", "cvProjectPoints2", "_ZN2cv17DescriptorMatcher20DescriptorCollectionD2Ev", "jpc_seg_destroy", "_ZN3Imf10CompressorD0Ev", "_ZN3Imf17altitudeAttributeERKNS_6HeaderE", "_ZN8CvMatrix4readEP13CvFileStoragePKci", "_ZN17CvCapture_AndroidC1Ei", "_ZNK2cv5flann11IndexParams6getIntERKSsi", "_ZNK2cv14MatOp_Identity6assignERKNS_7MatExprERNS_3MatEi", "Java_org_opencv_features2d_FeatureDetector_write_10", "_ZNK2cv11RotatedRect6pointsEPNS_6Point_IfEE", "TIFFNumberOfDirectories", "_ZN2cv3ogl6BufferC1Eiiijb", "_ZN2cv20DTreeBestSplitFinderC2ERKS0_NS_5SplitE", "Java_org_opencv_core_Algorithm_setDouble_10", "_ZN2cv7MatExprC1ERKNS_3MatE", "jas_cmprof_createfromclrspc", "_ZN3Imf13ZipCompressorC2ERKNS_6HeaderEjj", "Java_org_opencv_imgproc_Moments_get_1mu21_10", "_ZNK2cv4LBPH7predictERKNS_11_InputArrayERiRd", "_ZN3Imf5focusERKNS_6HeaderE", "_ZN25CvBlobTrackPostProcKalmanD2Ev", "Java_org_opencv_imgproc_Subdiv2D_getVoronoiFacetList_10", "_ZN2cv16OneWayDescriptor8GetPatchEi", "_ZN2cv10PxMDecoderD2Ev", "_ZNK8CvMLData12get_var_typeEi", "cvStereoRectify", "_Z21Mat_to_vector_Point3fRN2cv3MatERSt6vectorINS_7Point3_IfEESaIS4_EE", "_ZN2cv8superres31createSuperResolution_BTVL1_GPUEv", "_ZN4epnp19find_betas_approx_1EPK5CvMatS2_Pd", "Java_org_opencv_core_Core_divide_15", "_ZN2cv10ExrDecoder9RGBToGrayEPfS1_", "_ZN2cv17LatentSvmDetector4loadERKSt6vectorISsSaISsEES5_", "_ZN2cv14createTrackbarERKSsS1_PiiPFviPvES3_", "_ZN2cv17ParvoRetinaFilterC2Ejj", "_ZN2cv3ogl9Texture2DC1Ev", "Java_org_opencv_contrib_FaceRecognizer_update_10", "Java_org_opencv_objdetect_HOGDescriptor_get_1svmDetector_10", "_ZN2cv8GlBufferC1ENS0_5UsageE", "Java_org_opencv_imgproc_Imgproc_integral_11", "_ZN10CvVSModuleD2Ev", "_ZN7CvDTree24find_surrogate_split_catEP11CvDTreeNodeiPh", "_ZN2cv3ocl7compareERKNS0_6oclMatES3_RS1_i", "cvCalcDecompCoeff", "_ZN2cv3Mat8pop_backEj", "_ZN3Imf8TimeCode7setBgf0Eb", "_Z19Mat_to_vector_ucharRN2cv3MatERSt6vectorIhSaIhEE", "_ZNK3Imf17ScanLineInputFile11frameBufferEv", "jinit_color_deconverter", "_ZN3Imf9Attribute12newAttributeEPKc", "_ZN2cv25BOWImgDescriptorExtractor7computeERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_PS4_IS4_IiSaIiEESaISB_EEPS1_", "_ZN13CvBlobTracker10SetBlobHypEiP6CvBlob", "Java_org_opencv_objdetect_HOGDescriptor_get_1histogramNormType_10", "png_free", "png_handle_cHRM", "Java_org_opencv_ml_EM_trainE_10", "_ZN9IlmThread10ThreadPool4DataC1Ev", "_ZN2cv18createLinearFilterEiiRKNS_11_InputArrayENS_6Point_IiEEdiiRKNS_7Scalar_IdEE", "_ZN2cv8internal16ComputeJacobiansERKNS_11_InputArrayES3_RKNS0_15IntrinsicParamsES3_S3_RKiRKdRNS_3MatESC_", "_ZN3Imf13PizCompressor10uncompressEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN11CvSVMSolver11get_row_svrEiPfS0_b", "_ZN3Imf16lookModTransformERKNS_6HeaderE", "cvGetRows", "Java_org_opencv_imgproc_Imgproc_integral2_11", "Java_org_opencv_core_Core_merge_10", "_ZN7testing8internal21StackLowerThanAddressEPKvPb", "_ZNK2cv10PxMDecoder15signatureLengthEv", "_Z40cvCreateModuleBlobTrackAnalysisTrackDistv", "_ZN2cv12KalmanFilterC1Eiiii", "_ZN23CvNormalBayesClassifier5clearEv", "_ZN23CvFuzzyMeanShiftTracker12SearchWindowC2Ev", "png_do_expand_palette", "_ZN24CvBlobTrackPredictKalmanD1Ev", "_Z21Mat_to_vector_Point3dRN2cv3MatERSt6vectorINS_7Point3_IdEESaIS4_EE", "_ZN2cv14findHomographyERKNS_11_InputArrayES2_idRKNS_12_OutputArrayE", "_ZN2cv9videostab11LogToStdout5printEPKcz", "Java_org_opencv_core_Core_flip_10", "_ZN2cv3gpu6GpuMat6uploadERKNS_3MatE", "Java_org_opencv_features2d_GenericDescriptorMatcher_write_10", "_ZN2cv11_InputArrayC2ERKSt6vectorINS_3MatESaIS2_EE", "_ZNK3Imf14TypedAttributeIN5Imath4Vec3IdEEE12writeValueToERNS_7OStreamEi", "Java_org_opencv_ml_CvGBTreesParams_set_1subsample_1portion_10", "jinit_d_coef_controller", "_ZN2cv25BOWImgDescriptorExtractorC2ERKNS_3PtrINS_19DescriptorExtractorEEERKNS1_INS_17DescriptorMatcherEEE", "_ZN7CvBoostC2ERKN2cv3MatEiS3_S3_S3_S3_S3_13CvBoostParams", "_ZN3Imf10OutputFile4DataD2Ev", "TIFFInitSGILog", "jpc_streamlist_destroy", "_ZN2cv16BaseImageDecoderC2Ev", "_ZN2cv10BmpDecoderD0Ev", "_ZN2cv11WBaseStream8allocateEv", "cvIntegral", "cvMahalanobis", "_ZN2cv11JpegDecoderC1Ev", "_ZN5RFace9GetWeightEv", "_ZN2cv23OneWayDescriptorMatcherC2ERKNS0_6ParamsE", "_ZNK3Imf14TiledInputFile11isValidTileEiiii", "_ZN2cv14RandomizedTree12getPosteriorEPh", "png_handle_pHYs", "_ZN2cv23getPerspectiveTransformEPKNS_6Point_IfEES3_", "_ZNK2cv9Algorithm6getIntERKSs", "restore_core_regs", "_Z21cvCreateBlobTrackerMSv", "_ZN2cv11RetinaColor16_computeGradientEPKf", "_ZNK3Imf10OutputFile15currentScanLineEv", "_ZN3Imf13hasWorldToNDCERKNS_6HeaderE", "cvWatershed", "png_permit_mng_features", "Java_org_opencv_core_Algorithm_getString_10", "Java_org_opencv_contrib_StereoVar_set_1lambda_10", "_ZN2cv3ocl6oclMatdVERKS1_", "_ZN9CvANN_MLP5trainEPK5CvMatS2_S2_S2_21CvANN_MLP_TrainParamsi", "_ZN3Imf8xDensityERNS_6HeaderE", "_ZN2cv6detail12CameraParamsC1ERKS1_", "_ZNK2cv16FeatureEvaluator5cloneEv", "_ZN2cv12StarAdjusterC1Eddd", "_ZN2cv12VideoCapture3setEid", "_ZN2cv17BasicRetinaFilter25runFilter_LocalAdapdationERKSt8valarrayIfES4_RS2_", "_ZN2cv3Mat4onesEiii", "_ZN4perf8TestBase19RecordRunParametersEv", "Java_org_opencv_core_Algorithm_getDouble_10", "jpeg_make_d_derived_tbl", "_ZN3Imf13B44CompressorD2Ev", "_ZN2cv14RandomizedTree8finalizeEji", "_ZN3Imf10OutputFileC2ERNS_7OStreamERKNS_6HeaderEi", "_ZN3Imf8apertureERNS_6HeaderE", "_ZN2cv9SparseMat13resizeHashTabEj", "_ZNK2cv17DescriptorMatcher5writeERNS_11FileStorageE", "Java_org_opencv_core_Core_multiply_12", "png_get_sCAL_s", "Java_org_opencv_core_Mat_n_1convertTo__JJI", "png_gamma_significant", "_ZN2cv22OneWayDescriptorObjectC2E6CvSizeiPKcS3_S3_S3_i", "_ZN2cv6detail12DisjointSets13findSetByElemEi", "_ZN2cv9ExceptionD0Ev", "_Z20icvDynamicCorrespondPiiS_iS_S_", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1bp_1dw_1scale_10", "_ZN2cv11makeOffsetsEPiii", "_ZN2cv17BasicRetinaFilter29runFilter_LPfilter_AutonomousERSt8valarrayIfEj", "_ZN2cv3ocl17initializeContextEPvS1_S1_", "Java_org_opencv_ml_CvGBTreesParams_get_1loss_1function_1type_10", "_ZN2cv23BackgroundSubtractorGMGC2Ev", "_ZN13CvBlobTracker10UpdateBlobEiP6CvBlobP9_IplImageS3_", "_ZN2cv15RTreeClassifier34setFloatPosteriorsFromTextfile_176ESs", "_ZN2cv6detail17stitchingLogLevelEv", "_ZN3Imf17ScanLineInputFileD1Ev", "_ZN2cvmlERKNS_7MatExprEd", "_ZNK7testing8internal8FilePath14RemoveFileNameEv", "_ZN23CvFuzzyMeanShiftTracker12SearchWindowC1Ev", "_ZN17CvFuzzyController10calcOutputEdd", "_ZN2cv6RetinaC2ENS_5Size_IiEE", "_ZN16CvBlobDetectorCCD1Ev", "_ZN2cv21ImageLogPolProjectionC2EjjNS0_14PROJECTIONTYPEEb", "_ZN2cv6RetinaC1ENS_5Size_IiEE", "_ZN10CvVSModule11GetParamPtrEi", "Java_org_opencv_features2d_DescriptorExtractor_descriptorSize_10", "jas_matrix_create", "_ZNK2cv5flann11IndexParams9getStringERKSsS3_", "_ZN2cv14ChamferMatcher8Matching20addTemplateFromImageERNS_3MatEf", "Java_org_opencv_core_Mat_n_1convertTo__JJID", "cvReleaseMemStorage", "_ZN2cv3ocl6device3hog22compute_gradients_8UC1EiiRKNS0_6oclMatEfRS3_S6_b", "_ZNK2cv20OneWayDescriptorBase5WriteERNS_11FileStorageE", "_ZNK3Imf14TiledInputFile9tileYSizeEv", "_ZN25CvBlobTrackPostProcKalman7ProcessEP6CvBlob", "_ZN2cv21ImageLogPolProjectionD2Ev", "_ZN9CvANN_MLPC2EPK5CvMatidd", "_Z17Mat_to_vector_intRN2cv3MatERSt6vectorIiSaIiEE", "Java_org_opencv_objdetect_Objdetect_groupRectangles_11", "cvReleaseMat", "_ZNK7testing8UnitTest26successful_test_case_countEv", "_ZN10CvVSModule21TransferParamsToChildEPS_Pc", "_ZN2cv17LogPolar_AdjacentD2Ev", "Java_org_opencv_calib3d_Calib3d_initCameraMatrix2D_11", "cvGetImage", "Java_org_opencv_highgui_Highgui_imwrite_10", "cvColorToScalar", "_ZN2cv27createSeparableLinearFilterEiiRKNS_11_InputArrayES2_NS_6Point_IiEEdiiRKNS_7Scalar_IdEE", "TIFFSwabArrayOfDouble", "Java_org_opencv_core_Core_gemm_10", "jpc_seq_conv", "_ZN2cv21ImageLogPolProjection27_initLogPolarCortexSamplingEdd", "jpeg_calc_output_dimensions", "Java_org_opencv_ml_CvDTreeParams_CvDTreeParams_10", "_Z21vector_Point2d_to_MatRSt6vectorIN2cv6Point_IdEESaIS2_EERNS0_3MatE", "cvCopyMakeBorder", "Java_org_opencv_ml_CvDTreeParams_get_1use_1surrogates_10", "cvMulTransposed", "_ZN2cv16OneWayDescriptorC2Ev", "_ZNK3Imf6HeaderixEPKc", "_ZN7testing8internal12UnitTestImpl31SetGlobalTestPartResultReporterEPNS_31TestPartResultReporterInterfaceE", "_ZNK3Imf14TypedAttributeIN5Imath4Vec3IiEEE12writeValueToERNS_7OStreamEi", "icvGetCrossLineDirect", "_ZN3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IiEEEEE14staticTypeNameEv", "_ZNK3Imf14TiledInputFile18dataWindowForLevelEi", "_ZN2cv12VideoCaptureC2Ei", "_Z18vector_Rect_to_MatRSt6vectorIN2cv5Rect_IiEESaIS2_EERNS0_3MatE", "cvLoadHaarClassifierCascade", "_ZN18CvBlobTrackerAuto17ProcessEP9_IplImageS1_", "_ZN10CvVSModule16IsModuleTypeNameEPKc", "jpc_enc_tile_destroy", "_ZN2cv3gpu24printShortCudaDeviceInfoEi", "_ZN2cv7linemod13ColorGradientC1Efjf", "jpeg_add_quant_table", "jpc_getdata", "_Z5angle12CvPoint2D32fS_", "_ZNK2cv17SelfSimDescriptor22computeLogPolarMappingERNS_3MatE", "Java_org_opencv_core_Core_patchNaNs_11", "_ZN3Imf13PizCompressorC2ERKNS_6HeaderEjj", "cvCreateConDensation", "Java_org_opencv_core_Mat_n_1Mat__DDI", "_ZN3Imf5ownerERKNS_6HeaderE", "Java_org_opencv_ml_CvRTParams_set_1term_1crit_10", "_ZNK3Imf8TimeCode4bgf2Ev", "cvPseudoInverse", "_ZNK3Imf9InputFile6headerEv", "_ZNKSt13bad_exception4whatEv", "searchObjectThresholdSomeComponents", "jpc_floorlog2", "Java_org_opencv_calib3d_StereoSGBM_get_1fullDP_10", "_ZN7testing8internal12UnitTestImpl28CurrentOsStackTraceExceptTopEi", "_ZNK2cv16OneWayDescriptor12GetPCADimLowEv", "_Z13convFFTConv2dPK14CvLSVMFftImageS1_iiPPf", "_ZN2cv8superres26createOptFlow_DualTVL1_GPUEv", "_ZN2cv15NAryMatIteratorC2EPPKNS_3MatEPS1_i", "_ZNK23CvNormalBayesClassifier5writeEP13CvFileStoragePKc", "_ZN2cv9rectangleERNS_3MatENS_6Point_IiEES3_RKNS_7Scalar_IdEEiii", "_ZN2cv3MatC2EiPKiiPvPKj", "_ZN2cv3of211ChowLiuTree20reduceEdgesToMinSpanERSt4listINS1_4infoESaIS3_EE", "_Unwind_GetTextRelBase", "_ZNK2cv16FeatureEvaluator7calcOrdEi", "_ZN2cv6Retina5setupENS0_16RetinaParametersE", "_ZNK2cv5BRISK34computeDescriptorsAndOrOrientationERKNS_11_InputArrayES3_RSt6vectorINS_8KeyPointESaIS5_EERKNS_12_OutputArrayEbbb", "_ZN2cv10PngEncoderD2Ev", "_ZN2cv12RetinaFilter25getMagnoParaFoveaResponseERSt8valarrayIfE", "_ZN6cvtest2TS7vprintfEiPKcSt9__va_list", "_ZN2cv17calcOpticalFlowSFERNS_3MatES1_S1_iii", "cvChangeSeqBlock", "_ZNK2cv16MatConstIterator4lposEv", "_ZN2cv6detail18GraphCutSeamFinderD0Ev", "Java_org_opencv_core_Core_bitwise_1not_10", "cvLUT", "Java_org_opencv_imgproc_Imgproc_warpPerspective_10", "_ZN2cv23BackgroundSubtractorMOGC1Ev", "_ZN7testing8internal12UnitTestImpl12ShuffleTestsEv", "cvReleaseGraphScanner", "Java_org_opencv_video_Video_estimateRigidTransform_10", "Java_org_opencv_ml_CvRTrees_clear_10", "_ZN2cv7pyrDownERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi", "_ZN7testing8internal8FilePath13GetCurrentDirEv", "_ZN2cv8GlBufferC2ENS_5Size_IiEEiNS0_5UsageE", "Java_org_opencv_calib3d_Calib3d_solvePnPRansac_10", "png_get_pHYs", "_Z10LSVMparserPKcPPP18CvLSVMFilterObjectPiS5_PS5_PPfS5_S7_", "_ZN7testing8internal26GoogleTestFailureExceptionC2ERKNS_14TestPartResultE", "_ZN3Imf6Header4findEPKc", "_ZN2cv9transformERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN16EllipticKeyPointC1ERKN2cv6Point_IfEERKNS0_7Scalar_IdEE", "jas_image_create0", "_ZN8CvRTrees5trainERKN2cv3MatEiS3_S3_S3_S3_S3_10CvRTParams", "png_free_default", "_ZN2cv14ChamferMatcher8Matching23findContourOrientationsERKSt6vectorISt4pairIiiESaIS4_EERS2_IfSaIfEE", "_ZN2cv9SparseMat3ptrEiibPj", "_Z17getFeaturePyramidP9_IplImagePP20CvLSVMFeaturePyramid", "Java_org_opencv_calib3d_StereoSGBM_get_1speckleRange_10", "_ZNK3Imf14TypedAttributeINS_6EnvmapEE12writeValueToERNS_7OStreamEi", "Java_org_opencv_core_Core_trace_10", "jas_iccprof_gethdr", "_ZN2cv15stereoCalibrateERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayES5_S5_S5_NS_5Size_IiEES5_S5_S5_S5_NS_12TermCriteriaEi", "_ZN7CvBoostD2Ev", "Java_org_opencv_imgproc_Imgproc_compareHist_10", "_Unwind_DeleteException", "jas_cmprof_createfromiccprof", "png_formatted_warning", "_ZN2cv8superres23createOptFlow_PyrLK_GPUEv", "_ZN10__cxxabiv115__forced_unwindD0Ev", "_ZNK2cv23OneWayDescriptorMatcher5cloneEb", "png_calloc", "Java_org_opencv_imgproc_Imgproc_approxPolyDP_10", "_ZN3Imf10OutputFileD1Ev", "_ZN2cv3of29FabMapFBOD2Ev", "_ZN2cv20OneWayDescriptorBaseC1E6CvSizeiRKSsS3_S3_fffiii", "Java_org_opencv_features2d_GenericDescriptorMatcher_match_10", "png_reciprocal2", "_ZNK2cv7linemod8Detector10matchClassERKSt6vectorIS2_IS2_INS_3MatESaIS3_EESaIS5_EESaIS7_EERKS2_INS_5Size_IiEESaISD_EEfRS2_INS0_5MatchESaISI_EERKSsRKS2_IS2_INS0_8TemplateESaISO_EESaISQ_EE", "_ZN2cv2EM5trainERKNS_11_InputArrayERKNS_12_OutputArrayES6_S6_", "_ZN2cv5flann17LinearIndexParamsC2Ev", "jp2_write_header", "Java_org_opencv_calib3d_StereoSGBM_set_1speckleRange_10", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow5shiftEv", "_ZN3Imf14whiteLuminanceERNS_6HeaderE", "cvConvertPointsHomogeneous", "_ZN9IlmThread9TaskGroupD2Ev", "ratestrtosize", "cvReleaseObsInfo", "_Z19Mat_to_vector_floatRN2cv3MatERSt6vectorIfSaIfEE", "_ZN3Imf16expTimeAttributeERKNS_6HeaderE", "_ZN2cv3MatC1ERKNS_3gpu6GpuMatE", "_ZN7testing8internal17GetCapturedStderrEv", "Java_org_opencv_calib3d_Calib3d_findHomography_12", "_ZNK8CvRTrees12predict_probEPK5CvMatS2_", "png_safecat", "_ZNK2cv14FernClassifier5writeERNS_11FileStorageERKSs", "TIFFSwabShort", "_ZN2cv8Subdiv2D12initDelaunayENS_5Rect_IiEE", "_ZN10CvVSModule12GetParamNameEi", "_ZN2cv3ocl3MOGC2Ei", "_ZNK2cv3ocl26BruteForceMatcher_OCL_base5emptyEv", "_ZN3Imf9addEnvmapERNS_6HeaderERKNS_6EnvmapE", "_ZN3Imf11ChannelList18channelsWithPrefixEPKcRNS0_8IteratorES4_", "_ZN10__cxxabiv116__enum_type_infoD1Ev", "_ZN2cv11JpegEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "cvNextGraphItem", "_ZN2cv6OctreeC1ERKSt6vectorINS_7Point3_IfEESaIS3_EEii", "_ZN2cv9videostab14StabilizerBaseC1Ev", "_ZN10__cxxabiv115__forced_unwindD2Ev", "_ZN2cv11arrowedLineERNS_3MatENS_6Point_IiEES3_RKNS_7Scalar_IdEEiiid", "jas_free", "_ZN2cv8Subdiv2D6insertERKSt6vectorINS_6Point_IfEESaIS3_EE", "_ZN2cv7linemod18DepthNormalPyramid7pyrDownEv", "_ZN9IlmThread9TaskGroupC2Ev", "cvStartReadChainPoints", "cvFindContours", "_ZN7testing14InitGoogleTestEPiPPw", "Java_org_opencv_ml_CvDTreeParams_get_1regression_1accuracy_10", "_ZN5CvSVMC1Ev", "_ZN2cv17BasicRetinaFilter36_localSquaringSpatioTemporalLPfilterEPKfPfPKjj", "_ZN2cv18CvMeanShiftTracker18getTrackingEllipseEv", "_ZN2cv11RBaseStreamD1Ev", "_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EEidPS0_IiSaIiEEPS0_IdSaIdEE", "_ZNK2cv5MatOp8subtractERKNS_7MatExprES3_RS1_", "_ZN7testing8internal20SingleFailureCheckerC2EPKNS_19TestPartResultArrayENS_14TestPartResult4TypeERKSs", "_ZN2cv3ocl23StereoBeliefPropagationC1Eiiii", "cvConvertScale", "_ZN2cv3SVD7computeERKNS_11_InputArrayERKNS_12_OutputArrayES6_S6_i", "Java_org_opencv_imgproc_Imgproc_cornerHarris_10", "_ZNK2cv3ocl7Context24getOpenCLCommandQueuePtrEv", "Java_org_opencv_calib3d_Calib3d_findHomography_10", "_ZN7testing8internal11CmpHelperLTEPKcS2_xx", "Java_org_opencv_core_Core_absdiff_10", "png_set_write_fn", "Java_org_opencv_calib3d_StereoSGBM_get_1uniquenessRatio_10", "_ZN2cv3PtrI15CvStereoBMStateE10delete_objEv", "_ZN7testing18TestEventListeners8repeaterEv", "png_get_gAMA", "_ZN2cv7normL1_EPKfS1_i", "cvCalibrationMatrixValues", "_ZN4epnp11compute_ccsEPKdS1_", "_ZN3Imf9InputFile4DataD2Ev", "_ZN13CvCalibFilter4StopEb", "_ZN2cv3ocl25openCLGetKernelFromSourceEPKNS0_7ContextEPKNS0_12ProgramEntryESs", "Java_org_opencv_imgproc_Imgproc_watershed_10", "_ZN3Imf12addMultiViewERNS_6HeaderERKSt6vectorISsSaISsEE", "_ZN3Imf9utcOffsetERNS_6HeaderE", "_ZN2cv5eigenERKNS_11_InputArrayERKNS_12_OutputArrayEii", "TIFFRasterScanlineSize64", "Java_org_opencv_imgproc_Imgproc_accumulateWeighted_10", "Java_org_opencv_ml_CvBoostParams_delete", "_ZN2cv3ocl15CvSVMKernel_ocl11calc_linearEiiPfRNS_3MatE", "_ZNK2cv21FernDescriptorMatcher5writeERNS_11FileStorageE", "Java_org_opencv_calib3d_Calib3d_stereoRectify_10", "png_set_read_status_fn", "_ZN2cv3minERKNS_3MatEdRS0_", "_ZN2cvmlEdRKNS_7MatExprE", "cvSetOpenGlDrawCallback", "_ZN6cvtest12fillGradientERN2cv3MatEi", "Java_org_opencv_core_Core_dft_10", "_ZN2cv15CvHybridTrackerC2Ev", "_ZN7testing8internal35DefaultGlobalTestPartResultReporterC2EPNS0_12UnitTestImplE", "jpc_mqenc_setctxs", "_ZN2cv11matchShapesERKNS_11_InputArrayES2_id", "Java_org_opencv_photo_Photo_fastNlMeansDenoisingMulti_10", "_ZN2cv8superres23createFrameSource_VideoERKSs", "_ZN3Imf11skipChannelERPKcNS_9PixelTypeEj", "_ZN12CvForestTree5trainEP16CvDTreeTrainDataPK5CvMat", "Java_org_opencv_ml_EM_predict_10", "cvRefineForegroundMaskBySegm", "_ZN2cv8superres27createOptFlow_Farneback_GPUEv", "cvInitIntrinsicParams2D", "_ZNK2cv13HOGDescriptor16detectMultiScaleERKNS_3MatERSt6vectorINS_5Rect_IiEESaIS6_EERS4_IdSaIdEEdNS_5Size_IiEESE_ddb", "__gnu_Unwind_Restore_WMMXC", "_ZN2cv8superres13convertToTypeERKNS_3MatEiRS1_S4_", "_ZN2cv10ExrDecoderD1Ev", "png_get_pHYs_dpi", "Java_org_opencv_imgproc_Imgproc_Scharr_12", "Java_org_opencv_imgproc_Imgproc_getStructuringElement_10", "_ZN7testing8internal17TestEventRepeater22OnEnvironmentsSetUpEndERKNS_8UnitTestE", "_Z29cvCreateBlobTrackPostProcListPFP22CvBlobTrackPostProcOnevE", "_ZN3Imf16capDateAttributeERKNS_6HeaderE", "Java_org_opencv_calib3d_StereoBM_StereoBM_10", "cvDiv", "_ZN2cv3ocl13HOGDescriptor14numPartsWithinEiii", "Java_org_opencv_imgproc_Imgproc_adaptiveBilateralFilter_11", "_ZN18CvBlobTrackerAuto1D0Ev", "_ZN2cv3ocl22getInitializationMutexEv", "png_do_encode_alpha", "Java_org_opencv_features2d_GenericDescriptorMatcher_knnMatch_13", "_ZN13CvDTreeParamsC2Ev", "_ZN2cv12FilterEngine4initERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "png_write_finish_row", "TIFFInitCCITTRLEW", "_ZN6cvtest19calcLaplaceKernel2DEi", "_ZN2cv13Jpeg2KDecoder16readComponent16uEPtPviiiii", "_ZNK2cv13HOGDescriptor5writeERNS_11FileStorageERKSs", "_ZN2cv10HoughLinesERKNS_11_InputArrayERKNS_12_OutputArrayEddidd", "cvGetTrackbarPos", "png_get_bit_depth", "_ZN3Imf18addFramesPerSecondERNS_6HeaderERKNS_8RationalE", "cvSetReal1D", "Java_org_opencv_features2d_GenericDescriptorMatcher_empty_10", "Java_org_opencv_core_Core_fillPoly_10", "_ZNK2cv13HOGDescriptor6copyToERS0_", "_ZN2cv10PngEncoderD1Ev", "Java_org_opencv_core_Core_sqrt_10", "_ZNK8CvMLData11get_missingEv", "_ZN2cv3ogl9Texture2DC1ERKNS_11_InputArrayEb", "_ZN8CvMLData14chahge_var_idxEib", "_ZN7testing8internal12UnitTestImpl26RegisterParameterizedTestsEv", "_ZNK2cv3Mat7reshapeEiiPKi", "_Z22icvCvt_BGR2RGB_16u_C3RPKtiPti6CvSize", "_ZNK2cv24BriefDescriptorExtractor4infoEv", "_ZN2cv10BOWTrainerC1Ev", "png_set_gray_to_rgb", "_ZN9IlmThread9TaskGroup4Data10removeTaskEv", "_ZN2cvdvERKNS_7MatExprERKNS_3MatE", "_ZN3Imf10addKeyCodeERNS_6HeaderERKNS_7KeyCodeE", "_ZN2cv8KeyPoint7convertERKSt6vectorINS_6Point_IfEESaIS3_EERS1_IS0_SaIS0_EEffii", "_ZNK2cv17LatentSvmDetector13getClassCountEv", "_ZN16EllipticKeyPointC2Ev", "_ZNK7CvDTree7predictERKN2cv3MatES3_b", "Java_org_opencv_imgproc_Imgproc_integral3_10", "_ZN2cv6detail13estimateFocalERKSt6vectorINS0_13ImageFeaturesESaIS2_EERKS1_INS0_11MatchesInfoESaIS7_EERS1_IdSaIdEE", "Java_org_opencv_features2d_GenericDescriptorMatcher_train_10", "cvDecodeImage", "_ZN21DetectionBasedTracker21SeparateDetectionWork23workcycleObjectDetectorEv", "png_get_interlace_type", "_ZNK21DetectionBasedTracker10getObjectsERSt6vectorIN2cv5Rect_IiEESaIS3_EE", "_ZN7testing8internal6String12FormatHexIntEi", "_ZN24CirclesGridClusterFinder18findOutsideCornersERKSt6vectorIN2cv6Point_IfEESaIS3_EERS5_", "_ZN2cv12getThreadNumEv", "_Z29cvCreateModuleBlobTrackGenYMLv", "_ZN2cv6circleERNS_3MatENS_6Point_IiEEiRKNS_7Scalar_IdEEiii", "_ZNK3Imf8TimeCode5frameEv", "_ZN4perf10Regression8instanceEv", "_ZN13CvCalibFilter16LoadCameraParamsEPKc", "_ZNK2cv7linemod20ColorGradientPyramid15extractTemplateERNS0_8TemplateE", "_ZN4perf7PrintToERKNS_7MatTypeEPSo", "_ZN2cv3ocl21StereoConstantSpaceBPC1Eiiiiffffii", "cvSegmentFGMask", "_ZNK2cv10PngDecoder10newDecoderEv", "_ZNK2cv8Subdiv2D7symEdgeEi", "_ZNK3Iex7BaseExc4whatEv", "_ZN21FaceDetectionListElemD0Ev", "jpeg_read_header", "_Unwind_GetDataRelBase", "cvCreatePyramid", "cvDynamicCorrespondMulti", "_ZN2cv7seqPushEP5CvSeqPKv", "_ZNK2cv12HOGEvaluator5cloneEv", "_ZN2cv9SparseMat3ptrEiiibPj", "_ZNK2cv17SelfSimDescriptor7computeERKNS_3MatERSt6vectorIfSaIfEENS_5Size_IiEERKS4_INS_6Point_IiEESaISB_EE", "_ZN2cv3ocl18openCLCopyBuffer2DEPNS0_7ContextEPvjiPKvjjji", "_ZN2cv8StereoBMC1Eiii", "_ZN10__cxxabiv111__terminateEPFvvE", "_ZN2cv10fastMallocEj", "_ZN6cvtest8BaseTest15update_progressEiiid", "_TIFFmalloc", "_ZN2cv12HOGEvaluatorD0Ev", "_ZN2cv6detail14FeatherBlender4feedERKNS_3MatES4_NS_6Point_IiEE", "_ZN2cv12RLByteStreamD2Ev", "_ZN2cv11TiffDecoderD2Ev", "_ZN3Imf19copyFromFrameBufferERPcRPKcS3_jNS_10Compressor6FormatENS_9PixelTypeE", "_ZN2cv13HaarEvaluatorC1Ev", "_ZN3Imf16addWorldToCameraERNS_6HeaderERKN5Imath8Matrix44IfEE", "_ZN7testing8internal15UnitTestOptions27GetAbsolutePathToOutputFileEv", "cvGetND", "_ZN2cv3gpu11TargetArchs3hasEii", "Java_org_opencv_ml_CvSVMParams_set_1gamma_10", "Java_org_opencv_imgproc_Imgproc_medianBlur_10", "_ZN2cv9Algorithm9setStringERKSsS2_", "_Z30GetGeneratorReduceFundSolutionP5CvMatS0_S0_S0_", "_ZN3Imf14TiledInputFile9readTilesEiiiiii", "_ZN2cv14solvePnPRansacERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_bifiS5_i", "_ZN10CvVSModule15GetParamCommentEPKc", "_ZNK2cv23BackgroundSubtractorGMG4infoEv", "_ZNK2cv11Fisherfaces4infoEv", "_ZN2cv9ExceptionC2EiRKSsS2_S2_i", "_ZN2cv8GlBuffer11unmapDeviceEv", "_ZN2cv22SparseMatConstIteratorC1EPKNS_9SparseMatE", "_ZN17CvFuzzyController7addRuleEP12CvFuzzyCurveS1_S1_", "_ZNK2cv17LatentSvmDetector13getClassNamesEv", "_ZN3Imf12PreviewImageC2ERKS0_", "_ZN3Imf6envmapERKNS_6HeaderE", "_ZN3Imf6Header6insertEPKcRKNS_9AttributeE", "png_malloc", "cvCorrectMatches", "_ZN14CvForestERTree13calc_node_dirEP11CvDTreeNode", "png_crc_read", "Java_org_opencv_core_Mat_n_1size", "_ZN2cv3ocl10DeviceInfoC2Ev", "_ZNK2cv22OneWayDescriptorObject16MatchPointToPartE7CvPoint", "_ZN2cv13batchDistanceERKNS_11_InputArrayES2_RKNS_12_OutputArrayEiS5_iiS2_ib", "_ZN3Imf16staticInitializeEv", "_ZN2cv3PtrI11CvHistogramE10delete_objEv", "_ZNK16EllipticKeyPoint22getSecondMomentsMatrixEv", "_ZN2cv8colormap8ColorMap15linear_colormapERKNS_11_InputArrayES4_S4_S4_S4_", "_ZN2cv17DescriptorMatcherD1Ev", "png_write_start_row", "_ZN3Imf14TiledInputFile8readTileEiii", "_ZNK2cv12StarAdjuster4goodEv", "_ZN3Imf10wav2EncodeEPtiiiit", "_ZN2cv3Mat4onesENS_5Size_IiEEi", "_ZN2cv7linemod11DepthNormalC1Ev", "_ZN4perf8TestBase15validateMetricsEv", "_ZN3Imf11StdOFStream5writeEPKci", "_ZN2cv22cornerEigenValsAndVecsERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "Java_org_opencv_gpu_DeviceInfo_totalMemory_10", "_ZN3Imf14TypedAttributeIfE14staticTypeNameEv", "_ZN2cv6detail11PlaneWarper7warpRoiENS_5Size_IiEERKNS_3MatES6_S6_", "_ZN2cv16BaseImageDecoder9setSourceERKNS_3MatE", "_ZN2cv6detail13ProjectorBase15setCameraParamsERKNS_3MatES4_S4_", "cvEqualizeHist", "cvAddS", "_ZNK2cv3ogl6Buffer5bufIdEv", "_ZN2cv6detail7Blender4feedERKNS_3MatES4_NS_6Point_IiEE", "_ZN6cvtest3minERKN2cv3MatEdRS1_", "_ZN9CvANN_MLP16calc_input_scaleEPK9CvVectorsi", "_ZN10CvKNearestC1EPK5CvMatS2_S2_bi", "_ZN7CvDTree5trainERKN2cv3MatEiS3_S3_S3_S3_S3_13CvDTreeParams", "Java_org_opencv_objdetect_HOGDescriptor_HOGDescriptor_13", "Java_org_opencv_ml_CvGBTreesParams_CvGBTreesParams_10", "_ZN2cvmlERKNS_3MatEd", "_ZN2cv6detail20matchesGraphAsStringERSt6vectorISsSaISsEERS1_INS0_11MatchesInfoESaIS5_EEf", "_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj", "cvReleaseFaceTracker", "jpc_mqenc_putbit_func", "jas_iccattrval_clone", "_ZNK2cv14FernClassifier13getStructSizeEv", "_ZN2cv22OneWayDescriptorObjectC2E6CvSizeiRKSsS3_S3_fffi", "_ZN2cv3ocl18getOpenCLPlatformsERSt6vectorIPKNS0_12PlatformInfoESaIS4_EE", "Java_org_opencv_imgproc_Imgproc_boxFilter_11", "_ZN4CvEM5trainEPK5CvMatS2_10CvEMParamsPS0_", "_ZNK2cv14PatchGenerator14warpWholeImageERKNS_3MatERS1_S4_S4_iRNS_3RNGE", "_ZN2cv12buildPyramidERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN16CvTrainTestSplitC1Ev", "_Z18cvPrepareTrainDataPKcPK5CvMatiS3_iS3_S3_bPPPKfPiS8_S8_PPS1_SA_SA_SA_", "_ZN17CvERTreeTrainData13get_cv_labelsEP11CvDTreeNodePi", "_ZN2cv9SparseMatC1EPK11CvSparseMat", "_Z11convolutionPK18CvLSVMFilterObjectPK16CvLSVMFeatureMapPf", "TIFFInitThunderScan", "_Z21icvGetCoefficientOrtoP9CvMatrix36CvSizePiS2_S2_", "_ZN2cv19updateMotionHistoryERKNS_11_InputArrayERKNS_12_OutputArrayEdd", "_Z31workcycleObjectDetectorFunctionPv", "cvFindChessBoardCornerGuesses", "_ZN2cv3ocl13HOGDescriptor24getDefaultPeopleDetectorEv", "_ZN7testing10TestResult5ClearEv", "_ZN2cv20OneWayDescriptorBase24InitializePoseTransformsEv", "cvbFastArctan", "_ZN2cv15KeyPointsFilter16removeDuplicatedERSt6vectorINS_8KeyPointESaIS2_EE", "_ZN2cv17triangulatePointsERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayE", "_ZN2cv3ocl6oclMatcvNS_11_InputArrayEEv", "_ZN10__cxxabiv120__si_class_type_infoD0Ev", "_ZNK2cv10PxMDecoder10newDecoderEv", "_ZN2cv7MatExprC2ERKNS_3MatE", "_ZNK2cv22OneWayDescriptorObject18IsDescriptorObjectEi", "_Z6rot2PIPfiiS_ii", "_ZTv0_n24_NK2cv19FastFeatureDetector4infoEv", "_ZN2cv8HOGCacheC1EPKNS_13HOGDescriptorERKNS_3MatENS_5Size_IiEES8_bS8_", "cvInpaint", "_ZN13CvFMEstimator18computeReprojErrorEPK5CvMatS2_S2_PS0_", "_ZNK2cv7linemod8Detector12numTemplatesEv", "_ZN3Imf10worldToNDCERNS_6HeaderE", "_Z17cvTestSeqAddNoisePvid", "icvComputeStereoParamsForCameras", "_ZNK2cv16BaseImageEncoder11throwOnErorEv", "_ZN2cv11TiffEncoderD1Ev", "cvAdaptiveThreshold", "_ZN5CvSVM8do_trainEiiiPPKfPK5CvMatP12CvMemStoragePd", "_ZN2cv14FernClassifierC2ERKNS_8FileNodeE", "_ZN7testing8TestCaseC1EPKcS2_PFvvES4_", "_ZN2cv8GlBufferC1EiiiNS0_5UsageE", "_ZN7CvBoostC2EPK5CvMatiS2_S2_S2_S2_S2_13CvBoostParams", "_ZN2cv5flann12SearchParamsC2Eifb", "_ZN2cv3gpu5setToERNS0_6GpuMatENS_7Scalar_IdEERKS1_Pv", "Java_org_opencv_imgproc_Imgproc_getRectSubPix_10", "_ZNK2cv13AlgorithmInfo4nameEv", "uv_encode", "jpeg_mem_term", "cvAddWeighted", "_ZN2cv9videostab25ConsistentMosaicInpainterC1Ev", "_Z27cvCreateModuleBlobTrackGen1v", "_ZNK3Imf10OutputFile8fileNameEv", "TIFFReadCustomDirectory", "_ZN2cv17CascadeClassifier16getMaskGeneratorEv", "Java_org_opencv_core_Core_scaleAdd_10", "_ZN4perf4sortERSt6vectorIN2cv8KeyPointESaIS2_EERKNS1_12_OutputArrayE", "_ZNK3Imf8TimeCode10fieldPhaseEv", "Java_org_opencv_core_Core_cubeRoot_10", "_ZN2cv9Algorithm12setMatVectorERKSsRKSt6vectorINS_3MatESaIS4_EE", "_ZN3Iex7BaseExcD1Ev", "_ZN2cv12_OutputArrayC2ERNS_3MatE", "_ZNK2cv17DescriptorMatcher20DescriptorCollection13getDescriptorEi", "_ZN2cv15scalarToRawDataERKNS_7Scalar_IdEEPvii", "_ZN2cv3maxERKNS_3MatEd", "png_get_cHRM_XYZ", "_ZNK2cv3ocl6oclMat6copyToERS1_RKS1_", "_ZN2cv17SelfSimDescriptorC2Ev", "_ZN7testing8internal6String10FormatByteEh", "__gnu_thumb1_case_sqi", "Java_org_opencv_imgproc_Moments_get_1mu02_10", "Java_org_opencv_calib3d_Calib3d_RQDecomp3x3_10", "Java_org_opencv_video_Video_calcGlobalOrientation_10", "_ZN2cv16displayStatusBarERKSsS1_i", "_ZN2cv3ocl31GoodFeaturesToTrackDetector_OCL14downloadPointsERKNS0_6oclMatERSt6vectorINS_6Point_IfEESaIS7_EE", "_ZNK8CvRTrees12predict_probERKN2cv3MatES3_", "_ZN11CvBoostTree4readEP13CvFileStorageP10CvFileNodeP16CvDTreeTrainData", "_ZNK2cv25BOWImgDescriptorExtractor14descriptorTypeEv", "_ZN7testing8internal16ForkingDeathTest4WaitEv", "_ZN2cv8superres22createOptFlow_Brox_GPUEv", "_ZN2cv24GenericDescriptorMatcher18KeyPointCollectionC1Ev", "_ZN2cv6detail17VoronoiSeamFinder4findERKSt6vectorINS_5Size_IiEESaIS4_EERKS2_INS_6Point_IiEESaISA_EERS2_INS_3MatESaISF_EE", "_ZN12CvFGDetectorC2Ev", "_Z19vector_Point_to_MatRSt6vectorIN2cv6Point_IiEESaIS2_EERNS0_3MatE", "_ZN3Imf8TimeCode12setDropFrameEb", "_ZN2cv5MutexC2Ev", "_ZN6cvtest9ArrayTest5clearEv", "Java_org_opencv_core_Core_meanStdDev_10", "Java_org_opencv_imgproc_Imgproc_moments_10", "_ZN7testing8internal30WriteToShardStatusFileIfNeededEv", "_ZN2cv12WMByteStream8putDWordEi", "_ZN3Imf11addCommentsERNS_6HeaderERKSs", "_ZN10__cxxabiv123__fundamental_type_infoD0Ev", "_ZN2cv23OneWayDescriptorMatcher5trainEv", "_Z9printBitsRSof", "Java_org_opencv_features2d_DescriptorMatcher_getTrainDescriptors_10", "_ZN14CvBlobTrackSeqD0Ev", "_ZN2cv16SunRasterDecoderD1Ev", "jpc_bitstream_putbits", "icvCompute3DPoint", "_ZN2cv3PtrI13CvVideoWriterE10delete_objEv", "_ZN2cv6detail21leaveBiggestComponentERSt6vectorINS0_13ImageFeaturesESaIS2_EERS1_INS0_11MatchesInfoESaIS6_EEf", "_ZN7testing8internal17TestEventRepeaterD0Ev", "png_get_error_ptr", "Java_org_opencv_imgproc_Imgproc_cornerSubPix_10", "_ZNK9CvANN_MLP21calc_activ_func_derivEP5CvMatS1_PKd", "png_get_mem_ptr", "_ZN3Imf10OutputFile18updatePreviewImageEPKNS_11PreviewRgbaE", "cvCreateHist", "cvHoughLinesP", "_ZN2cvplERKNS_7MatExprERKNS_7Scalar_IdEE", "cvWriteString", "_ZN15CvFuzzyFunctionD1Ev", "_ZN2cv3ocl27matchTemplate_SQDIFF_NORMEDERKNS0_6oclMatES3_RS1_RNS0_16MatchTemplateBufE", "_ZN2cv20FindOneWayDescriptorEiPKNS_16OneWayDescriptorEP9_IplImageiRSt6vectorIiSaIiEES8_RS5_IfSaIfEEP5CvMatSD_", "_ZN7testing8internal19TypedTestCasePState25VerifyRegisteredTestNamesEPKciS3_", "_ZN2cv3of26FabMap11addTrainingERKNS_3MatE", "Java_org_opencv_video_KalmanFilter_predict_11", "_ZN16CvCapture_Images13retrieveFrameEi", "_ZNK2cv3Mat3mulERKNS_11_InputArrayEd", "jas_stream_isseekable", "_ZN2cv11matMulDerivERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_", "cvSetNumThreads", "png_check_cHRM_fixed", "_ZNK9CvGBTrees5writeEP13CvFileStoragePKc", "_ZN2cv8cvtColorERKNS_11_InputArrayERKNS_12_OutputArrayEii", "png_decompress_chunk", "_ZN3Imf9AttributeD1Ev", "_ZN2cv11drawMatchesERKNS_3MatERKSt6vectorINS_8KeyPointESaIS4_EES2_S8_RKS3_IS3_INS_6DMatchESaIS9_EESaISB_EERS0_RKNS_7Scalar_IdEESK_RKS3_IS3_IcSaIcEESaISM_EEi", "_ZN2cv12updateWindowERKSs", "Java_org_opencv_features2d_DescriptorMatcher_train_10", "_ZN2cv11RNG_MT199374nextEv", "cvInsertNodeIntoTree", "_ZN5CvSVM11read_paramsEP13CvFileStorageP10CvFileNode", "_ZN7testing8internal13DeathTestImpl6PassedEb", "cvSetZero", "Java_org_opencv_imgproc_Subdiv2D_getEdge_10", "png_set_iCCP", "_ZN8CvRTrees5clearEv", "_ZN2cv3ocl5CannyERKNS0_6oclMatES3_RNS0_8CannyBufERS1_ddb", "_ZN2cv14setTrackbarPosERKSsS1_i", "jpeg_abort_compress", "_ZN6cvtest6insertERKN2cv3MatERS1_i", "_ZN3Imf9InputFileD0Ev", "cvApproxChains", "_ZNK2cv3SVD9backSubstERKNS_11_InputArrayERKNS_12_OutputArrayE", "jpc_pchglist_get", "Java_org_opencv_photo_Photo_inpaint_10", "_ZN2cv8Subdiv2D12clearVoronoiEv", "_ZN2cv15loadPCAFeaturesEPKcS1_RSt6vectorIP9_IplImageSaIS4_EE6CvSize", "_ZN2cv3ogl6Arrays16setTexCoordArrayERKNS_11_InputArrayE", "_ZNK2cv13HOGDescriptor16detectMultiScaleERKNS_3MatERSt6vectorINS_5Rect_IiEESaIS6_EEdNS_5Size_IiEESB_ddb", "jpc_bitstream_align", "_ZN2cv14fillConvexPolyERNS_3MatEPKNS_6Point_IiEEiRKNS_7Scalar_IdEEii", "cvFindHandRegionA", "Java_org_opencv_calib3d_StereoBM_compute_11", "TIFFSetFileno", "jpc_pchg_destroy", "_ZN2cv3ocl15CvSVMSolver_ocl13solve_genericER17CvSVMSolutionInfo", "_ZN3Imf6Header13displayWindowEv", "_ZN3Imf11StdIFStreamD2Ev", "_ZN9CvGBTrees10calc_errorEP8CvMLDataiPSt6vectorIfSaIfEE", "_ZN2cv10solveCubicERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZNK2cv12_OutputArray5clearEv", "Java_org_opencv_ml_EM_delete", "Java_org_opencv_ml_CvBoostParams_get_1weight_1trim_1rate_10", "Java_org_opencv_calib3d_Calib3d_filterSpeckles_10", "_ZN2cv6detail12CameraParamsC2Ev", "_Z16cvFindDataMatrixP5CvMat", "_ZN9IlmThread9TaskGroup4DataD1Ev", "icvGetQuadsTransform", "_ZN10__cxxabiv117__class_type_infoD2Ev", "_ZN3Imf12addWrapmodesERNS_6HeaderERKSs", "_ZN3Imf6HeaderC2ERKS0_", "_ZN2cv3of26FabMapD0Ev", "jas_stream_gets", "_ZN3Imf14focusAttributeERNS_6HeaderE", "_ZN2cv10BaseFilterC2Ev", "png_set_write_user_transform_fn", "_ZN2cv24GenericDescriptorMatcherD2Ev", "cvEndWriteSeq", "_ZNK2cv10BOWTrainer14getDescriptorsEv", "_ZN9CvERTreesD1Ev", "_ZN11CvBoostTree5scaleEd", "_ZNK2cv12StarDetectorclERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EE", "_ZN2cv11RBaseStream7releaseEv", "_ZN17FaceDetectionListC1Ev", "_ZN2cv3LDA7projectERKNS_11_InputArrayE", "_ZN2cv3ocl10warpAffineERKNS0_6oclMatERS1_RKNS_3MatENS_5Size_IiEEi", "_ZNK2cv16OneWayDescriptor7GetPoseEi", "_ZN3Imf14TiledInputFileC2EPKci", "_ZN2cv13HaarEvaluator7Feature4readERKNS_8FileNodeE", "Java_org_opencv_objdetect_HOGDescriptor_get_1nbins_10", "_ZN2cv5BRISKD1Ev", "_ZN2cv18CvMeanShiftTrackerD1Ev", "_ZN7testing8internal9DeathTest6CreateEPKcPKNS0_2REES3_iPPS1_", "_ZN2cv17MagnoRetinaFilter20setCoefficientsTableEffffff", "_ZN2cv11JpegDecoderD1Ev", "png_get_valid", "_ZN2cv7hconcatERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv14FernClassifierD1Ev", "_Z16icvBoltingPointsPiS_iPddPS_S1_S_", "_ZN21DetectionBasedTracker21SeparateDetectionWork3runEv", "_ZN3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IfEEEEE14staticTypeNameEv", "Java_org_opencv_imgproc_Imgproc_floodFill_11", "_ZNK2cv5FREAK14descriptorSizeEv", "_ZN11CvSVMKernelC1Ev", "_ZN11CvBoostTree4readEP13CvFileStorageP10CvFileNode", "cvWaitKey", "_ZN2cv12HoughCirclesERKNS_11_InputArrayERKNS_12_OutputArrayEiddddii", "_ZN2cv5Mutex7trylockEv", "Java_org_opencv_imgproc_Imgproc_phaseCorrelateRes_10", "_ZN2cv17LatentSvmDetectorC2Ev", "cvCreateStereoGCState", "Java_org_opencv_core_Core_normalize_13", "_ZN2cv3MatC2ERKS0_RKNS_5Rect_IiEE", "_ZN2cv12equalizeHistERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZTv0_n24_NK2cv20DenseFeatureDetector4infoEv", "_ZN8CvMLData16set_response_idxEi", "cvSeqPush", "_ZN7testing8internal12UnitTestImplD0Ev", "_ZNK2cv24GenericDescriptorMatcher5matchERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_S8_RS4_INS_6DMatchESaIS9_EES3_", "_ZNK2cv3gpu6GpuMat6copyToERS1_", "_ZNK2cv12GFTTDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "Java_org_opencv_features2d_DescriptorMatcher_clone_11", "_Z12FillUniColorPhRS_iiRiii12PaletteEntry", "_ZN2cv9GlTextureC2Ev", "cvCreateLSH", "_ZN3Imf7KeyCode9setPrefixEi", "_Z25filterDispositionLevelFFTPK18CvLSVMFilterObjectPK14CvLSVMFftImagePPfPPiS8_", "Java_org_opencv_ml_CvGBTreesParams_set_1loss_1function_1type_10", "_ZN2cv24GenericDescriptorMatcher5clearEv", "_ZN7testing18TestEventListenersD2Ev", "_ZN2cv9videostab18InpaintingPipeline10setMotionsERKSt6vectorINS_3MatESaIS3_EE", "_ZNSt13bad_exceptionD2Ev", "_ZN7testing8TestCase11AddTestInfoEPNS_8TestInfoE", "TIFFSwabArrayOfLong8", "_ZN2cv15FeatureDetectorD1Ev", "_ZN2cv8StereoBMC1Ev", "_ZN3Iex7BaseExcC2ERKSs", "_Unwind_VRS_Set", "cvInitMatNDHeader", "Java_org_opencv_imgproc_Moments_set_1m10_10", "_ZN3Imf10Compressor12compressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "Java_org_opencv_ml_CvANN_1MLP_CvANN_1MLP_11", "_ZN2cv23VectorDescriptorMatcherC2ERKNS_3PtrINS_19DescriptorExtractorEEERKNS1_INS_17DescriptorMatcherEEE", "png_handle_as_unknown", "_ZN3Imf11ChannelList3endEv", "_ZN5CvSVMC1ERKN2cv3MatES3_S3_S3_11CvSVMParams", "Java_org_opencv_imgproc_Imgproc_initWideAngleProjMap_11", "_ZN2cv8superres26createOptFlow_DualTVL1_OCLEv", "_ZN3Imf17ScanLineInputFile4DataD1Ev", "_ZN2cv13Jpeg2KDecoderD0Ev", "_ZNK2cv3ocl7Context15supportsFeatureENS0_12FEATURE_TYPEE", "_ZNK2cv21FernDescriptorMatcher5emptyEv", "png_handle_sCAL", "jpeg_open_backing_store", "_ZN2cv14PCABackProjectERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE", "TIFFFindField", "png_reset_crc", "_ZN3Imf10addExpTimeERNS_6HeaderERKf", "png_get_IHDR", "png_do_bgr", "Java_org_opencv_imgproc_Imgproc_bilateralFilter_11", "Java_org_opencv_objdetect_HOGDescriptor_getDaimlerPeopleDetector_10", "_ZN2cv3ocl26BruteForceMatcher_OCL_base5matchERKNS0_6oclMatES4_RSt6vectorINS_6DMatchESaIS6_EES4_", "TIFFSetDirectory", "_ZN2cv17rectify3CollinearERKNS_11_InputArrayES2_S2_S2_S2_S2_S2_S2_NS_5Size_IiEES2_S2_S2_S2_RKNS_12_OutputArrayES7_S7_S7_S7_S7_S7_dS4_PNS_5Rect_IiEESA_i", "_ZN2cv11sepFilter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_S2_NS_6Point_IiEEdi", "_ZN7testing8UnitTest14AddEnvironmentEPNS_11EnvironmentE", "_ZNK3Imf6Header11compressionEv", "jp2_encode_uuid", "Java_org_opencv_imgproc_Moments_get_1mu20_10", "TIFFInitZIP", "_ZN2cv14FernClassifier4readERKNS_8FileNodeE", "cvLoad", "_ZNK2cv16OneWayDescriptor9GetCenterEv", "_ZN2cv7hconcatERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "jpc_mqdec_create", "_ZNK2cv23BackgroundSubtractorMOG4infoEv", "Java_org_opencv_video_Video_calcOpticalFlowPyrLK_11", "_ZN2cv10warpAffineERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv10PxMDecoderD0Ev", "_ZN13CvCalibFilter10FindEtalonEPP5CvMat", "Java_org_opencv_imgproc_Imgproc_distanceTransformWithLabels_10", "_ZN2cv17LatentSvmDetector15ObjectDetectionC2ERKNS_5Rect_IiEEfi", "png_handle_sBIT", "Java_org_opencv_contrib_StereoVar_get_1fi_10", "jas_iccprof_save", "_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_", "_ZN4epnp19find_betas_approx_3EPK5CvMatS2_Pd", "_ZN8CvMLData15str_to_flt_elemEPKcRfRi", "_ZNK3Imf14TypedAttributeINS_8RationalEE12writeValueToERNS_7OStreamEi", "_ZN2cv6detail20focalsFromHomographyERKNS_3MatERdS4_RbS5_", "_ZNK2cv8GlArrays4bindEv", "_ZN2cv5errorERKNS_9ExceptionE", "Java_org_opencv_ml_CvDTreeParams_get_1max_1categories_10", "___Unwind_ForcedUnwind", "_ZN17CvModelEstimator2C2Ei6CvSizei", "_ZNK2cv15RTreeClassifier5writeERSo", "Java_org_opencv_calib3d_Calib3d_calibrateCamera_11", "_ZN7testing32ScopedFakeTestPartResultReporterD0Ev", "_ZN2cv11VideoWriterD0Ev", "_ZN17CirclesGridFinder7findMCSERKSt6vectorIN2cv6Point_IfEESaIS3_EERS0_I5GraphSaIS8_EE", "icvGetCrossRectDirect", "_ZN13CvFMEstimator9run7PointEPK5CvMatS2_PS0_", "_ZN7testing8internal14CapturedStream14ReadEntireFileEP7__sFILE", "_ZN23CvNormalBayesClassifier5trainEPK5CvMatS2_S2_S2_b", "_ZN2cv12HOGEvaluator4readERKNS_8FileNodeE", "cvUpdateMotionHistory", "_ZN14CvBlobTrackSeqD2Ev", "_ZN12CvForestTree4readEP13CvFileStorageP10CvFileNodeP8CvRTreesP16CvDTreeTrainData", "_ZN2cv9videostab12calcFlowMaskERKNS_3MatES3_S3_fS3_S3_RS1_", "Java_org_opencv_ml_CvANN_1MLP_clear_10", "_ZN3Imf11StdOFStreamD2Ev", "cvRelease2DHMM", "_ZN2cv23BackgroundSubtractorGMGD1Ev", "png_xy_from_XYZ", "_ZN2cv3ogl9Texture2DC2Ev", "jpc_ms_destroy", "_ZN6CvTypeD1Ev", "_ZN2cv6detail20BundleAdjusterReproj24setUpInitialCameraParamsERKSt6vectorINS0_12CameraParamsESaIS3_EE", "_ZN3Imf7KeyCode16setPerfsPerFrameEi", "_ZN3Imf10OutputFileC1EPKcRKNS_6HeaderEi", "png_set_read_user_transform_fn", "_ZN3Imf12hasMultiViewERKNS_6HeaderE", "Java_org_opencv_ml_CvDTree_train_10", "_ZN16CvDTreeTrainDataC1EPK5CvMatiS2_S2_S2_S2_S2_RK13CvDTreeParamsbb", "_ZN2cv21ImageLogPolProjection13runProjectionERKSt8valarrayIfEb", "_ZN2cv12FilterEngineD0Ev", "png_set_packswap", "Java_org_opencv_ml_CvSVMParams_set_1kernel_1type_10", "Java_org_opencv_contrib_StereoVar_compute_10", "jas_image_chclrspc", "Java_org_opencv_core_Core_ellipse_12", "_ZN12FaceTemplateD2Ev", "_ZN2cv3ocl17KNearestNeighbour12find_nearestERKNS0_6oclMatEiRS2_", "_ZN2cv9videostab18InpaintingPipeline6updateEv", "Java_org_opencv_highgui_VideoCapture_n_1release", "__fixunsdfsi", "_ZN2cv18findFundamentalMatERKNS_11_InputArrayES2_RKNS_12_OutputArrayEidd", "_ZN2cv11WBaseStream4openERKSs", "_ZN2cv11normHammingEPKhS1_i", "cvSmooth", "_ZN2cv11JpegDecoder8readDataERNS_3MatE", "_ZN5CvSVMC2EPK5CvMatS2_S2_S2_11CvSVMParams", "_ZN7SamplerC2EP5CvMat7CvPointS2_S2_", "png_write_png", "cvSetErrMode", "png_info_destroy", "_ZNK2cv6KDTree8getPointEiPi", "_ZNK2cv24GenericDescriptorMatcher14getTrainImagesEv", "png_longjmp", "_ZN3Imf9InputFileC2EPKci", "jas_image_writecmptsample", "_ZN2cv3ocl11bitwise_andERKNS0_6oclMatES3_RS1_S3_", "Java_org_opencv_calib3d_Calib3d_findFundamentalMat_11", "jp2_box_destroy", "_ZNK3Imf6Header3endEv", "_ZN2cvorERKNS_3MatERKNS_7Scalar_IdEE", "_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj", "_ZN7testing8internal24XmlUnitTestResultPrinter17OutputXmlTestInfoEPSoPKcRKNS_8TestInfoE", "_ZN2cv15CvHybridTracker19updateTrackerWithEMENS_3MatE", "_ZN16CvObjectDetectorD2Ev", "_ZN2cv3ocl3absERKNS0_6oclMatERS1_", "_ZN3Imf13PizCompressor12compressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN2cv3ocl6sqrSumERKNS0_6oclMatE", "_ZN2cv9videostab17OnePassStabilizer9resetImplEv", "png_do_write_intrapixel", "Java_org_opencv_ml_CvSVMParams_get_1gamma_10", "_ZN2cv13insertChannelERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZNK2cv17FlannBasedMatcher4infoEv", "_ZN2cv12SurfAdjuster7tooManyEii", "_ZN2cv3ocl25openCLGetKernelFromSourceEPKNS0_7ContextEPKNS0_12ProgramEntryESsPKc", "_ZN2cv3ocl20FarnebackOpticalFlow28setPolynomialExpansionConstsEid", "_ZN2cv3of211ChowLiuTreeD1Ev", "_ZN2cv9minMaxLocERKNS_11_InputArrayEPdS3_PNS_6Point_IiEES6_S2_", "cvSquareAcc", "_ZN6cvtest12randomDoubleEdd", "_ZN2cv9TickMeterC2Ev", "_ZNK7CvDTree5writeEP13CvFileStoragePKc", "_ZN2cv3Mat3eyeENS_5Size_IiEEi", "_ZN6cvtest9ArrayTest17prepare_test_caseEi", "Java_org_opencv_imgproc_Imgproc_cvtColor_11", "_ZNK3Imf7KeyCode8filmTypeEv", "_ZNK2cv14FernClassifier14getStructCountEv", "Java_org_opencv_core_Mat_n_1copyTo__JJ", "_ZN2cv7linemod8DetectorC2ERKSt6vectorINS_3PtrINS0_8ModalityEEESaIS5_EERKS2_IiSaIiEE", "_ZN2cv3dctERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv21FernDescriptorMatcher6ParamsC2ERKSs", "_ZN7testing8internal17TestEventRepeater27OnEnvironmentsTearDownStartERKNS_8UnitTestE", "cvKMeans", "_ZN13CvCalibFilter10DrawPointsEPP9_IplImage", "_ZN9IlmThread6ThreadD0Ev", "_ZNK3Imf17ScanLineInputFile8fileNameEv", "cvGetMinMaxHistValue", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1rp_1dw_1max_10", "_ZN3Imf18wrapmodesAttributeERKNS_6HeaderE", "_ZN2cv9AlgorithmD2Ev", "_ZN2cv16FileNodeIteratorC1Ev", "_ZN3Imf14TypedAttributeINS_11ChannelListEE14staticTypeNameEv", "_ZNK7testing8internal12UnitTestImpl21successful_test_countEv", "Java_org_opencv_ml_CvSVMParams_get_1term_1crit_10", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow32getResizeAttribsEdgeDensityFuzzyERiS1_S1_S1_", "png_get_current_row_number", "png_set_background", "_ZN2cv14chamerMatchingERNS_3MatES1_RSt6vectorIS2_INS_6Point_IiEESaIS4_EESaIS6_EERS2_IfSaIfEEdidiiidddd", "_ZNK2cv5MatOp3absERKNS_7MatExprERS1_", "_ZN11CvBoostTree5trainEP16CvDTreeTrainDataPK5CvMat", "_ZN3Imf6Header18setTileDescriptionERKNS_15TileDescriptionE", "Java_org_opencv_core_Core_extractChannel_10", "TIFFInitPackBits", "_ZN2cv20PlanarObjectDetectorC2Ev", "_ZN2cv9Algorithm3setEPKcRKNS_3PtrIS0_EE", "Java_org_opencv_imgproc_Imgproc_pyrDown_11", "_ZN16EllipticKeyPoint7convertERKSt6vectorIN2cv8KeyPointESaIS2_EERS0_IS_SaIS_EE", "_ZNK2cv10Eigenfaces7predictERKNS_11_InputArrayERiRd", "_ZN2cv3of29FabMapFBO17setWordStatisticsERKNS_3MatERSt8multisetINS1_9WordStatsESt4lessIS6_ESaIS6_EE", "_ZN2cv3ocl23OclCascadeClassifierBuf14CreateBaseBufsEiiii", "png_convert_from_time_t", "jp2_box_put", "cvAddText", "_ZN2cv3ocl20openCLExecuteKernel2EPNS0_7ContextEPKNS0_12ProgramEntryESsPjS6_RSt6vectorISt4pairIjPKvESaISB_EEiiNS0_10FLUSH_MODEE", "_ZN2cv17validateDisparityERKNS_12_OutputArrayERKNS_11_InputArrayEiii", "_ZN2cv3ocl5splitERKNS0_6oclMatEPS1_", "_ZN4epnp5dist2EPKdS1_", "_ZN9IlmThread9SemaphoreD0Ev", "_ZNK2cv17MatOp_Initializer8multiplyERKNS_7MatExprEdRS1_", "_ZN2cv17MagnoRetinaFilter9runFilterERKSt8valarrayIfES4_", "_ZN2cv3ogl6Buffer7mapHostENS1_6AccessE", "_ZNK2cv9SparseMat9convertToERS0_id", "cvScalarToRawData", "_ZN2cv16FeatureEvaluatorD2Ev", "_ZNK2cv17DescriptorMatcher5emptyEv", "_ZN2cv3ocl22cornerMinEigenVal_dxdyERKNS0_6oclMatERS1_S4_S4_iii", "_TIFFSetupFields", "_ZN3Imf8hasFocusERKNS_6HeaderE", "cvStartWriteSeq", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRibMS1_FivEMS1_FviERKSs", "jas_matrix_cmp", "_ZN14CameraActivityD0Ev", "_ZN3Imf9InputFile4DataD0Ev", "jas_image_dump", "_ZN2cv18findFundamentalMatERKNS_11_InputArrayES2_iddRKNS_12_OutputArrayE", "jpc_pchglist_copy", "_ZN2cv16BaseImageEncoder14setDestinationERSt6vectorIhSaIhEE", "_Z22cvPreprocessIndexArrayPK5CvMatib", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1term_1crit_10", "_ZN2cv9Algorithm4readERKNS_8FileNodeE", "_ZNK2cv16BaseImageDecoder15signatureLengthEv", "_TIFFMultiply64", "_ZNK2cv5MatOp6matmulERKNS_7MatExprES3_RS1_", "_ZN11CvSVMSolver11get_row_svcEiPfS0_b", "_ZN2cv6divideERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi", "cvOr", "_ZN2cv10BmpEncoderC2Ev", "_ZN2cv18SimpleBlobDetector6Params4readERKNS_8FileNodeE", "_ZN13CvBlobTracker10GetBlobHypEii", "_ZN2cv3ocl8integralERKNS0_6oclMatERS1_", "_ZN3Imf7KeyCodeaSERKS0_", "_ZN2cv15getNearestPointERKSt6vectorINS_6Point_IfEESaIS2_EEf", "cvPerspectiveTransform", "cvCalcEMD2", "cvMatchShapes", "Java_org_opencv_features2d_DescriptorMatcher_radiusMatch_11", "cvSegmentMotion", "_ZN2cvdvERKNS_3MatES2_", "png_set_expand_16", "__restore_core_regs", "_ZN17CvCamShiftTracker15reset_histogramEv", "_ZNK2cv17DescriptorMatcher20DescriptorCollection14getDescriptorsEv", "_ZN2cv17LatentSvmDetectorC1Ev", "__adddf3", "Java_org_opencv_imgproc_Imgproc_getRectSubPix_11", "_Z25cvCreateBlobTrackerCCMSPFv", "png_destroy_struct_2", "_ZN2cv3ocl4MOG2C1Ei", "_ZN6cvtest9ArrayTestC2Ev", "_Z21icvComputeTransform4DP5CvMatS0_S0_", "_ZN2cv3ocl26BruteForceMatcher_OCL_base13matchDownloadERKNS0_6oclMatES4_S4_RSt6vectorINS_6DMatchESaIS6_EE", "_ZN2cv8GlBuffer9unmapHostEv", "TIFFGetFieldDefaulted", "_ZNK9CvANN_MLP5writeEP13CvFileStoragePKc", "_ZN11CvSVMSolver12solve_nu_svrEiiPPKfS1_P12CvMemStorageP11CvSVMKernelPdR17CvSVMSolutionInfo", "Java_org_opencv_objdetect_HOGDescriptor_getDescriptorSize_10", "Java_org_opencv_highgui_VideoCapture_n_1VideoCapture__", "_ZN2cv16BaseColumnFilter5resetEv", "_ZN2cv9FormattedC1ERKNS_3MatEPKNS_9FormatterERKSt6vectorIiSaIiEE", "_ZNK3Imf7KeyCode13perfsPerCountEv", "_ZN2cv3ocl12PlatformInfoC1Ev", "__powisf2", "_ZN3Imf15OpaqueAttribute13readValueFromERNS_7IStreamEii", "_ZN2cv13AlgorithmInfo9addParam_ERNS_9AlgorithmEPKciPvbMS1_KFivEMS1_FviERKSs", "cvFirstType", "Java_org_opencv_ml_CvNormalBayesClassifier_train_11", "_ZTv0_n12_N2cv19DescriptorExtractorD0Ev", "_ZN2cv5FREAKC1EbbfiRKSt6vectorIiSaIiEE", "_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKPi", "_ZN2cv23VectorDescriptorMatcherC1ERKNS_3PtrINS_19DescriptorExtractorEEERKNS1_INS_17DescriptorMatcherEEE", "_ZN2cv3ocl19openCLExecuteKernelEPNS0_7ContextEPKNS0_12ProgramEntryESsPjS6_RSt6vectorISt4pairIjPKvESaISB_EEii", "_ZN2cv11FileStorage7releaseEv", "TIFFSwabLong8", "_ZN2cv6detail14FeaturesFinderclERKNS_3MatERNS0_13ImageFeaturesERKSt6vectorINS_5Rect_IiEESaIS9_EE", "_ZN2cv9Directory14GetListFoldersERKSsS2_b", "_ZNK2cv19FastFeatureDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_ZNK2cv8FileNodeixEPKc", "_ZN2cv11RetinaColor35normalizeRGBOutput_0_maxOutputValueEf", "_ZNK3Imf15Pxr24Compressor6formatEv", "_ZN2cv9videostab25ConsistentMosaicInpainterC2Ev", "png_do_write_transformations", "_ZN2cv17CascadeClassifierD2Ev", "_ZN3Imf17latitudeAttributeERKNS_6HeaderE", "_ZN2cv24convertPointsHomogeneousERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv20OneWayDescriptorBase20InitializeDescriptorEiP9_IplImagePKc", "_ZN2cv17FlannBasedMatcher4readERKNS_8FileNodeE", "_Z31cvComputeEpipolesFromFundMatrixPfP12CvPoint3D32fS1_", "_ZN7testing8internal8FilePath22GenerateUniqueFileNameERKS1_S3_PKc", "Java_org_opencv_gpu_Gpu_printShortCudaDeviceInfo_10", "Java_org_opencv_ml_CvParamGrid_set_1max_1val_10", "cvCreateFileCapture", "_ZN2cv9solvePolyERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN4perf8TestBase14_declareHelper4runsEj", "jpeg_mem_init", "_ZN3GMM11endLearningEv", "_ZN2cv9videostab17OnePassStabilizer14stabilizeFrameEv", "jas_iccattrval_create", "Java_org_opencv_imgproc_Imgproc_pyrUp_12", "_ZN2cv7linemod14getDefaultLINEEv", "_ZN2cv11_InputArrayC2ERKNS_3MatE", "_ZN7testing8internal12UnitTestImpl21os_stack_trace_getterEv", "_ZNK16EllipticKeyPoint14calcProjectionERKN2cv4Mat_IdEERS_", "_Z20Mat_to_vector_DMatchRN2cv3MatERSt6vectorINS_6DMatchESaIS3_EE", "_ZN2cv7waitKeyEi", "_ZN7testing18TestEventListeners23SetDefaultResultPrinterEPNS_17TestEventListenerE", "_ZN17CvERTreeTrainData16get_ord_var_dataEP11CvDTreeNodeiPfPiPPKfPPKiS3_", "_ZN2cv17getOptimalDFTSizeEi", "_ZN2cv13LevMarqSparse5clearEv", "_ZN13CvCalibFilter7RectifyEPP5CvMatS2_", "jas_seq2d_output", "TIFFIsCODECConfigured", "_ZN2cv16CvFeatureTracker28updateTrackingWindowWithSIFTENS_3MatE", "_ZN7testing8internal14CapturedStream11GetFileSizeEP7__sFILE", "_ZN2cv8Stitcher17estimateTransformERKNS_11_InputArrayERKSt6vectorIS4_INS_5Rect_IiEESaIS6_EESaIS8_EE", "_ZN2cv6KDTreeC1Ev", "_ZN16CvDTreeTrainDataC2Ev", "_Z20cvPreparePredictDataPKviPK5CvMatiS3_PPfi", "icvComputeStereoLineCoeffs", "Java_org_opencv_contrib_FaceRecognizer_delete", "_ZN2cv16BaseColumnFilterC2Ev", "cvSetWindowProperty", "_ZN9IlmThread9Semaphore4waitEv", "jpc_decode", "TIFFCleanup", "Java_org_opencv_video_Video_segmentMotion_10", "_ZN2cv3of213BOWMSCTrainerD0Ev", "_ZN17CvCamShiftTracker15color_transformEPK9_IplImage", "_ZNK3Imf6Header7writeToERNS_7OStreamEb", "Java_org_opencv_photo_Photo_fastNlMeansDenoisingColored_10", "cvHoughLines2", "cvStartReadRawData", "_ZNK3Imf14TiledInputFile18dataWindowForLevelEii", "_ZN2cv8CholeskyEPfjiS0_ji", "_ZN13FaceDetection10ResetImageEv", "Java_org_opencv_core_Mat_n_1cols", "cvMean", "_ZN2cv11_InputArrayC2ERKNS_3ogl9Texture2DE", "_ZNK7testing8UnitTest22test_case_to_run_countEv", "cvSave", "_ZN17CvERTreeTrainData16get_cat_var_dataEP11CvDTreeNodeiPi", "_ZN9CvANN_MLP11train_rpropE9CvVectorsS0_PKd", "_ZN4perf8TestBase14_declareHelper2inERKN2cv12_OutputArrayEi", "Java_org_opencv_android_Utils_nBitmapToMat2", "TIFFInitNeXT", "_ZN2cv3ocl5canny17calcMagnitude_gpuERKNS0_6oclMatES4_RS2_S5_S5_iib", "_ZNK3Imf14TiledInputFile9numYTilesEi", "_ZNK3Imf6Header11sanityCheckEb", "jpc_seglist_remove", "_ZN7testing8internal12UnitTestImpl19current_test_resultEv", "_ZN2cv8Subdiv2DC1ENS_5Rect_IiEE", "Java_org_opencv_core_Core_sort_10", "_ZNK2cv3PCA7projectERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv12StarDetectorC2Eiiiii", "icvGetCrossDirectDirect", "_ZNK2cv9Algorithm7getBoolERKSs", "jpc_tsfb_destroy", "_ZN2cv7grabCutERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Rect_IiEES5_S5_ii", "_ZN2cv8internal15IntrinsicParamsaSERKNS_3MatE", "_ZN2cv8superres15SuperResolutionC2Ev", "png_do_expand", "cvSeqInvert", "_Z25cvHaarDetectObjectsForROCPKvP23CvHaarClassifierCascadeP12CvMemStorageRSt6vectorIiSaIiEERS5_IdSaIdEEdii6CvSizeSC_b", "_ZN2cv4LBPH5trainERKNS_11_InputArrayES3_b", "_ZN2cv10PngEncoderD0Ev", "cvFillImage", "_ZNK13CvCalibFilter9GetEtalonEPiPPKdS0_PPK12CvPoint2D32f", "_ZN2cv20DenseFeatureDetectorC1Efifiibb", "jpeg_free_large", "_ZN3Imf17ScanLineInputFileC1ERKNS_6HeaderEPNS_7IStreamEi", "_ZN2cv12StarAdjuster7tooManyEii", "_ZN7testing8internal9DeathTest11LastMessageEv", "_ZN24CirclesGridClusterFinder20rectifyPatternPointsERKSt6vectorIN2cv6Point_IfEESaIS3_EES7_RS5_", "_ZN2cv5flann33HierarchicalClusteringIndexParamsC1EiN7cvflann20flann_centers_init_tEii", "png_set_swap", "__gnu_Unwind_Restore_WMMXD", "_ZN4half7convertEi", "_ZNKSt9bad_alloc4whatEv", "_ZN3Imf15Pxr24Compressor8compressEPKciiRS2_", "_ZN2cv11writeScalarERNS_11FileStorageEf", "_ZN2cv3ocl11interpolate11blendFramesERKNS0_6oclMatES4_S4_fRS2_RP7_cl_memS8_", "_ZN3Imf11hasLatitudeERKNS_6HeaderE", "_ZN2cv3absERKNS_3MatE", "_ZN20CvBlobDetectorSimpleD1Ev", "_ZN6cvtest8BaseTestC1Ev", "cvWriteRawData", "_ZN9IlmThread15supportsThreadsEv", "_ZN3Imf14TypedAttributeINS_7KeyCodeEE13readValueFromERNS_7IStreamEii", "Java_org_opencv_ml_CvSVMParams_CvSVMParams_10", "_ZN2cv8Subdiv2D10deleteEdgeEi", "_Z12icvTestPoint12CvPoint2D64fPdS0_S_Pi", "cv3dTrackerLocateObjects", "_ZNK3Imf8TimeCode11binaryGroupEi", "cvGetImageCOI", "cvFindExtrinsicCameraParams_64d", "Java_org_opencv_imgproc_Moments_get_1mu12_10", "_ZN2cv12VideoCaptureD2Ev", "jpc_qmfb_split_colres", "TIFFCheckTile", "_ZN2cv23BackgroundSubtractorGMGclERKNS_11_InputArrayERKNS_12_OutputArrayEd", "_ZN3Imf14TypedAttributeIN5Imath4Vec2IfEEE14staticTypeNameEv", "_ZN2cv8GlCamera12setCameraPosENS_7Point3_IdEEddd", "jas_image_lookupfmtbyid", "cvGetFileNode", "_ZN12FaceTemplateD1Ev", "_ZN2cv9startLoopEPFiiPPcEiS1_", "_ZN6cvtest9ArrayTest21prepare_to_validationEi", "_ZN2cv16TLSDataContainerD2Ev", "_ZNK21DetectionBasedTracker10getObjectsERSt6vectorISt4pairIN2cv5Rect_IiEEiESaIS5_EE", "_ZN2cv12ellipse2PolyENS_6Point_IiEENS_5Size_IiEEiiiiRSt6vectorIS1_SaIS1_EE", "_ZN2cv17CascadeClassifierC1ERKSs", "_ZN2cv8internal15IntrinsicParamsC1Ev", "cvFindHandRegion", "cvGetCaptureProperty", "Java_org_opencv_core_Core_subtract_11", "Java_org_opencv_core_Core_meanStdDev_11", "_ZNK2cv17CascadeClassifier18isOldFormatCascadeEv", "png_set_cHRM", "_ZN25CvBlobTrackPostProcKalmanD0Ev", "_ZN2cv3of211ChowLiuTree14sortInfoScoresERKNS1_4infoES4_", "TIFFCurrentDirectory", "_ZNSt13bad_exceptionD1Ev", "Java_org_opencv_core_Mat_nGetD", "_ZNK14HarrisDetector4infoEv", "_ZN3Imf9AttributeD2Ev", "_ZN3Imf15Pxr24CompressorD0Ev", "_ZN2cv11convertMapsERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_ib", "cvUseOptimized", "_ZN8CvRTrees5trainEPK5CvMatiS2_S2_S2_S2_S2_10CvRTParams", "_ZN7testing8internal6String28CaseInsensitiveCStringEqualsEPKcS3_", "_ZN2cv3ocl10bitwise_orERKNS0_6oclMatES3_RS1_S3_", "_ZN2cv6GlFontC1ERKSsiNS0_6WeightENS0_5StyleE", "_ZN2cv11RetinaColor21applyLMS2LabTransformERSt8valarrayIfE", "_ZNK2cv9videostab18FastMarchingMethod5solveEiiii", "_TIFFSwab24BitData", "png_write_flush", "png_set_packing", "__gnu_Unwind_Resume", "cvCompareHist", "_ZN2cv17CascadeClassifierC2Ev", "_ZN3Imf6Header15tileDescriptionEv", "_ZN11CvStatModelD0Ev", "_ZNK3Imf17ScanLineInputFile10isCompleteEv", "_ZN3p3p5solveERN2cv3MatES2_RKS1_S4_", "png_read_info", "_ZN2cv21ImageLogPolProjectionD1Ev", "_ZN8CvRTrees4readEP13CvFileStorageP10CvFileNode", "_ZN2cv13LevMarqSparse8optimizeER5CvMat", "Java_org_opencv_imgproc_Imgproc_convertMaps_10", "png_default_read_data", "_Z23icvGetRectSubPix_8u_C1RPKhi6CvSizePhiS1_12CvPoint2D32f", "_ZN2cv6detail18BundleAdjusterBase8estimateERKSt6vectorINS0_13ImageFeaturesESaIS3_EERKS2_INS0_11MatchesInfoESaIS8_EERS2_INS0_12CameraParamsESaISD_EE", "Java_org_opencv_calib3d_Calib3d_calibrateCamera_10", "jpc_qmfb_join_colgrp", "_ZNK8CvMLData19get_test_sample_idxEv", "_ZN2cv20LogPolar_OverlappingD2Ev", "_ZN3Imf14chromaticitiesERKNS_6HeaderE", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1rp_1dw_1max_10", "Java_org_opencv_core_Core_SVDecomp_11", "_ZN2cv17DescriptorMatcher20DescriptorCollection3setERKSt6vectorINS_3MatESaIS3_EE", "TIFFXYZToRGB", "_Z15icvCheckGlErrorPKciS0_", "_ZN2cv11TiffDecoder10readHeaderEv", "_ZN2cv10BaseFilterD2Ev", "_ZN2cv15RTreeClassifier22saveAllFloatPosteriorsESs", "Java_org_opencv_core_Core_add_15", "_ZN2cv20createGaussianFilterEiNS_5Size_IiEEddi", "_ZN2cv20OneWayDescriptorBase18LoadPCADescriptorsEPKc", "_ZN3Imf17dataWindowForTileERKNS_15TileDescriptionEiiiiiiii", "cvReleaseStereoGCState", "Java_org_opencv_imgproc_Moments_set_1m02_10", "_ZN2cv15LogPolar_Interp12to_cartesianERKNS_3MatE", "_ZN2cv14ChamferMatcher21LocationImageIterator4nextEv", "_ZNK2cv12HOGEvaluator17integralHistogramERKNS_3MatERSt6vectorIS1_SaIS1_EERS1_i", "_ZN3Imf8TimeCode13setColorFrameEb", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1train_1method_10", "_ZNK2cv16OneWayDescriptor12EstimatePoseEP9_IplImageRiRf", "Java_org_opencv_calib3d_Calib3d_validateDisparity_10", "_ZN2cv8Subdiv2DC2ENS_5Rect_IiEE", "_ZN5Graph9addVertexEj", "jpc_ft_synthesize", "_ZN2cv4MSERC2Eiiiddiddi", "_ZN2cv5flann5Index9knnSearchERKNS_11_InputArrayERKNS_12_OutputArrayES7_iRKNS0_12SearchParamsE", "_ZN2cv3ocl6kmeansERKNS0_6oclMatEiRS1_NS_12TermCriteriaEiiS4_", "cvCalcSubdivVoronoi2D", "_ZNK5CvSVM24get_support_vector_countEv", "TIFFGetReadProc", "_ZN2cv9videostab17TwoPassStabilizer9nextFrameEv", "_TIFFfree", "_ZN2cvltEdRKNS_3MatE", "_ZN2cv3ocl5mergeERKSt6vectorINS0_6oclMatESaIS2_EERS2_", "_ZN2cv3LDA7computeERKNS_11_InputArrayES3_", "_ZN2cv11FileStorageC2ERKSsiS2_", "cvSampleLine", "_ZN7CvDTree10calc_errorEP8CvMLDataiPSt6vectorIfSaIfEE", "Java_org_opencv_ml_CvRTrees_predict_1prob_11", "_ZN8CvMLData11get_var_idxEv", "_ZN2cv3ocl11ContextImpl10setContextEPKNS0_10DeviceInfoE", "_ZN2cvorERKNS_7Scalar_IdEERKNS_3MatE", "_ZNK2cv9Feature2D7computeERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZN7cvflann19flann_distance_typeEv", "_ZN9IlmThread9TaskGroup4DataC1Ev", "_ZN2cv6detail15SphericalWarper15detectResultRoiENS_5Size_IiEERNS_6Point_IiEES6_", "_ZN2cv6detail15GainCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_3MatESaIS9_EERKS2_ISt4pairIS9_hESaISF_EE", "_ZN2cv10PCAProjectERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE", "_ZN2cv11TiffDecoderC1Ev", "_ZN17MouthFaceTemplateD0Ev", "_ZN2cv12WLByteStream7putByteEi", "_ZN3Imf7KeyCode14setFilmMfcCodeEi", "_ZN2cv10TLSStorageD2Ev", "_ZN3Imf18renderingTransformERNS_6HeaderE", "_ZN2cv15undistortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_S2_", "Java_org_opencv_highgui_VideoCapture_n_1open__JI", "_ZN2cv19getRotationMatrix2DENS_6Point_IfEEdd", "jas_iccprof_sethdr", "_ZN2cv11createCLAHEEdNS_5Size_IiEE", "_ZN2cv3ocl8__ModuleC1Ev", "_ZN2cv13Jpeg2KDecoder5closeEv", "_ZN2cv4MSERC1Eiiiddiddi", "Java_org_opencv_core_Core_getTickFrequency_10", "_ZN2cv9StereoVarC2Ev", "_ZN2cv24currentParallelFrameworkEv", "png_get_copyright", "_ZN24CirclesGridClusterFinder11findCornersERKSt6vectorIN2cv6Point_IfEESaIS3_EERS5_", "_ZN2cv3gpu6GpuMatC2ERKS1_", "cvCalcPCA", "png_set_IHDR", "Java_org_opencv_core_Mat_n_1checkVector__JII", "_ZN7testing8internal17TestEventRepeater11OnTestStartERKNS_8TestInfoE", "jinit_phuff_decoder", "_ZN7CvBoost5pruneE7CvSlice", "_ZN3Imf17apertureAttributeERNS_6HeaderE", "_ZN3Imf10OutputFileD2Ev", "_ZN22CameraWrapperConnector19fillListWrapperLibsERKSsRSt6vectorISsSaISsEE", "Java_org_opencv_gpu_DeviceInfo_delete", "_ZN2cveqEdRKNS_3MatE", "cvCalcOpticalFlowPyrLK", "cvGetHashedKey", "Java_org_opencv_imgproc_Imgproc_getGaussianKernel_10", "_ZN7CvBoostD0Ev", "_ZN2cv14FernClassifierD2Ev", "Java_org_opencv_core_Core_max_11", "_ZN2cv11cornerScoreILi8EEEiPKhPKii", "_ZNK2cv3Matcv9_IplImageEv", "_ZN7testing8internal24XmlUnitTestResultPrinter21OutputXmlCDataSectionEPSoPKc", "_ZN2cv21FernDescriptorMatcher23calcBestProbAndMatchIdxERKNS_3MatERKNS_6Point_IfEERfRiRSt6vectorIfSaIfEE", "Java_org_opencv_core_Mat_n_1total", "_ZN6cvtest2TS20set_failed_test_infoEi", "_ZN2cv3gpu11resetDeviceEv", "_ZN2cv8superres31createSuperResolution_BTVL1_OCLEv", "_ZN2cv9floodFillERKNS_12_OutputArrayENS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i", "cvNulDevReport", "png_get_pixels_per_inch", "_ZN2cv10checkRangeERKNS_11_InputArrayEbPNS_6Point_IiEEdd", "_ZN2cv12approxPolyDPERKNS_11_InputArrayERKNS_12_OutputArrayEdb", "_ZN2cv13Jpeg2KDecoder15readComponent8uEPhPviiiii", "_ZN2cv12StarDetectorC1Eiiiii", "_ZN3Imf9Attribute23unRegisterAttributeTypeEPKc", "Java_org_opencv_core_Core_getBuildInformation_10", "_ZN2cv3of27FabMap221getNewPlaceLikelihoodERKNS_3MatE", "_ZNK3GMMclEN2cv3VecIdLi3EEE", "_ZN2cv3ogl9Texture2D8copyFromERKNS_11_InputArrayEb", "_ZN2cv20ConvertImageToMatrixEP9_IplImage", "_ZN2cv4idctERKNS_11_InputArrayERKNS_12_OutputArrayEi", "png_set_quantize", "jpc_ns_fwdlift_col", "Java_org_opencv_core_Core_circle_11", "_ZN7testing8internal14CmpHelperSTRNEEPKcS2_PKwS4_", "_ZN7testing8internal6String17WideCStringEqualsEPKwS3_", "_ZN2cv11RBaseStreamD2Ev", "_ZN2cv4swapERNS_3MatES1_", "cvGet2D", "_ZN3Imf12PreviewImageD1Ev", "_ZN2cv12LBPEvaluatorD0Ev", "_ZN11CvFuzzyRuleC2Ev", "cvbSqrt", "jcopy_block_row", "_ZN3Imf11hasApertureERKNS_6HeaderE", "_ZN2cv6detail18SphericalWarperGpu9buildMapsENS_5Size_IiEERKNS_3MatES6_RNS_3gpu6GpuMatES9_", "_ZN3Imf17altitudeAttributeERNS_6HeaderE", "Java_org_opencv_imgproc_Imgproc_adaptiveBilateralFilter_12", "_ZN2cv7linemod11DepthNormalC1Eiiji", "_ZN10CvVSModuleD1Ev", "_ZN2cv7fisheye15undistortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_S3_S3_", "_ZN2cv12RLByteStreamD0Ev", "_ZN2cv15CvHybridTracker10newTrackerENS_3MatENS_5Rect_IiEE", "_ZN2cv15BriskScaleSpaceD2Ev", "Java_org_opencv_features2d_DescriptorMatcher_empty_10", "_ZN2cv9videostab14StabilizerBase14doOneIterationEv", "_ZN7CvImage4saveEPKcS1_PKi", "cvAvg", "cvCreateSeqBlock", "_ZN2cv15RTreeClassifier22discardFloatPosteriorsEv", "_ZN17CirclesGridFinder23areSegmentsIntersectingENS_7SegmentES0_", "_ZN7testing14InitGoogleTestEPiPPc", "_ZN2cv9SparseMatC2ERKNS_3MatE", "_ZNK7CvBoost7predictERKN2cv3MatES3_RKNS0_5RangeEbb", "_ZN3Imf18renderingTransformERKNS_6HeaderE", "_ZN17CvERTreeTrainData11get_vectorsEPK5CvMatPfPhS3_b", "_ZN2cvgeEdRKNS_3MatE", "_ZNK2cv14ChamferMatcher23SlidingWindowImageRange8iteratorEv", "_ZN2cv22OneWayDescriptorObject27InitializeObjectDescriptorsEP9_IplImageRKSt6vectorINS_8KeyPointESaIS4_EEPKcifi", "_ZN10CvVSModule13SetModuleNameEPKc", "_ZNK2cv9videostab17TwoPassStabilizer7motionsEv", "jpc_mqenc_codelps", "_ZN11CvBoostTree18find_split_ord_regEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN2cv17DescriptorMatcher20DescriptorCollectionD0Ev", "_ZNK2cv6detail15GainCompensator5gainsEv", "_ZN2cv12RetinaFilter18_createHybridTableEv", "_ZN2cv10ExrDecoderD2Ev", "Java_org_opencv_objdetect_HOGDescriptor_getWinSigma_10", "_ZN2cv13LevMarqSparse3runEiiiiiRNS_3MatES2_S2_NS_12TermCriteriaEPFviiS2_S2_S2_S2_PvEPFviiS2_S2_S2_S4_ES4_", "_Z29Mat_to_vector_vector_KeyPointRN2cv3MatERSt6vectorIS2_INS_8KeyPointESaIS3_EESaIS5_EE", "_ZN9CvGBTrees10leaves_getEPP11CvDTreeNodeRiS1_", "_ZN4perf8TestBase13reportMetricsEb", "_ZN2cv8GlBuffer7mapHostEv", "cvFindHomography", "_ZN2cv11RBaseStreamC1Ev", "_ZN2cv6Retina8getMagnoERNS_3MatE", "cvCreateData", "Java_org_opencv_features2d_GenericDescriptorMatcher_match_12", "_ZN3Imf14TiledInputFileD2Ev", "Java_org_opencv_core_Core_circle_10", "png_get_x_offset_inches", "_Z17Mat_to_vector_MatRN2cv3MatERSt6vectorIS0_SaIS0_EE", "_ZN3Imf7KeyCode8setCountEi", "_ZN2cv3ocl6oclMat6createEiii", "_ZN9IlmThread10ThreadPoolC2Ej", "_ZN2cv6detail20CylindricalWarperGpu4warpERKNS_3gpu6GpuMatERKNS_3MatES8_iiRS3_", "_ZN4perf8TestBase14_declareHelper11tbb_threadsEi", "_ZNK2cv6Retina5writeESs", "jpc_ppxstab_create", "cvMaxRect", "_Z19ChoiceTrackingFace3P13CvFaceTrackeriPK13CvFaceElementP14CvTrackingRectRi", "_ZN2cv9videostab25ConsistentMosaicInpainter7inpaintEiRNS_3MatES3_", "png_set_chunk_cache_max", "jas_stream_tmpfile", "_ZN3Imf23whiteLuminanceAttributeERNS_6HeaderE", "_ZN10CvKNearestD2Ev", "_ZN3Imf11ChannelList6insertEPKcRKNS_7ChannelE", "_ZN3Imf9longitudeERKNS_6HeaderE", "cvMerge", "_ZN17CirclesGridFinderC1EN2cv5Size_IiEERKSt6vectorINS0_6Point_IfEESaIS5_EERK27CirclesGridFinderParameters", "Java_org_opencv_ml_CvDTree_clear_10", "TIFFClientdata", "_ZN2cv3of26FabMap5PzqGLEibbb", "_ZN2cv3Mat9push_backERKS0_", "_ZN2cv3ocl17KNearestNeighbourC1Ev", "_Z11cvTsConvertPK5CvMatPS_", "_ZN2cv3Mat8copySizeERKS0_", "_ZN2cv5flann11IndexParamsD1Ev", "_ZN6cvtest9readImageERKSsi", "_ZN2cv10BmpEncoderD2Ev", "_ZN7testing15AssertionResultC1ERKS0_", "Java_org_opencv_core_Core_idft_10", "_ZN3Imf9multiViewERNS_6HeaderE", "_ZN2cv16MatConstIterator4seekEPKib", "_ZN17CirclesGridFinder9findHolesEv", "cvFindChessboardCorners", "_ZN2cv15calcBackProjectERKNS_11_InputArrayERKSt6vectorIiSaIiEES2_RKNS_12_OutputArrayERKS3_IfSaIfEEd", "Java_org_opencv_core_Mat_n_1Mat__", "_ZN2cv3SVD7computeERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZNK2cv14RandomizedTree13getPosterior2EPh", "_ZN10CvEMParamsC2Ev", "_ZN2cv11RetinaColor24_adaptiveSpatialLPfilterEPKfPf", "cvUnregisterType", "_ZN3Imf9Attribute21registerAttributeTypeEPKcPFPS0_vE", "_ZN2cv8superres13convertToTypeERKNS_3gpu6GpuMatEiRS2_S5_", "_ZN3Imf7OStreamC2EPKc", "Java_org_opencv_contrib_Contrib_chamerMatching_10", "_ZN3Imf11StdIFStream5tellgEv", "_ZNK2cv14RandomizedTree5writeERSo", "Java_org_opencv_contrib_StereoVar_get_1levels_10", "_ZN2cv6detail12DpSeamFinder14closeToContourEiiRKNS_4Mat_IhEE", "_ZN13CvCalibFilter9SetEtalonE17CvCalibEtalonTypePdiP12CvPoint2D32f", "Java_org_opencv_ml_CvStatModel_delete", "_ZN3Imf7KeyCodeC1Eiiiiiii", "_ZN2cv18WriteStructContextD2Ev", "cvInitSparseMatIterator", "_ZNK10CvKNearest13get_var_countEv", "_ZN2cv9SparseMat5eraseEiiiPj", "_ZN2cv24CvMeanShiftTrackerParamsC2Ei14CvTermCriteria", "_ZN7testing8internal14CmpHelperSTREQEPKcS2_PKwS4_", "Java_org_opencv_objdetect_HOGDescriptor_save_10", "_ZN7testing8internal17TestEventRepeater7ReleaseEPNS_17TestEventListenerE", "__gedf2", "Java_org_opencv_calib3d_Calib3d_solvePnPRansac_11", "_ZN3Imf8addFocusERNS_6HeaderERKf", "_ZN2cv3ocl9sortByKeyERNS0_6oclMatES2_ib", "_ZN12CvFuzzyCurveD2Ev", "jpc_ft_fwdlift_colres", "_ZN23CvFuzzyMeanShiftTrackerC2Ev", "_ZN2cv3ogl9Texture2DC2EiiNS1_6FormatEb", "_ZN2cv3ocl8calcHistERKNS0_6oclMatERS1_", "_ZN2cv15getRowSumFilterEiiii", "_ZN2cv9LaplacianERKNS_11_InputArrayERKNS_12_OutputArrayEiiddi", "Java_org_opencv_core_Core_mulTransposed_11", "Java_org_opencv_imgproc_Subdiv2D_Subdiv2D_11", "_ZN8CvModuleD2Ev", "_ZN2cv32OpponentColorDescriptorExtractorC1ERKNS_3PtrINS_19DescriptorExtractorEEE", "_ZN7testing10TestResult20ValidateTestPropertyERKSsRKNS_12TestPropertyE", "_ZN2cv11WBaseStreamC1Ev", "_Z22cvSortSamplesByClassesPPKfPK5CvMatPiPPKh", "_ZNK10CvKNearest12find_nearestEPK5CvMatiPS0_PPKfS3_S3_", "_Z29cvCreateBlobTrackAnalysisListPFP22CvBlobTrackAnalysisOnevE", "_ZN2cv6Octree9buildNextEj", "_ZN2cv14seqInsertSliceEP5CvSeqiPKv", "_ZN2cv15extractImageCOIEPKvRKNS_12_OutputArrayEi", "cvMorphEpilinesMulti", "_ZN2cv7linemod20ColorGradientPyramid6updateEv", "_ZN2cv3ogl6Buffer11unmapDeviceEv", "Java_org_opencv_features2d_DescriptorExtractor_compute_10", "_ZN3Imf13B44CompressorC1ERKNS_6HeaderEjjb", "_ZN8CvMLDataD2Ev", "_ZN2cv11RNG_MT19937C1Ej", "_ZN2cv12VideoCapture7releaseEv", "_ZN15CvGBTreesParamsC2Ev", "_ZNK2cv3Mat7reshapeEii", "_ZNK2cv12SurfAdjuster5cloneEv", "Java_org_opencv_calib3d_Calib3d_Rodrigues_11", "Java_org_opencv_core_Core_subtract_14", "Java_org_opencv_imgproc_Imgproc_PSNR_10", "Java_org_opencv_features2d_GenericDescriptorMatcher_knnMatch_12", "Java_org_opencv_features2d_FeatureDetector_detect_10", "_ZNK2cv11FileStorageixERKSs", "Java_org_opencv_core_Mat_n_1push_1back", "Java_org_opencv_ml_CvRTParams_get_1term_1crit_10", "_ZN2cv16BaseColumnFilterD1Ev", "_ZN2cv20DTreeBestSplitFinderclERKNS_12BlockedRangeE", "_ZN5CvSVM5clearEv", "_ZN2cv6detail15createWeightMapERKNS_3MatEfRS1_", "_ZN2cv7MomentsC2ERK9CvMoments", "_ZN2cv2EM13decomposeCovsEv", "_ZN2cv17LatentSvmDetector15ObjectDetectionC2Ev", "cvReleaseStereoBMState", "_ZN3Imf14TypedAttributeIN5Imath4Vec2IdEEE13readValueFromERNS_7IStreamEii", "_ZNK2cv10MatOp_GEMM3addERKNS_7MatExprES3_RS1_", "png_set_gamma_fixed", "Java_org_opencv_ml_CvDTreeParams_set_1use_1surrogates_10", "_ZN4perf8TestBase14_declareHelper10iterationsEj", "_ZN2cv9Algorithm3setEPKcb", "_ZN2cv6Mesh3DD1Ev", "_ZN11CvBoostTree24find_surrogate_split_ordEP11CvDTreeNodeiPh", "jpc_tagtree_decode", "TIFFGetWriteProc", "Java_org_opencv_core_Algorithm_setInt_10", "Java_org_opencv_imgproc_Imgproc_pyrMeanShiftFiltering_10", "_ZN3p3p5alignEPA3_ddddddddddS1_Pd", "_ZN2cv14ChamferMatcher8Matching13followContourERNS_3MatERSt6vectorISt4pairIiiESaIS6_EEi", "_ZN2cv16pointPolygonTestERKNS_11_InputArrayENS_6Point_IfEEb", "_ZN2cv9undistortERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_", "_ZN2cv5remapERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_iiRKNS_7Scalar_IdEE", "_ZN2cv9videostab20GaussianMotionFilter6updateEv", "jp2_write_codestream", "_ZN2cv9videostab14StabilizerBase5setUpEiRKNS_3MatE", "Java_org_opencv_calib3d_Calib3d_convertPointsToHomogeneous_10", "_ZN2cv3of29FabMapLUT14getLikelihoodsERKNS_3MatERKSt6vectorIS2_SaIS2_EERS5_INS0_6IMatchESaISA_EE", "Java_org_opencv_calib3d_Calib3d_findHomography_11", "_ZNK2cv18SimpleBlobDetector9findBlobsERKNS_3MatES3_RSt6vectorINS0_6CenterESaIS5_EE", "_ZN7testing8internal6String15ShowWideCStringEPKw", "_ZN2cv5BRISKC1Eiif", "_ZN3Imf14TiledInputFile4DataC1Ebi", "Java_org_opencv_core_Core_bitwise_1and_10", "_ZN2cv10PngDecoderC1Ev", "_ZN6cvtest8BaseTest8safe_runEi", "Java_org_opencv_core_Core_norm_10", "png_set_filter_heuristics_fixed", "_ZN2cv9SparseMat7newNodeEPKij", "jpeg_stdio_dest", "_Z22cvCreateBlobDetectorCCv", "jas_realloc2", "_ZN2cv17CommandLineParser12analyzeValueISsEET_RKSsb", "_ZN2cv10BmpDecoderD1Ev", "_ZN2cv6detail7Blender7prepareENS_5Rect_IiEE", "_ZN2cv3ocl6device3mog22getBackgroundImage_oclEiRKNS0_6oclMatES5_RS3_if", "Java_org_opencv_imgproc_Moments_Moments_10", "_ZNK2cv10MatOp_GEMM9transposeERKNS_7MatExprERS1_", "_ZNK2cv3Mat1tEv", "_ZN2cv10BmpDecoder5closeEv", "_ZNK2cv24BriefDescriptorExtractor5writeERNS_11FileStorageE", "_ZN9CvGBTreesC2Ev", "_ZN2cv3ocl15CvSVMSolver_oclC2EPK11CvSVMParams", "Java_org_opencv_core_Core_mean_11", "Java_org_opencv_features2d_GenericDescriptorMatcher_radiusMatch_13", "_ZN2cv14ChamferMatcher8Matching26fillNonContourOrientationsERNS_3MatES3_", "Java_org_opencv_core_Mat_n_1colRange", "Java_org_opencv_core_Mat_n_1rowRange", "_ZN2cv21calcGlobalOrientationERKNS_11_InputArrayES2_S2_dd", "_ZN7CvImage4loadEPKcS1_i", "_TIFFDataSize", "_ZN3Imf11ChannelList11findChannelERKSs", "_ZN2cv9StereoVar17VariationalSolverERNS_3MatES2_S2_S2_i", "_Z34cvCreateModuleBlobTrackAnalysisIORv", "_ZN2cv3ocl19buildWarpAffineMapsERKNS_3MatEbNS_5Size_IiEERNS0_6oclMatES7_", "_ZNK2cv11TiffEncoder10newEncoderEv", "_ZN2cv3ocl9minMaxLocERKNS0_6oclMatEPdS4_PNS_6Point_IiEES7_S3_", "_ZN2cv3ocl26BruteForceMatcher_OCL_baseC1ENS1_8DistTypeE", "Java_org_opencv_ml_CvSVM_train_1auto_11", "_ZN2cv12RMByteStreamD2Ev", "_ZN2cveqERKNS_3MatEd", "_ZN2cv3ocl23StereoBeliefPropagationclERKNS0_6oclMatERS2_", "_ZN2cv3ocl26BruteForceMatcher_OCL_base8knnMatchERKNS0_6oclMatES4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEiS4_b", "_ZN16CvBlobDetectorCCD0Ev", "Java_org_opencv_features2d_DescriptorMatcher_match_11", "_ZN2cv12completeSymmERKNS_12_OutputArrayEb", "_ZN2cv15BriskScaleSpace16constructPyramidERKNS_3MatE", "_ZN10CvKNearest5clearEv", "_ZN2cv23OneWayDescriptorMatcherD0Ev", "jpc_pi_destroy", "_ZN2cv12VideoCaptureC1Ev", "_Z25icvCvt_BGRA2BGR_16u_C4C3RPKtiPti6CvSizei", "_ZN10CvVSModule7IsParamEPKc", "_ZN7testing8internal12UnitTestImpl24ConfigureStreamingOutputEv", "_ZN2cv5writeERNS_11FileStorageERKSsd", "cvLSHAdd", "_ZN7testing16AssertionFailureEv", "jas_getdbglevel", "png_write_IHDR", "Java_org_opencv_gpu_DeviceInfo_freeMemory_10", "_ZThn4_NK2cv5BRISK14descriptorTypeEv", "Java_org_opencv_imgproc_Imgproc_getStructuringElement_11", "Java_org_opencv_core_Mat_n_1delete", "_ZN3Iex7BaseExcD2Ev", "_ZTv0_n24_NK2cv20FastFeatureDetector24infoEv", "png_set_text_compression_strategy", "_ZN5CvSVMC2ERKN2cv3MatES3_S3_S3_11CvSVMParams", "Java_org_opencv_imgproc_Imgproc_dilate_10", "_ZN2cv11RQDecomp3x3ERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_S5_S5_", "_ZN2cv11RetinaColorD2Ev", "__gnu_Unwind_Restore_VFP_D_16_to_31", "_ZNK3Imf14TypedAttributeIN5Imath4Vec3IfEEE12writeValueToERNS_7OStreamEi", "_ZNK3Imf6Header8channelsEv", "_ZNK2cv15RTreeClassifier5writeEPKc", "_ZNK2cv13Jpeg2KEncoder17isFormatSupportedEi", "cvTreeToNodeSeq", "_ZNK2cv13HOGDescriptor17checkDetectorSizeEv", "Java_org_opencv_ml_CvANN_1MLP_delete", "cvCreateFGDStatModel", "_ZN2cv3ogl9Texture2D6createEiiNS1_6FormatEb", "_ZThn4_NK2cv5BRISK11computeImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZN2cv12_OutputArrayC1ERKNS_3MatE", "TIFFInitCCITTRLE", "_ZN2cv12FilterEngineD2Ev", "_ZN2cv17ParvoRetinaFilter31setOPLandParvoFiltersParametersEffffff", "_ZN2cv3ocl20FarnebackOpticalFlow23updateFlow_gaussianBlurERKNS0_6oclMatES4_RS2_S5_S5_S5_ib", "_ZN3Imf11StdOFStreamC1EPKc", "_ZN2cv21find4QuadCornerSubpixERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEE", "_ZNK2cv7linemod18DepthNormalPyramid15extractTemplateERNS0_8TemplateE", "_ZN7testing8internal14ShouldUseColorEb", "_ZN2cv17MagnoRetinaFilterC1Ejj", "Java_org_opencv_ml_CvDTreeParams_set_1min_1sample_1count_10", "_ZN2cv3ocl26createMorphologyFilter_GPUEiiRKNS_3MatERKNS_6Point_IiEEi", "_ZN2cv15getLinearFilterEiiRKNS_11_InputArrayENS_6Point_IiEEdi", "_ZN2cv3ocl8multiplyERKNS0_6oclMatES3_RS1_d", "jas_cmxform_apply", "png_write_gAMA_fixed", "_ZN2cv3of26FabMap3addERKNS_3MatE", "cvEstimateTransProb", "_ZN5CvSVM5trainEPK5CvMatS2_S2_S2_11CvSVMParams", "_ZN17FaceDetectionList7GetDataEv", "__eqsf2", "Java_org_opencv_ml_CvSVMParams_get_1svm_1type_10", "Java_org_opencv_calib3d_Calib3d_calibrateCamera_12", "cvKMeans2", "_ZN21DetectionBasedTracker10ParametersC1Ev", "_ZN2cv16SunRasterEncoderD2Ev", "_ZN2cv3PCAC1ERKNS_11_InputArrayES3_ii", "Java_org_opencv_core_Core_randn_10", "_Z21cvCombineResponseMapsP5CvMatPKS_S0_PS0_", "_ZN2cv3ocl24OpticalFlowDual_TVL1_OCLclERKNS0_6oclMatES4_RS2_S5_", "_ZN2cv25decomposeProjectionMatrixERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_S5_S5_S5_S5_", "_ZN7testing8internal37FormatCompilerIndependentFileLocationEPKci", "_ZN2cv3of29FabMapFBOC2ERKNS_3MatEddiiddii", "jpc_qmfb_split_row", "_ZN2cv8calcHistERKNS_11_InputArrayERKSt6vectorIiSaIiEES2_RKNS_12_OutputArrayES7_RKS3_IfSaIfEEb", "_ZN2cv3Mat9adjustROIEiiii", "_ZN6cvtest7loadMatERKN2cv3MatEb", "_ZN2cv10BriskLayerC1ERKS0_i", "_ZN7testing8internal18FormatFileLocationEPKci", "Java_org_opencv_calib3d_Calib3d_reprojectImageTo3D_11", "_ZN9IlmThread10ThreadPoolD0Ev", "_ZN2cv3ocl9CvSVM_OCLC2Ev", "_ZN2cvmiERKNS_7MatExprERKNS_7Scalar_IdEE", "_ZN2cv15LogPolar_InterpD1Ev", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection8getImageEi", "_ZNK2cv2EM7predictERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv15RTreeClassifier4readERSi", "png_do_write_swap_alpha", "_ZNK8CvRTrees7predictERKN2cv3MatES3_", "cvConDensInitSampleSet", "_ZN8CvMatrix4showEPKc", "_ZNK2cv16MatConstIterator3posEPi", "_ZN2cv11VideoWriter5writeERKNS_3MatE", "_ZN9IlmThread9TaskGroup4DataD2Ev", "_ZN2cv5splitERKNS_3MatERSt6vectorIS0_SaIS0_EE", "TIFFError", "_ZN2cv8Stitcher6stitchERKNS_11_InputArrayERKSt6vectorIS4_INS_5Rect_IiEESaIS6_EESaIS8_EERKNS_12_OutputArrayE", "_ZN2cv7linemod20ColorGradientPyramidC1ERKNS_3MatES4_fjf", "_ZN2cvmiERKNS_3MatES2_", "_ZN2cv16SunRasterDecoderD2Ev", "_ZN2cv3ocl10DeviceInfoD2Ev", "_ZN2cv15calcCovarMatrixEPKNS_3MatEiRS0_S3_ii", "cvSetAdd", "_ZN3Imf10CompressorC2ERKNS_6HeaderE", "_ZN2cv13Jpeg2KEncoder17writeComponent16uEPvRKNS_3MatE", "_ZN2cv15RTreeClassifier5trainERKSt6vectorINS_12BaseKeypointESaIS2_EERNS_3RNGERNS_14PatchGeneratorEiiiji", "_ZN10CvVSModule12CommentParamEPKcS1_", "_ZN2cv15NAryMatIteratorC1Ev", "_ZN2cv16OneWayDescriptor19GenerateSamplesFastEP9_IplImageP5CvMatS4_PS0_", "_ZN2cv3ocl23OclCascadeClassifierBuf4InitEiidiiPKj6CvSizeS4_", "_ZN2cv16CvFeatureTracker17getTrackingCenterEv", "_ZN3Imf14TypedAttributeIN5Imath4Vec3IiEEE13readValueFromERNS_7IStreamEii", "_ZNK2cv7linemod18DepthNormalPyramid8quantizeERNS_3MatE", "Java_org_opencv_imgproc_Moments_set_1nu03_10", "_ZN2cv11RBaseStream5closeEv", "_ZNK5CvSVM7predictEPK5CvMatPS0_", "_ZN2cv21getStructuringElementEiNS_5Size_IiEENS_6Point_IiEE", "_ZNK8CvMLData20get_train_sample_idxEv", "_ZN21FaceDetectionListElemD1Ev", "_ZN2cv3gpu9convertToERKNS0_6GpuMatERS1_", "_ZN3Imf15envmapAttributeERNS_6HeaderE", "_ZN2cv3RNG8gaussianEd", "_ZN2cv6detail12DpSeamFinderC2ENS1_12CostFunctionE", "_ZNK2cv15RTreeClassifier18getSparseSignatureEP9_IplImagePff", "_ZN2cv6Mesh3DC2Ev", "_ZN2cv3ocl8subtractERKNS0_6oclMatES3_RS1_S3_", "cvSetTrackbarMax", "cvInitPerspectiveTransform", "cvFindType", "_ZN3Imf13PizCompressorD0Ev", "_ZN8CvMLDataC1Ev", "jas_stream_flushbuf", "Java_org_opencv_video_BackgroundSubtractorMOG2_BackgroundSubtractorMOG2_10", "cvSetImagesForHaarClassifierCascade", "TIFFRGBAImageGet", "cvSobel", "TIFFIsBigEndian", "jinit_1pass_quantizer", "_ZN4CvEMD0Ev", "_ZN2cv3oclanERKNS0_6oclMatES3_", "_ZN2cv10PxMDecoder10readHeaderEv", "cvPointSeqFromMat", "_ZN11CvBoostTreeD0Ev", "_ZN2cv3ogl6Buffer6unbindENS1_6TargetE", "cvGrabFrame", "_ZN12CvFuzzyCurveD1Ev", "_ZNK2cv3Mat11checkVectorEiib", "png_get_y_offset_microns", "Java_org_opencv_core_Core_batchDistance_11", "_ZN2cv9videostab24estimateOptimalTrimRatioERKNS_3MatENS_5Size_IiEE", "_ZN2cv7MomentsC1Ev", "_ZNK2cv11_InputArray4kindEv", "_ZN2cv3ocl12ProgramCacheC2Ev", "_ZN7testing8internal12UnitTestImpl23ListTestsMatchingFilterEv", "_ZN2cv8eigen2x2EPKfPfi", "_ZN7testing8internal17TestEventRepeater16OnTestPartResultERKNS_14TestPartResultE", "_ZN2cv8internal15IntrinsicParams4InitERKNS_3VecIdLi2EEES5_RKNS2_IdLi4EEERKd", "_ZN2cv6detail15FeaturesMatcherclERKSt6vectorINS0_13ImageFeaturesESaIS3_EERS2_INS0_11MatchesInfoESaIS8_EERKNS_3MatE", "_ZN3Imf17commentsAttributeERKNS_6HeaderE", "png_set_cHRM_XYZ", "Java_org_opencv_calib3d_Calib3d_triangulatePoints_10", "icvComputeCoeffForStereo", "_ZN7CvBoostD1Ev", "_ZNK2cv12FilterEngine19remainingOutputRowsEv", "_ZN6cvtest13printCudaInfoEv", "TIFFNumberOfStrips", "Java_org_opencv_core_Core_ellipse_13", "Java_org_opencv_imgproc_Imgproc_warpAffine_11", "_ZN17CirclesGridFinder7SegmentC2EN2cv6Point_IfEES3_", "_ZN2cv17BasicRetinaFilter23_spatiotemporalLPfilterEPKfPfj", "jas_memdump", "LogL10fromY", "icvSubdiv2DCheck", "_ZN7testing8internal17StreamingListener9UrlEncodeEPKc", "_ZNK2cv16SunRasterDecoder10newDecoderEv", "Java_org_opencv_calib3d_StereoSGBM_get_1speckleWindowSize_10", "nonMaximumSuppression", "_ZN2cv3of26FabMap5PeqGLEibb", "Java_org_opencv_imgproc_Imgproc_sepFilter2D_10", "cvGetDimSize", "_ZN2cv3gpu11TargetArchs20hasEqualOrGreaterPtxEii", "_ZN2cv10StereoSGBMD0Ev", "_ZN24CvBlobTrackPredictKalman6UpdateEP6CvBlob", "_ZNK2cv10BOWTrainer17descripotorsCountEv", "_ZN2cv3ogl6Arrays7releaseEv", "cvSolvePoly", "Java_org_opencv_ml_CvParamGrid_set_1step_10", "_ZN16CvDTreeTrainDataD0Ev", "_ZN2cv21FernDescriptorMatcherD2Ev", "_ZN2cv6detail18GraphCutSeamFinder4Impl10findInPairEjjNS_5Rect_IiEE", "_ZN7testing18TestEventListeners23SuppressEventForwardingEv", "_ZN2cv15CvHybridTracker13updateTrackerENS_3MatE", "jpc_mqdec_init", "_ZN2cv9GlTexture7releaseEv", "_ZN2cv12RetinaFilter15clearAllBuffersEv", "cvEllipse2Poly", "__divdf3", "_ZNK8CvMLData13get_delimiterEv", "_ZN2cv13bsIsBigEndianEv", "_ZN2cv8GlBufferC1ENS_5Size_IiEEiNS0_5UsageE", "_ZN2cv3ocl26BruteForceMatcher_OCL_base15knnMatchConvertERKNS_3MatES4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "_ZN4perf8TestBase9stopTimerEv", "_ZNK7testing10TestResult18HasNonfatalFailureEv", "_ZN7testing8internal24XmlUnitTestResultPrinter16PrintXmlTestCaseEPSoRKNS_8TestCaseE", "jinit_marker_writer", "_ZN10CvVSModule11GetTypeNameEv", "_ZN7testing8TestInfoC1ERKSsS2_PKcS4_PKvPNS_8internal15TestFactoryBaseE", "_ZN2cv3of29FabMapFBO17bennettInequalityEddd", "png_free_data", "_ZNK2cv9TickMeter12getTimeMilliEv", "_ZN7testing4Test14RecordPropertyERKSsi", "jpc_enc_encodetiledata", "_ZN8CvRTrees10calc_errorEP8CvMLDataiPSt6vectorIfSaIfEE", "_ZN2cv3ocl5SobelERKNS0_6oclMatERS1_iiiiddi", "Java_org_opencv_ml_CvRTrees_train_10", "Java_org_opencv_features2d_DescriptorMatcher_radiusMatch_13", "Java_org_opencv_contrib_StereoVar_get_1lambda_10", "_ZN2cv12useOptimizedEv", "cvMoments", "_ZN2cv9AlgorithmC2Ev", "_ZN2cv15CvHybridTracker21getGaussianProjectionENS_3MatEidNS_6Point_IfEE", "_ZNK2cv14FernClassifier20getCompressionMethodEv", "_ZN13CvCalibFilter15SetCameraParamsEP8CvCamera", "_ZN7testing8TestInfoC2ERKSsS2_PKcS4_PKvPNS_8internal15TestFactoryBaseE", "_ZN2cv5phaseERKNS_11_InputArrayES2_RKNS_12_OutputArrayEb", "_ZN2cv8superres15SuperResolution14collectGarbageEv", "cvDrawChessboardCorners", "Java_org_opencv_core_Core_getNumThreads_10", "_ZN2cv3Mat6createEiPKii", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow11extractInfoEP9_IplImageS2_b", "_ZN13CvCalibFilter16SaveCameraParamsEPKc", "_ZN2cv13Jpeg2KEncoder16writeComponent8uEPvRKNS_3MatE", "_ZN2cv21FernDescriptorMatcher15isMaskSupportedEv", "_ZNK2cv9LDetectorclERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EEib", "_ZN2cv6detail12DpSeamFinder12computeCostsERKNS_3MatES4_NS_6Point_IiEES6_iRNS_4Mat_IfEES9_", "jpc_enc_enccblks", "_ZNK3Imf11FrameBufferixEPKc", "_ZN2cv3gpu6GpuMatC2EiiiPvj", "_ZN2cv11RBaseStream8isOpenedEv", "_Z19ChoiceTrackingFace2P13CvFaceTrackeriPK13CvFaceElementP14CvTrackingRectRii", "_ZN2cv8Stitcher15composePanoramaERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv14ChamferMatcher8Template20getTemplateAddressesEi", "cvQueryFrame", "jas_image_writecmpt", "png_get_bKGD", "jpeg_input_complete", "_ZN2cv8clipLineENS_5Rect_IiEERNS_6Point_IiEES4_", "_ZNK17CirclesGridFinder9drawBasisERKSt6vectorIN2cv6Point_IfEESaIS3_EES3_RNS1_3MatE", "_ZN9CvERTreesD2Ev", "_ZN3Imf7capDateERNS_6HeaderE", "_ZN3Imf8TimeCodeC1ERKS0_", "Java_org_opencv_highgui_Highgui_imread_11", "_ZNK7CvDTree5writeEP13CvFileStorage", "_ZN7testing14ExitedWithCodeC2Ei", "_ZN2cv6detail19ExposureCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_3MatESaIS9_EESD_", "cvCreateMatHeader", "_ZN3Imf14chromaticitiesERNS_6HeaderE", "_ZN2cv3ocl9CvSVM_OCLC2ERKNS_3MatES4_S4_S4_11CvSVMParams", "_ZN2cv3of26FabMap7compareERKSt6vectorINS_3MatESaIS3_EES7_RS2_INS0_6IMatchESaIS8_EERKS3_", "_ZN2cv25BOWImgDescriptorExtractor13setVocabularyERKNS_3MatE", "cvCartToPolar", "Java_org_opencv_imgproc_Subdiv2D_edgeDst_10", "_ZN3Imf6Header8channelsEv", "_ZN3Imf13addWorldToNDCERNS_6HeaderERKN5Imath8Matrix44IfEE", "_ZN2cv17BasicRetinaFilter36runFilter_LocalAdapdation_autonomousERKSt8valarrayIfERS2_", "_ZNK7testing10TestResult15HasFatalFailureEv", "_ZN2cv3ocl13matchTemplateERKNS0_6oclMatES3_RS1_i", "_ZN2cv3ocl5canny17calcMagnitude_gpuERKNS0_6oclMatES4_RS2_iib", "_ZN2cv10StereoSGBMclERKNS_11_InputArrayES3_RKNS_12_OutputArrayE", "_ZN2cv9StereoVarclERKNS_3MatES3_RS1_", "_ZN2cv3of27FabMap210addToIndexERKNS_3MatERSt6vectorIdSaIdEERSt3mapIiS5_IiSaIiEESt4lessIiESaISt4pairIKiSB_EEE", "_ZN2cv19DescriptorExtractorD1Ev", "_ZN8CvRTreesC2Ev", "_ZN2cv3ocl6oclMatpLERKS1_", "_ZN24CvBlobTrackPredictKalman7PredictEv", "_ZN2cv9videostab26PyrLkRobustMotionEstimatorC1Ev", "Java_org_opencv_imgproc_Moments_get_1nu03_10", "_ZN2cv11VideoWriterC1Ev", "Java_org_opencv_ml_CvRTrees_predict_10", "Java_org_opencv_imgproc_Imgproc_getRotationMatrix2D_10", "_ZN2cv24GenericDescriptorMatcherD0Ev", "_Z21cvReleaseBlobDetectorPP14CvBlobDetector", "_ZN3Imf14ownerAttributeERKNS_6HeaderE", "_ZN2cv6detail23calibrateRotatingCameraERKSt6vectorINS_3MatESaIS2_EERS2_", "Java_org_opencv_imgproc_Imgproc_filter2D_12", "cvGetOptimalDFTSize", "_ZN9CvLevMarqC1Ev", "Java_org_opencv_objdetect_HOGDescriptor_get_1winSize_10", "Java_org_opencv_core_Mat_n_1assignTo__JJ", "Java_org_opencv_core_Core_batchDistance_12", "_ZN7CvDTree15free_prune_dataEb", "png_write_destroy", "_ZNK7testing8UnitTest18ad_hoc_test_resultEv", "cvGetWindowHandle", "_ZN2cv3ocl26BruteForceMatcher_OCL_base12matchConvertERKNS_3MatES4_RSt6vectorINS_6DMatchESaIS6_EE", "Java_org_opencv_ml_CvBoostParams_set_1weight_1trim_1rate_10", "_ZN2cv10ExrDecoder9UpSampleYEPhiii", "png_init_read_transformations", "__gnu_Unwind_Resume_or_Rethrow", "_ZN2cv3MatC1ERKS0_PKNS_5RangeE", "_ZN2cv20FastFeatureDetector2C1Eibi", "_ZTv0_n24_NK2cv26GridAdaptedFeatureDetector4infoEv", "_ZN2cv3ocl6oclMat8createExEiiiNS0_8DevMemRWENS0_10DevMemTypeE", "_ZN2cv3maxERKNS_3MatEdRS0_", "_ZN3Imf14TypedAttributeIN5Imath8Matrix44IfEEE14staticTypeNameEv", "_TIFFRewriteField", "_ZN2cv3ocl4normERKNS0_6oclMatES3_i", "Java_org_opencv_core_Core_divide_13", "_ZN7CvBoost10calc_errorEP8CvMLDataiPSt6vectorIfSaIfEE", "_ZN2cv17BasicRetinaFilterD2Ev", "Java_org_opencv_imgproc_Moments_set_1mu12_10", "Java_org_opencv_core_Algorithm_paramType_10", "_ZN3Imf13RleCompressorC1ERKNS_6HeaderEj", "_ZN2cv12RetinaFilter17runLMSToneMappingERKSt8valarrayIfERS2_bff", "png_do_expand_16", "Java_org_opencv_ml_EM_predict_11", "_ZN2cv18CvMeanShiftTracker17getTrackingCenterEv", "jpc_qmfb_join_colres", "_ZN3Imf14TypedAttributeINS_14ChromaticitiesEE14staticTypeNameEv", "_ZN2cv5BRISKC2Eiif", "_ZN3Imf11StdIFStreamC1EPKc", "_ZN2cv8StereoBMC2Ev", "_ZN23CvFuzzyMeanShiftTracker12FuzzyResizer10calcOutputEdd", "Java_org_opencv_core_Core_reduce_11", "_ZTv0_n12_N2cv5BRISKD1Ev", "_ZN3Imf14adoptedNeutralERKNS_6HeaderE", "_ZNK2cv9SparseMat9convertToERNS_3MatEidd", "_ZN2cv17BasicRetinaFilter18runFilter_LPfilterERKSt8valarrayIfEj", "_ZNK2cv12VideoCapture8isOpenedEv", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRSsbMS1_FSsvEMS1_FvRKSsES9_", "jpc_pchglist_insert", "cvCalcCovarMatrixEx", "_ZN7testing8internal12UnitTestImpl32SuppressTestEventsIfInSubprocessEv", "_ZN7testing8internal13PrintStringToERKSsPSo", "_ZN2cv20OneWayDescriptorBase18SavePCADescriptorsEPKc", "_ZN2cv6detail12DisjointSets17createOneElemSetsEi", "_Z21searchObjectThresholdPK20CvLSVMFeaturePyramidPPK18CvLSVMFilterObjectifiifPP7CvPointPPiS9_PPfPS8_i", "_ZN2cv13HaarEvaluatorD2Ev", "_Z24thresholdFunctionalScorePPK18CvLSVMFilterObjectiPK20CvLSVMFeaturePyramidfiifPPfPP7CvPointPPiSB_PSA_", "_ZN2cv5eigenERKNS_11_InputArrayERKNS_12_OutputArrayES5_ii", "_ZN3Imf18multiViewAttributeERKNS_6HeaderE", "Java_org_opencv_imgproc_Moments_get_1m03_10", "_ZN2cv6detail20BundleAdjusterReproj9calcErrorERNS_3MatE", "_ZNK2cv12GFTTDetector4infoEv", "Java_org_opencv_video_BackgroundSubtractor_apply_11", "cvAcc", "_ZN7testing10TestResultD2Ev", "_ZN7testing8internal29ParseInternalRunDeathTestFlagEv", "png_read_data", "_ZN2cv12HOGEvaluator8setImageERKNS_3MatENS_5Size_IiEE", "_ZNK9CvERTrees7getNameEv", "Java_org_opencv_imgproc_Moments_get_1m10_10", "cvEllipse", "_ZN2cv3ocl17interpolateFramesERKNS0_6oclMatES3_S3_S3_S3_S3_fRS1_S4_", "Java_org_opencv_ml_CvKNearest_CvKNearest_12", "_ZTv0_n24_NK2cv5BRISK4infoEv", "cvReleaseVideoWriter", "_Z21cvTestSeqGetObjectNumPv", "_ZNK2cv5MatOp3addERKNS_7MatExprERKNS_7Scalar_IdEERS1_", "_ZN2cv11RBaseStream6getPosEv", "_ZNK7CvBoost8get_dataEv", "_ZN10CvVSModule9SaveStateEP13CvFileStorage", "_ZN2cv9HuMomentsERKNS_7MomentsEPd", "Java_org_opencv_imgproc_Imgproc_HoughCircles_10", "_ZN2cv3ogl6Arrays16resetNormalArrayEv", "Java_org_opencv_features2d_DescriptorExtractor_descriptorType_10", "_ZN3Imf11addLatitudeERNS_6HeaderERKf", "_ZN2cv11JpegDecoder10readHeaderEv", "_ZN3Imf17apertureAttributeERKNS_6HeaderE", "_ZN3Imf17ScanLineInputFile10readPixelsEi", "jas_stream_seek", "_ZN2cv15getCopyMaskFuncEj", "_ZN2cv6detail18SurfFeaturesFinder4findERKNS_3MatERNS0_13ImageFeaturesE", "Java_org_opencv_core_Mat_n_1isContinuous", "_ZN2cv17BasicRetinaFilter23_horizontalCausalFilterEPfjj", "_ZN2cv17FlannBasedMatcher3addERKSt6vectorINS_3MatESaIS2_EE", "_ZN14CvBlobTrackSeq16DelBlobTrackByIDEi", "_ZN2cv21FernDescriptorMatcher15radiusMatchImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEfRKS4_IS1_SaIS1_EEb", "_ZNK2cv3ORB14descriptorTypeEv", "cvSetReal3D", "cvSumPixels", "_ZN2cv14ChamferMatcher9showMatchERNS_3MatENS0_5MatchE", "_ZNK2cv25BOWImgDescriptorExtractor14descriptorSizeEv", "_ZNK2cv9Algorithm12getAlgorithmERKSs", "_ZN6cvtest9randomMatERN2cv3RNGERKSt6vectorIiSaIiEEiddb", "_ZN11CvBoostTreeC2Ev", "_ZN2cv3ocl9transposeERKNS0_6oclMatERS1_", "_ZNK3Imf8TimeCode9dropFrameEv", "Java_org_opencv_calib3d_StereoSGBM_get_1minDisparity_10", "_ZN12CvForestTreeD0Ev", "_ZN7CvDTree18get_var_importanceEv", "_ZN13CvBlobTracker11SetBlobByIDEiP6CvBlob", "cvPtrND", "_Z15cvCreateTestSeqPcPS_ifid", "_ZN2cv6KDTree5buildERKNS_11_InputArrayEb", "_ZN2cv14RandomizedTree13getPosterior2EPh", "jpc_tsfb_synthesize2", "cvStopLoop", "_ZN2cv15FeatureDetectorD0Ev", "_ZN2cv6detail18GraphCutSeamFinderC1Eiff", "_ZN2cv12resizeWindowERKSsii", "_ZN2cv9minMaxIdxERKNS_11_InputArrayEPdS3_PiS4_S2_", "_ZN2cv24GenericDescriptorMatcher18KeyPointCollection5clearEv", "_ZN2cv3PtrINS_3ogl6Buffer4ImplEE10delete_objEv", "_ZN2cv13LevMarqSparse12bundleAdjustERSt6vectorINS_7Point3_IdEESaIS3_EERKS1_IS1_INS_6Point_IdEESaIS8_EESaISA_EERKS1_IS1_IiSaIiEESaISG_EERS1_INS_3MatESaISL_EESO_SO_SO_RKNS_12TermCriteriaEPFbidPvESS_", "_Z26vector_vector_Point_to_MatRSt6vectorIS_IN2cv6Point_IiEESaIS2_EESaIS4_EERNS0_3MatE", "Java_org_opencv_video_KalmanFilter_delete", "_ZN16CvTrainTestSplitC2Eib", "_ZN6cvtest9dumpImageERKSsRKN2cv3MatE", "_ZNK2cv8FileNodeixERKSs", "jpc_pow2i", "_ZN2cv11RNG_MT199374seedEj", "_ZN10CvVSModule8AddParamEPKcPi", "jas_image_copy", "Java_org_opencv_imgproc_Moments_set_1m01_10", "_ZN7testing8internal20SingleFailureCheckerD1Ev", "_ZN2cv5flann20CompositeIndexParamsC1EiiiN7cvflann20flann_centers_init_tEf", "_ZNK2cv7linemod11DepthNormal11processImplERKNS_3MatES4_", "_ZN11CvBoostTreeC1Ev", "_ZN2cv9videostab17TwoPassStabilizer9resetImplEv", "_ZN2cv8filter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEdi", "_ZN2cv24BriefDescriptorExtractorC1Ei", "_ZN3p3p5solveEPA3_dPddddddddddddddddddddd", "_ZN6cvtest15checkSimilarityERKN2cv11_InputArrayES3_", "_ZN3GMMC2ERN2cv3MatE", "TIFFVGetField", "_ZN2cvmlERKNS_7MatExprERKNS_3MatE", "jpeg_CreateDecompress", "_ZN7Sampler8getpixelEii", "_ZN2cv15CvHybridTracker17getTrackingWindowEv", "_ZN2cv13BaseRowFilterC2Ev", "_ZN7CvImage4readEP13CvFileStoragePKcS3_", "Java_org_opencv_features2d_DescriptorMatcher_isMaskSupported_10", "_ZN2cv10ExrDecoder8readDataERNS_3MatE", "_ZN7testing8internal27PrettyUnitTestResultPrinter11OnTestStartERKNS_8TestInfoE", "cvGetQuadrangleSubPix", "cvRANSACUpdateNumIters", "_ZN13CvBoostParamsC1Ev", "Java_org_opencv_calib3d_StereoSGBM_get_1SADWindowSize_10", "Java_org_opencv_ml_CvNormalBayesClassifier_train_10", "_ZN2cv16GeneralizedHough7releaseEv", "png_warning_parameter_signed", "_ZN2cv16BaseImageEncoderC2Ev", "_ZN2cv3ocl5canny25edgesHysteresisGlobal_gpuERNS0_6oclMatES3_S3_S3_ii", "jpc_tagtree_copy", "_ZN2cv7linemod8Detector20addSyntheticTemplateERKSt6vectorINS0_8TemplateESaIS3_EERKSs", "_ZN9CvGBTrees5trainEPK5CvMatiS2_S2_S2_S2_S2_15CvGBTreesParamsb", "_ZN16CvTrainTestSplitC1Efb", "_ZNK10CvKNearest13is_regressionEv", "_ZN2cv3oclplERKNS0_6oclMatES3_", "_ZN20CvBlobDetectorSimpleC1Ev", "cvVoronoiDiagramFromImage", "_ZN3Imf13B44Compressor10uncompressEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "__fixunssfsi", "_ZN3Imf14lineBufferMinYEiii", "Java_org_opencv_core_Core_norm_13", "_ZN2cv12getTickCountEv", "_ZNK2cv3gpu10DeviceInfo10freeMemoryEv", "cvNormalize", "Java_org_opencv_core_Core_ellipse_10", "Java_org_opencv_gpu_DeviceInfo_isCompatible_10", "_ZN2cv5flann11IndexParams12setAlgorithmEi", "png_set_alpha_mode_fixed", "_ZN2cv3ocl6oclMat6uploadERKNS_3MatE", "_ZN6cvtest2TSC1Ev", "_Znwj", "cvCalcArrHist", "_Z26cvCreateBlobTrackerOneMSPFv", "_ZN22CameraWrapperConnector10disconnectEPPv", "cvPreWarpImage", "cvInRange", "_ZN2cv10BOWTrainerD2Ev", "_ZNK2cv14SpinImageModel16repackSpinImagesERKSt6vectorIhSaIhEERNS_3MatEb", "_ZN2cv9transposeERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv20BackgroundSubtractorclERKNS_11_InputArrayERKNS_12_OutputArrayEd", "_ZNK3Imf11ChannelListeqERKS0_", "_ZN2cv3ocl13HOGDescriptor16detectMultiScaleERKNS0_6oclMatERSt6vectorINS_5Rect_IiEESaIS7_EEdNS_5Size_IiEESC_di", "_ZN3Imf8commentsERNS_6HeaderE", "_ZN2cv12LBPEvaluatorD2Ev", "jas_cmxform_destroy", "jpc_initluts", "cvGetHuMoments", "Java_org_opencv_ml_CvGBTrees_train_11", "Java_org_opencv_calib3d_StereoSGBM_set_1minDisparity_10", "_ZN2cv8imdecodeERKNS_11_InputArrayEi", "icvProjectPointToImage", "_ZN3Imf10worldToNDCERKNS_6HeaderE", "_ZN12ocl_tvl1flow21estimateDualVariablesERN2cv3ocl6oclMatES3_S3_S3_S3_S3_f", "Java_org_opencv_core_Core_putText_11", "_ZN2cv8multiplyERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi", "_ZN2cv17BasicRetinaFilterC1Ejjjb", "_ZN2cv14FernClassifier5clearEv", "_ZNK4CvEM8get_covsEv", "cvWarpPerspective", "_ZN2cv12RLByteStream7getWordEv", "_ZNK2cv6Octree21getPointsWithinSphereERKNS_7Point3_IfEEfRSt6vectorIS2_SaIS2_EE", "_ZN2cv16BOWKMeansTrainerD0Ev", "_ZN2cv8superres12arrGetGpuMatERKNS_11_InputArrayERNS_3gpu6GpuMatE", "Java_org_opencv_contrib_StereoVar_set_1nIt_10", "_ZNK2cv3gpu10DeviceInfo12isCompatibleEv", "_ZN2cv16BaseColumnFilterD0Ev", "_ZN2cv3ocl15CvSVMSolver_ocl12get_row_baseEiPbRNS_3MatE", "_ZN3Imf14TypedAttributeIN5Imath8Matrix44IdEEE13readValueFromERNS_7IStreamEii", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection12getKeypointsEi", "_ZN2cv20OneWayDescriptorBase5clearEv", "_ZN2cvdvERKNS_7MatExprEd", "Java_org_opencv_core_Core_transpose_10", "_ZN15CvOpenGlFuncTabD1Ev", "_ZN6cvtest8showDiffERKN2cv11_InputArrayES3_d", "_ZN22CvAdaptiveSkinDetector8initDataEP9_IplImageii", "jpc_enc_destroy", "png_convert_from_struct_tm", "png_set_gamma", "Java_org_opencv_ml_CvGBTrees_delete", "_ZN2cv3ocl13HOGDescriptor14setSVMDetectorERKSt6vectorIfSaIfEE", "__gnu_thumb1_case_si", "_ZN2cv8solvePnPERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_bi", "__gesf2", "_ZN2cv23BackgroundSubtractorMOGC1Eiidd", "Java_org_opencv_calib3d_StereoSGBM_set_1preFilterCap_10", "_ZNSt9exceptionD0Ev", "_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE", "_ZN7testing8internal8GTestLogD2Ev", "_ZNK2cv24BackgroundSubtractorMOG218getBackgroundImageERKNS_12_OutputArrayE", "_ZN2cv14FaceRecognizer6updateERKNS_11_InputArrayES3_", "_ZN2cv3ocl12GaussianBlurERKNS0_6oclMatERS1_NS_5Size_IiEEddi", "_ZN2cv4LBPH6updateERKNS_11_InputArrayES3_", "_ZN2cvleEdRKNS_3MatE", "jas_stream_freopen", "_ZN2cv3ocl13HOGDescriptor23getPeopleDetector64x128Ev", "_ZN2cv8Stitcher6stitchERKNS_11_InputArrayERKNS_12_OutputArrayE", "Java_org_opencv_imgproc_Imgproc_blur_12", "_ZN2cv8superres22createOptFlow_DualTVL1Ev", "_ZN6cvtest2TS16get_file_storageEv", "_ZN2cv4globESsRSt6vectorISsSaISsEEb", "_ZN2cv19getConvertScaleFuncEii", "Java_org_opencv_core_Core_line_11", "_ZN2cv14FernClassifierC1ERKNS_8FileNodeE", "_ZN2cv7momentsERKNS_11_InputArrayEb", "_ZN2cv3ocl7pyrDownERKNS0_6oclMatERS1_", "_ZN2cv11RBaseStream4openERKNS_3MatE", "_ZN2cv14FernClassifier7prepareEiiiiiii", "Java_org_opencv_ml_CvDTreeParams_set_1max_1depth_10", "png_user_version_check", "_cvConstructLCM", "_Z14fftImagesMultiPfS_iiS_", "_ZNK2cv16BaseImageEncoder17isFormatSupportedEi", "_ZNK2cv8GlBuffer6unbindEv", "_ZNK2cv9SparseMat6copyToERNS_3MatE", "_ZN16CvDTreeTrainData11get_vectorsEPK5CvMatPfPhS3_b", "_ZNK2cv14RandomizedTree12getPosteriorEPh", "png_set_expand", "_ZN2cv3of211ChowLiuTree1PEib", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRhbMS1_FhvEMS1_FvhERKSs", "_ZNK3Imf11FrameBuffer9findSliceEPKc", "_ZN4perf8TestBase14_declareHelper2inERKN2cv12_OutputArrayES5_S5_S5_i", "cvCreateGaussianBGModel2", "_ZN2cv3ocl8cvtColorERKNS0_6oclMatERS1_ii", "_ZN16CvObjectDetectorC2EPKc", "_ZNK3Imf8TimeCode7minutesEv", "Java_org_opencv_imgproc_Moments_set_1mu30_10", "_Z24computePredecessorMatrixRKN2cv3MatEiRS0_", "_ZN2cv19getMorphologyFilterEiiRKNS_11_InputArrayENS_6Point_IiEE", "_ZN2cv12LBPEvaluator4readERKNS_8FileNodeE", "_ZN2cv3of29FabMapLUTD0Ev", "_ZN2cv9TickMeterC1Ev", "_ZN2cv17CascadeClassifier16detectMultiScaleERKNS_3MatERSt6vectorINS_5Rect_IiEESaIS6_EERS4_IiSaIiEERS4_IdSaIdEEdiiNS_5Size_IiEESH_b", "_ZNK2cv29DynamicAdaptedFeatureDetector5emptyEv", "_ZN23CvNormalBayesClassifier4readEP13CvFileStorageP10CvFileNode", "png_64bit_product", "_ZN2cv8HOGCache4initEPKNS_13HOGDescriptorERKNS_3MatENS_5Size_IiEES8_bS8_", "_ZN2cv7linemod20ColorGradientPyramidC2ERKNS_3MatES4_fjf", "_ZN9CvERTrees5trainERKN2cv3MatEiS3_S3_S3_S3_S3_10CvRTParams", "_ZN2cvplERKNS_7Scalar_IdEERKNS_7MatExprE", "_ZN21DetectionBasedTracker21SeparateDetectionWork13resetTrackingEv", "cvStartNextStream", "Java_org_opencv_objdetect_HOGDescriptor_get_1blockStride_10", "_ZNK2cv11TiffDecoder15signatureLengthEv", "_ZN2cv16FeatureEvaluatorD1Ev", "_ZN2cv9SparseMatC1ERKNS_3MatE", "Java_org_opencv_objdetect_HOGDescriptor_get_1winSigma_10", "_ZN2cv6OctreeD0Ev", "png_set_tIME", "_ZN2cv5FREAKD1Ev", "_ZN23CvNormalBayesClassifierD1Ev", "_ZN3Imf11FrameBuffer6insertEPKcRKNS_5SliceE", "_ZN9CvGBTrees13change_valuesEP7CvDTreei", "_ZN2cv14ChamferMatcher26SlidingWindowImageIteratorC1Eiiiiiff", "_ZN6cvtest13DeviceManager4loadEi", "_ZNK3Imf14TiledInputFile9numLevelsEv", "_ZN3Iex13throwErrnoExcERKSsi", "jpc_tsfb_getbands2", "_ZN6cvtest8BaseTest19get_test_case_countEv", "_ZN2cv5Mutex4lockEv", "_ZN2cv20OneWayDescriptorBase10LoadPCAallERKNS_8FileNodeE", "_ZN2cv3gpu11TargetArchs6hasBinEii", "cvComposeRT", "jp2_box_get", "cvRectangle", "_ZN8CvMatrix4saveEPKcS1_PKi", "_ZNK7testing8UnitTest17current_test_infoEv", "cvCloneSparseMat", "_ZN2cv12WLByteStream7putWordEi", "__gnu_unwind_execute", "Java_org_opencv_core_Algorithm_paramHelp_10", "_ZN16CvDTreeTrainData16get_cat_var_dataEP11CvDTreeNodeiPi", "_ZN2cv3ogl9Texture2DC2ERKNS_11_InputArrayEb", "cvConDensUpdateByTime", "Java_org_opencv_core_Algorithm_getMat_10", "_ZN17CvCapture_AndroidD0Ev", "_ZN4perf8TestBase4InitERKSt6vectorISsSaISsEEiPKPKc", "Java_org_opencv_core_Core_getNumberOfCPUs_10", "_ZN2cv18CvMeanShiftTrackerC1ENS_24CvMeanShiftTrackerParamsE", "_ZN2cv3PtrI13CvFileStorageE10delete_objEv", "_ZNK2cv10ExrEncoder10newEncoderEv", "_ZN2cv17SelfSimDescriptorC1Ev", "png_set_crc_action", "TIFFDefaultDirectory", "png_get_sCAL", "_ZN2cv9GlTextureC1Ev", "Java_org_opencv_ml_CvGBTreesParams_get_1subsample_1portion_10", "_ZN3Imf17ScanLineInputFileD2Ev", "_ZN9CvGBTrees11read_paramsEP13CvFileStorageP10CvFileNode", "_ZNK8CvRTrees7predictEPK5CvMatS2_", "Java_org_opencv_objdetect_CascadeClassifier_load_10", "TIFFInitDumpMode", "Java_org_opencv_core_Mat_nPutD", "LogLuv24toXYZ", "png_init_io", "_ZN11CvSVMKernel6createEPK11CvSVMParamsMS_FviiPPKfS4_PfE", "_Unwind_RaiseException", "Java_org_opencv_imgproc_Imgproc_pyrDown_12", "_ZN2cv13Jpeg2KEncoderC2Ev", "_ZNK2cv7MatOp_T8multiplyERKNS_7MatExprEdRS1_", "_ZNK2cv3of213BOWMSCTrainer7clusterEv", "_ZN2cv5flann5Index5buildERKNS_11_InputArrayERKNS0_11IndexParamsEN7cvflann16flann_distance_tE", "Java_org_opencv_features2d_DescriptorMatcher_knnMatch_12", "_ZN12CvFuzzyCurve8addPointEdd", "cvDet", "_ZN7testing4Test5SetUpEv", "_ZN3Imf6HeaderC1ERKS0_", "_ZN2cv13Jpeg2KDecoderD1Ev", "cvInitNArrayIterator", "png_get_int_32", "_ZN6cvtest8BaseTestD2Ev", "_ZN7testing8internal11CmpHelperGEEPKcS2_xx", "Java_org_opencv_contrib_StereoVar_set_1poly_1n_10", "_ZNK7testing8UnitTest17failed_test_countEv", "_ZN2cv15CvHybridTrackerC1Ev", "_ZN14CvBlobTrackSeq12GetBlobTrackEi", "_ZNK2cv3ocl9CvSVM_OCL7predictEPK5CvMatPS2_", "TIFFInitLZW", "_ZN2cv12FilterEngine5startENS_5Size_IiEENS_5Rect_IiEEi", "_ZN7testing8internal15UnitTestOptions20PatternMatchesStringEPKcS3_", "cvContourBoundingRect", "_ZN2cv6detail16createLaplacePyrERKNS_3MatEiRSt6vectorIS1_SaIS1_EE", "_ZN2cv3ocl31GoodFeaturesToTrackDetector_OCLclERKNS0_6oclMatERS2_S4_", "TIFFComputeStrip", "_ZN3Imf7KeyCode16setPerfsPerCountEi", "_ZN6cvtest7cmpEps2EPNS_2TSERKN2cv3MatES5_dbPKc", "jas_stream_gobble", "Java_org_opencv_highgui_VideoCapture_n_1delete", "cvCreateCameraCapture", "_Z17ThresholdingParamP9_IplImageiRiS1_RfS2_i", "_ZN2cv14RandomizedTree14savePosteriorsESsb", "_ZN10__cxxabiv119__pointer_type_infoD2Ev", "png_fixed_error", "_ZN2cvplERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv3ocl6absSumERKNS0_6oclMatE", "_ZN2cv3ocl21StereoConstantSpaceBPC1Eiiiii", "_ZN2cv12randShuffle_ERKNS_12_OutputArrayEd", "_ZN7testing8internal27PrettyUnitTestResultPrinter9OnTestEndERKNS_8TestInfoE", "_ZN3Imf6Header15setPreviewImageERKNS_12PreviewImageE", "_ZN5CvSVM13create_kernelEv", "_ZNK2cv9Algorithm9getStringERKSs", "_ZNK2cv9TickMeter12getTimeMicroEv", "_ZNK2cv26GridAdaptedFeatureDetector5emptyEv", "_TIFFsetFloatArray", "_ZN5Graph7addEdgeEjj", "_ZN2cv6detail12DpSeamFinder11getSeamTipsEiiRNS_6Point_IiEES4_", "Java_org_opencv_core_Core_countNonZero_10", "Java_org_opencv_imgproc_Imgproc_fitLine_10", "_ZN2cv9videostab17TwoPassStabilizerC2Ev", "_ZNK7testing8UnitTest6PassedEv", "cvMakeAlphaScanlines", "TIFFReadRGBATile", "_ZN2cv32fastNlMeansDenoisingColoredMultiERKNS_11_InputArrayERKNS_12_OutputArrayEiiffii", "_ZN2cv14RandomizedTree22allocPosteriorsAlignedEii", "_ZN2cv27computeRecallPrecisionCurveERKSt6vectorIS0_INS_6DMatchESaIS1_EESaIS3_EERKS0_IS0_IhSaIhEESaIS9_EERS0_INS_6Point_IfEESaISF_EE", "_ZN16CvDTreeTrainData5clearEv", "cvSeqInsertSlice", "cvInitMixSegm", "_ZN7testing8internal27PrettyUnitTestResultPrinter24OnEnvironmentsSetUpStartERKNS_8UnitTestE", "_ZN2cv3ogl6Buffer8copyFromERKNS_11_InputArrayENS1_6TargetEb", "_ZNK7testing8internal8FilePath15DirectoryExistsEv", "png_get_image_height", "_ZN3Imf11hasIsoSpeedERKNS_6HeaderE", "_ZN6cvtest9ArrayTest21validate_test_resultsEi", "_ZN3Imf9InputFile14setFrameBufferERKNS_11FrameBufferE", "Java_org_opencv_ml_CvKNearest_train_10", "_ZN6cvtest5checkERKN2cv3MatEddPSt6vectorIiSaIiEE", "png_info_init_3", "cvCloneImage", "png_get_y_pixels_per_meter", "_ZN7testing4Test3RunEv", "jinit_inverse_dct", "_Z13allocFFTImagePP14CvLSVMFftImageiii", "_ZN2cv6detail21BestOf2NearestMatcherC2Ebfii", "_ZN3Imf6Header18screenWindowCenterEv", "_ZN3Imf17latitudeAttributeERNS_6HeaderE", "_ZN2cvplERKNS_3MatES2_", "_ZN2cv3ocl9setDeviceEPKNS0_10DeviceInfoE", "_ZN7CvBoost12trim_weightsEv", "cvWrite", "_ZNK2cv17CascadeClassifier5emptyEv", "_ZN2cv17ParvoRetinaFilterD0Ev", "Java_org_opencv_contrib_StereoVar_get_1poly_1n_10", "_ZN2cv16TLSDataContainerD1Ev", "cvMinAreaRect", "Java_org_opencv_imgproc_Moments_get_1nu20_10", "_ZNK7testing8TestCase30reportable_disabled_test_countEv", "_Z20Mat_to_vector_doubleRN2cv3MatERSt6vectorIdSaIdEE", "Java_org_opencv_ml_CvSVMParams_set_1p_10", "_ZN2cv6RetinaC2ENS_5Size_IiEEbNS_26RETINA_COLORSAMPLINGMETHODEbdd", "_ZN21DetectionBasedTracker7processERKN2cv3MatE", "_ZN2cv12_OutputArrayC2ERNS_3ogl6BufferE", "Java_org_opencv_core_Mat_n_1submat", "_ZN2cv8fillPolyERNS_3MatEPPKNS_6Point_IiEEPKiiRKNS_7Scalar_IdEEiiS3_", "_ZN7testing8TestCase14UnshuffleTestsEv", "cvSubstituteContour", "png_handle_iCCP", "_Z12searchObjectPK20CvLSVMFeaturePyramidPPK18CvLSVMFilterObjectifiiPP7CvPointPPiS9_PfPS8_", "_ZN2cv9Algorithm9setDoubleERKSsd", "cvSub", "allocFeaturePyramidObject", "_ZN2cv6KDTreeC2ERKNS_11_InputArrayES3_b", "cvClearSeq", "cvArcLength", "_ZN2cv11JpegEncoderC2Ev", "TIFFSwabDouble", "_ZN2cv12WLByteStream8putBytesEPKvi", "_ZN2cv7MomentsC1ERK9CvMoments", "_ZNK7testing8TestCase16total_test_countEv", "_ZN2cv10BmpDecoder10readHeaderEv", "cvExtractSURF", "_ZN2cv3ocl14clBlasTeardownEv", "_ZN7testing8TestInfoD1Ev", "LogLuv24fromXYZ", "_ZNK2cv8Subdiv2D10rotateEdgeEii", "_ZN2cv10PngEncoder8flushBufEPv", "_Z22vector_KeyPoint_to_MatRSt6vectorIN2cv8KeyPointESaIS1_EERNS0_3MatE", "_ZN2cv2LUEPdjiS0_ji", "jpc_pi_init", "_ZN2cv5flann33HierarchicalClusteringIndexParamsC2EiN7cvflann20flann_centers_init_tEii", "cvRestoreMemStoragePos", "_ZN7testing8internal7PrintToEwPSo", "cvGet3D", "_Z26icvCvt_BGR5652BGR_8u_C2C3RPKhiPhi6CvSize", "jpeg_quality_scaling", "_ZN2cv3ogl6renderERKNS0_6ArraysERKNS_11_InputArrayEiNS_7Scalar_IdEE", "png_set_background_fixed", "_ZNK2cv19DescriptorExtractor7computeERKSt6vectorINS_3MatESaIS2_EERS1_IS1_INS_8KeyPointESaIS7_EESaIS9_EERS4_", "_ZNK2cv5FREAK14descriptorTypeEv", "_ZN7testing8internal17StreamingListener12SocketWriter14MakeConnectionEv", "_ZN2cv15KeyPointsFilter10retainBestERSt6vectorINS_8KeyPointESaIS2_EEi", "_ZN2cv3gpu11TargetArchs6hasPtxEii", "_ZN7CvBoostC1EPK5CvMatiS2_S2_S2_S2_S2_13CvBoostParams", "Java_org_opencv_gpu_DeviceInfo_name_10", "_ZNK2cv8Subdiv2D6Vertex9isvirtualEv", "_ZN8CvMatrix4readEP13CvFileStoragePKcS3_", "_ZNK3Imf11ChannelListixEPKc", "Java_org_opencv_objdetect_HOGDescriptor_getDefaultPeopleDetector_10", "_ZN13CvCalibFilter7RectifyEPP9_IplImageS2_", "_ZN2cv12WLByteStreamD0Ev", "_ZN21DetectionBasedTracker21SeparateDetectionWorkD0Ev", "jpeg_save_markers", "_ZN2cv12_OutputArrayC2ERNS_3gpu6GpuMatE", "Java_org_opencv_ml_CvGBTrees_CvGBTrees_11", "_ZNK2cv9MatOp_Bin6divideEdRKNS_7MatExprERS1_", "Java_org_opencv_ml_CvSVMParams_set_1degree_10", "_ZN2cv16CvFeatureTracker20updateTrackingWindowENS_3MatE", "_ZNK2cv20OneWayDescriptorBase10SavePCAallERNS_11FileStorageE", "jas_seq2d_bindsub", "_ZN21DetectionBasedTracker21SeparateDetectionWorkC1ERS_RKSs", "_ZN2cv8Subdiv2D6VertexC1ENS_6Point_IfEEbi", "_ZN2cv3ocl22createLinearFilter_GPUEiiRKNS_3MatERKNS_6Point_IiEEi", "_ZN4epnp12copy_R_and_tEPA3_KdPS0_PA3_dPd", "_ZN23CvFuzzyMeanShiftTracker12SearchWindowD1Ev", "png_handle_PLTE", "_ZdlPv", "_ZN11CvStatModelC2Ev", "_ZN2cv3gpu11TargetArchs17hasEqualOrGreaterEii", "_ZN2cv7noArrayEv", "png_set_text_compression_level", "png_destroy_gamma_table", "_ZNK3Imf14TypedAttributeINS_8TimeCodeEE12writeValueToERNS_7OStreamEi", "cvAbsDiffS", "_ZN2cv3ocl19openCLExecuteKernelEPNS0_7ContextEP10_cl_kernelPjS5_RSt6vectorISt4pairIjPKvESaISA_EE", "_ZN2cv9videostab28completeFrameAccordingToFlowERKNS_3MatES3_S3_S3_S3_fRS1_S4_", "_ZN2cv10BmpEncoderD0Ev", "_ZN3Imf7IStreamC2EPKc", "Java_org_opencv_objdetect_HOGDescriptor_computeGradient_10", "_ZN2cv3ocl12ProgramCache15getProgramCacheEv", "_ZN17CirclesGridFinder12insertWinnerEfffbRKSt6vectorIjSaIjEES4_RS0_IS2_SaIS2_EE", "_ZN3Imf10OutputFileD0Ev", "Java_org_opencv_features2d_GenericDescriptorMatcher_match_13", "_ZN2cv5writeERNS_11FileStorageERKSsRKNS_3MatE", "_ZN2cv12SurfAdjusterC1Eddd", "_ZNK2cv23VectorDescriptorMatcher5emptyEv", "_ZN21CvANN_MLP_TrainParamsC1Ev", "_ZN2cv16OneWayDescriptor14InitializeFastEiP9_IplImagePKcP5CvMatS6_PS0_", "_ZN2cv3ocl17distanceToCentersERKNS0_6oclMatES3_RNS_3MatES5_i", "_ZN3Imf11FrameBuffer3endEv", "_ZN2cv32OpponentColorDescriptorExtractorC2ERKNS_3PtrINS_19DescriptorExtractorEEE", "_ZN2cv9Algorithm6setIntEPKci", "Java_org_opencv_imgproc_Imgproc_getDefaultNewCameraMatrix_11", "_ZNK2cv17DescriptorMatcher8knnMatchERKNS_3MatES3_RSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiS3_b", "_ZN4perf10Regression10addMatchesEPNS_8TestBaseERKSsRKSt6vectorIN2cv6DMatchESaIS7_EEdNS_10ERROR_TYPEE", "Java_org_opencv_core_Mat_n_1empty", "_ZN2cv23initUndistortRectifyMapERKNS_11_InputArrayES2_S2_S2_NS_5Size_IiEEiRKNS_12_OutputArrayES7_", "_ZN9IlmThread4TaskC2EPNS_9TaskGroupE", "_ZN21DetectionBasedTracker3runEv", "_ZN2cv24BackgroundSubtractorMOG2D2Ev", "Java_org_opencv_gpu_TargetArchs_delete", "_ZN2cv3ogl9Texture2DC1EiiNS1_6FormatEjb", "_ZN2cv12GFTTDetectorC1Eiddibd", "_Z29cvCreateCameraCapture_Androidi", "_Z8icvLMedSPiS_iP9CvMatrix3", "_ZN2cv3ocl14copyMakeBorderERKNS0_6oclMatERS1_iiiiiRKNS_7Scalar_IdEE", "_ZN3Imf17isoSpeedAttributeERKNS_6HeaderE", "cvSet", "_ZN3Imf10hasCapDateERKNS_6HeaderE", "_ZN2cv12VideoCaptureC1Ei", "_ZN2cv17BasicRetinaFilterD1Ev", "cvConvexHull", "_ZNK2cv11TiffEncoder17isFormatSupportedEi", "png_set_filler", "Java_org_opencv_imgproc_Imgproc_remap_10", "Java_org_opencv_objdetect_HOGDescriptor_checkDetectorSize_10", "_ZN17CvCapture_Android9OutputMap14getIplImagePtrEv", "_ZNK2cv7MatExpr3invEi", "_ZN6cvtest10BadArgTestD2Ev", "cvBGCodeBookUpdate", "_ZN2cv3ocl10meanStdDevERKNS0_6oclMatERNS_7Scalar_IdEES6_", "_ZN2cv24BackgroundSubtractorMOG2C2Eifb", "_ZNK2cv9Exception4whatEv", "cvInitMatHeader", "cvInitFont", "_ZN2cvmlEdRKNS_3MatE", "png_get_unknown_chunks", "_ZN7CvDTree24find_surrogate_split_ordEP11CvDTreeNodeiPh", "_ZN2cv3of26FabMap21getNewPlaceLikelihoodERKNS_3MatE", "_ZN2cv23OneWayDescriptorMatcher6ParamsC2EiNS_5Size_IiEESsSsSsfff", "jas_image_delcmpt", "_ZN11CvSVMSolver13solve_eps_svrEiiPPKfS1_P12CvMemStorageP11CvSVMKernelPdR17CvSVMSolutionInfo", "_ZN2cv6Retina5_initENS_5Size_IiEEbNS_26RETINA_COLORSAMPLINGMETHODEbdd", "Java_org_opencv_core_Core_normalize_10", "_ZN2cv20OneWayDescriptorBase4ReadERKNS_8FileNodeE", "_ZN2cv14RandomizedTree14quantizeVectorEPfiiS1_i", "_ZN2cv3ocl12PlatformInfoD1Ev", "__ltdf2", "_ZN2cv3ocl26BruteForceMatcher_OCL_base18radiusMatchConvertERKNS_3MatES4_S4_S4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "jas_seq2d_input", "_ZN2cv3gpu9convertToERKNS0_6GpuMatERS1_ddPv", "jpeg_fdct_float", "jas_iccprof_destroy", "Java_org_opencv_core_Mat_n_1mul__JJD", "Java_org_opencv_core_Core_multiply_11", "_ZN7testing8internal19UniversalPrintArrayEPKwjPSo", "Java_org_opencv_imgproc_Imgproc_contourArea_11", "_ZNK2cv21FernDescriptorMatcher5cloneEb", "_ZN24CvBlobTrackPredictKalmanC1Ev", "Java_org_opencv_imgproc_Imgproc_Laplacian_12", "_ZN2cv13HOGDescriptor14setSVMDetectorERKNS_11_InputArrayE", "_ZN2cv3gpu11setGlDeviceEi", "_ZN12CvForestTreeD1Ev", "_ZN2cv9videostab17TwoPassStabilizer21runPrePassIfNecessaryEv", "_ZN12CvFuzzyCurveC1Ev", "TIFFYCbCrtoRGB", "png_chunk_benign_error", "_ZN2cv13LevMarqSparseD0Ev", "_ZN2cv11WBaseStreamC2Ev", "_ZN2cv3Mat5setToERKNS_11_InputArrayES3_", "_ZN2cv11Fisherfaces4loadERKNS_11FileStorageE", "cvPostBoostingFindFace", "_ZN2cv3ocl5pyrUpERKNS0_6oclMatERS1_", "Java_org_opencv_ml_CvRTrees_delete", "Java_org_opencv_calib3d_StereoSGBM_get_1numberOfDisparities_10", "_ZN2cv10BOWTrainer3addERKNS_3MatE", "_ZNK2cv14FernClassifier5emptyEv", "Java_org_opencv_core_Core_norm_15", "_ZN6cvtest8BaseTest3runEi", "_ZN12ocl_tvl1flow12warpBackwardERKN2cv3ocl6oclMatES4_RS2_S5_S5_S5_S5_S5_S5_S5_S5_", "cvGetSeqReaderPos", "jas_tvparser_destroy", "_ZN2cv3ogl6Arrays14setNormalArrayERKNS_11_InputArrayE", "cvGetReal3D", "Java_org_opencv_imgproc_Imgproc_preCornerDetect_11", "_Z37cvCreateModuleBlobTrackPostProcKalmanv", "_ZN8CvRTrees18get_var_importanceEv", "cvFindGraphEdge", "_ZN2cv3ogl6BufferC1ENS_5Size_IiEEijb", "cvReshapeMatND", "_ZN7testing8internal19UniversalPrintArrayEPKcjPSo", "_ZNK3Imf13B44Compressor6formatEv", "_ZN2cv13applyColorMapERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZNK2cv16OneWayDescriptor13GetPCADimHighEv", "_ZN2cv9GlTexture8copyFromERKNS_11_InputArrayEb", "_ZN2cvplERKNS_3MatERKNS_7MatExprE", "_ZN2cv11RetinaColor42_adaptiveVerticalAnticausalFilter_multGainEPfjj", "Java_org_opencv_video_BackgroundSubtractorMOG2_delete", "_Z10cvAddNoiseP9_IplImageidP11CvRandState", "_ZN2cv20checkHardwareSupportEi", "_ZNK17CirclesGridFinder13rng2gridGraphER5GraphRSt6vectorIN2cv6Point_IfEESaIS5_EE", "_ZN2cveoERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv3ocl11createCLAHEEdNS_5Size_IiEE", "_ZN2cv9videostab32estimateGlobalMotionLeastSquaresERKSt6vectorINS_6Point_IfEESaIS3_EES7_iPf", "_ZN2cv11TiffEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "_ZNK3Imf14TypedAttributeIN5Imath8Matrix33IfEEE12writeValueToERNS_7OStreamEi", "_TIFFCreateAnonField", "_ZN2cv12FastAdjuster6tooFewEii", "_ZN2cv9ExceptionD2Ev", "_ZN7testing8internal27PrettyUnitTestResultPrinter18OnTestIterationEndERKNS_8UnitTestEi", "_ZN3Imf14TypedAttributeIN5Imath4Vec3IiEEE14staticTypeNameEv", "Java_org_opencv_core_Core_putText_10", "_Z21icvCvt_BGR2RGB_8u_C3RPKhiPhi6CvSize", "_ZN5CvSVM6train1EiiPPKfPKvddP12CvMemStoragePdRd", "Java_org_opencv_features2d_DescriptorMatcher_radiusMatch_12", "png_XYZ_from_xy_checked", "_ZN2cv12VideoCapturersERNS_3MatE", "_ZN2cv3ocl25getLinearColumnFilter_GPUEiiRKNS_3MatEiid", "Java_org_opencv_core_Core_cartToPolar_10", "_ZN2cv9arcLengthERKNS_11_InputArrayEb", "_ZN3Imf11StdIFStreamC1ERSt14basic_ifstreamIcSt11char_traitsIcEEPKc", "_ZNK7CvDTree19get_pruned_tree_idxEv", "_ZNK7CvBoost7predictEPK5CvMatS2_PS0_7CvSlicebb", "_ZN2cv24GenericDescriptorMatcher18KeyPointCollection3addERKSt6vectorINS_3MatESaIS3_EERKS2_IS2_INS_8KeyPointESaIS8_EESaISA_EE", "_ZN22CvAdaptiveSkinDetector9HistogramD0Ev", "_ZN2cv5MutexD1Ev", "_ZN21DetectionBasedTracker21SeparateDetectionWork30communicateWithDetectingThreadERKN2cv3MatERSt6vectorINS1_5Rect_IiEESaIS7_EE", "_ZN2cv3ocl24OpticalFlowDual_TVL1_OCL14collectGarbageEv", "cvbReciprocal", "_ZN13CvBlobTracker16GetBlobIndexByIDEi", "png_build_gamma_table", "_ZN2cv9videostab18InpaintingPipeline9setFramesERKSt6vectorINS_3MatESaIS3_EE", "_ZN2cv12RetinaFilter21getParvoFoveaResponseERSt8valarrayIfE", "Java_org_opencv_core_Mat_nGetB", "_ZN6cvtest11cmpEps2_64fEPNS_2TSEPKdS3_idPKc", "cvRemap", "_ZN7testing8internal12UnitTestImpl14UnshuffleTestsEv", "_ZNK2cv4LBPH7predictERKNS_11_InputArrayE", "_ZN3Imf16capDateAttributeERNS_6HeaderE", "_ZN2cv13HaarEvaluator9setWindowENS_6Point_IiEE", "_ZN13CvCalibFilter9UndistortEPP5CvMatS2_", "_ZNK2cv3Mat6copyToERKNS_12_OutputArrayE", "_ZN5GraphC2Ej", "_ZN2cv15CvHybridTrackerC1ENS_21CvHybridTrackerParamsE", "_Z30cvConvertEssential2FundamentalPfS_S_S_", "_ZN21DetectionBasedTrackerC1ERKSsRKNS_10ParametersE", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection11getKeyPointEii", "_ZN2cv10PxMEncoderD2Ev", "Java_org_opencv_ml_CvSVMParams_set_1svm_1type_10", "_ZN2cv8clearSeqEP5CvSeq", "Java_org_opencv_imgproc_Imgproc_Canny_11", "_ZN2cv12RetinaFilterC2EjjbNS_26RETINA_COLORSAMPLINGMETHODEbdd", "_ZN2cv5flann5Index4loadERKNS_11_InputArrayERKSs", "_ZN4CvEM4readEP13CvFileStorageP10CvFileNode", "_ZN3Imf17hasAdoptedNeutralERKNS_6HeaderE", "_ZN20CvVideoWriter_Images5closeEv", "png_read_transform_info", "_ZN2cv16SunRasterEncoder5writeERKNS_3MatERKSt6vectorIiSaIiEE", "_ZN2cv24GenericDescriptorMatcher11radiusMatchERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEfRKS4_IS1_SaIS1_EEb", "_ZNK2cv3ocl10oclMatExpr6assignERNS0_6oclMatE", "Java_org_opencv_imgproc_Imgproc_accumulateProduct_11", "Java_org_opencv_core_Core_n_1getTextSize", "Java_org_opencv_imgproc_Moments_set_1m30_10", "_ZNK2cv5MatOp4sizeERKNS_7MatExprE", "_ZN2cv16SunRasterDecoderC1Ev", "png_do_scale_16_to_8", "_ZN2cv3ocl5phaseERKNS0_6oclMatES3_RS1_b", "Java_org_opencv_imgproc_Imgproc_convexHull_10", "_ZN4perf10RegressionD1Ev", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow33getResizeAttribsEdgeDensityLinearERiS1_S1_S1_", "_ZN4FaceD2Ev", "_ZN2cv13stereoRectifyERKNS_11_InputArrayES2_S2_S2_NS_5Size_IiEES2_S2_RKNS_12_OutputArrayES7_S7_S7_S7_idS4_PNS_5Rect_IiEESA_", "png_set_text_compression_method", "_ZNK7testing7Message9GetStringEv", "Java_org_opencv_imgproc_Imgproc_borderInterpolate_10", "_Z10icvGetCoefPdS_S_S_S_", "png_set_compression_level", "_ZNK2cv12_OutputArray9fixedSizeEv", "_ZN2cvltERKNS_3MatES2_", "cvUnDistort", "_ZN2cv9Algorithm7setBoolEPKcb", "jas_stream_ungetc", "_ZN2cv9SparseMat3ptrEPKibPj", "_Z16cvReleaseTestSeqPPv", "_ZN2cv10getSeqElemEPK5CvSeqi", "_Z25icvCvt_Gray2BGR_16u_C1C3RPKtiPti6CvSize", "_ZN2cv15RTreeClassifier20countNonZeroElementsEPfid", "_ZN2cv6Mesh3DC1Ev", "dump_layeringinfo", "_ZN2cv7vconcatERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZNK3Imf10Compressor6formatEv", "_ZN2cv7fisheye9calibrateERKNS_11_InputArrayES3_RKNS_5Size_IiEERKNS_12_OutputArrayESA_SA_SA_iNS_12TermCriteriaE", "_ZN2cv7linemod8Modality6createERKSs", "_ZdaPv", "_ZN2cv20AffineTransformPatchEP9_IplImageS1_NS_12CvAffinePoseE", "_ZN7testing8internal12UnitTestImpl41SetTestPartResultReporterForCurrentThreadEPNS_31TestPartResultReporterInterfaceE", "_ZN2cv12StarAdjuster6tooFewEii", "_ZNK3Imf11ChannelList11findChannelERKSs", "TIFFRawStripSize64", "_ZN2cv9GlTextureC1Eiii", "_ZN9CvGBTrees5clearEv", "_ZTv0_n16_NK2cv24BriefDescriptorExtractor5writeERNS_11FileStorageE", "cvSetHistBinRanges", "_ZN2cv16FeatureEvaluator8setImageERKNS_3MatENS_5Size_IiEE", "jpeg_abort", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_set_1rp_1dw_1minus_10", "_ZN2cv13setNumThreadsEi", "_ZN2cv6fontQtERKSsiNS_7Scalar_IdEEiii", "_ZN2cv4PSNRERKNS_11_InputArrayES2_", "_ZN2cv18WriteStructContextC2ERNS_11FileStorageERKSsiS4_", "_ZN7testing8internal17TestEventRepeater18OnTestIterationEndERKNS_8UnitTestEi", "_ZN2cv7ellipseERNS_3MatERKNS_11RotatedRectERKNS_7Scalar_IdEEii", "_ZN11CvSVMKernelC1EPK11CvSVMParamsMS_FviiPPKfS4_PfE", "_ZN2cv3ocl6oclMat7releaseEv", "_ZN4epnp14compute_L_6x10EPKdPd", "_ZN7testing8internal17TestEventRepeater9OnTestEndERKNS_8TestInfoE", "_ZN9CvLevMarq5clearEv", "_ZN2cv3ocl6resizeERKNS0_6oclMatERS1_NS_5Size_IiEEddi", "jpeg_huff_decode", "_ZN2cv3ocl3minERKNS0_6oclMatES3_RS1_", "_ZN7testing8internal14ParseInt32FlagEPKcS2_Pi", "Java_org_opencv_calib3d_StereoSGBM_set_1P2_10", "_ZN2cv11TiffEncoder12writeLibTiffERKNS_3MatERKSt6vectorIiSaIiEE", "cvRodrigues", "_ZN2cv5writeERNS_11FileStorageERKSsS3_", "_ZN7testing8internal12UnitTestImpl25set_os_stack_trace_getterEPNS0_27OsStackTraceGetterInterfaceE", "_ZNK2cv10MatOp_GEMM6assignERKNS_7MatExprERNS_3MatEi", "_ZN6cvtest6divideERKN2cv3MatES3_RS1_d", "_Z13convertPointsiiiP7CvPointPiPS0_iiii", "_ZN2cv14FernClassifier19trainFromSingleViewERKNS_3MatERKSt6vectorINS_8KeyPointESaIS5_EEiiiiiiRKNS_14PatchGeneratorE", "_ZN2cv12RLByteStream8getDWordEv", "_ZNK3Imf6HeaderixERKSs", "_ZN2cv3gpu18ensureSizeIsEnoughEiiiRNS0_6GpuMatE", "cvFindExtrinsicCameraParams2", "_ZN2cv8superres11FrameSourceD1Ev", "_ZN2cv20LogPolar_Overlapping12to_cartesianERKNS_3MatE", "_ZNK2cv7MatExpr3mulERKNS_3MatEd", "_ZNK3Imf9InputFile11frameBufferEv", "cvResize", "_ZNK3Imf7KeyCode13perfsPerFrameEv", "_ZN3Imf12hasUtcOffsetERKNS_6HeaderE", "Java_org_opencv_core_Core_absdiff_11", "_ZN9CvERTrees5trainEP8CvMLData10CvRTParams", "_ZN2cv6detail18GraphCutSeamFinder4findERKSt6vectorINS_3MatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_", "png_write_find_filter", "_ZN2cv3ocl11clBlasSetupEv", "_ZN2cv13HOGDescriptor24getDaimlerPeopleDetectorEv", "_ZN2cv11RetinaColor31_applyImageColorSpaceConversionERKSt8valarrayIfERS2_PKf", "_ZN2cv12RetinaFilter18runGrayToneMappingERKSt8valarrayIfERS2_ff", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1rp_1dw_1min_10", "_ZN2cv6detail17BundleAdjusterRay12calcJacobianERNS_3MatE", "_ZN12CvForestTreeD2Ev", "_ZN2cv11JpegEncoderC1Ev", "_ZNK2cv14PatchGeneratorclERKNS_3MatES3_RS1_NS_5Size_IiEERNS_3RNGE", "TIFFWriteRawStrip", "_ZN2cv23BackgroundSubtractorGMGC1Ev", "_ZN2cv20OneWayDescriptorBase11GeneratePCAEPKcS2_i", "_ZN6cvtest9createMatEN2cv5Size_IiEEib", "_ZN2cv16OneWayDescriptor5WriteEP13CvFileStoragePKc", "_ZN2cv23VectorDescriptorMatcher5clearEv", "_ZN11CvBoostTree4readEP13CvFileStorageP10CvFileNodeP7CvBoostP16CvDTreeTrainData", "_ZN2cv11RBaseStream9readBlockEv", "_ZN2cv18getAffineTransformEPKNS_6Point_IfEES3_", "_ZN2cv9Algorithm6setMatEPKcRKNS_3MatE", "_ZN2cv18calcMotionGradientERKNS_11_InputArrayERKNS_12_OutputArrayES5_ddi", "_ZN7testing8internal38DefaultPerThreadTestPartResultReporterC1EPNS0_12UnitTestImplE", "cvClone", "_ZN2cv3ogl6BufferC2ENS_5Size_IiEEiNS1_6TargetEb", "_ZN2cv20DenseFeatureDetectorC2Efifiibb", "_ZN2cv17BasicRetinaFilter45setProgressiveFilterConstants_CentredAccuracyEfffj", "_ZN16CvDTreeTrainDataD2Ev", "_ZNK3Imf8TimeCode4bgf0Ev", "TIFFReadRawStrip", "_ZN2cv5flann11IndexParams6setIntERKSsi", "png_set_bKGD", "Java_org_opencv_imgproc_Imgproc_sepFilter2D_11", "_ZNK2cv32OpponentColorDescriptorExtractor14descriptorSizeEv", "_ZN3p3p17solve_for_lengthsEPA3_dPdS2_", "LogL10toY", "_ZN2cv8GlCamera18setOrthoProjectionEdddddd", "cvInitImageHeader", "_ZN2cv8HOGCacheC2EPKNS_13HOGDescriptorERKNS_3MatENS_5Size_IiEES8_bS8_", "jas_image_depalettize", "_ZN3Imf19copyIntoFrameBufferERPKcPcS3_jbdNS_10Compressor6FormatENS_9PixelTypeES6_", "_ZN2cv3logEPKfPfi", "_ZN11CvSVMKernel11calc_linearEiiPPKfS1_Pf", "Java_org_opencv_calib3d_Calib3d_computeCorrespondEpilines_10", "TIFFReadRGBAImage", "_ZN2cv19createHanningWindowERKNS_12_OutputArrayENS_5Size_IiEEi", "Java_org_opencv_core_Core_putText_12", "_ZN2cv12_OutputArrayC2Ev", "cvContourArea", "cvTypeOf", "_ZN2cv21FernDescriptorMatcherD0Ev", "_ZN2cv13Jpeg2KEncoderC1Ev", "jas_seq2d_copy", "Java_org_opencv_highgui_Highgui_imwrite_11", "_ZN2cv5BRISKC1ERSt6vectorIfSaIfEERS1_IiSaIiEEffS6_", "_ZN2cv3of26FabMap7compareERKNS_3MatES4_RSt6vectorINS0_6IMatchESaIS6_EES4_", "png_set_filter", "_ZN2cv3of27FabMap23addERKSt6vectorINS_3MatESaIS3_EE", "_ZN2cv14SpinImageModelC1ERKNS_6Mesh3DE", "jpeg_idct_islow", "cvTranspose", "_ZNK7testing8internal12UnitTestImpl22test_case_to_run_countEv", "Java_org_opencv_imgproc_Moments_get_1m21_10", "jpc_bitstream_sopen", "_ZN3Imf14TypedAttributeINS_14ChromaticitiesEE13readValueFromERNS_7IStreamEii", "_ZN2cv24GenericDescriptorMatcher18KeyPointCollectionC1ERKS1_", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRsbMS1_FivEMS1_FviERKSs", "_ZN2cv3Mat10deallocateEv", "_ZN2cv3ocl15CvSVMKernel_ocl6createEPK11CvSVMParamsMS1_FviiPfRNS_3MatEEM11CvSVMKernelFviiPPKfSC_S5_E", "_ZN2cv32evaluateGenericDescriptorMatcherERKNS_3MatES2_S2_RSt6vectorINS_8KeyPointESaIS4_EES7_PS3_IS3_INS_6DMatchESaIS8_EESaISA_EEPS3_IS3_IhSaIhEESaISF_EERS3_INS_6Point_IfEESaISK_EERKNS_3PtrINS_24GenericDescriptorMatcherEEE", "_ZN7testing8internal24XmlUnitTestResultPrinter29TestPropertiesAsXmlAttributesERKNS_10TestResultE", "_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayES5_iii", "Java_org_opencv_ml_CvRTParams_get_1calc_1var_1importance_10", "_ZNK2cv11_InputArray12getOGlBufferEv", "Java_org_opencv_ml_CvERTrees_train_11", "jpc_encode", "_ZNK2cv17DescriptorMatcher5matchERKNS_3MatES3_RSt6vectorINS_6DMatchESaIS5_EES3_", "Java_org_opencv_ml_EM_trainM_11", "_ZN2cv3ocl26openCLExecuteKernelInteropEPNS0_7ContextERKNS0_13ProgramSourceESsPjS6_RSt6vectorISt4pairIjPKvESaISB_EEiiPKc", "_ZN2cv3ocl10openCLFreeEPv", "_ZN2cv15CvHybridTracker21getDistanceProjectionENS_3MatENS_6Point_IfEE", "_ZN2cv11VideoWriter4openERKSsidNS_5Size_IiEEb", "_ZN11CvSVMKernelD2Ev", "_ZN2cv3ogl6Arrays13setColorArrayERKNS_11_InputArrayE", "_ZN2cv21ImageLogPolProjection22_initLogRetinaSamplingEdd", "_ZN7testing8internal17AppendUserMessageERKSsRKNS_7MessageE", "Java_org_opencv_ml_CvDTreeParams_set_1truncate_1pruned_1tree_10", "_ZN2cv8internal15IntrinsicParamsplERKNS_3MatE", "_ZN2cv13LevMarqSparse12ask_for_projER5CvMatb", "Java_org_opencv_imgproc_Subdiv2D_getTriangleList_10", "jpc_ppmstabtostreams", "_ZN2cv3gpu5errorEPKcS2_iS2_", "_ZNK2cv5BRISK11computeImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZN22CvAdaptiveSkinDetector9Histogram17findCoverageIndexEdi", "_ZNK7testing8UnitTest11GetTestCaseEi", "_ZNK2cv11MatOp_Solve6assignERKNS_7MatExprERNS_3MatEi", "Java_org_opencv_video_BackgroundSubtractorMOG2_BackgroundSubtractorMOG2_11", "__fixunssfdi", "Java_org_opencv_imgproc_Moments_get_1nu11_10", "__gnu_Unwind_Save_VFP_D_16_to_31", "_ZN2cv3ocl10bitwise_orERKNS0_6oclMatERKNS_7Scalar_IdEERS1_S3_", "cv3dTrackerCalibrateCameras", "_ZN2cvdvERKNS_7MatExprES2_", "cvCreateTestSet", "Java_org_opencv_ml_CvRTrees_CvRTrees_10", "_ZN2cv3minERKNS_3MatEd", "_ZN2cv14ChamferMatcher8Matching20localChamferDistanceENS_6Point_IiEERNS_3MatES5_PNS0_8TemplateEf", "_ZNK3Imf9InputFile8fileNameEv", "_ZN2cv19DescriptorExtractorD0Ev", "_ZN2cv9videostab14ColorInpainter7inpaintEiRNS_3MatES3_", "_ZN3Imf13defaultFormatEPNS_10CompressorE", "_ZN2cv20PlanarObjectDetectorC2ERKSt6vectorINS_3MatESaIS2_EEiiiiiRKNS_9LDetectorERKNS_14PatchGeneratorE", "_ZN6cvtest14copyMakeBorderERKN2cv3MatERS1_iiiiiRKNS0_7Scalar_IdEE", "_Unwind_Complete", "_ZNK2cv7linemod13ColorGradient4nameEv", "_ZN2cv3SVDclERKNS_11_InputArrayEi", "cvLoadImage", "_ZN2cv3ogl6Arrays18resetTexCoordArrayEv", "_ZN3Imf14TiledInputFile4DataD0Ev", "_ZN2cv23VectorDescriptorMatcherD2Ev", "_ZN2cv21ImageLogPolProjection14initProjectionEdd", "_ZN17FaceDetectionList7AddElemEP4Face", "_ZN2cv6Retina26activateContoursProcessingEb", "_ZN2cv17CascadeClassifier29setFaceDetectionMaskGeneratorEv", "_ZN6cvtest9ArrayTest10fill_arrayEiiiRN2cv3MatE", "_ZN2cv17ParvoRetinaFilter23_OPL_OnOffWaysComputingEv", "_ZNK2cv3ocl13HOGDescriptor11getWinSigmaEv", "_ZN2cv7fisheye13stereoRectifyERKNS_11_InputArrayES3_S3_S3_RKNS_5Size_IiEES3_S3_RKNS_12_OutputArrayESA_SA_SA_SA_iS7_dd", "_ZN2cv5flann16SavedIndexParamsC1ERKSs", "Java_org_opencv_core_Core_ellipse2Poly_10", "Java_org_opencv_objdetect_CascadeClassifier_delete", "Java_org_opencv_imgproc_Imgproc_morphologyEx_11", "Java_org_opencv_core_Mat_n_1cross", "_ZN2cv9fromUtf16ERKSbIwSt11char_traitsIwESaIwEE", "_ZN2cv23evaluateFeatureDetectorERKNS_3MatES2_S2_PSt6vectorINS_8KeyPointESaIS4_EES7_RfRiRKNS_3PtrINS_15FeatureDetectorEEE", "_ZN7CvDTree5trainEP8CvMLData13CvDTreeParams", "Java_org_opencv_video_Video_calcOpticalFlowSF_11", "_ZN2cv25ForestTreeBestSplitFinderC1EP12CvForestTreeP11CvDTreeNode", "cvCreateContourTree", "_ZN2cv6Retina9inputSizeEv", "_ZN4perf19performance_metrics5clearEv", "_ZN21CvANN_MLP_TrainParamsC1E14CvTermCriteriaidd", "cvMemStorageAllocString", "_ZN2cv22OneWayDescriptorObjectC1E6CvSizeiRKSsS3_S3_fffi", "Java_org_opencv_ml_EM_EM_11", "_ZN17CvModelEstimator211checkSubsetEPK5CvMati", "_ZN2cv17LatentSvmDetector15ObjectDetectionC1Ev", "_ZN2cv10BriskLayer14getAgastPointsEiRSt6vectorINS_8KeyPointESaIS2_EE", "_ZN17CvCapture_Android8setFrameEPKvi", "_ZN2cv7inpaintERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi", "_ZN2cv3oclorERKNS0_6oclMatES3_", "_ZN7testing8UnitTestD1Ev", "Java_org_opencv_imgproc_Moments_set_1nu12_10", "_ZNK2cv10ExrDecoder10newDecoderEv", "_ZN2cv11writeScalarERNS_11FileStorageERKSs", "_ZN2cv14PatchGeneratorC1Edddbdddddd", "jpc_mqenc_init", "cvPyrUp", "_Z36cvCreateModuleBlobTrackAnalysisHistPv", "_ZN7Sampler7overlapERS_", "_ZN2cv3ocl26BruteForceMatcher_OCL_base5matchERKNS0_6oclMatERSt6vectorINS_6DMatchESaIS6_EERKS5_IS2_SaIS2_EE", "cvInitSystem", "_Z26Mat_to_vector_vector_PointRN2cv3MatERSt6vectorIS2_INS_6Point_IiEESaIS4_EESaIS6_EE", "cvLoadLatentSvmDetector", "_ZNK3Imf14TypedAttributeIN5Imath4Vec2IdEEE12writeValueToERNS_7OStreamEi", "_ZN2cv6divideEdRKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN21FaceDetectionListElemC1EP4FacePS_", "_ZN2cv14SpinImageModel7computeEv", "_ZN11CvBoostTreeD1Ev", "Java_org_opencv_objdetect_HOGDescriptor_get_1nlevels_10", "_ZN2cv12VideoCaptureC1ERKSs", "cvCreateTrackbar2", "_ZN7testing18TestEventListenersC1Ev", "_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE", "_ZN8CvModuleC2EP12CvModuleInfo", "_ZN2cv5FREAKD2Ev", "Java_org_opencv_contrib_Contrib_chamerMatching_11", "_ZN2cv9Algorithm3setEPKcRKSs", "_ZN2cv21FernDescriptorMatcher12knnMatchImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEiRKS4_IS1_SaIS1_EEb", "Java_org_opencv_imgproc_Moments_delete", "jpc_tsfb_getbands", "_ZN11CvSVMSolverD0Ev", "_ZNK7testing10TestResult15GetTestPropertyEi", "_ZN3Imf15OpaqueAttributeC1ERKS0_", "_ZN2cv20DTreeBestSplitFinder4joinERS0_", "Java_org_opencv_imgproc_Imgproc_Laplacian_11", "_ZN2cv24GenericDescriptorMatcherC2Ev", "_ZTv0_n12_N2cv5BRISKD0Ev", "_ZN2cv11VideoWriter7releaseEv", "_ZN2cv24BackgroundSubtractorMOG2C1Ev", "_ZN2cv25BOWImgDescriptorExtractorD0Ev", "Java_org_opencv_ml_CvBoost_train_10", "_ZNK2cv12MatOp_Invert6matmulERKNS_7MatExprES3_RS1_", "_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERNS_9SparseMatEiS4_PPKfbb", "Java_org_opencv_imgproc_Imgproc_findContours_10", "Java_org_opencv_imgproc_Imgproc_cornerMinEigenVal_10", "Java_org_opencv_core_Core_eigen_10", "jpeg_start_compress", "_ZN3Imf11addXDensityERNS_6HeaderERKf", "_Z11icvGaussMxNPdS_iiPS_", "_ZN2cv5FREAKD0Ev", "_ZNK2cv14ChamferMatcher8Template4showEv", "_ZN7CvDTree15update_tree_rncEii", "_ZN2cv3ocl9boxFilterERKNS0_6oclMatERS1_iNS_5Size_IiEENS_6Point_IiEEi", "jpeg_fdct_ifast", "_ZN6cvtest7cmpUlpsERKN2cv3MatES3_iPdPSt6vectorIiSaIiEE", "_ZN2cv9ExceptionC1EiRKSsS2_S2_i", "png_save_uint_32", "_ZNSt9bad_allocD2Ev", "cvErrorFromIppStatus", "_ZN3Imf13worldToCameraERKNS_6HeaderE", "Java_org_opencv_calib3d_StereoBM_StereoBM_11", "_ZN2cv17calcOpticalFlowSFERNS_3MatES1_S1_iiiddidddiddd", "cvCalcOpticalFlowBM", "Java_org_opencv_calib3d_Calib3d_reprojectImageTo3D_10", "_ZNK2cv12_OutputArray9fixedTypeEv", "_ZN6cvtest10randomSizeEii", "_ZNK7testing8UnitTest22failed_test_case_countEv", "_ZNK2cv17CascadeClassifier14getFeatureTypeEv", "_ZN2cv6imshowERKSsRKNS_11_InputArrayE", "_ZN2cv14RandomizedTreeC1Ev", "_ZN11CvSVMSolver5clearEv", "_ZN2cv9SparseMat3HdrC2EiPKii", "_ZN2cv11RBaseStream4skipEi", "_ZNK2cv17DescriptorMatcher20DescriptorCollection13getDescriptorEii", "_ZN2cv17DescriptorMatcher3addERKSt6vectorINS_3MatESaIS2_EE", "_ZNK2cv8Subdiv2D15getTriangleListERSt6vectorINS_3VecIfLi6EEESaIS3_EE", "png_set_cHRM_fixed", "_ZN2cv25createEigenFaceRecognizerEid", "_ZNK2cv3of211ChowLiuTree17getImgDescriptorsEv", "_ZN2cv3ocl21StereoConstantSpaceBP25estimateRecommendedParamsEiiRiS2_S2_S2_", "_ZNK3Imf11TileOffsets7isEmptyEv", "_ZNK2cv11_InputArray4sizeEi", "_ZN2cv14RandomizedTree10addExampleEiPh", "_ZN2cv11FileStorageC1EP13CvFileStorage", "_ZN2cv17BasicRetinaFilter37_local_squaringHorizontalCausalFilterEPKfPfjjPKj", "_ZN7testing8internal2RE4InitEPKc", "_ZN3Imf17ScanLineInputFile4DataC2EPNS_7IStreamEi", "cvInRangeS", "_ZN2cv23OneWayDescriptorMatcher6ParamsC1EiNS_5Size_IiEESsSsSsfff", "png_save_int_32", "_ZN2cv9Algorithm12setAlgorithmEPKcRKNS_3PtrIS0_EE", "_ZNSt9bad_allocD0Ev", "_ZN8CvModuleC1EP12CvModuleInfo", "_ZN7testing8internal2RED1Ev", "jas_iccprof_setattr", "png_write_info", "_ZN2cv11RetinaColor15clearAllBuffersEv", "_ZN2cv3ocl17KNearestNeighbourD1Ev", "_ZN21DetectionBasedTracker21SeparateDetectionWorkC2ERS_RKSs", "_ZN2cv25fastNlMeansDenoisingMultiERKNS_11_InputArrayERKNS_12_OutputArrayEiifii", "_ZN3Imf6HeaderC1ERKN5Imath3BoxINS1_4Vec2IiEEEES7_fRKNS3_IfEEfNS_9LineOrderENS_11CompressionE", "_ZN7testing8internal11ScopedTraceC2EPKciRKNS_7MessageE", "Java_org_opencv_video_BackgroundSubtractorMOG2_BackgroundSubtractorMOG2_12", "cvEstimateHMMStateParams", "_ZN7testing8internal20DoubleNearPredFormatEPKcS2_S2_ddd", "_ZN7testing8internal18CmpHelperSTRCASEEQEPKcS2_S2_S2_", "png_write_data", "_ZN7testing8TestCaseD2Ev", "_ZN3Imf8TimeCode10setMinutesEi", "Java_org_opencv_contrib_StereoVar_delete", "_ZN2cv14RandomizedTree5trainERKSt6vectorINS_12BaseKeypointESaIS2_EERNS_3RNGERNS_14PatchGeneratorEiiji", "_ZN8CvMLData14change_var_idxEib", "jpeg_gen_optimal_table", "_ZN2cv20LogPolar_OverlappingC2EiiNS_6Point_IiEEidiii", "TIFFScanlineSize", "jpc_ft_fwdlift_col", "_ZN2cv9composeRTERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_S5_S5_S5_S5_S5_S5_S5_S5_", "_ZN16CvDTreeTrainData13get_cv_labelsEP11CvDTreeNodePi", "_ZN23CvFuzzyMeanShiftTracker5trackEP9_IplImageS1_ibi", "_ZN6cvtest2TS16set_gtest_statusEv", "_ZN3Imf9InputFileC2ERNS_7IStreamEi", "cvAlloc", "_ZN6cvtest10randomSizeERN2cv3RNGEiidRSt6vectorIiSaIiEE", "_ZN7testing8internal14CmpHelperSTREQEPKcS2_S2_S2_", "TIFFReadRGBAStrip", "_ZN2cv21CvHybridTrackerParamsC1EffNS_22CvFeatureTrackerParamsENS_24CvMeanShiftTrackerParamsENS_13CvMotionModelE", "Java_org_opencv_calib3d_StereoSGBM_delete", "cvGetRectSubPix", "_ZN2cvplERKNS_7Scalar_IdEERKNS_3MatE", "cvCornerHarris", "_ZN6cvtest13minMaxLocGoldERKN2cv3MatEPdS4_PNS0_6Point_IiEES7_S3_", "_ZN2cv3ocl9sortByKeyERNS0_6oclMatES2_jib", "_Z19vector_Vec4f_to_MatRSt6vectorIN2cv3VecIfLi4EEESaIS2_EERNS0_3MatE", "cvDCT", "_ZN3Imf17xDensityAttributeERKNS_6HeaderE", "Java_org_opencv_core_Core_mulSpectrums_11", "_TIFFNoStripDecode", "jpc_getms", "_ZN2cv23VectorDescriptorMatcherD1Ev", "_ZN2cv20PlanarObjectDetectorD2Ev", "_ZN3Imf19worldToNDCAttributeERKNS_6HeaderE", "Java_org_opencv_core_Mat_n_1eye__III", "cvHoughCircles", "_ZN2cv3ocl25matchTemplateNaive_SQDIFFERKNS0_6oclMatES3_RS1_i", "_ZN3Imf14TypedAttributeINS_12PreviewImageEE14staticTypeNameEv", "_ZNK3Imf14TiledInputFile9levelModeEv", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1term_1crit_10", "jpc_pchglist_destroy", "_ZN2cv17cornerMinEigenValERKNS_11_InputArrayERKNS_12_OutputArrayEiii", "_ZN2cv9normalizeERKNS_11_InputArrayERKNS_12_OutputArrayEddiiS2_", "cvPutText", "_ZNK2cv15RTreeClassifier12getSignatureEP9_IplImagePf", "jas_stream_rewind", "_ZN2cv14SpinImageModel15spinCorrelationERKNS_3MatES3_fRf", "_ZN2cv7linemod17getDefaultLINEMODEv", "_ZN7testing8internal10ParseInt32ERKNS_7MessageEPKcPi", "_ZN10CvVSModuleC1Ev", "TIFFTileRowSize", "Java_org_opencv_ml_CvKNearest_find_1nearest_10", "_ZN2cv9videostab9getMotionEiiRKSt6vectorINS_3MatESaIS2_EE", "_ZN3Imf10addCapDateERNS_6HeaderERKSs", "_ZNK2cv26GridAdaptedFeatureDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "Java_org_opencv_ml_CvSVMParams_get_1p_10", "_ZN2cv13LevMarqSparse14ask_for_projacER5CvMat", "cvConvertImage", "_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZNK2cv10PxMEncoder17isFormatSupportedEi", "_ZNK2cv11TiffDecoder10newDecoderEv", "_ZN2cv16OneWayDescriptorD1Ev", "_ZN17CvCamShiftTracker12track_objectEPK9_IplImage", "_ZN2cv11RNG_MT19937cvjEv", "png_get_x_offset_inches_fixed", "_ZN2cv3ocl16openCLReadBufferEPNS0_7ContextEP7_cl_memPvj", "_ZN2cv3ogl6BufferC2Eiiijb", "_ZN2cv16OneWayDescriptor10InitializeEiP9_IplImagePKci", "_Z21cvCreateBlobTrackerCCv", "png_get_cHRM_fixed", "cvMoveWindow", "_ZN2cv7linemod8Modality6createERKNS_8FileNodeE", "_ZN2cv3ogl6Arrays16resetVertexArrayEv", "_ZN2cv17MagnoRetinaFilterD0Ev", "_ZN2cv11getTextSizeERKSsidiPi", "Java_org_opencv_imgproc_Subdiv2D_delete", "_ZN13CvCalibFilter14SetCameraCountEi", "_ZN5RFaceC2EP12FaceTemplate", "cvCircle", "_ZN2cv6detail14FeaturesFinderclERKNS_3MatERNS0_13ImageFeaturesE", "_ZN2cv3ogl10checkErrorEPKciS2_", "_ZN3Imf14TiledInputFileD1Ev", "jpeg_make_c_derived_tbl", "_ZN3Imf11StdOSStreamC1Ev", "_ZN3Imf6Header6insertERKSsRKNS_9AttributeE", "_ZN3Imf8RGBtoXYZENS_14ChromaticitiesEf", "_ZNK16CvObjectDetector16GetMaxBorderSizeEv", "_ZN3Imf9Attribute9knownTypeEPKc", "_ZN2cv14ChamferMatcher8Matching11findContourERNS_3MatERSt6vectorISt4pairIiiESaIS6_EE", "_ZN9CvANN_MLP6createERKN2cv3MatEidd", "_ZNK7testing8internal8FilePath21FileOrDirectoryExistsEv", "Java_org_opencv_features2d_DescriptorExtractor_create_10", "_ZN2cv6detail21GraphCutSeamFinderGpu10findInPairEjjNS_5Rect_IiEE", "_ZNK7testing8UnitTest20original_working_dirEv", "_ZN2cv12mulSpectrumsERKNS_11_InputArrayES2_RKNS_12_OutputArrayEib", "Java_org_opencv_gpu_DeviceInfo_majorVersion_10", "_ZNK2cv25BOWImgDescriptorExtractor13getVocabularyEv", "_ZNK2cv12_OutputArray12getGpuMatRefEv", "png_do_check_palette_indexes", "cvFillConvexPoly", "Java_org_opencv_core_Mat_n_1assignTo__JJI", "_ZN2cv17MagnoRetinaFilterC2Ejj", "cvResetImageROI", "_ZN2cv5flann17KMeansIndexParamsC1EiiN7cvflann20flann_centers_init_tEf", "_ZN2cv18CvMeanShiftTracker17newTrackingWindowENS_3MatENS_5Rect_IiEE", "Java_org_opencv_ml_EM_train_11", "Java_org_opencv_imgproc_Moments_set_1m11_10", "_ZN2cv12LBPEvaluator8setImageERKNS_3MatENS_5Size_IiEE", "_ZN3Imf6Header10dataWindowEv", "_ZN10__cxxabiv112__unexpectedEPFvvE", "_ZN3Imf17ScanLineInputFile4DataD0Ev", "Java_org_opencv_calib3d_Calib3d_rectify3Collinear_10", "_ZN2cv16setOpenGlContextERKSs", "png_get_iCCP", "_ZN3Imf13ZipCompressorD2Ev", "_ZN17CirclesGridFinder21doesIntersectionExistERKSt6vectorINS_7SegmentESaIS1_EERKS0_IS3_SaIS3_EE", "_ZN2cv11randShuffleERKNS_12_OutputArrayEdPNS_3RNGE", "_Z23icvMakeScanlinesLengthsPiiS_", "_ZN2cv8Subdiv2D6VertexC2ENS_6Point_IfEEbi", "_ZN3Imf14TypedAttributeINS_15TileDescriptionEE13readValueFromERNS_7IStreamEii", "_ZN4perf10Regression5writeERKN2cv11_InputArrayE", "_ZN7testing8internal17TestEventRepeater18OnTestProgramStartERKNS_8UnitTestE", "_ZN7CvDTree18find_split_ord_regEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN2cv6detail12DpSeamFinder14findComponentsEv", "_ZN2cv9TickMeter5startEv", "_ZN2cv9videostab17OnePassStabilizer5setUpERNS_3MatE", "png_write_end", "_ZN2cv10StereoSGBMC1Ev", "_ZN7CvDTree4readEP13CvFileStorageP10CvFileNode", "_ZN6cvtest13DeviceManager7loadAllEv", "_ZN2cv7linemod11DepthNormalC2Ev", "_ZN3Iex13throwErrnoExcERKSs", "_ZNK7testing8UnitTest19disabled_test_countEv", "_ZN2cv3PCAC2ERKNS_11_InputArrayES3_ii", "_ZN11CvSVMSolver15solve_one_classEiiPPKfP12CvMemStorageP11CvSVMKernelPdR17CvSVMSolutionInfo", "TIFFDefaultTileSize", "_ZN2cv19getBuildInformationEv", "_ZN4epnp8qr_solveEP5CvMatS1_S1_", "cvCreateGaussianBGModel", "_ZN6cvtest6cmpEpsERKN2cv3MatES3_PddPSt6vectorIiSaIiEEb", "_ZN2cv21initModule_features2dEv", "_ZN2cv12HOGEvaluatorC1Ev", "_ZN10CvVSModule11SetTypeNameEPKc", "_ZN2cv17createDerivFilterEiiiiii", "png_read_end", "cvWriteFrame", "_ZTv0_n24_NK2cv5FREAK4infoEv", "_ZN2cv2LUEPfjiS0_ji", "_ZTv0_n12_N2cv15FeatureDetectorD1Ev", "_ZN2cv3ocl26BruteForceMatcher_OCL_base3addERKSt6vectorINS0_6oclMatESaIS3_EE", "Java_org_opencv_ml_CvParamGrid_get_1max_1val_10", "_ZN14CameraActivityD1Ev", "cv2DRotationMatrix", "Java_org_opencv_core_Core_divide_14", "_ZN2cv17LatentSvmDetector5clearEv", "TIFFSetupStrips", "_ZN2cv3ocl5CannyERKNS0_6oclMatES3_RS1_ddb", "_ZN3Imf14TypedAttributeIiE14staticTypeNameEv", "cvApproxPoly", "cvEndWriteStruct", "_ZN6cvtest8multiplyERKN2cv3MatES3_RS1_d", "_ZN2cv16BaseColumnFilterC1Ev", "_ZN3Imf14TypedAttributeIdE14staticTypeNameEv", "Java_org_opencv_imgproc_Imgproc_invertAffineTransform_10", "__extendsfdf2", "_ZNK2cv7MatExpr4sizeEv", "_ZN6cvtest7PrintToERKNS_6UseRoiEPSo", "_ZSt9terminatev", "_ZN2cv3ocl4MOG2clERKNS0_6oclMatERS2_f", "Java_org_opencv_core_Core_solve_11", "_ZN4FaceC1EP12FaceTemplate", "_ZN2cv9fastAtan2Eff", "_ZN2cv5flann11IndexParams9setStringERKSsS3_", "_ZN7testing8TestCase11ClearResultEv", "Java_org_opencv_core_Core_bitwise_1or_10", "_ZNK9CvANN_MLP12write_paramsEP13CvFileStorage", "_ZN11FaceFeatureC2EdPvb", "_ZNK3Imf14TypedAttributeIN5Imath8Matrix33IdEEE12writeValueToERNS_7OStreamEi", "_ZN2cv8imdecodeERKNS_11_InputArrayEiPNS_3MatE", "_ZNK2cv5MatOp4typeERKNS_7MatExprE", "_ZN2cv6RetinaD0Ev", "_ZNK2cv3ocl9CvSVM_OCL7predictEiiRNS_3MatEb", "Java_org_opencv_ml_CvBoost_predict_10", "_ZN2cv15subspaceProjectERKNS_11_InputArrayES2_S2_", "_ZN2cv9StereoVarD1Ev", "png_read_row", "_ZN2cv12VideoCaptureD0Ev", "_ZN3GMM12initLearningEv", "Java_org_opencv_imgproc_Moments_set_1m00_10", "_ZN9IlmThread6ThreadC2Ev", "_ZN2cv14FernClassifierC2ERKSt6vectorIS1_INS_6Point_IfEESaIS3_EESaIS5_EERKS1_INS_3MatESaISA_EERKS1_IS1_IiSaIiEESaISG_EEiiiiiiiRKNS_14PatchGeneratorE", "_ZN4perf10Regression22getCurrentTestNodeNameEv", "Java_org_opencv_core_Mat_n_1submat_1rr", "_ZNK7testing8internal8FilePath12CreateFolderEv", "jpc_validate", "cvCalcPGH", "_Z25Mat_to_vector_vector_charRN2cv3MatERSt6vectorIS2_IcSaIcEESaIS4_EE", "cvStartAppendToSeq", "png_get_user_transform_ptr", "_ZN2cv23VectorDescriptorMatcher15isMaskSupportedEv", "Java_org_opencv_imgproc_Imgproc_erode_10", "_ZN4perf10Regression4initERKSsS2_", "png_write_sBIT", "_ZN2cv12FilterEngine5applyERKNS_3MatERS1_RKNS_5Rect_IiEENS_6Point_IiEEb", "cvSetMemoryManager", "_ZN2cv11TiffDecoder8readDataERNS_3MatE", "_ZN7testing18TestEventListenersC2Ev", "_ZN6cvtest10randomTypeERN2cv3RNGEiii", "png_read_filter_row", "_ZN2cv3ogl6BufferC2EiiiNS1_6TargetEb", "_ZN2cv11_InputArrayC1ERKNS_3gpu6GpuMatE", "_ZN2cv19subspaceReconstructERKNS_11_InputArrayES2_S2_", "_ZN2cv3of211ChowLiuTree11calcMutInfoEii", "_ZN17CvCamShiftTracker13set_hist_dimsEiPi", "cvValidateDisparity", "png_get_x_pixels_per_inch", "_ZN5Graph10removeEdgeEjj", "_ZN2cv5flann11IndexParamsC2Ev", "_ZN9CvGBTrees18find_optimal_valueEPK5CvMat", "_ZN2cv10PngEncoderC2Ev", "_ZN2cv11cornerScoreILi12EEEiPKhPKii", "_ZN2cv12LBPEvaluatorD1Ev", "_ZN3Imf12PreviewImageaSERKS0_", "Java_org_opencv_calib3d_StereoSGBM_get_1preFilterCap_10", "_ZN2cv12RLByteStreamD1Ev", "_ZN3Imf13B44CompressorC2ERKNS_6HeaderEjjb", "_ZN2cv3ocl6oclMatcvNS_12_OutputArrayEEv", "_ZNK3Imf14TiledInputFile8fileNameEv", "Java_org_opencv_core_Mat_n_1inv__J", "Java_org_opencv_ml_CvSVMParams_set_1coef0_10", "_ZNK2cv7MatExpr3rowEi", "_ZN2cv5flann11IndexParamsC1Ev", "_ZN2cv3ocl13matchTemplateERKNS0_6oclMatES3_RS1_iRNS0_16MatchTemplateBufE", "_TIFFsetString", "_ZN6cvtest9transposeERKN2cv3MatERS1_", "png_create_struct_2", "_ZN2cv17ParvoRetinaFilterD2Ev", "_ZN24CvBlobTrackPredictKalmanC2Ev", "_ZN2cv3ocl26BruteForceMatcher_OCL_base16knnMatchDownloadERKNS0_6oclMatES4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "_ZN2cv3of26FabMap7compareERKSt6vectorINS_3MatESaIS3_EERS2_INS0_6IMatchESaIS8_EEbRKS3_", "_ZN2cv17DescriptorMatcher5matchERKNS_3MatERSt6vectorINS_6DMatchESaIS5_EERKS4_IS1_SaIS1_EE", "_ZN7CvDTree9free_treeEv", "_Z20normalizeAndTruncateP16CvLSVMFeatureMapf", "_ZN5RFaceD2Ev", "cvTriangulatePoints", "_ZN2cv19GenRandomAffinePoseEv", "_ZNK2cv11MatOp_AddEx6divideEdRKNS_7MatExprERS1_", "png_reset_zstream", "_ZN10CvKNearest5trainEPK5CvMatS2_S2_bib", "Java_org_opencv_calib3d_Calib3d_getOptimalNewCameraMatrix_11", "_ZN2cv3PtrINS_8GlBuffer4ImplEE10delete_objEv", "_ZN2cv5mergeERKSt6vectorINS_3MatESaIS1_EERKNS_12_OutputArrayE", "cvCreateChildMemStorage", "_ZN3Imf14TypedAttributeIN5Imath8Matrix33IdEEE13readValueFromERNS_7IStreamEii", "_Z12FillGrayRow4PhS_iS_", "Java_org_opencv_ml_CvSVMParams_get_1coef0_10", "png_do_invert", "_ZN7testing8internal23DefaultDeathTestFactory6CreateEPKcPKNS0_2REES3_iPPNS0_9DeathTestE", "_ZNK17CirclesGridFinder19getDetectedGridSizeEv", "_ZN4CvEMC2EPK5CvMatS2_10CvEMParamsPS0_", "Java_org_opencv_video_BackgroundSubtractorMOG_BackgroundSubtractorMOG_10", "_ZN2cv17BasicRetinaFilter31_verticalCausalFilter_IrregularEPfjjPKf", "_ZN2cv5flann5IndexD1Ev", "_ZN2cv11setIdentityERKNS_12_OutputArrayERKNS_7Scalar_IdEE", "_ZNK5Graph12getNeighborsEj", "_ZN2cv3MatC2ERKNS_3gpu6GpuMatE", "_ZNK2cv9Algorithm12getMatVectorERKSs", "_ZN2cv11_InputArrayC1ERKSt6vectorINS_3MatESaIS2_EE", "_ZN4perf10Regression3addEPNS_8TestBaseERKSsRKN2cv11_InputArrayEdNS_10ERROR_TYPEE", "png_write_pCAL", "_Z17vector_int_to_MatRSt6vectorIiSaIiEERN2cv3MatE", "_Z8icvCubicdddPd", "_ZNK2cv13HOGDescriptor9detectROIERKNS_3MatERKSt6vectorINS_6Point_IiEESaIS6_EERS8_RS4_IdSaIdEEdNS_5Size_IiEESG_", "_ZN2cv3expERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv14RandomizedTreeC2Ev", "_ZNK2cv3ocl7Context13getDeviceInfoEv", "_TIFFFindFieldByName", "TIFFCheckpointDirectory", "jas_stream_putc_func", "_ZN2cv17BasicRetinaFilter31_squaringSpatiotemporalLPfilterEPKfPfj", "Java_org_opencv_imgproc_Moments_set_1m03_10", "_ZN7testing8internal24XmlUnitTestResultPrinter26RemoveInvalidXmlCharactersERKSs", "_ZNSt8bad_castD0Ev", "_ZN2cv24GenericDescriptorMatcher5trainEv", "_ZN3Imf15OpaqueAttributeD1Ev", "_ZN7CvDTree5clearEv", "_ZN7testing4Test8TearDownEv", "_ZN2cv18accumulateWeightedERKNS_11_InputArrayERKNS_12_OutputArrayEdS2_", "_ZN3Imf8TimeCode7setBgf1Eb", "Java_org_opencv_highgui_VideoCapture_n_1retrieve__JJI", "_Z23icvGetCoefficientStereoP9CvMatrix36CvSizePfS2_PiS3_S3_", "_ZNK9CvANN_MLP12scale_outputEPK5CvMatPS0_", "png_set_alpha_mode", "_ZN9IlmThread9TaskGroupD1Ev", "_ZN2cv3ocl9CvSVM_OCLC1ERKNS_3MatES4_S4_S4_11CvSVMParams", "_ZN13CvCalibFilter10DrawPointsEPP5CvMat", "_ZN2cv3ocl12ProgramCache10progLookupERKSs", "_ZNK9IlmThread9Semaphore5valueEv", "_ZN2cv7addTextERKNS_3MatERKSsNS_6Point_IiEE6CvFont", "_ZN10__cxxabiv117__pbase_type_infoD0Ev", "LogL16fromY", "__cmpsf2", "jpc_pchglist_remove", "Java_org_opencv_imgproc_Imgproc_Scharr_10", "_ZN13CvFaceElement6EnergyEv", "_ZN2cv3ocl20BackgroundSubtractorD0Ev", "_ZN13CvBoostParamsC1EiidibPKf", "Java_org_opencv_ml_CvANN_1MLP_CvANN_1MLP_10", "jpeg_write_m_header", "_ZNK7testing8internal8FilePath21FindLastPathSeparatorEv", "jpc_mqdec_getbit_func", "_Z28vector_vector_Point2f_to_MatRSt6vectorIS_IN2cv6Point_IfEESaIS2_EESaIS4_EERNS0_3MatE", "Java_org_opencv_objdetect_CascadeClassifier_empty_10", "_ZNK2cv9GlTexture6unbindEv", "cvReadRawData", "_ZN2cv16CvFeatureTracker28updateTrackingWindowWithFlowENS_3MatE", "png_get_io_chunk_name", "cvPolarToCart", "_ZN2cv19FastFeatureDetectorC2Eib", "__gnu_unwind_frame", "TIFFMergeFieldInfo", "_ZN21CvANN_MLP_TrainParamsC2E14CvTermCriteriaidd", "_ZN2cv3ogl6Arrays15resetColorArrayEv", "_ZN2cv5BRISKC2ERSt6vectorIfSaIfEERS1_IiSaIiEEffS6_", "_ZN12CvFuzzyPointC2Edd", "_ZN2cv16FileNodeIteratorpLEi", "freeFeaturePyramidObject", "_ZNK3Imf8TimeCode4bgf1Ev", "_ZN2cv3of29FabMapFBO8compInfoERKNS1_9WordStatsES4_", "Java_org_opencv_core_Mat_n_1dot", "_ZN2cv9ExceptionC2Ev", "_ZN10CvVSModule11GetParamStrEPKc", "_ZN3Imf11StdOSStreamC2Ev", "jas_iccprof_dump", "_ZN2cv17CommandLineParserC1EiPKPKcS2_", "_ZN2cv20BackgroundSubtractorD0Ev", "_Z17icvIntersectLinesddddddddPd", "jas_image_readcmpt2", "Java_org_opencv_features2d_DescriptorMatcher_knnMatch_11", "_ZN23CvFuzzyMeanShiftTracker12FuzzyResizerC2Ev", "_ZN2cv3ocl3maxERKNS0_6oclMatES3_RS1_", "_ZNK7testing8TestCase21reportable_test_countEv", "_ZN7testing8internal14GetThreadCountEv", "_ZN2cv17LogPolar_Adjacent10create_mapEiiiidd", "_ZN2cv21ImageLogPolProjection6resizeEjj", "_ZNK13CvCalibFilter13GetFrameCountEPi", "TIFFWriteCustomDirectory", "jpc_qmfb_split_colgrp", "_ZN2cv18CvMeanShiftTracker20updateTrackingWindowENS_3MatE", "_ZN2cv17LogPolar_AdjacentC1EiiNS_6Point_IiEEiddiii", "_Z24cvCreateBlobTrackerMSFGSv", "_ZN2cv9AlgorithmD0Ev", "_ZThn4_N2cv8superres15SuperResolution5resetEv", "_ZN2cv8StereoBMC2Eiii", "_ZN2cv8stopLoopEv", "_ZN2cv3ocl8CannyBuf6createERKNS_5Size_IiEEi", "Java_org_opencv_features2d_DescriptorMatcher_create_10", "Java_org_opencv_ml_CvBoost_CvBoost_12", "_ZN4CvEMC1Ev", "cvClearND", "_ZN4perf8TestBase14getSizeInBytesERKN2cv11_InputArrayE", "_ZN4perf8TestBase22setPerformanceStrategyENS_13PERF_STRATEGYE", "png_do_rgb_to_gray", "Java_org_opencv_core_Core_idct_11", "_ZN2cv17DescriptorMatcher11radiusMatchERKNS_3MatERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfRKS4_IS1_SaIS1_EEb", "_ZN7testing8internal12AssertHelperD2Ev", "_ZNK2cv7linemod11DepthNormal5writeERNS_11FileStorageE", "jas_image_rawsize", "_ZN2cv5BRISKD2Ev", "TIFFSetWriteOffset", "_ZN9CvANN_MLPD1Ev", "_ZN16CvTrainTestSplitC2Ev", "_ZN7testing8internal11CmpHelperEQEPKcS2_xx", "_ZN2cv9StereoVar12VCycle_MyFASERNS_3MatES2_S2_S2_i", "_Z28Mat_to_vector_vector_Point3fRN2cv3MatERSt6vectorIS2_INS_7Point3_IfEESaIS4_EESaIS6_EE", "_ZN6cvtest8BaseTestD1Ev", "_ZN2cv3ocl20OclCascadeClassifier16detectMultiScaleERNS0_6oclMatERSt6vectorINS_5Rect_IiEESaIS6_EEdiiNS_5Size_IiEESB_", "_ZN2cv20OneWayDescriptorBase20InitializeDescriptorEiP9_IplImageRKNS_8KeyPointEPKc", "jas_image_fmttostr", "_ZN13FaceDetection25PostBoostingFindCandidatsEP9_IplImage", "_ZN2cv3ocl8__ModuleD2Ev", "jpc_qmfb_split_col", "__cmpdf2", "cvPyrSegmentation", "_ZN6cvtest8BaseTest10find_paramEP13CvFileStoragePKc", "_ZN17CirclesGridFinder18findCandidateHolesERSt6vectorIjSaIjEES3_bN2cv6Point_IfEES3_S3_", "_ZN2cv16GeneralizedHough6detectERKNS_11_InputArrayES3_S3_RKNS_12_OutputArrayES6_", "_ZNK5CvSVM7predictERKN2cv11_InputArrayERKNS0_12_OutputArrayE", "png_fixed", "_ZN2cvlsERNS_11FileStorageERKSs", "_ZN7testing10TestResult14RecordPropertyERKSsRKNS_12TestPropertyE", "_ZN2cv7linemod8DetectorC2Ev", "TIFFSetFileName", "TIFFFieldWithName", "_ZN2cv3gpu6GpuMatC2ENS_5Size_IiEEiPvj", "_ZN5CvSVM10train_autoERKN2cv3MatES3_S3_S3_11CvSVMParamsi11CvParamGridS5_S5_S5_S5_S5_b", "Java_org_opencv_core_Core_min_11", "_ZN3Imf14TypedAttributeIN5Imath4Vec2IiEEE13readValueFromERNS_7IStreamEii", "_ZN2cv3of27FabMap2C1ERKNS_3MatEddi", "_ZN2cv15calcCovarMatrixERKNS_11_InputArrayERKNS_12_OutputArrayES5_ii", "TIFFRGBAImageOK", "cvProjectPoints", "_ZN2cv6Retina5setupERNS_11FileStorageEb", "_ZN7CvImage5writeEP13CvFileStoragePKc", "_ZN2cv3ocl8CannyBufC2ERKNS0_6oclMatES4_", "_Z32icvComputeProjectMatrices6PointsP5CvMatS0_S0_S0_S0_S0_", "_ZN2cv3gpu6GpuMat4swapERS1_", "_ZN2cv16GeneralizedHough6createEi", "_ZN2cv3ocl15bilateralFilterERKNS0_6oclMatERS1_iddi", "_ZNK2cv14PatchGeneratorclERKNS_3MatENS_6Point_IfEERS1_NS_5Size_IiEERNS_3RNGE", "png_set_sRGB_gAMA_and_cHRM", "_ZN2cv13redirectErrorEPFiiPKcS1_S1_iPvES2_PS2_", "_ZN2cv21invertAffineTransformERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv16convexityDefectsERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_ZN2cv6Retina20setupIPLMagnoChannelEbfffffff", "_ZNK2cv3gpu6GpuMat7reshapeEii", "TIFFReadBufferSetup", "_ZN11CvSVMSolverC2Ev", "cvGetDiag", "_ZN16CvObjectDetector4LoadEPKc", "png_crc_finish", "_ZN2cv9videostab26PyrLkRobustMotionEstimatorC2Ev", "Java_org_opencv_imgproc_Imgproc_matchShapes_10", "_ZN2cv11RetinaColor15_applyRIFfilterEPKfPf", "_ZN3Imf6Header8readFromERNS_7IStreamERi", "png_get_cHRM", "_ZN2cv12FilterEngineC1ERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "_ZN7CvBoost10set_paramsERK13CvBoostParams", "_ZN2cv17ParvoRetinaFilter6resizeEjj", "_ZN2cv9floodFillERKNS_12_OutputArrayES2_NS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i", "_ZNK2cv14RandomizedTree8getIndexEPh", "_ZN2cv20FastFeatureDetector2C2Eibi", "_ZN3Imf13B44CompressorD0Ev", "_ZN7testing8internal18OsStackTraceGetter17CurrentStackTraceEii", "_ZN2cv3of27FabMap2D2Ev", "_ZN14CameraActivity11setPropertyEid", "Java_org_opencv_core_Mat_n_1checkVector__JI", "Java_org_opencv_imgproc_Moments_set_1mu02_10", "_ZN2cv3of29FabMapFBOC1ERKNS_3MatEddiiddii", "Java_org_opencv_imgproc_Imgproc_Laplacian_10", "_ZNK7testing8internal12UnitTestImpl21total_test_case_countEv", "_ZNK7testing8UnitTest17test_to_run_countEv", "_ZN2cv9GlTextureC2ERKNS_11_InputArrayEb", "_ZN3Imf22worldToCameraAttributeERNS_6HeaderE", "_ZN7CvBoost14update_weightsEP11CvBoostTree", "_ZN2cv3ocl6device3hog22extract_descrs_by_rowsEiiiiiiiiRKNS0_6oclMatERS3_", "cvMakeHistHeaderForArray", "cvCreateMat", "_ZN2cv4normERKNS_11_InputArrayEiS2_", "cvSetImageROI", "_ZN2cv3ocl7Context10getContextEv", "TIFFNumberOfTiles", "_ZN3Imf11ChannelList5beginEv", "_ZN2cv11RNG_MT19937cvfEv", "_ZN3Imf11StdOFStreamC1ERSt14basic_ofstreamIcSt11char_traitsIcEEPKc", "_ZN2cv8CholeskyEPdjiS0_ji", "_ZN9CvANN_MLP11read_paramsEP13CvFileStorageP10CvFileNode", "_ZN2cv21pyrMeanShiftFilteringERKNS_11_InputArrayERKNS_12_OutputArrayEddiNS_12TermCriteriaE", "_ZN2cv13HaarEvaluator8setImageERKNS_3MatENS_5Size_IiEE", "_ZN3Imf14TypedAttributeIN5Imath4Vec2IiEEE14staticTypeNameEv", "cvHoughLines", "_ZN2cv17LatentSvmDetector6detectERKNS_3MatERSt6vectorINS0_15ObjectDetectionESaIS5_EEfi", "_ZN9CvGBTreesC1Ev", "_Z9showBoxesP9_IplImagePK7CvPointS3_i8CvScalariii", "_ZN2cv17DescriptorMatcher8knnMatchERKNS_3MatERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiRKS4_IS1_SaIS1_EEb", "_ZN4epnp31compute_barycentric_coordinatesEv", "png_do_read_interlace", "_ZN2cv22findCirclesGridDefaultERKNS_11_InputArrayENS_5Size_IiEERKNS_12_OutputArrayEi", "_ZN2cv6detail11MatchesInfoC1ERKS1_", "png_create_write_struct", "_ZN3Imf12hasLongitudeERKNS_6HeaderE", "_ZN14CameraActivity7connectEi", "_ZN2cv3maxEdRKNS_3MatE", "_ZN2cv12boundingRectERKNS_11_InputArrayE", "cvGetReal1D", "Java_org_opencv_core_Core_bitwise_1xor_10", "_ZN2cv3ocl17KNearestNeighbour5clearEv", "_ZN17CvCamShiftTrackerC2Ev", "_ZN4perf10Regression7getElemERN2cv3MatEiii", "Java_org_opencv_ml_CvBoostParams_get_1split_1criteria_10", "Java_org_opencv_contrib_StereoVar_set_1flags_10", "cvGraphVtxDegree", "TIFFReadScanline", "_ZNK3Imf14TiledInputFile11frameBufferEv", "_ZNK2cv9videostab20GaussianMotionFilter9stabilizeEiPKNS_3MatEi", "__ledf2", "_ZN2cv15BriskScaleSpaceD1Ev", "__gnu_thumb1_case_shi", "_ZNK2cv3PCA11backProjectERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN3Imf15OpaqueAttribute13copyValueFromERKNS_9AttributeE", "_ZN2cv20OneWayDescriptorBase20CreatePCADescriptorsEv", "_ZN2cvdvERKNS_3MatEd", "Java_org_opencv_imgproc_Moments_set_1mu20_10", "_ZNK5CvSVM7predictEPK5CvMatb", "_ZN10CvVSModule11SetNickNameEPKc", "cvCreateGLCM", "Java_org_opencv_calib3d_Calib3d_findCirclesGridDefault_10", "_ZN2cv14FaceRecognizer12getLabelInfoERKi", "_ZN2cv23OneWayDescriptorMatcher5clearEv", "_ZNK3Imf14TypedAttributeISt6vectorISsSaISsEEE12writeValueToERNS_7OStreamEi", "_TIFFNoStripEncode", "_ZN2cv10StereoSGBMC2Eiiiiiiiiiib", "_ZN2cv7MomentsC2Edddddddddd", "_ZN2cv23VectorDescriptorMatcher3addERKSt6vectorINS_3MatESaIS2_EERS1_IS1_INS_8KeyPointESaIS7_EESaIS9_EE", "Java_org_opencv_gpu_DeviceInfo_multiProcessorCount_10", "_ZNK7testing8internal8FilePath14IsAbsolutePathEv", "cvImgToObs_DCT", "Java_org_opencv_gpu_TargetArchs_hasEqualOrLessPtx_10", "TIFFFlush", "_ZNK17CvCapture_Android8isOpenedEv", "cvPtr3D", "_ZN4perf8TestBase14_declareHelper3outERKN2cv12_OutputArrayES5_i", "_ZN2cv12VideoCapture4openERKSs", "Java_org_opencv_imgproc_Imgproc_adaptiveBilateralFilter_10", "_ZN7testing8internal18SetInjectableArgvsEPKSt6vectorISsSaISsEE", "_ZN2cv3gpu6GpuMatC1ERKS1_", "_ZN2cv3ocl15CvSVMKernel_ocl12calc_sigmoidEiiPfRNS_3MatE", "TIFFSwabArrayOfShort", "_ZN3Imf9InputFileD2Ev", "cvCreateHandMask", "cvSetCaptureProperty", "_ZNK17CirclesGridFinder14eraseUsedGraphERSt6vectorI5GraphSaIS1_EE", "TIFFVStripSize64", "_Z19cvTestSeqQueryFramePv", "TIFFTileRowSize64", "_ZN2cv3ocl19openCLExecuteKernelEPNS0_7ContextEPKNS0_12ProgramEntryESsPjS6_RSt6vectorISt4pairIjPKvESaISB_EEiiPKc", "_ZN10CvVSModule8AddParamEPKc", "jpc_ns_invlift_row", "_Z20icvFindBaseTransformP5CvMatS0_", "Java_org_opencv_core_Mat_n_1ones__III", "_ZN2cvplERKNS_7MatExprES2_", "cvGraphAddEdge", "_ZN11CvSVMSolverC2EiiPPKfPaiPdddP12CvMemStorageP11CvSVMKernelMS_FPfiS9_S9_bEMS_FbRiSC_EMS_FvRdSF_E", "_Z20freeFeatureMapObjectPP16CvLSVMFeatureMap", "_ZN2cv11HoughLinesPERKNS_11_InputArrayERKNS_12_OutputArrayEddidd", "_ZN2cv13Jpeg2KDecoderD2Ev", "Java_org_opencv_android_Utils_nBitmapToMat", "_ZNK10CvKNearest13write_resultsEiiiiPKfS1_P5CvMatS3_S3_P7Cv32suf", "_ZN2cv3of26FabMap3PzqEib", "Java_org_opencv_ml_CvGBTreesParams_set_1shrinkage_10", "_ZN9IlmThread4Task5groupEv", "_ZN9IlmThread9TaskGroup4Data7addTaskEv", "cvRandArr", "_ZN9IlmThread10ThreadPool4Data6finishEv", "Java_org_opencv_core_Core_magnitude_10", "_ZN2cv12SurfAdjusterC2Eddd", "TIFFWriteTile", "_ZNK9CvANN_MLP15calc_activ_funcEP5CvMatPKd", "cvRead", "_ZN2cv4blurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEENS_6Point_IiEEi", "_ZNK2cv17DescriptorMatcher20DescriptorCollection4sizeEv", "Java_org_opencv_photo_Photo_fastNlMeansDenoisingMulti_11", "_ZNK5CvSVM18get_support_vectorEi", "_ZN9CvGBTreesD0Ev", "_ZN7testing8internal15GetTimeInMillisEv", "cvSum", "_ZN2cv11RetinaColor29clipRGBOutput_0_maxInputValueEPff", "png_write_pHYs", "_ZN10__cxxabiv119__foreign_exceptionD2Ev", "_ZN2cv3ogl6ArraysC2Ev", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1bp_1dw_1scale_10", "_ZN2cv11RetinaColor6resizeEjj", "_ZN3Imf10OutputFile11writePixelsEi", "_ZNK9IlmThread10ThreadPool4Data7stoppedEv", "_ZNK3Imf13PizCompressor6formatEv", "_ZN7testing7MessagelsEPKw", "_ZN9CvANN_MLP6createEPK5CvMatidd", "_ZNK3Imf11ChannelList3endEv", "Java_org_opencv_objdetect_HOGDescriptor_load_11", "_ZN2cv9Algorithm3setEPKcRKNS_3MatE", "_ZN10CvVSModule9LoadStateEP13CvFileStorageP10CvFileNode", "Java_org_opencv_calib3d_Calib3d_findFundamentalMat_10", "_ZN2cv10PxMEncoderC2Ev", "_ZNK8CvRTrees13get_proximityEPK5CvMatS2_S2_S2_", "_ZN2cv8superres9arrGetMatERKNS_11_InputArrayERNS_3MatE", "_ZN2cv15CvHybridTracker30updateTrackerWithLowPassFilterENS_3MatE", "_ZN2cv3ocl6device3hog22extract_descrs_by_colsEiiiiiiiiRKNS0_6oclMatERS3_", "_ZN2cv3gpu6GpuMatC1ENS_5Size_IiEEiPvj", "Java_org_opencv_imgproc_Moments_set_1mu11_10", "_ZN20CvBlobDetectorSimple13DetectNewBlobEP9_IplImageS1_P9CvBlobSeqS3_", "_ZNK3Imf14TypedAttributeINS_9LineOrderEE12writeValueToERNS_7OStreamEi", "_ZNK2cv10ExrEncoder17isFormatSupportedEi", "TIFFSwabFloat", "_ZN3Imf11addIsoSpeedERNS_6HeaderERKf", "_ZN2cv3addERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i", "_ZN2cv15findCirclesGridERKNS_11_InputArrayENS_5Size_IiEERKNS_12_OutputArrayEiRKNS_3PtrINS_15FeatureDetectorEEE", "_ZN2cv3of26FabMap2pqEi", "cvBGCodeBookClearStale", "_ZN6cvtest21getMatchedPointsCountERKSt6vectorIN2cv8KeyPointESaIS2_EES6_RKS0_INS1_6DMatchESaIS7_EE", "_ZN9CvANN_MLP17calc_output_scaleEPK9CvVectorsi", "TIFFFlushData1", "_ZN3Imf8TimeCodeC2Eiiiibbbbbbiiiiiiii", "_ZN2cv5BRISK14generateKernelERSt6vectorIfSaIfEERS1_IiSaIiEEffS6_", "Java_org_opencv_imgproc_Imgproc_pyrMeanShiftFiltering_11", "_ZN7testing8internal15UnitTestOptions13MatchesFilterERKSsPKc", "_ZNK3Imf14TiledInputFile9numXTilesEi", "Java_org_opencv_imgproc_Imgproc_phaseCorrelateRes_11", "_ZTv0_n24_NK2cv12GFTTDetector4infoEv", "TIFFSwabArrayOfFloat", "_ZN3Imf9InputFile5tFileEv", "_ZNK2cv8GlBuffer4bindEv", "_ZN2cv9videostab26PyrLkRobustMotionEstimator8estimateERKNS_3MatES4_", "_ZN2cv3ocl13setBinaryPathEPKc", "_ZN13CvFMEstimatorC2Ei", "_ZN4CvEMD2Ev", "_ZN3Imf6HeaderC2ERKN5Imath3BoxINS1_4Vec2IiEEEES7_fRKNS3_IfEEfNS_9LineOrderENS_11CompressionE", "_ZN2cv12drawContoursERKNS_12_OutputArrayERKNS_11_InputArrayEiRKNS_7Scalar_IdEEiiS5_iNS_6Point_IiEE", "_ZN3Iex7BaseExcC1ERKS0_", "cvFindNextContour", "cvMulSpectrums", "Java_org_opencv_imgproc_CLAHE_setClipLimit_10", "_ZN6cvtest11getTypeNameEi", "Java_org_opencv_imgproc_Imgproc_Sobel_12", "_ZN2cv13getKernelTypeERKNS_11_InputArrayENS_6Point_IiEE", "_ZN2cv12FilterEngine7proceedEPKhiiPhi", "_ZN4perf8TestBase14_declareHelper2inERKN2cv12_OutputArrayES5_i", "cvMax", "_ZN17CvModelEstimator2D0Ev", "_ZN9CvANN_MLP14train_backpropE9CvVectorsS0_PKd", "_ZN2cv3ocl26BruteForceMatcher_OCL_base19radiusMatchDownloadERKNS0_6oclMatES4_S4_RSt6vectorIS5_INS_6DMatchESaIS6_EESaIS8_EEb", "Java_org_opencv_ml_CvDTree_CvDTree_10", "_ZNK7testing8UnitTest17current_test_caseEv", "_ZNK2cv7linemod8Template5writeERNS_11FileStorageE", "cvCmp", "jas_image_readcmpt", "_ZN21DetectionBasedTracker4stopEv", "Java_org_opencv_core_Core_SVBackSubst_10", "jas_iccprof_createfromcmprof", "_ZN2cv5flann20AutotunedIndexParamsC2Effff", "_TIFFUInt64ToFloat", "_ZNK2cv3ocl13HOGDescriptor17getDescriptorSizeEv", "_ZN7testing8internal11ShouldShardEPKcS2_b", "_ZN2cv6Retina28_convertCvMat2ValarrayBufferENS_3MatERSt8valarrayIfE", "_ZN13CvBlobTracker7SetBlobEiP6CvBlob", "_ZN2cv11RBaseStream4openERKSs", "_ZNK2cv15RTreeClassifier12getSignatureEP9_IplImagePh", "_ZN5CvSVMC2Ev", "_ZN2cv15RTreeClassifier5trainERKSt6vectorINS_12BaseKeypointESaIS2_EERNS_3RNGEiiiji", "_ZN2cv16getTickFrequencyEv", "cvCreateVideoWriter", "_ZN2cv3ocl31createSeparableLinearFilter_GPUEiiRKNS_3MatES3_RKNS_6Point_IiEEdiNS_5Size_IiEE", "_ZN2cv3ocl17cornerMinEigenValERKNS0_6oclMatERS1_iii", "_ZN6cvtest2TS4initERKSs", "_ZN2cv21FernDescriptorMatcher5trainEv", "_ZN2cv20LogPolar_OverlappingC1EiiNS_6Point_IiEEidiii", "_ZN6cvtest7compareERKN2cv3MatES3_RS1_i", "_ZN17CirclesGridFinder17findCandidateLineERSt6vectorIjSaIjEEjbN2cv6Point_IfEES3_", "png_write_sCAL_s", "TIFFReadRGBAImageOriented", "_ZNK4CvEM10getWeightsEv", "Java_org_opencv_core_Mat_n_1t", "_ZN3Imf6Header4findERKSs", "Java_org_opencv_ml_CvKNearest_train_11", "Java_org_opencv_core_Mat_n_1eye__DDI", "Java_org_opencv_core_Mat_n_1diag__J", "_ZN2cv17DescriptorMatcher5trainEv", "jpeg_simple_progression", "_ZN2cv11RNG_MT199377uniformEff", "_Z22cvCreateFGDetectorBaseiPv", "png_warning", "_ZNK2cv17DescriptorMatcher19getTrainDescriptorsEv", "_ZN7testing8internal24ParseGoogleTestFlagsOnlyEPiPPc", "Java_org_opencv_core_Mat_n_1Mat__IIIDDDD", "_ZN4perf8TestBase7getSizeERKN2cv11_InputArrayE", "_ZN2cv11RBaseStreamD0Ev", "_ZN2cv14insertImageCOIERKNS_11_InputArrayEPvi", "TIFFStripSize64", "Java_org_opencv_ml_CvDTreeParams_get_1max_1depth_10", "_ZN2cv3ocl16getBoxFilter_GPUEiiRKNS_5Size_IiEENS_6Point_IiEEi", "_ZN27CirclesGridFinderParametersC2Ev", "_ZN2cv20OneWayDescriptorBase9SetPCALowEP5CvMatS2_", "_Z12_cvWorkSouthiiPP8__CvWorkP12CvPoint2D32fS3_", "_ZN2cv16FileNodeIteratormmEv", "_ZNK2cv9MatOp_Cmp6assignERKNS_7MatExprERNS_3MatEi", "Java_org_opencv_contrib_StereoVar_get_1cycle_10", "cvMatArray", "_ZNK2cv9Algorithm6getMatERKSs", "cvSVBkSb", "_ZTv0_n12_N2cv19DescriptorExtractorD1Ev", "Java_org_opencv_objdetect_HOGDescriptor_load_10", "_ZNK2cv12LBPEvaluator5cloneEv", "_ZN2cv3ocl6device3hog13compute_histsEiiiiiRKNS0_6oclMatES5_S5_RS3_", "cvCreateMemoryLSH", "Java_org_opencv_core_Core_convertScaleAbs_10", "_ZN3Imf13RleCompressorD0Ev", "_ZN2cv11_InputArrayC1ERKNS_3ogl6BufferE", "png_get_compression_buffer_size", "_ZNKSt9exception4whatEv", "png_error", "_ZN4CvEM5trainERKN2cv3MatES3_10CvEMParamsPS1_", "__gnu_ldivmod_helper", "Java_org_opencv_imgproc_CLAHE_setTilesGridSize_10", "TIFFVGetFieldDefaulted", "_ZN2cv15warpPerspectiveERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE", "_ZN2cv3of29FabMapFBOD1Ev", "Java_org_opencv_ml_CvNormalBayesClassifier_delete", "_ZN3Imf14TypedAttributeINS_6EnvmapEE13readValueFromERNS_7IStreamEii", "_ZN2cv6detail21BlocksGainCompensator5applyEiNS_6Point_IiEERNS_3MatERKS4_", "Java_org_opencv_core_Mat_n_1step1__J", "_ZN2cv9BFMatcherC2Eib", "_ZN14CameraActivity15applyPropertiesEv", "_ZNK7testing18TestEventListeners22EventForwardingEnabledEv", "Java_org_opencv_ml_CvRTParams_CvRTParams_10", "_ZN2cv5splitERKNS_3MatEPS0_", "_ZN7testing8internal20StringStreamToStringEPSt18basic_stringstreamIcSt11char_traitsIcESaIcEE", "_ZN2cv17CommandLineParser12analyzeValueIyEET_RKSsb", "_Z19icvSetOpenGlFuncTabPK15CvOpenGlFuncTab", "_ZNK7CvDTree8get_rootEv", "_ZN4FaceD1Ev", "_ZN2cv3ocl13HOGDescriptor15computeGradientERKNS0_6oclMatERS2_S5_", "TIFFClientOpen", "_ZN2cv24GenericDescriptorMatcher4readERKNS_8FileNodeE", "_ZrsRSiR4half", "_ZNK2cv3LDA4saveERKSs", "_ZN17btv_l1_device_ocl8diffSignERKN2cv3ocl6oclMatES4_RS2_", "TIFFSetCompressionScheme", "Java_org_opencv_imgproc_Imgproc_filter2D_11", "png_get_image_width", "Java_org_opencv_features2d_DescriptorExtractor_write_10", "_ZN2cv9videostab17WeightingDeblurer6deblurEiRNS_3MatE", "_ZN2cv3ocl23OclCascadeClassifierBuf23CreateFactorRelatedBufsEiiidPKj6CvSizeS4_", "_ZN3Imf14TypedAttributeINS_8TimeCodeEE13readValueFromERNS_7IStreamEii", "jcopy_sample_rows", "__divsi3", "_ZN2cv15setUseOptimizedEb", "cvGetWindowName", "_ZN2cv6detail12DpSeamFinder4findERKSt6vectorINS_3MatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_", "_ZNK7testing8TestCase17test_to_run_countEv", "_ZN2cv9FormattedC2ERKNS_3MatEPKNS_9FormatterERKSt6vectorIiSaIiEE", "cvReleaseConDensation", "Java_org_opencv_features2d_GenericDescriptorMatcher_radiusMatch_10", "_ZN2cv3ocl20cvPreparePredictDataEPKviPK5CvMatiS5_PPfi", "_ZN2cv5ParamC2EibiMNS_9AlgorithmEKFivEMS1_FviERKSs", "_ZNK3Imf14TypedAttributeIN5Imath8Matrix44IfEEE12writeValueToERNS_7OStreamEi", "_ZN2cv10fitEllipseERKNS_11_InputArrayE", "_ZN7testing14ExitedWithCodeC1Ei", "cvGetImageROI", "_ZN6cvtest9ArrayTest30get_test_array_types_and_sizesEiRSt6vectorIS1_IN2cv5Size_IiEESaIS4_EESaIS6_EERS1_IS1_IiSaIiEESaISB_EE", "png_set_rows", "Java_org_opencv_calib3d_Calib3d_solvePnP_10", "png_set_strip_alpha", "Java_org_opencv_calib3d_Calib3d_findChessboardCorners_10", "TIFFCurrentDirOffset", "jas_image_lookupfmtbyname", "TIFFOpen", "_ZN2cv17FlannBasedMatcherC1ERKNS_3PtrINS_5flann11IndexParamsEEERKNS1_INS2_12SearchParamsEEE", "_ZN2cv12RetinaFilterD2Ev", "png_set_check_for_invalid_index", "_ZN7CvBoost19get_weak_predictorsEv", "_ZNK3Imf10OutputFile6headerEv", "cvEViterbi", "_ZN7testing8internal12UnitTestImpl11RunAllTestsEv", "Java_org_opencv_core_Core_fillPoly_11", "_ZN2cv16BOWKMeansTrainerC2EiRKNS_12TermCriteriaEii", "_ZN2cv24GenericDescriptorMatcher3addERKSt6vectorINS_3MatESaIS2_EERS1_IS1_INS_8KeyPointESaIS7_EESaIS9_EE", "_ZN2cvmiERKNS_3MatERKNS_7MatExprE", "_ZN2cv11FileStorage8writeObjERKSsPKv", "_ZN2cv14ChamferMatcher8Matching14matchEdgeImageERNS_3MatERKNS0_10ImageRangeEfif", "_ZNK2cv3ocl9CvSVM_OCL7predictERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZNK2cv6GlFont4drawEPKci", "_ZN7testing14TestPartResult14ExtractSummaryEPKc", "_ZN3Iex7BaseExc6assignERSt18basic_stringstreamIcSt11char_traitsIcESaIcEE", "_ZThn4_N2cv5BRISKD0Ev", "_ZN2cv8GlCamera24setPerspectiveProjectionEdddd", "_ZN2cv3of211ChowLiuTree3addERKNS_3MatE", "png_get_color_type", "_ZNK7CvDTree16write_tree_nodesEP13CvFileStorage", "_ZN2cv3PtrI5CvMatE10delete_objEv", "_ZN3Imf23whiteLuminanceAttributeERKNS_6HeaderE", "Java_org_opencv_imgproc_Imgproc_convexityDefects_10", "_ZN7testing8internal12UnitTestImpl31GetGlobalTestPartResultReporterEv", "_ZNK3Imf13RleCompressor12numScanLinesEv", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection10imageCountEv", "_ZN11CvSVMParamsC1EiiddddddP5CvMat14CvTermCriteria", "_ZN2cv14RandomizedTree14compressLeavesEj", "_ZN2cv9getRecallERKSt6vectorINS_6Point_IfEESaIS2_EEf", "Java_org_opencv_core_Core_dct_11", "_ZN3Imf6HeaderaSERKS0_", "_ZN2cv9Algorithm7getListERSt6vectorISsSaISsEE", "_ZN2cv23VectorDescriptorMatcher15radiusMatchImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEfRKS4_IS1_SaIS1_EEb", "TIFFGetCloseProc", "_ZN2cv25getMorphologyColumnFilterEiiii", "_ZN3Imf14TypedAttributeIN5Imath4Vec2IfEEE13readValueFromERNS_7IStreamEii", "LogL16toY", "_ZN2cv11_InputArrayC2ERKNS_3gpu6GpuMatE", "_ZN2cv26convertPointsToHomogeneousERKNS_11_InputArrayERKNS_12_OutputArrayE", "icvConvertWarpCoordinates", "_Z12fftInverse2dPfS_ii", "TIFFCreateCustomDirectory", "_ZN2cv12RetinaFilterD1Ev", "_ZN24CvBlobTrackPredictKalmanD0Ev", "jpc_ms_dump", "_ZN7CvBoost4readEP13CvFileStorageP10CvFileNode", "_ZN2cv9GlTextureC2Eiii", "_Unwind_Resume", "png_set_text", "cvSetData", "_ZN3Imf11TileOffsets9findTilesERNS_7IStreamE", "_ZN2cv17BasicRetinaFilter37_horizontalAnticausalFilter_IrregularEPfjjPKf", "_ZN2cv3of211ChowLiuTree9buildTreeEiRSt4listINS1_4infoESaIS3_EE", "Java_org_opencv_ml_EM_clear_10", "___Unwind_Backtrace", "_ZNK7testing8internal8FilePath27RemoveTrailingPathSeparatorEv", "_ZN2cv14PatchGeneratorC2Ev", "Java_org_opencv_ml_CvGBTrees_CvGBTrees_10", "Java_org_opencv_contrib_StereoVar_StereoVar_11", "_ZN7Sampler7hasbarsEv", "Java_org_opencv_ml_CvGBTrees_predict_10", "_ZN2cv6detail23SphericalPortraitWarper15detectResultRoiENS_5Size_IiEERNS_6Point_IiEES6_", "_ZNK2cv12_OutputArray15getOGlBufferRefEv", "jinit_downsampler", "_ZN2cv16TLSDataContainerC2Ev", "_ZN2cv8Subdiv2D6insertENS_6Point_IfEE", "_ZN2cv6detail16MultiBandBlenderC1Eiii", "_ZN3Imf17isoSpeedAttributeERNS_6HeaderE", "_ZN2cv3gpu11TargetArchs9builtWithENS0_10FeatureSetE", "Java_org_opencv_contrib_StereoVar_get_1maxDisp_10", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRjbMS1_FjvEMS1_FvjERKSs", "_ZN7testing15AssertionResultC2ERKS0_", "_ZN3Imf14TypedAttributeISsE14staticTypeNameEv", "_Z36cvCreateModuleBlobTrackPredictKalmanv", "_ZN2cv17CascadeClassifier17detectSingleScaleERKNS_3MatEiNS_5Size_IiEEiidRSt6vectorINS_5Rect_IiEESaIS8_EERS6_IiSaIiEERS6_IdSaIdEEb", "_ZN2cv5FREAK11selectPairsERKSt6vectorINS_3MatESaIS2_EERS1_IS1_INS_8KeyPointESaIS7_EESaIS9_EEdb", "Java_org_opencv_core_Mat_n_1dims", "_ZNK2cv5MatOp4diagERKNS_7MatExprEiRS1_", "_ZN11CvSVMSolverC1EiiPPKfPaiPdddP12CvMemStorageP11CvSVMKernelMS_FPfiS9_S9_bEMS_FbRiSC_EMS_FvRdSF_E", "jas_image_fmtfromname", "_ZN3Imf12PreviewImageD2Ev", "_ZN8CvRTrees11grow_forestE14CvTermCriteria", "cvRandShuffle", "_ZN2cv15NAryMatIteratorppEv", "_ZNK3Imf6Header10dataWindowEv", "_ZN2cv8superres27createOptFlow_Farneback_OCLEv", "_ZN7testing18TestEventListeners7ReleaseEPNS_17TestEventListenerE", "Java_org_opencv_objdetect_HOGDescriptor_detectMultiScale_10", "_ZN4perf8TestBase14_declareHelper3outERKN2cv12_OutputArrayES5_S5_S5_i", "_ZN2cvanERKNS_3MatERKNS_7Scalar_IdEE", "_ZN2cv11RNG_MT19937cvdEv", "jas_seq2d_create", "_ZNK7testing8internal12UnitTestImpl19disabled_test_countEv", "_ZN6cvtest9ArrayTestD1Ev", "cvFitLine2D", "_ZN2cv14ChamferMatcher26SlidingWindowImageIterator4nextEv", "_ZN7testinglsERSoRKNS_14TestPartResultE", "_ZNK3Imf6Header15tileDescriptionEv", "_ZN2cv17CommandLineParser12analyzeValueIdEET_RKSsb", "cvInitTreeNodeIterator", "cvMemStorageAlloc", "_ZN7testing7MessageC2Ev", "_ZN3Imf15Pxr24Compressor10uncompressEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZNK2cv5BRISKclERKNS_11_InputArrayES3_RSt6vectorINS_8KeyPointESaIS5_EERKNS_12_OutputArrayEb", "_ZN2cv23VectorDescriptorMatcher12knnMatchImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS4_IS4_INS_6DMatchESaIS9_EESaISB_EEiRKS4_IS1_SaIS1_EEb", "_ZN2cv6OctreeD2Ev", "cvReleaseFileStorage", "_Z18Mat_to_vector_RectRN2cv3MatERSt6vectorINS_5Rect_IiEESaIS4_EE", "_ZN2cv6detail12CameraParamsaSERKS1_", "_ZN22CameraWrapperConnector11getPropertyEPviPd", "___Unwind_Resume_or_Rethrow", "_ZNK2cv4MSERclERKNS_3MatERSt6vectorIS4_INS_6Point_IiEESaIS6_EESaIS8_EES3_", "_ZN12CvFuzzyCurveC2Ev", "cvGetDims", "_ZN2cv5SobelERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiddi", "_ZN2cv12RetinaFilter6resizeEjj", "_ZN10CvKNearestC2EPK5CvMatS2_S2_bi", "_ZN3Iex7BaseExcD0Ev", "jpc_mqdec_lpsexchrenormd", "_ZN2cv5mergeEPKNS_3MatEjRKNS_12_OutputArrayE", "_ZNK2cv3ogl9Texture2D5texIdEv", "_ZN2cv10accumulateERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN2cvngERKNS_7MatExprE", "_ZN2cv3PtrI23CvHaarClassifierCascadeE10delete_objEv", "_ZN23CvNormalBayesClassifierC2EPK5CvMatS2_S2_S2_", "getMaxFilterDims", "_ZN21DetectionBasedTracker21SeparateDetectionWorkD1Ev", "_ZN3Imf10CompressorD1Ev", "TIFFSetWarningHandler", "Java_org_opencv_imgproc_Imgproc_floodFill_10", "_ZN3Imf14TiledInputFileD0Ev", "_ZN2cv3ocl25createSeparableFilter_GPUERKNS_3PtrINS0_17BaseRowFilter_GPUEEERKNS1_INS0_20BaseColumnFilter_GPUEEE", "Java_org_opencv_core_Mat_n_1inv__JI", "png_set_tRNS_to_alpha", "_ZN2cv8GlBuffer9mapDeviceEv", "_ZN14CameraActivityD2Ev", "_ZNSt9bad_allocD1Ev", "Java_org_opencv_ml_EM_isTrained_10", "_ZN4CvEMD1Ev", "_ZN2cv11VideoWriterC2Ev", "_ZN6cvtest9randomIntEii", "cvLineAA", "Java_org_opencv_imgproc_Subdiv2D_findNearest_10", "_ZN4epnp12compute_poseERN2cv3MatES2_", "_Z21cvTestSeqGetImageSizePv", "Java_org_opencv_core_Core_SVDecomp_10", "cvCircleAA", "_ZN8CvMLData13set_delimiterEc", "_ZN7testing4Test15HasFatalFailureEv", "_ZN2cv14SpinImageModelC2Ev", "_ZN2cv9Algorithm3setERKSsRKNS_3PtrIS0_EE", "_ZNK2cv3ocl3MOG18getBackgroundImageERNS0_6oclMatE", "_ZN2cv8HOGCacheC1Ev", "jp2_decode", "_ZN2cv17LatentSvmDetector15ObjectDetectionC1ERKNS_5Rect_IiEEfi", "_ZNK2cv12_OutputArray7releaseEv", "Java_org_opencv_gpu_TargetArchs_hasPtx_10", "_ZN17CirclesGridFinder22computeGraphConfidenceERKSt6vectorI5GraphSaIS1_EEbRKS0_IjSaIjEES9_", "Java_org_opencv_calib3d_StereoSGBM_compute_10", "_ZNK2cv5BRISK10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_ZN2cv17LogPolar_Adjacent21subdivide_recursivelyEddiidd", "_ZN23CvNormalBayesClassifierC1ERKN2cv3MatES3_S3_S3_", "_ZN7testing8internal11ScopedTraceD1Ev", "_ZN2cv3ocl12getOclMatRefERKNS_12_OutputArrayE", "Java_org_opencv_imgproc_Imgproc_HoughLinesP_11", "Java_org_opencv_ml_CvGBTrees_train_10", "_ZN21FaceDetectionListElemC2EP4FacePS_", "_ZN2cv9Algorithm12setAlgorithmERKSsRKNS_3PtrIS0_EE", "_ZN2cv14FernClassifierD0Ev", "cvFindDominantPoints", "_ZN2cv19DescriptorExtractorD2Ev", "_ZN7Sampler5coordEii", "_ZN2cv21getLinearColumnFilterEiiRKNS_11_InputArrayEiidi", "TIFFErrorExt", "_ZN7testing8internal24XmlUnitTestResultPrinter18OutputXmlAttributeEPSoRKSsS4_S4_", "_ZN11CvSVMSolver7get_rowEiPf", "_ZN2cv11_InputArrayC1ERKNS_3ogl9Texture2DE", "_ZN14CameraActivityC1Ev", "cvGetSpatialMoment", "_ZN9CvGBTrees4readEP13CvFileStorageP10CvFileNode", "_ZN2cv15RTreeClassifier15setQuantizationEi", "_ZN2cv16SunRasterEncoderD1Ev", "_ZN2cv3Mat5zerosENS_5Size_IiEEi", "Java_org_opencv_video_Video_calcOpticalFlowPyrLK_10", "TIFFIsMSB2LSB", "_ZNK2cv5MatOp12augAssignAndERKNS_7MatExprERNS_3MatE", "cvXor", "Java_org_opencv_video_BackgroundSubtractorMOG_delete", "jinit_compress_master", "Java_org_opencv_calib3d_StereoSGBM_set_1SADWindowSize_10", "_ZN2cv11RetinaColor22runColorDemultiplexingERKSt8valarrayIfEbf", "_ZN2cv12RetinaFilter19setGlobalParametersEfffffffffbbfff", "_ZN3Imf13ZipCompressorD0Ev", "Java_org_opencv_imgproc_Subdiv2D_getVertex_11", "_ZN4perf10Regression6verifyEN2cv8FileNodeENS1_3MatEdSsNS_10ERROR_TYPEE", "_ZNK7testing8TestCase19disabled_test_countEv", "_ZN2cv6repeatERKNS_3MatEii", "_ZN2cv3ocl6repeatERKNS0_6oclMatEiiRS1_", "_ZN2cv16BOWKMeansTrainerD1Ev", "_ZN2cv3ocl15CvSVMKernel_ocl17calc_non_rbf_baseEiiPfRNS_3MatE", "_ZN2cv11JpegEncoderD0Ev", "_ZN2cv6RetinaC1ENS_5Size_IiEEbNS_26RETINA_COLORSAMPLINGMETHODEbdd", "Java_org_opencv_ml_CvBoost_CvBoost_10", "jpeg_idct_float", "_ZN2cv3ocl3dftERKNS0_6oclMatERS1_NS_5Size_IiEEi", "_ZN7testing8internal16ForkingDeathTestC2EPKcPKNS0_2REE", "Java_org_opencv_ml_CvERTrees_delete", "_ZN2cv7fisheye13distortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_d", "_ZN2cv21findChessboardCornersERKNS_11_InputArrayENS_5Size_IiEERKNS_12_OutputArrayEi", "_ZN6cvtest10patchZerosERN2cv3MatEd", "_ZN7testing8internal38DefaultPerThreadTestPartResultReporterC2EPNS0_12UnitTestImplE", "jpc_ft_invlift_row", "_ZN3Imf11StdIFStream5seekgEy", "png_get_cHRM_XYZ_fixed", "_ZN2cv6detail29restoreImageFromLaplacePyrGpuERSt6vectorINS_3MatESaIS2_EE", "_ZN22CameraWrapperConnector15applyPropertiesEPPv", "_ZN17CvFuzzyControllerD2Ev", "png_set_sRGB", "Java_org_opencv_core_Mat_n_1Mat__JIIII", "_ZN3Imf15Pxr24Compressor12compressTileEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZNK4CvEM13get_nclustersEv", "_Unwind_GetCFA", "_ZN3Imf11hasTimeCodeERKNS_6HeaderE", "_ZN10__cxxabiv120__si_class_type_infoD2Ev", "_ZN2cv8GlCamera6lookAtENS_7Point3_IdEES2_S2_", "jas_image_create", "Java_org_opencv_core_Mat_n_1elemSize", "_ZN4perf10RegressionD2Ev", "png_create_read_struct_2", "_ZN3Imf6HeaderC1EiifRKN5Imath4Vec2IfEEfNS_9LineOrderENS_11CompressionE", "_ZN13CvCalibFilter4PushEPPK12CvPoint2D32f", "_ZN2cv12FilterEngineC1Ev", "_ZN2cv3ocl9CvSVM_OCL13create_kernelEv", "_ZN17MouthFaceTemplateD2Ev", "Java_org_opencv_core_Mat_n_1dataAddr", "_ZN2cv10convexHullERKNS_11_InputArrayERKNS_12_OutputArrayEbb", "Java_org_opencv_imgproc_Imgproc_copyMakeBorder_10", "png_set_swap_alpha", "Java_org_opencv_core_Mat_n_1Mat__III", "_ZN2cv24calcOpticalFlowFarnebackERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdiiiidi", "Java_org_opencv_ml_CvSVMParams_delete", "_ZN2cv9videostab15VideoFileSourceC2ERKSsb", "Java_org_opencv_imgproc_Imgproc_boxFilter_10", "_ZN10__cxxabiv121__vmi_class_type_infoD2Ev", "_ZN2cv3of27FabMap1D2Ev", "_ZNK17CirclesGridFinder9drawHolesERKN2cv3MatERS1_", "png_do_swap", "jas_stream_length", "cvSnakeImage", "_TIFFCheckRealloc", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1rp_1dw0_10", "_ZN2cv11VideoWriterC1ERKSsidNS_5Size_IiEEb", "_ZN3Imf7KeyCodeC2ERKS0_", "cvGetValidDisparityROI", "JPC_SEGTYPE", "_ZN8CvMLData13get_var_typesEv", "jpc_quantize", "Java_org_opencv_core_Core_idct_10", "png_set_compression_mem_level", "Java_org_opencv_contrib_StereoVar_StereoVar_10", "_ZN8CvRTreesC1Ev", "_ZN2cv17SelfSimDescriptorD2Ev", "_ZNK2cv14RandomizedTree5writeEPKc", "_ZN2cv15RTreeClassifierC1Ev", "_ZN2cv11RetinaColor34applyKrauskopfLMS2Acr1cr2TransformERSt8valarrayIfE", "png_write_sig", "_ZN9CvANN_MLPC2Ev", "_ZN22CvAdaptiveSkinDetector9Histogram9mergeWithEPS0_d", "Java_org_opencv_core_Core_mulSpectrums_10", "_ZN7Sampler6timingEv", "Java_org_opencv_core_Mat_n_1row", "_ZN2cv3ocl26matchTemplate_CCORR_NORMEDERKNS0_6oclMatES3_RS1_RNS0_16MatchTemplateBufE", "_ZN3Imf25lookModTransformAttributeERKNS_6HeaderE", "_ZN7testing8internal20ExitedUnsuccessfullyEi", "_ZN10__cxxabiv121__vmi_class_type_infoD1Ev", "_ZN18CvBlobTrackerAuto1D1Ev", "_ZN2cv5flann11IndexParamsD2Ev", "_ZN2cv8internal8median3dERKNS_11_InputArrayE", "Java_org_opencv_imgproc_Imgproc_threshold_10", "_ZN2cv17DescriptorMatcher20DescriptorCollectionC2ERKS1_", "_Z23VResizeCubicVec_32f_avxPPKhPhS0_i", "_ZN2cv12LBPEvaluatorC2Ev", "_ZN2cv3MataSERKNS_7Scalar_IdEE", "_ZN2cv11VideoWriterC2ERKSsidNS_5Size_IiEEb", "_ZN5CvSVM10train_autoEPK5CvMatS2_S2_S2_11CvSVMParamsi11CvParamGridS4_S4_S4_S4_S4_b", "_ZN10__cxxabiv119__foreign_exceptionD0Ev", "_ZN2cvmiERKNS_7Scalar_IdEERKNS_3MatE", "_ZN9CvLevMarqC2Ev", "_ZN7testing8internal9EqFailureEPKcS2_RKSsS4_b", "_ZNK2cv7linemod7Feature5writeERNS_11FileStorageE", "_ZN2cv3gpu6GpuMat7releaseEv", "_ZN2cv3ocl20FarnebackOpticalFlow15prepareGaussianEidPfS2_S2_RdS3_S3_S3_", "png_malloc_default", "_ZN2cv3ocl12ProgramCacheD1Ev", "_ZN2cv3ocl3logERKNS0_6oclMatERS1_", "_ZN2cv3ocl20OclCascadeClassifier20oclHaarDetectObjectsERNS0_6oclMatEP12CvMemStoragedii6CvSizeS6_", "__gcclibcxx_demangle_callback", "_ZNK2cv14FaceRecognizer4saveERKSs", "_ZN2cv17FlannBasedMatcherC2ERKNS_3PtrINS_5flann11IndexParamsEEERKNS1_INS2_12SearchParamsEEE", "cvGoodFeaturesToTrack", "_ZN3Imf11StdIFStream5clearEv", "_ZN13CvFaceElement12FindContoursEP9_IplImageS1_ii", "_ZN17CvCapture_AndroidD2Ev", "Java_org_opencv_video_BackgroundSubtractorMOG_BackgroundSubtractorMOG_12", "Java_org_opencv_objdetect_HOGDescriptor_detect_10", "Java_org_opencv_ml_CvSVM_CvSVM_10", "_ZN2cv17BasicRetinaFilter34_verticalAnticausalFilter_multGainEPfjj", "_ZN2cv11WBaseStreamD1Ev", "_ZN2cv3ogl6BufferC1Ev", "Java_org_opencv_photo_Photo_fastNlMeansDenoising_10", "_ZN4perf8TestBaseC2Ev", "_ZN3Imf13RleCompressor8compressEPKciiRS2_", "_ZN23CvNormalBayesClassifierD2Ev", "_ZN14CameraActivity10disconnectEv", "_ZN2cv3ogl6BufferC1EiiiNS1_6TargetEb", "_ZN3Imf14ChromaticitiesC2ERKN5Imath4Vec2IfEES5_S5_S5_", "_ZN3Imf15OpaqueAttributeD0Ev", "_ZN2cv12WLByteStream8putDWordEi", "jpeg_destroy_decompress", "_ZN2cv12VideoCaptureC2ERKSs", "__eqdf2", "Java_org_opencv_core_Mat_n_1release", "_ZN2cv14getConvertFuncEii", "_ZN2cv14filterSpecklesERKNS_12_OutputArrayEdidS2_", "_ZNK2cv3PCA11backProjectERKNS_11_InputArrayE", "_ZN2cv3MatC2EPK7CvMatNDb", "_ZN3Imf10OutputFile10initializeERKNS_6HeaderE", "_ZN2cv11bitwise_andERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_", "_ZN2cv10PxMDecoderD1Ev", "cvFindStereoCorrespondenceGC", "_ZN2cv3ocl23OclCascadeClassifierBuf16detectMultiScaleERNS0_6oclMatERSt6vectorINS_5Rect_IiEESaIS6_EEdiiNS_5Size_IiEESB_", "_ZN6cvtest2TSD0Ev", "_ZN9IlmThread4TaskD2Ev", "_Z21allocFeatureMapObjectPP16CvLSVMFeatureMapiii", "_ZN2cv9boxFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiNS_5Size_IiEENS_6Point_IiEEbi", "Java_org_opencv_imgproc_Imgproc_intersectConvexConvex_10", "_ZN8CvMLDataC2Ev", "_ZNK3Imf11ChannelListixERKSs", "_ZN2cv13Jpeg2KEncoderD2Ev", "cvCloneMatND", "_ZNK17CirclesGridFinder19findNearestKeypointEN2cv6Point_IfEE", "Java_org_opencv_imgproc_Moments_get_1m01_10", "Java_org_opencv_core_Core_ellipse_11", "Java_org_opencv_calib3d_StereoBM_compute_10", "_ZN2cv9videostab18InpaintingPipeline7inpaintEiRNS_3MatES3_", "_ZN7testing8internal38DefaultPerThreadTestPartResultReporter20ReportTestPartResultERKNS_14TestPartResultE", "_Z24icvCvt_CMYK2BGR_8u_C4C3RPKhiPhi6CvSize", "_ZN7CvBoost17get_weak_responseEv", "Java_org_opencv_objdetect_HOGDescriptor_get_1L2HysThreshold_10", "JNI_OnUnload", "cvCreateGraph", "Java_org_opencv_objdetect_HOGDescriptor_compute_11", "_ZN9CvERTreesC2Ev", "jpc_mqdec_setinput", "_ZN2cv9TickMeter5resetEv", "_ZN2cv8superres20createOptFlow_SimpleEv", "_ZN4epnp16estimate_R_and_tEPA3_dPd", "_ZN7CvDTree8do_trainEPK5CvMat", "_ZN3Imf13PizCompressor8compressEPKciiRS2_", "_ZN8CvMatrixC2EiiiP12CvMemStorageb", "icvDrawMosaic", "_ZN2cveqERKNS_3MatES2_", "_ZN3Imf9wrapmodesERKNS_6HeaderE", "_ZN9CvERTreesC1Ev", "_Z27VResizeLinearVec_32s8u_avx2PPKhPhS0_i", "_ZN2cv3ocl6device3mog23getBackgroundImage2_oclEiRKNS0_6oclMatES5_S5_RS3_i", "_ZN2cv3ogl6Buffer6createEiiiNS1_6TargetEb", "_ZN2cv3PCAC2Ev", "_ZN4epnpD1Ev", "png_zfree", "jp2_encode", "_ZN2cv14ChamferMatcher9showMatchERNS_3MatEi", "cvCreateKDTree", "_ZN2cv3ocl26BruteForceMatcher_OCL_base21radiusMatchCollectionERKNS0_6oclMatERS2_S5_S5_S5_fRKSt6vectorIS2_SaIS2_EE", "_ZN3Imf15OpaqueAttributeC1EPKc", "Java_org_opencv_imgproc_Imgproc_integral_10", "_ZN2cv3expEPKfPfi", "_ZN7cvflann9dummyfuncEv", "_ZN2cv13initModule_mlEv", "jpc_cstate_destroy", "Java_org_opencv_video_Video_calcMotionGradient_10", "cvDisplayStatusBar", "_ZNK2cv3ocl6oclMat9convertToERS1_idd", "TIFFLastDirectory", "_ZN13CvBlobTracker11ProcessBlobEiP6CvBlobP9_IplImageS3_", "_ZNK2cv11_InputArray5emptyEv", "_ZN7CvDTree16getVarImportanceEv", "_ZN2cv13AlgorithmInfoC2ERKSsPFPNS_9AlgorithmEvE", "cvRepeat", "Java_org_opencv_gpu_DeviceInfo_minorVersion_10", "_ZN6cvtest16initUndistortMapERKN2cv3MatES3_NS0_5Size_IiEERS1_S6_", "_ZN3Imf11hasAltitudeERKNS_6HeaderE", "_ZN2cv22FindOneWayDescriptorExEiPKNS_16OneWayDescriptorEP9_IplImagefffiRSt6vectorIiSaIiEES8_RS5_IfSaIfEESB_P5CvMatSD_", "_ZNK2cv5FREAK11computeImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EERS1_", "_ZNK3Imf15OpaqueAttribute12writeValueToERNS_7OStreamEi", "_ZN7testing7FloatLEEPKcS1_ff", "_ZNK2cv20BackgroundSubtractor18getBackgroundImageERKNS_12_OutputArrayE", "_ZN2cv12_OutputArrayC1Ev", "_ZNK9CvGBTrees7predictEPK5CvMatS2_PS0_7CvSlicei", "_ZN2cv13drawKeypointsERKNS_3MatERKSt6vectorINS_8KeyPointESaIS4_EERS0_RKNS_7Scalar_IdEEi", "jinit_forward_dct", "_ZN17FaceDetectionListC2Ev", "_ZN2cv3Mat6resizeEj", "_ZN2cv3minERKNS_3MatES2_", "TIFFClose", "_ZN3Imf8TimeCode8setFrameEi", "_ZN2cv11FileStorageC1Ev", "_ZN2cv17LatentSvmDetectorD1Ev", "_ZN2cv9AlgorithmC1Ev", "_ZN4perf8TestBase15getSelectedImplEv", "_ZN2cv3ocl18setBinaryDiskCacheEiSs", "_ZN3Imf17ScanLineInputFileD0Ev", "_ZN15CvFuzzyFunctionC2Ev", "Java_org_opencv_contrib_FaceRecognizer_train_10", "_ZN4perf8TestBaseC1Ev", "_ZNK2cv23OneWayDescriptorMatcher5emptyEv", "clippingBoxes", "_ZN2cv17DescriptorMatcher4readERKNS_8FileNodeE", "_ZN2cv17FlannBasedMatcher5trainEv", "cvUpdateBGStatModel", "Java_org_opencv_gpu_DeviceInfo_supports_10", "_ZNK2cv8Subdiv2D11getEdgeListERSt6vectorINS_3VecIfLi4EEESaIS3_EE", "_ZNK2cv2EM20computeProbabilitiesERKNS_3MatEPS1_", "_ZN2cv3ocl6dilateERKNS0_6oclMatERS1_RKNS_3MatENS_6Point_IiEEiiRKNS_7Scalar_IdEE", "Java_org_opencv_imgproc_Imgproc_cornerEigenValsAndVecs_10", "_ZN25CvBlobTrackPostProcKalmanC2Ev", "jpc_tagtree_destroy", "_ZN2cv3of211ChowLiuTreeC2Ev", "_ZN3Imf7KeyCodeC2Eiiiiiii", "_ZN2cv20OneWayDescriptorBase26CreateDescriptorsFromImageEP9_IplImageRKSt6vectorINS_8KeyPointESaIS4_EE", "__nedf2", "_ZN2cv12FilterEngineC2ERKNS_3PtrINS_10BaseFilterEEERKNS1_INS_13BaseRowFilterEEERKNS1_INS_16BaseColumnFilterEEEiiiiiRKNS_7Scalar_IdEE", "_ZN2cv14extractChannelERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_TIFFNoFixupTags", "cvDisplayOverlay", "TIFFWriteCheck", "Java_org_opencv_features2d_FeatureDetector_delete", "_ZN2cv8superres15SuperResolution5resetEv", "_ZN7CvDTree4readEP13CvFileStorageP10CvFileNodeP16CvDTreeTrainData", "_ZN2cv13destroyWindowERKSs", "Java_org_opencv_core_Mat_n_1col", "_ZN2cv14ChamferMatcher26SlidingWindowImageIteratorC2Eiiiiiff", "_ZN2cv11FileStorage20getDefaultObjectNameERKSs", "_ZN15CvOpenGlFuncTabD0Ev", "_ZN2cv10ExrDecoder10readHeaderEv", "_ZN3p3pC2EN2cv3MatE", "_ZNK2cv13AlgorithmInfo9paramTypeEPKc", "_ZN2cv17BasicRetinaFilter18runFilter_LPfilterERKSt8valarrayIfERS2_j", "_ZN16CvDTreeTrainData13new_split_catEif", "png_muldiv_warn", "_ZN2cv18getColumnSumFilterEiiiid", "_ZN2cv6KDTreeC1ERKNS_11_InputArrayES3_b", "_ZN7testing8internal12AssertHelperD1Ev", "_ZN2cv9minMaxLocERKNS_9SparseMatEPdS3_PiS4_", "_ZN6cvtest8BaseTest5clearEv", "png_set_rgb_to_gray", "_ZN2cv5ParamC1Ev", "cvReleaseBGCodeBookModel", "Java_org_opencv_gpu_Gpu_getCudaEnabledDeviceCount_10", "_ZN2cv3ocl15warpPerspectiveERKNS0_6oclMatERS1_RKNS_3MatENS_5Size_IiEEi", "_ZN2cv3ocl11interpolate10bindImgTexERKNS0_6oclMatERP7_cl_mem", "_ZN2cv8Subdiv2D13setEdgePointsEiii", "_ZN2cv12RetinaFilter19_runGrayToneMappingERKSt8valarrayIfERS2_ff", "png_get_oFFs", "_ZN2cv3ocl3addERKNS0_6oclMatES3_RS1_S3_", "_Z14IsColorPaletteP12PaletteEntryi", "cvLine", "_ZN2cv11RNG_MT19937C1Ev", "_ZN22CvAdaptiveSkinDetector7processEP9_IplImageS1_", "cvDFT", "_ZN2cv15isContourConvexERKNS_11_InputArrayE", "Java_org_opencv_core_Core_bitwise_1not_11", "_ZN2cv2EM6trainMERKNS_11_InputArrayES3_RKNS_12_OutputArrayES6_S6_", "_ZN2cv3dftERKNS_11_InputArrayERKNS_12_OutputArrayEii", "_ZN2cv8Subdiv2D11deletePointEi", "cvFindFace", "_ZN21DetectionBasedTracker10ParametersC2Ev", "jpeg_read_scanlines", "_ZN2cv3ogl6renderERKNS0_9Texture2DENS_5Rect_IdEES5_", "cvReleaseLSH", "Java_org_opencv_calib3d_Calib3d_estimateAffine3D_10", "_ZN2cv11_InputArrayC1Ev", "icvGetQuadsTransformStruct", "_ZNK7testing8UnitTest21total_test_case_countEv", "_cvNodeMultyplicity", "cvStartReadSeq", "jas_iccprof_createfromclrspc", "_ZN2cv12HOGEvaluatorD2Ev", "Java_org_opencv_core_Mat_nPutF", "_ZN4perf10Regression8isVectorERKN2cv11_InputArrayE", "_Z12FillGrayRow8PhS_iS_", "_ZN2cv6detail12DpSeamFinder7processERKNS_3MatES4_NS_6Point_IiEES6_RS2_S7_", "_ZN3Imf14TypedAttributeIN5Imath4Vec3IfEEE13readValueFromERNS_7IStreamEii", "_Z21getFFTImageFeatureMapPK16CvLSVMFeatureMapPP14CvLSVMFftImage", "Java_org_opencv_core_Core_PCABackProject_10", "_ZN2cv9Algorithm9setStringEPKcRKSs", "_ZN3Imf9InputFile4DataD1Ev", "Java_org_opencv_features2d_FeatureDetector_empty_10", "_ZN2cv17BasicRetinaFilter21setLPfilterParametersEfffj", "Java_org_opencv_imgproc_Subdiv2D_getEdgeList_10", "_ZN4perf8TestBase14_declareHelperC2EPS0_", "_Z1Q12CvPoint2D32fS_S_d", "_ZN14CvForestERTree20find_split_ord_classEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZN2cv12KalmanFilter7predictERKNS_3MatE", "_ZNK2cv5MatOp8multiplyERKNS_7MatExprES3_RS1_d", "png_set_strip_16", "_ZN6cvtest9ArrayTest23get_success_error_levelEiii", "_ZN2cv3PtrI11CvSparseMatE10delete_objEv", "_ZN7testing8internal12UnitTestImpl14RecordPropertyERKNS_12TestPropertyE", "png_get_user_chunk_ptr", "jpc_pchg_copy", "_ZN2cv3Mat3eyeEiii", "_ZN2cv23OneWayDescriptorMatcher10initializeERKNS0_6ParamsERKNS_3PtrINS_20OneWayDescriptorBaseEEE", "_ZN2cv16GeneralizedHoughD2Ev", "png_set_compression_method", "_ZN7testing32ScopedFakeTestPartResultReporterC1EPNS_19TestPartResultArrayE", "_ZN7testing8internal17Int32FromGTestEnvEPKci", "Java_org_opencv_ml_CvANN_1MLP_1TrainParams_get_1bp_1moment_1scale_10", "_ZNK2cv11JpegEncoder10newEncoderEv", "_ZNK2cv11RotatedRect12boundingRectEv", "_ZNK2cv12StarAdjuster10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_ZN4perf8TestBase14_declareHelper2inERKN2cv12_OutputArrayES5_S5_i", "_ZNK2cv6KDTree11findNearestERKNS_11_InputArrayEiiRKNS_12_OutputArrayES6_S6_S6_", "jpc_enc_enccblk", "cvExp", "_ZN7testing8internal6String32CaseInsensitiveWideCStringEqualsEPKwS3_", "_ZN2cv11FileStorageD0Ev", "cvMinMaxLoc", "_ZN16CvDTreeTrainData13new_split_ordEifiif", "_ZN3p3pC2Edddd", "_ZN2cv21ImageLogPolProjection15clearAllBuffersEv", "_ZNSt10bad_typeidD0Ev", "_ZN7testing8internal20ShouldRunTestOnShardEiii", "_ZN2cv23OneWayDescriptorMatcher4readERKNS_8FileNodeE", "jas_stream_display", "_ZN2cv5MutexC2ERKS0_", "_ZN2cv3ocl6device3mog7mog_oclERKNS0_6oclMatEiRS3_S6_S6_S6_S6_iffff", "jpeg_idct_ifast", "_ZN2cv3SVD9backSubstERKNS_11_InputArrayES3_S3_S3_RKNS_12_OutputArrayE", "jpc_ppxstabent_create", "_ZN4half8overflowEv", "Java_org_opencv_core_Core_completeSymm_11", "_ZN2cv31GenerateAffineTransformFromPoseE6CvSizeNS_12CvAffinePoseEP5CvMat", "_ZN3Imf14TiledInputFile11rawTileDataERiS1_S1_S1_RPKcS1_", "_ZNK7testing8internal8FilePath11IsDirectoryEv", "_ZN2cv3ocl11isCpuDeviceEv", "_ZNK8CvMLData16get_response_idxEv", "_ZN2cv15RTreeClassifier17countZeroElementsEv", "_ZN2cv14findDataMatrixERKNS_11_InputArrayERSt6vectorISsSaISsEERKNS_12_OutputArrayES9_", "_ZN2cv24BackgroundSubtractorMOG2clERKNS_11_InputArrayERKNS_12_OutputArrayEd", "_TIFFDefaultStripSize", "_ZN2cv3ocl12StereoBM_OCLclERKNS0_6oclMatES4_RS2_", "_ZN2cv9StereoVarD0Ev", "_ZN2cv14ChamferMatcher8Matching14matchTemplatesERNS_3MatES3_RKNS0_10ImageRangeEf", "_ZN17CirclesGridFinder9findBasisERKSt6vectorIN2cv6Point_IfEESaIS3_EERS5_RS0_I5GraphSaIS9_EE", "_ZN2cv13BaseRowFilterD2Ev", "_ZN2cv11drawMatchesERKNS_3MatERKSt6vectorINS_8KeyPointESaIS4_EES2_S8_RKS3_INS_6DMatchESaIS9_EERS0_RKNS_7Scalar_IdEESI_RKS3_IcSaIcEEi", "_ZN2cv17CommandLineParser12analyzeValueIiEET_RKSsb", "cvmPerspectiveProject", "jpeg_write_m_byte", "Java_org_opencv_core_Core_invert_10", "_ZN2cv5MutexaSERKS0_", "cvOrS", "_ZN16CvDTreeTrainData17get_child_buf_idxEP11CvDTreeNode", "jdiv_round_up", "jas_image_ishomosamp", "_ZN3Imf13ZipCompressorC1ERKNS_6HeaderEjj", "_ZN2cv14getConvertElemEii", "png_get_rows", "icvGetCrossPieceVector", "Java_org_opencv_features2d_Features2d_drawMatches_10", "TIFFFieldWithTag", "_ZN2cv3ocl26BruteForceMatcher_OCL_base13matchDownloadERKNS0_6oclMatES4_RSt6vectorINS_6DMatchESaIS6_EE", "cvAndS", "_Z21Mat_to_vector_Point2fRN2cv3MatERSt6vectorINS_6Point_IfEESaIS4_EE", "_ZNK2cv3ocl9CvSVM_OCL7predictEiRNS_3MatEb", "TIFFVSetField", "_ZNK10__cxxabiv119__pointer_type_info14__is_pointer_pEv", "_ZN2cv12RLByteStream7getByteEv", "_ZNK7testing8internal12AssertHelperaSERKNS_7MessageE", "_ZN2cv9StereoVarC2Eidiiiidffiii", "_ZN2cv17Affine3DEstimator11checkSubsetEPK5CvMati", "_ZN2cv11namedWindowERKSsi", "_ZN2cv3ocl13meanShiftProcERKNS0_6oclMatERS1_S4_iiNS_12TermCriteriaE", "_ZN8CvMLData11set_miss_chEc", "_Z14getFeatureMapsPK9_IplImageiPP16CvLSVMFeatureMap", "_Z17icvGetCoefficientP9CvMatrix36CvSizePiS2_S2_", "_ZN6cvtestlsERSoRKNS_7MatInfoE", "jas_iccprof_createfrombuf", "cvTransform", "png_check_fp_number", "_ZN2cv13HOGDescriptor24getDefaultPeopleDetectorEv", "_ZN2cv16FileNodeIteratorppEv", "jpeg_start_decompress", "_ZN23CvNormalBayesClassifierC2Ev", "_ZN3Imf8TimeCodeC2Ev", "_ZNK3Imf11ChannelList18channelsWithPrefixEPKcRNS0_13ConstIteratorES4_", "_cvProjectionPointToSegment", "_ZN21DetectionBasedTracker13resetTrackingEv", "_ZN2cvgeERKNS_3MatEd", "_ZN2cv6detail18SphericalWarperGpu4warpERKNS_3gpu6GpuMatERKNS_3MatES8_iiRS3_", "_ZN3Imf11ChannelList15channelsInLayerERKSsRNS0_8IteratorES4_", "_ZNK3Imf7IStream14isMemoryMappedEv", "_ZN2cv14RandomizedTree14quantizeVectorEPfiiS1_Ph", "_ZN2cv3PtrINS_9GlTexture4ImplEE10delete_objEv", "_ZN2cv12countNonZeroERKNS_11_InputArrayE", "_ZN3Imf9InputFile12rawPixelDataEiRPKcRi", "_ZN2cv12_OutputArrayC1ERNS_3ogl6BufferE", "png_destroy_write_struct", "_Z27icvBuildScanlineRightStereo6CvSizeP9CvMatrix3PfS2_fPiS3_S3_", "jpc_dec_decodepkts", "cvCreateImageHeader", "Java_org_opencv_gpu_TargetArchs_hasEqualOrGreaterBin_10", "cvFindStereoCorrespondence", "_ZN2cv8GlCameraC2Ev", "_ZN2cv14FernClassifierC1Ev", "_ZN2cv10PngDecoder15readDataFromBufEPvPhj", "cvVoronoiDiagramFromContour", "_ZN3Imf8latitudeERNS_6HeaderE", "png_set_sig_bytes", "_ZN22CvAdaptiveSkinDetectorD2Ev", "_ZN2cv7linemod8colormapERKNS_3MatERS1_", "jpc_seq_upsample", "_ZN2cv21FernDescriptorMatcher5clearEv", "_ZN2cv18minEnclosingCircleERKNS_11_InputArrayERNS_6Point_IfEERf", "_ZN2cv7linemod8Detector9readClassERKNS_8FileNodeERKSs", "_ZN6cvtest9ArrayTest17get_minmax_boundsEiiiRN2cv7Scalar_IdEES4_", "_ZNK11CvParamGrid5checkEv", "_ZN17CirclesGridFinder18isDetectionCorrectEv", "_ZN2cv17FlannBasedMatcher17convertToDMatchesERKNS_17DescriptorMatcher20DescriptorCollectionERKNS_3MatES7_RSt6vectorIS8_INS_6DMatchESaIS9_EESaISB_EE", "_ZN16CvDTreeTrainData8set_dataEPK5CvMatiS2_S2_S2_S2_S2_RK13CvDTreeParamsbbb", "Java_org_opencv_highgui_VideoCapture_n_1set", "_ZN7testing8internal35DefaultGlobalTestPartResultReporterC1EPNS0_12UnitTestImplE", "_ZN3Imf11ChannelList4findERKSs", "_ZN2cv9patchNaNsERKNS_12_OutputArrayEd", "_ZN7testing8internal24HasNewFatalFailureHelperC2Ev", "_ZN3Iex7BaseExcC1ERSt18basic_stringstreamIcSt11char_traitsIcESaIcEE", "_ZN7testing8internal27PrettyUnitTestResultPrinter15OnTestCaseStartERKNS_8TestCaseE", "_ZN6cvtest13assertMatNearEPKcS1_S1_RKN2cv11_InputArrayES5_d", "_ZNK3Imf6Header16pixelAspectRatioEv", "_ZN2cv23OneWayDescriptorMatcherD1Ev", "jpc_tagtree_getleaf", "Java_org_opencv_core_Core_divide_10", "_ZN3Imf6envmapERNS_6HeaderE", "_ZN2cv16BaseImageDecoderC1Ev", "icvComputeeInfiniteProject1", "_ZN3Imf11TileOffsets19reconstructFromFileERNS_7IStreamE", "_ZN2cv29PyramidAdaptedFeatureDetectorC1ERKNS_3PtrINS_15FeatureDetectorEEEi", "cvGetErrMode", "_ZN2cv10PngEncoderC1Ev", "_ZN2cv8StereoBMclERKNS_11_InputArrayES3_RKNS_12_OutputArrayEi", "_ZN2cv20OneWayDescriptorBaseD0Ev", "Java_org_opencv_core_Mat_n_1step1__JI", "_TIFFMergeFields", "png_get_x_pixels_per_meter", "_ZN17CvFuzzyControllerC2Ev", "_ZN2cv17CommandLineParser3getIbEET_RKSsb", "Java_org_opencv_imgproc_Imgproc_findContours_11", "Java_org_opencv_core_Core_completeSymm_10", "_ZNK2cv8Subdiv2D9isRightOfENS_6Point_IfEEi", "_Z32cvPreprocessCategoricalResponsesPK5CvMatS1_iPPS_S3_", "cvbFastExp", "_Z10icvChoose7PiS_iS_S_", "jpc_getzcctxno", "_ZN7testing8TestCaseC2EPKcS2_PFvvES4_", "TIFFCreateDirectory", "Java_org_opencv_features2d_DescriptorMatcher_delete", "Java_org_opencv_core_Core_subtract_12", "_ZN12FaceTemplateD0Ev", "png_flush", "jpc_streamlist_get", "Java_org_opencv_ml_CvSVM_clear_10", "_Unwind_GetLanguageSpecificData", "_ZN2cv10BaseFilterD1Ev", "Java_org_opencv_ml_CvGBTrees_clear_10", "_ZN2cv3ocl15CvSVMKernel_oclC1EPK11CvSVMParamsMS1_FviiPfRNS_3MatEEM11CvSVMKernelFviiPPKfSC_S5_E", "_ZNK3Imf6Header13displayWindowEv", "_ZN3Imf14TypedAttributeINS_8TimeCodeEE14staticTypeNameEv", "_ZTv0_n12_N2cv15FeatureDetectorD0Ev", "cvbInvSqrt", "_ZN22CameraWrapperConnector11setPropertyEPvid", "_ZN23CvFuzzyMeanShiftTrackerD2Ev", "jpc_initmqctxs", "jinit_huff_encoder", "_ZNK2cv12FastAdjuster10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_ZN6cvtest8BaseTestC2Ev", "_ZN2cv14FernClassifier10setVerboseEb", "_ZN11CvSVMParamsC2Ev", "_ZN2cv8Subdiv2D6spliceEii", "_ZNK2cv5BRISK14descriptorTypeEv", "_ZNK4CvEM14calcLikelihoodERKN2cv3MatE", "_ZNK2cv18SimpleBlobDetector4infoEv", "_ZN16CvObjectDetectorD1Ev", "png_gamma_correct", "_ZN2cv8internal14InitExtrinsicsERKNS_3MatES3_RKNS0_15IntrinsicParamsERS1_S7_", "_ZN2cv2EM5mStepEv", "_ZN2cv13HOGDescriptor12readALTModelESs", "_ZSt14__convert_to_vIfEvPKcRT_RSt12_Ios_IostateRKPi", "_ZN2cv3gpu6GpuMat5setToENS_7Scalar_IdEERKS1_", "_ZN3Imf10CompressorD2Ev", "_ZNK2cv13AlgorithmInfo5writeEPKNS_9AlgorithmERNS_11FileStorageE", "_ZN2cv20DTreeBestSplitFinderC1ERKS0_NS_5SplitE", "Java_org_opencv_core_Core_polylines_10", "cvGetOptimalNewCameraMatrix", "_ZN2cv5ParamC1EibiMNS_9AlgorithmEKFivEMS1_FviERKSs", "_ZN2cv6detail11PlaneWarper9buildMapsENS_5Size_IiEERKNS_3MatES6_S6_RS4_S7_", "_ZN3Imf9hasEnvmapERKNS_6HeaderE", "_ZN2cv16SunRasterDecoder5closeEv", "cvStartScanGraph", "_ZN2cv20DTreeBestSplitFinderC1EP7CvDTreeP11CvDTreeNode", "_ZNK3Imf13B44Compressor12numScanLinesEv", "_Z21icvFindRunsInOneImageiPhPiS0_S0_", "_ZN2cv13AlgorithmInfo8addParamERNS_9AlgorithmEPKcRdbMS1_FdvEMS1_FvdERKSs", "_ZN2cv13mulTransposedERKNS_11_InputArrayERKNS_12_OutputArrayEbS2_di", "_Z14_cvBendingWorkP12CvPoint2D32fS0_S0_S0_", "_ZN6cvtest3minERKN2cv3MatES3_RS1_", "cvGetModuleInfo", "jpc_getspb", "_ZN2cv3ogl9Texture2DC2EiiNS1_6FormatEjb", "_ZN2cv12LBPEvaluator9setWindowENS_6Point_IiEE", "_ZN2cv19DescriptorExtractor6createERKSs", "_ZN2cv9TickMeter4stopEv", "TIFFPredictorCleanup", "_ZN4perf10RegressionclERKSsRKN2cv11_InputArrayEdNS_10ERROR_TYPEE", "_ZN9CvGBTreesD1Ev", "Java_org_opencv_features2d_DescriptorMatcher_knnMatch_10", "_Z24icvCvt_Gray2BGR_8u_C1C3RPKhiPhi6CvSize", "_ZN17CvCamShiftTracker18set_hist_bin_rangeEiii", "_ZNK2cv9BFMatcher4infoEv", "_ZN2cv3LDA4loadERKNS_11FileStorageE", "_ZNK2cv17FlannBasedMatcher5cloneEb", "cvGetCentralMoment", "_ZN2cv8superres7arrCopyERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv17SelfSimDescriptorC2Eiiiii", "Java_org_opencv_contrib_StereoVar_set_1fi_10", "_ZN2cv10ExrDecoder11ChromaToBGREPfii", "_ZN6cvtest2TS13str_from_codeEi", "Java_org_opencv_imgproc_Moments_set_1nu21_10", "cvErrorStr", "_ZN3Imf15OpaqueAttributeD2Ev", "_ZNK7testing10TestResult17GetTestPartResultEi", "_ZN21DetectionBasedTracker15InnerParametersC1Ev", "_ZN2cv11RetinaColorD1Ev", "_ZN2cv20OneWayDescriptorBase22AllocatePCADescriptorsEv", "_ZN3Imf7capDateERKNS_6HeaderE", "_ZN16CvBlobDetectorCCC2Ev", "_ZN2cv20LogPolar_OverlappingD1Ev", "_ZN10CvVSModule11SetParamStrEPKcS1_", "_ZN2cv3ocl6device3mog13loadConstantsEfffffffh", "_Z24icvGetRectSubPix_32f_C1RPKfi6CvSizePfiS1_12CvPoint2D32f", "_ZN2cv28convertPointsFromHomogeneousERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv13AlgorithmInfoD2Ev", "Java_org_opencv_imgproc_Subdiv2D_insert_11", "_ZN2cv13Jpeg2KDecoderC2Ev", "Java_org_opencv_features2d_DescriptorMatcher_knnMatch_13", "_ZN2cv5pyrUpERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi", "_ZN2cv3ocl14releaseTextureERP7_cl_mem", "_ZN6cvtest8BaseTest8run_funcEv", "_ZN13CvDTreeParamsC1Ev", "_ZN3Imf13worldToCameraERNS_6HeaderE", "_cvConstructLCMComplexNode", "_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEiS4_PPKfbb", "_ZN2cvdvEdRKNS_3MatE", "_ZN17CvCapture_Android11setPropertyEid", "__fixsfsi", "cvWarpAffine", "cvCreateStereoBMState", "_ZNK2cv13HaarEvaluator5cloneEv", "_ZN16CvCapture_Images9grabFrameEv", "cvLog", "_ZNK5CvSVM12write_paramsEP13CvFileStorage", "_ZN8CvMLData15change_var_typeEii", "Java_org_opencv_features2d_GenericDescriptorMatcher_radiusMatch_12", "cvStartLoop", "_ZNK2cv9Algorithm9paramTypeERKSs", "_ZN2cv3ocl5splitERKNS0_6oclMatERSt6vectorIS1_SaIS1_EE", "_ZN2cv6KDTreeC2ERKNS_11_InputArrayEb", "_ZN2cv3ocl26BruteForceMatcher_OCL_base15matchCollectionERKNS0_6oclMatES4_RS2_S5_S5_S4_", "_ZN9IlmThread5MutexD2Ev", "_ZN2cv3of26FabMap14getLikelihoodsERKNS_3MatERKSt6vectorIS2_SaIS2_EERS5_INS0_6IMatchESaISA_EE", "_ZNK2cv17MatOp_Initializer6assignERKNS_7MatExprERNS_3MatEi", "_ZN2cv21FernDescriptorMatcher6ParamsC1ERKSs", "_ZN2cvneERKNS_3MatES2_", "cvSet2D", "png_set_shift", "_ZN21DetectionBasedTrackerD1Ev", "_ZN2cv3ogl6renderERKNS0_6ArraysEiNS_7Scalar_IdEE", "cvGraphRemoveEdge", "_ZN2cv20FastFeatureDetector2C2Eib", "_ZN3Imf8TimeCode10setSecondsEi", "_ZN9CvGBTrees5trainEP8CvMLData15CvGBTreesParamsb", "Java_org_opencv_imgproc_Moments_get_1m20_10", "Java_org_opencv_ml_CvDTreeParams_get_1truncate_1pruned_1tree_10", "_ZN2cv10Eigenfaces4loadERKNS_11FileStorageE", "png_write_bKGD", "_ZNK2cv12SurfAdjuster4goodEv", "JPC_PASSTYPE", "_ZN2cv3ocl23adaptiveBilateralFilterERKNS0_6oclMatERS1_NS_5Size_IiEEddNS_6Point_IiEEi", "Java_org_opencv_calib3d_StereoSGBM_StereoSGBM_11", "_ZNK2cv5MatOp12augAssignXorERKNS_7MatExprERNS_3MatE", "_ZN2cv3gpu14deviceSupportsENS0_10FeatureSetE", "jpc_bitstream_getbit_func", "_ZNK2cv7MatExprclERKNS_5RangeES3_", "_ZN2cv6detail12DpSeamFinder9findEdgesEv", "cvGetStarKeypoints", "_ZN3Imf17addChromaticitiesERNS_6HeaderERKNS_14ChromaticitiesE", "_ZN2cv3ocl5CannyERKNS0_6oclMatERNS0_8CannyBufERS1_ddib", "_ZN2cv9LDetector10setVerboseEb", "Java_org_opencv_imgproc_Imgproc_erode_11", "_ZN7testing10TestResult20ClearTestPartResultsEv", "_ZN2cv16SunRasterDecoderC2Ev", "Java_org_opencv_core_Core_polarToCart_10", "_ZN2cv16GeneralizedHoughD0Ev", "_ZNK3Imf11ChannelList4findEPKc", "Java_org_opencv_core_Mat_n_1elemSize1", "_ZN2cv9HuMomentsERKNS_7MomentsERKNS_12_OutputArrayE", "_ZN2cv3maxERKNS_11_InputArrayES2_RKNS_12_OutputArrayE", "_Z26icvBuildScanlineLeftStereo6CvSizeP9CvMatrix3PfS2_fPiS3_S3_", "_ZN2cv9videostab14StabilizerBaseC2Ev", "png_set_invert_mono", "Java_org_opencv_gpu_TargetArchs_hasEqualOrGreaterPtx_10", "Java_org_opencv_imgproc_Imgproc_warpPerspective_11", "_ZN2cv11_InputArrayC1ERKNS_8GlBufferE", "_ZN2cv11RetinaColor40_adaptiveHorizontalCausalFilter_addInputEPKfPfjj", "_ZN2cv8Subdiv2D11findNearestENS_6Point_IfEEPS2_", "Java_org_opencv_gpu_DeviceInfo_DeviceInfo_11", "_ZN2cv11contourAreaERKNS_11_InputArrayEb", "png_get_current_pass_number", "_Z26VResizeCubicVec_32s8u_avx2PPKhPhS0_i", "_ZN2cv3of29FabMapLUTC1ERKNS_3MatEddiii", "_ZN2cv3ocl20FarnebackOpticalFlow15gaussianBlurOclERKNS0_6oclMatEiRS2_", "_ZN7testing8internal2RE9FullMatchEPKcRKS1_", "_ZnwjRKSt9nothrow_t", "_ZN10CvEMParamsC1Ev", "_ZN3Imf13hufUncompressEPKciPti", "_ZN15CvGBTreesParamsC1Ev", "cvbFastLog", "_ZN2cv3ocl23StereoBeliefPropagationC2Eiiiffffi", "_ZN3Imf14TiledInputFile14setFrameBufferERKNS_11FrameBufferE", "_ZN7testing18TestEventListenersD1Ev", "Java_org_opencv_calib3d_StereoSGBM_set_1speckleWindowSize_10", "Java_org_opencv_core_Core_bitwise_1or_11", "_ZN5RFaceD1Ev", "_ZNK3Imf11ChannelList11findChannelEPKc", "_ZN3Imf13B44Compressor8compressEPKciN5Imath3BoxINS3_4Vec2IiEEEERS2_", "_ZN2cv3Mat7reserveEj", "png_set_user_limits", "_ZN2cv11RBaseStreamC2Ev", "jas_iccprof_copy", "_ZN2cv22SparseMatConstIteratorC2EPKNS_9SparseMatE", "png_get_y_offset_pixels", "_ZN2cv2EM6trainEERKNS_11_InputArrayES3_S3_S3_RKNS_12_OutputArrayES6_S6_", "_ZN11CvBoostTree18find_split_cat_regEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZNK3Imf14TypedAttributeIN5Imath4Vec2IfEEE12writeValueToERNS_7OStreamEi", "_ZN10CvVSModule11GetParamPtrEPKc", "_ZN2cv27fastNlMeansDenoisingColoredERKNS_11_InputArrayERKNS_12_OutputArrayEffii", "_Z11FillUniGrayPhRS_iiRiiih", "_ZN7CvDTree20find_split_ord_classEP11CvDTreeNodeifP12CvDTreeSplitPh", "_ZNK2cv4MSER4infoEv", "_ZN2cv16FileNodeIteratorC1ERKS0_", "Java_org_opencv_imgproc_Imgproc_accumulateSquare_11", "cvFindGraphEdgeByPtr", "cvThreshHist", "_ZN2cv17ParvoRetinaFilter15clearAllBuffersEv", "_ZN2cv14ChamferMatcher8Matching24computeDistanceTransformERNS_3MatES3_S3_fff", "Java_org_opencv_video_Video_calcOpticalFlowPyrLK_12", "_ZN2cv15setBreakOnErrorEb", "_ZN7CvDTreeD2Ev", "_ZN2cv5flann17LinearIndexParamsC1Ev", "_ZN2cv3ocl12PlatformInfoC2Ev", "_ZN2cv3of26FabMap6PzqGeqEbb", "_Z19GetNextCycleElementiii", "_ZN2cv5erodeERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "jas_stream_fdopen", "TIFFSwabLong", "_Z28cvPreprocessOrderedResponsesPK5CvMatS1_i", "_ZN2cv8Subdiv2D8QuadEdgeC1Ei", "_ZNK2cv3Matcv7CvMatNDEv", "cvRunHaarClassifierCascade", "png_destroy_read_struct", "_ZN5RFace4ShowEP9_IplImage", "_ZN2cv14ChamferMatcher8matchingERNS0_8TemplateERNS_3MatE", "_ZNK3Imf11TileOffsetsclEiiii", "_ZNK3Imf7IStream8fileNameEv", "cvStereoRectifyUncalibrated", "Java_org_opencv_ml_CvSVM_CvSVM_11", "_ZN7testing8UnitTestC2Ev", "_ZN7testing32ScopedFakeTestPartResultReporterD2Ev", "_ZNK2cv18SimpleBlobDetector10detectImplERKNS_3MatERSt6vectorINS_8KeyPointESaIS5_EES3_", "_Z30cvTestSeqAddIntensityVariationPvfff", "_ZN2cv6seqPopEP5CvSeqPv", "_ZN7testing8internal15UnitTestOptions15GetOutputFormatEv", "Java_org_opencv_features2d_GenericDescriptorMatcher_add_10", "png_set_gAMA", "_ZN2cv14SpinImageModel5matchERKS0_RSt6vectorIS3_INS_3VecIiLi2EEESaIS5_EESaIS7_EE", "Java_org_opencv_core_Core_reduce_10", "_ZN6cvtest9all_typesEv", "_TIFFMultiply32", "_ZN3Imf14TypedAttributeISt6vectorISsSaISsEEE14staticTypeNameEv", "_ZN2cv3Mat4onesEiPKii", "cvCreateImage", "_ZN2cv14ChamferMatcher8Matching11addTemplateERNS0_8TemplateE", "_ZN10CvVSModuleC2Ev", "_ZN21DetectionBasedTracker21SeparateDetectionWorkD2Ev", "_ZN2cv3ocl17cornerHarris_dxdyERKNS0_6oclMatERS1_S4_S4_iidi", "_ZN2cv12cornerHarrisERKNS_11_InputArrayERKNS_12_OutputArrayEiidi", "Java_org_opencv_ml_CvSVMParams_set_1C_10", "jinit_marker_reader", "_ZN2cv18initModule_contribEv", "_ZN3Imf11FrameBuffer5beginEv", "_ZN2cv14PatchGenerator14setAffineParamEddd", "Java_org_opencv_ml_CvNormalBayesClassifier_CvNormalBayesClassifier_10", "_ZNK2cv11_InputArray4typeEi", "cvLaplace", "_ZNK2cv11VideoWriter8isOpenedEv", "_ZN16CvDTreeTrainData16get_class_labelsEP11CvDTreeNodePi", "icvGetCrossLines", "_ZN2cv16OneWayDescriptorC1Ev", "_ZN2cv3powERKNS_11_InputArrayEdRKNS_12_OutputArrayE", "Java_org_opencv_calib3d_StereoSGBM_StereoSGBM_10", "_ZN2cv7linemod8Detector11readClassesERKSt6vectorISsSaISsEERKSs", "Java_org_opencv_imgproc_Imgproc_Scharr_11", "_ZN2cv10PngDecoderC2Ev", "_ZN2cv3ocl12cornerHarrisERKNS0_6oclMatERS1_iidi", "_ZN2cv3ocl26BruteForceMatcher_OCL_base19knnMatch2CollectionERKNS0_6oclMatES4_RS2_S5_S5_S4_", "Java_org_opencv_core_Algorithm_getInt_10", "_ZN2cv9FormattedC2ERKNS_3MatEPKNS_9FormatterEPKi", "_ZN2cv6dilateERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE", "_ZN17CirclesGridFinder15findLongestPathERSt6vectorI5GraphSaIS1_EER4Path", "_ZN2cv5flann5IndexC1Ev", "_ZN11CvSVMSolver8calc_rhoERdS0_", "_ZN2cv3ocl12countNonZeroERKNS0_6oclMatE", "Java_org_opencv_ml_CvNormalBayesClassifier_predict_10", "_ZN2cv14seqRemoveSliceEP5CvSeq7CvSlice", "Java_org_opencv_imgproc_Imgproc_calcBackProject_10", "_ZN2cv3gpu25getCudaEnabledDeviceCountEv", "_ZN2cv12RGBDOdometryERNS_3MatERKS0_S3_S3_S3_S3_S3_S3_S3_fffRKSt6vectorIiSaIiEERKS4_IfSaIfEEi", "Java_org_opencv_objdetect_HOGDescriptor_get_1blockSize_10", "_ZN2cv3ocl26BruteForceMatcher_OCL_baseC2ENS1_8DistTypeE", "_ZNK2cv16MatConstIterator3posEv", "jpeg_set_colorspace", "_ZN2cv17CascadeClassifier4readERKNS_8FileNodeE", "_ZN10CvVSModule8NewParamEPKc", "_ZNK7CvDTree10write_nodeEP13CvFileStorageP11CvDTreeNode", "__powidf2", "_ZN2cv24BriefDescriptorExtractor4readERKNS_8FileNodeE", "_ZN3Imf16hasWorldToCameraERKNS_6HeaderE", "_ZN3Imf13B44Compressor8compressEPKciiRS2_", "icvComputeRestStereoParams", "Java_org_opencv_core_Core_invert_11", "Java_org_opencv_ml_CvDTreeParams_delete", "_ZNK2cv20OneWayDescriptorBase14FindDescriptorEP9_IplImageNS_6Point_IfEERiS5_Rf", "_ZN2cv16BOWKMeansTrainerC1EiRKNS_12TermCriteriaEii", "_ZN2cv25ForestTreeBestSplitFinderC2EP12CvForestTreeP11CvDTreeNode", "_ZN2cv3of26FabMap3addERKSt6vectorINS_3MatESaIS3_EE", "Java_org_opencv_ml_CvGBTrees_CvGBTrees_12", "Java_org_opencv_ml_CvSVM_CvSVM_12", "_ZN2cv22FindOneWayDescriptorExEiPKNS_16OneWayDescriptorEP9_IplImagefffRiS5_RfS6_P5CvMatS8_", "__gnu_Unwind_Save_VFP", "_ZN11CvStatModelC1Ev", "Java_org_opencv_imgproc_Imgproc_matchTemplate_10", "_ZNK5CvSVM7predictERKN2cv3MatEb", "_ZN2cv3ocl26BruteForceMatcher_OCL_base17radiusMatchSingleERKNS0_6oclMatES4_RS2_S5_S5_fS4_", "TIFFComputeTile", "Java_org_opencv_calib3d_Calib3d_stereoRectifyUncalibrated_11", "_ZN2cv6detail12DpSeamFinder16computeGradientsERKNS_3MatES4_", "_ZN8CvRTrees16getVarImportanceEv", "cvRodrigues2", "_ZN9IlmThread10ThreadPoolD2Ev", "_ZN2cv12_OutputArrayC1ERKNS_3gpu6GpuMatE", "_Z20icvBuildScanlineLeftP9CvMatrix36CvSizePiS2_PfS2_", "jpeg_std_error", "Java_org_opencv_imgproc_Imgproc_boundingRect_10", "_ZN3Imf11TileOffsetsclEiiii", "_ZN2cv6detail18GraphCutSeamFinder4Impl20setGraphWeightsColorERKNS_3MatES5_S5_S5_R7GCGraphIfE", "cvRand", "_ZN7testing8internal12UnitTestImplC2EPNS_8UnitTestE", "_Z21vector_Point3f_to_MatRSt6vectorIN2cv7Point3_IfEESaIS2_EERNS0_3MatE", "cvTrace", "_ZN3Imf11FrameBuffer9findSliceERKSs", "png_do_gamma", "_ZN2cv16OneWayDescriptorD2Ev", "_ZN2cv3ogl6BufferC2ERKNS_11_InputArrayENS1_6TargetEb", "_ZNK2cv9LDetector5writeERNS_11FileStorageERKSs", "_ZN5RFace9CheckElemEPvS0_", "Java_org_opencv_imgproc_Imgproc_minEnclosingCircle_10", "_ZN2cv11polarToCartERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_b", "_ZN13CvBoostParamsC2EiidibPKf", "_Z18vector_char_to_MatRSt6vectorIcSaIcEERN2cv3MatE", "_ZNSt10bad_typeidD2Ev", "_ZN2cv3ocl4gemmERKNS0_6oclMatES3_dS3_dRS1_i", "png_write_chunk_start", "_ZN2cv3ocl12KalmanFilter7correctERKNS0_6oclMatE", "png_get_user_width_max", "_ZNK2cv16BOWKMeansTrainer7clusterERKNS_3MatE", "_ZN2cv13AlgorithmInfoD1Ev", "_ZN2cv7inRangeERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE", "_ZNK3Imf14TypedAttributeIN5Imath8Matrix44IdEEE12writeValueToERNS_7OStreamEi", "_Z26cvCreateFileCapture_ImagesPKc", "_ZN2cv11TiffDecoderC2Ev", "_ZN6cvtest7vec2strERKSsPKij", "Java_org_opencv_core_Core_calcCovarMatrix_11", "_ZN2cv5flann11IndexParams9setDoubleERKSsd", "_ZN2cv20perspectiveTransformERKNS_11_InputArrayERKNS_12_OutputArrayES2_", "_ZN2cv23VectorDescriptorMatcherD0Ev", "_ZN3Imf6Header12previewImageEv", "png_do_read_swap_alpha", "Java_org_opencv_imgproc_Moments_get_1mu03_10", "Java_org_opencv_features2d_Features2d_drawMatches2_11", "Java_org_opencv_ml_CvSVM_train_11", "Java_org_opencv_ml_CvGBTreesParams_delete", "_ZN9IlmThread4TaskD0Ev", "_ZN17CvERTreeTrainData18get_sample_indicesEP11CvDTreeNodePi", "_ZN7testing8internal6String23EndsWithCaseInsensitiveERKSsS3_", "Java_org_opencv_calib3d_Calib3d_getOptimalNewCameraMatrix_10", "_ZN2cv9StereoVar3FMGERNS_3MatES2_S2_S2_i", "_ZN2cv3ocl3sumERKNS0_6oclMatE", "Java_org_opencv_ml_CvKNearest_delete", "cvSeqPushFront", "_ZN2cv11mixChannelsEPKNS_3MatEjPS0_jPKij", "_ZN13FaceDetection16AddContours2RectEP5CvSeqii", "_ZN21FaceDetectionListElemC1Ev", "_ZN2cv17BasicRetinaFilter32_horizontalCausalFilter_addInputEPKfPfjj", "_ZN7Sampler6fcoordEff", "png_handle_sPLT", "cvCreate2DHMM", "_ZN2cv12FastAdjuster7tooManyEii", "_ZN2cv3EMDERKNS_11_InputArrayES2_iS2_PfRKNS_12_OutputArrayE", "_TIFFPrintFieldInfo", "Java_org_opencv_core_Core_solvePoly_11", "_ZN3Imf7KeyCode11setFilmTypeEi", "_ZN6cvtest9transformERKN2cv3MatERS1_S3_S3_", "TIFFGetField", "_ZN2cv12FilterEngineD1Ev", "cvRelease", "_ZNK2cv3gpu6GpuMat8downloadERNS_3MatE", "_ZN3GMM23calcInverseCovAndDetermEi", "_ZN8CvRTreesD1Ev", "_ZN3Imf21addRenderingTransformERNS_6HeaderERKSs", "_ZN2cv3ocl11interpolate10vectorWarpERKNS0_6oclMatES4_S4_RS2_ifi", "_ZN2cv14generateColorsERSt6vectorINS_7Scalar_IdEESaIS2_EEjj", "___Unwind_Resume", "cvSetImageCOI", "_ZNK2cv7linemod8Detector12getTemplatesERKSsi", "Java_org_opencv_ml_CvANN_1MLP_create_11", "_ZNK7testing8UnitTest30reportable_disabled_test_countEv", "_ZN3Imf11StdOFStream5tellpEv", "_ZNK16CvDTreeTrainData12write_paramsEP13CvFileStorage", "_ZN3Imf13PizCompressorD1Ev", "_ZTv0_n24_NK2cv18SimpleBlobDetector4infoEv", "Java_org_opencv_objdetect_HOGDescriptor_detectMultiScale_11", "_ZN17CvCapture_Android13retrieveFrameEi", "_ZNK3Imf9InputFile10isCompleteEv", "_ZN2cv12VideoCapture4readERNS_3MatE", "_ZN2cv11WBaseStream6getPosEv", "_ZN6cvtest2TSD2Ev", "_ZN2cv9Algorithm3setEPKcRKSt6vectorINS_3MatESaIS4_EE", "_ZN4perf8TestBase14_declareHelper3outERKN2cv12_OutputArrayES5_S5_i", "_ZN11CvSVMKernelD1Ev", "_ZN7testing4Test19HasSameFixtureClassEv", "_ZN2cv7fitLineERKNS_11_InputArrayERKNS_12_OutputArrayEiddd", "_ZN2cv3ocl5mergeEPKNS0_6oclMatEjRS1_", "jpc_tsfb_synthesize", "_ZN23CvFuzzyMeanShiftTracker12SearchWindow9meanShiftEP9_IplImageS2_ib", "_ZN2cv9Feature2D6createERKSs", "Java_org_opencv_ml_EM_EM_10", "Java_org_opencv_objdetect_HOGDescriptor_HOGDescriptor_10", "Java_org_opencv_features2d_DescriptorExtractor_empty_10", "_Z18cvTestSeqGetFGMaskPv", "_ZN4epnp15compute_R_and_tEPKdS1_PA3_dPd", "_ZN21CvHomographyEstimator6refineEPK5CvMatS2_PS0_i", "_ZN2cv2EMC1EiiRKNS_12TermCriteriaE", "_ZN2cv5flann17KDTreeIndexParamsC1Ei", "_ZN2cv9Formatter3getEPKc", "_ZN2cv3ocl12medianFilterERKNS0_6oclMatERS1_i", "_ZNK2cv9LDetectorclERKSt6vectorINS_3MatESaIS2_EERS1_INS_8KeyPointESaIS7_EEib", "_ZN17CvModelEstimator28runLMeDSEPK5CvMatS2_PS0_S3_di", "Java_org_opencv_ml_CvRTParams_get_1nactive_1vars_10", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_i", "_ZN2cv17CommandLineParserC2EiPKPKcS2_", "_ZN23CvFuzzyMeanShiftTracker23findOptimumSearchWindowERNS_12SearchWindowEP9_IplImageS3_iib", "_ZN16CvDTreeTrainData16get_ord_var_dataEP11CvDTreeNodeiPfPiPPKfPPKiS3_", "_ZN3p3p5solveEPA3_A3_dPS0_ddddddddddddddd", "Java_org_opencv_calib3d_StereoSGBM_get_1P2_10", "Java_org_opencv_imgproc_Moments_get_1m11_10", "_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPPhi", "cvGetThreadNum", "_ZN2cv11_InputArrayC2Ev", "_ZN2cv12RetinaFilter11getContoursEv", "Java_org_opencv_core_Mat_n_1channels", "_ZN2cv3ocl4MOG27releaseEv", "Java_org_opencv_contrib_StereoVar_get_1poly_1sigma_10", "_ZN2cv10moveWindowERKSsii", "cvReleaseKalman", "_ZNK3Imf7ChanneleqERKS0_", "_ZN24CirclesGridClusterFinder22hierarchicalClusteringESt6vectorIN2cv6Point_IfEESaIS3_EERKNS1_5Size_IiEERS5_", "_ZN2cv23BackgroundSubtractorMOGC2Ev", "icvGetVect", "_ZN10__cxxabiv119__pointer_type_infoD1Ev", "Java_org_opencv_core_Core_getOptimalDFTSize_10", "_ZN2cv9videostab26estimateGlobalMotionRobustERKSt6vectorINS_6Point_IfEESaIS3_EES7_iRKNS0_12RansacParamsEPfPi", "_ZN2cv3gpu6GpuMatC1ERKS1_NS_5Rect_IiEE", "Java_org_opencv_contrib_StereoVar_set_1minDisp_10", "_ZN3p3p23init_inverse_parametersEv", "_TIFFSwab16BitData", "_ZN7testing8internal8GTestLogD1Ev", "cvCreateKalman", "cvEstimateObsProb", "_ZN11CvFuzzyRule9calcValueEdd", "loadModel", "_ZN6cvtest3maxERKN2cv3MatEdRS1_", "Java_org_opencv_gpu_TargetArchs_hasBin_10", "_ZN3Imf27renderingTransformAttributeERNS_6HeaderE", "_ZNK2cv5MatOp8subtractERKNS_7Scalar_IdEERKNS_7MatExprERS5_", "_ZNK2cv10PxMDecoder14checkSignatureERKSs", "jas_matrix_bindsub", "_ZN2cv12RMByteStreamD1Ev", "_ZN2cv6Retina12clearBuffersEv", "Java_org_opencv_features2d_FeatureDetector_detect_12", "_ZN2cv10PngDecoderD2Ev", "TIFFGetUnmapFileProc", "png_get_sPLT", "Java_org_opencv_calib3d_Calib3d_getValidDisparityROI_10", "_ZN2cv20OneWayDescriptorBase29InitializeTransformsFromPosesEv", "_ZN2cv3PtrI9_IplImageE10delete_objEv", "Java_org_opencv_core_Core_getTickCount_10", "_ZN2cv8internal14compose_motionERKNS_11_InputArrayES3_S3_S3_RNS_3MatES5_S5_S5_S5_S5_S5_S5_S5_S5_", "Java_org_opencv_ml_CvSVMParams_set_1term_1crit_10", "jpc_dec_decodecblks", "_ZN2cv11JpegDecoder5closeEv", "_ZNK2cv3ogl6Arrays4bindEv", "_ZN2cv11normHammingEPKhS1_ii", "icvComCoeffForLine", "_ZN11CvSVMSolverD1Ev", "_ZN2cv17getGaussianKernelEidi", "_ZN2cv3ocl12ProgramCache14releaseProgramEv", "png_set_rgb_to_gray_fixed", "Java_org_opencv_imgproc_Imgproc_equalizeHist_10", "_ZN2cv8GlArrays13setColorArrayERKNS_11_InputArrayEb", "_ZNK3Imf7OStream8fileNameEv", "Java_org_opencv_core_Core_line_12", "cvSeqRemove", "_ZNK2cv13HOGDescriptor19detectMultiScaleROIERKNS_3MatERSt6vectorINS_5Rect_IiEESaIS6_EERS4_INS_12DetectionROIESaISA_EEdi", "_ZN2cv14copyMakeBorderERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiiRKNS_7Scalar_IdEE", "Java_org_opencv_imgproc_Imgproc_getDerivKernels_10", "_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZN2cv12_OutputArrayC1ERNS_3MatE", "_ZNK2cv11MatOp_AddEx8multiplyERKNS_7MatExprEdRS1_", "Java_org_opencv_photo_Photo_fastNlMeansDenoisingColoredMulti_11", "Java_org_opencv_imgproc_Imgproc_arcLength_10", "_ZN2cv4sqrtERKNS_11_InputArrayERKNS_12_OutputArrayE", "_ZN2cv13projectPointsERKNS_11_InputArrayES2_S2_S2_S2_RKNS_12_OutputArrayES5_d", "_ZN2cv15LogPolar_InterpC1EiiNS_6Point_IiEEidiiii", "_ZN2cv14ChamferMatcher8TemplateC2ERNS_3MatEf", "_ZNK2cv8Subdiv2D7edgeDstEiPNS_6Point_IfEE", "_ZNK2cv5MatOp3addERKNS_7MatExprES3_RS1_", "_ZN2cv11TiffEncoder8writeTagERNS_12WLByteStreamENS_7TiffTagENS_13TiffFieldTypeEii", "jpeg_set_quality", "_ZN11CvSVMKernel4calcEiiPPKfS1_Pf", "jpc_enc_pi_create", "_ZN2cvcoERKNS_3MatE", "_ZNK3Imf14TypedAttributeIN5Imath4Vec2IiEEE12writeValueToERNS_7OStreamEi", "_ZN2cv10medianBlurERKNS_11_InputArrayERKNS_12_OutputArrayEi", "_ZNK23CvNormalBayesClassifier7predictEPK5CvMatPS0_", "_ZN2cv12LBPEvaluatorC1Ev", "Java_org_opencv_imgproc_Subdiv2D_symEdge_10", "_ZThn4_NK2cv3ORB14descriptorTypeEv", "_ZN3Imf12hasWrapmodesERKNS_6HeaderE", "_ZN2cv3ocl23OclCascadeClassifierBuf9GenResultERSt6vectorINS_5Rect_IiEESaIS4_EERKS6_RKS2_IiSaIiEE", "jround_up", "Java_org_opencv_contrib_FaceRecognizer_predict_10", "Java_org_opencv_ml_CvDTreeParams_get_1cv_1folds_10", "png_access_version_number", "_ZNK2cv24GenericDescriptorMatcher18KeyPointCollection13keypointCountEv", "_ZNK3Imf6Header17screenWindowWidthEv", "_ZN2cv9Algorithm3setERKSsS2_", "_ZN17CvCamShiftTracker16update_histogramEPK9_IplImage"], "allstrings": ["Mat::n_1clone()", "Mat::n_1inv__J()", "Mat::n_1convertTo__JJIDD()", "Mat::n_1push_1back()", "Mat::n_1zeros__III()", "Mat::n_1copyTo__JJJ()", "Mat::n_1diag__J()", "Mat::n_1reshape__JII()", "Mat::nPutF()", "Mat::n_1ones__DDI()", "Mat::nPutD()", "Mat::n_1submat_1rr()", "Mat::nPutB()", "Mat::nPutI()", "Mat::n_1setTo__JDDDD()", "Mat::nPutS()", "Mat::n_1reshape__JI()", "Mat::n_1checkVector__JI()", "Mat::n_1t()", "Mat::n_1eye__III()", "Mat::n_1Mat__III()", "Mat::n_1create__JDDI()", "Mat::n_1colRange()", "Mat::n_1rowRange()", "Mat::nGetF()", "Mat::n_1Mat__IIIDDDD()", "Mat::n_1copyTo__JJ()", "Mat::nGetB()", "Mat::nGetI()", "Mat::n_1cross()", "Mat::nDump()", "Mat::n_1mul__JJ()", "Mat::nGetS()", "Mat::n_1submat()", "Mat::nGet()", "Mat::n_1assignTo__JJI()", "Mat::n_1Mat__JIIII()", "Mat::n_1ones__III()", "Mat::n_1checkVector__JII()", "Mat::n_1zeros__DDI()", "Mat::n_1setTo__JJJ()", "static cv::Mat cv::Mat::diag(const cv::Mat&)", "Mat::nGetD()", "Mat::n_1setTo__JDDDDJ()", "Mat::n_1adjustROI()", "Mat::n_1convertTo__JJID()", "Mat::n_1diag__JI()", "Mat::n_1setTo__JJ()", "Mat::n_1row()", "Mat::n_1mul__JJD()", "Mat::n_1assignTo__JJ()", "Mat::n_1release()", "Mat::n_1col()", "Mat::n_1Mat__DDI()", "Mat::n_1checkVector__JIIZ()", "Mat::n_1Mat__DDIDDDD()", "Mat::n_1inv__JI()", "Mat::n_1convertTo__JJI()", "Mat::n_1create__JIII()", "Mat::n_1dot()", "Mat::n_1eye__DDI()", "Mat::n_1Mat__JII()", "Mat::n_1size()", "core::locateROI_10()", "d.cols == 1 || d.rows == 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/mat.hpp", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.core.Mat", "%s caught %s", "vector::_M_insert_aux", "vector::reserve", "highgui::VideoCapture::set(int propId, double value)", "highgui::VideoCapture::get(int propId)", "highgui::VideoCapture::open(int device)", "highgui::VideoCapture::grab()", "highgui::VideoCapture::retrieve(Mat image, int channel)", "highgui::VideoCapture::VideoCapture()", "highgui::VideoCapture::isOpened()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.highgui.VideoCapture", "%s caught %s", "highgui::VideoCapture::retrieve(Mat image)", "highgui::VideoCapture::read(Mat image)", "highgui::VideoCapture::VideoCapture(int device)", "highgui::VideoCapture::release()", "highgui::VideoCapture::getSupportedPreviewSizes(...)", "void Java_org_opencv_android_Utils_nMatToBitmap2(JNIEnv*, jclass, jlong, jobject, jboolean)", "AndroidBitmap_getInfo(env, bitmap, &info) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/java/generator/src/cpp/utils.cpp", "info.format == ANDROID_BITMAP_FORMAT_RGBA_8888 || info.format == ANDROID_BITMAP_FORMAT_RGB_565", "AndroidBitmap_lockPixels(env, bitmap, &pixels) >= 0", "pixels", "org.opencv.android.Utils", "nBitmapToMat catched cv::Exception: %s", "org/opencv/core/CvException", "java/lang/Exception", "nBitmapToMat catched unknown exception (...)", "Unknown exception in JNI code {nBitmapToMat}", "src.dims == 2 && info.height == (uint32_t)src.rows && info.width == (uint32_t)src.cols", "src.type() == CV_8UC1 || src.type() == CV_8UC3 || src.type() == CV_8UC4", "nMatToBitmap catched cv::Exception: %s", "nMatToBitmap catched unknown exception (...)", "Unknown exception in JNI code {nMatToBitmap}", "void Java_org_opencv_android_Utils_nBitmapToMat2(JNIEnv*, jclass, jobject, jlong, jboolean)", "gpu::has_10()", "gpu::hasEqualOrLessPtx_10()", "gpu::builtWith_10()", "gpu::sharedMemPerBlock_10()", "gpu::name_10()", "gpu::deviceSupports_10()", "gpu::totalMemory_10()", "gpu::hasEqualOrGreaterBin_10()", "gpu::queryMemory_10()", "gpu::supports_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.gpu", "%s caught %s", "gpu::hasEqualOrGreaterPtx_10()", "gpu::DeviceInfo_10()", "gpu::DeviceInfo_11()", "gpu::setDevice_10()", "gpu::resetDevice_10()", "gpu::hasEqualOrGreater_10()", "gpu::freeMemory_10()", "gpu::hasBin_10()", "gpu::getCudaEnabledDeviceCount_10()", "gpu::getDevice_10()", "gpu::hasPtx_10()", "gpu::isCompatible_10()", "gpu::printCudaDeviceInfo_10()", "gpu::printShortCudaDeviceInfo_10()", "core::normalize_10()", "core::convertScaleAbs_10()", "core::fillConvexPoly_11()", "core::max_10()", "core::add_13()", "core::exp_10()", "core::PCAComputeVar_10()", "core::setDouble_10()", "core::subtract_14()", "core::gemm_11()", "core::getNumThreads_10()", "core::transform_10()", "core::getTickFrequency_10()", "core::randShuffle_10()", "core::SVBackSubst_10()", "core::norm_14()", "core::absdiff_11()", "core::completeSymm_10()", "core::getBuildInformation_10()", "core::pow_10()", "core::getBool_10()", "core::PCABackProject_10()", "core::reduce_11()", "core::idft_11()", "core::findNonZero_10()", "core::eigen_10()", "core::putText_12()", "core::mulTransposed_11()", "core::multiply_15()", "core::checkRange_10()", "core::multiply_12()", "core::merge_10()", "core::multiply_10()", "core::setIdentity_11()", "core::subtract_11()", "org/opencv/core/CvException", "java/lang/Exception", "Unknown exception in JNI code {core::minMaxLoc()}", "Unknown exception in JNI code {core::getTextSize()}", "unknown exception", "std::exception", "cv::Exception", "org.opencv.core", "%s caught %s", "core::getNumberOfCPUs_10()", "core::add_10()", "core::gemm_10()", "core::invert_10()", "core::setBool_10()", "core::Mahalanobis_10()", "core::divide_17()", "core::determinant_10()", "core::magnitude_10()", "core::circle_12()", "core::split_10()", "core::trace_10()", "core::setInt_10()", "core::putText_11()", "core::bitwise_1not_11()", "core::paramHelp_10()", "core::fillPoly_11()", "core::norm_11()", "core::randu_10()", "core::clipLine_10()", "core::ellipse_13()", "core::extractChannel_10()", "core::reduce_10()", "core::idft_10()", "core::divide_11()", "core::batchDistance_11()", "core::norm_12()", "core::setString_10()", "core::add_15()", "core::getMat_10()", "core::addWeighted_10()", "core::bitwise_1or_10()", "core::fastAtan2_10()", "core::PCACompute_11()", "core::bitwise_1xor_10()", "core::batchDistance_12()", "core::idct_11()", "core::phase_10()", "core::bitwise_1and_11()", "core::polylines_12()", "core::countNonZero_10()", "core::transpose_10()", "core::sumElems_10()", "core::mulSpectrums_10()", "core::calcCovarMatrix_11()", "core::divide_16()", "core::divide_14()", "core::circle_11()", "core::SVDecomp_11()", "core::LUT_10()", "core::line_10()", "core::divide_12()", "core::subtract_10()", "core::kmeans_10()", "core::multiply_14()", "core::dct_10()", "core::inRange_10()", "core::log_10()", "core::PCAProject_10()", "core::solvePoly_10()", "core::ellipse_12()", "core::ellipse_10()", "core::rectangle_11()", "core::perspectiveTransform_10()", "core::getCPUTickCount_10()", "core::dft_11()", "core::convertScaleAbs_11()", "core::getThreadNum_10()", "core::max_11()", "core::add_14()", "core::add_12()", "core::mean_10()", "core::subtract_15()", "core::PCACompute_10()", "core::subtract_13()", "core::setIdentity_10()", "core::sqrt_10()", "core::getOptimalDFTSize_10()", "core::compare_11()", "core::flip_10()", "core::getMatVector_10()", "core::vconcat_10()", "core::polylines_11()", "core::cartToPolar_11()", "core::absdiff_10()", "core::ellipse_15()", "core::compare_10()", "core::meanStdDev_11()", "core::divide_13()", "core::norm_13()", "core::setMat_10()", "core::polylines_10()", "core::repeat_10()", "core::min_10()", "core::cubeRoot_10()", "core::sortIdx_10()", "core::SVDecomp_10()", "core::mulTransposed_10()", "core::getInt_10()", "core::hconcat_10()", "core::patchNaNs_10()", "core::multiply_11()", "core::setNumThreads_10()", "core::paramType_10()", "core::invert_11()", "core::mean_11()", "core::dft_10()", "core::normalize_12()", "core::getDouble_10()", "core::mixChannels_10()", "core::min_11()", "core::add_11()", "core::line_12()", "core::subtract_12()", "core::polarToCart_11()", "core::putText_10()", "core::rectangle_12()", "core::dct_11()", "core::solveCubic_10()", "core::fillPoly_10()", "core::solve_11()", "core::cartToPolar_10()", "core::solvePoly_11()", "core::norm_10()", "core::ellipse_14()", "core::ellipse2Poly_10()", "core::getString_10()", "core::meanStdDev_10()", "core::bitwise_1or_11()", "core::divide_10()", "core::batchDistance_10()", "core::addWeighted_11()", "core::bitwise_1and_10()", "core::scaleAdd_10()", "core::randShuffle_11()", "core::idct_10()", "core::normalize_13()", "core::normalize_11()", "core::arrowedLine_11()", "core::insertChannel_10()", "core::norm_15()", "core::completeSymm_11()", "core::sort_10()", "core::mulSpectrums_11()", "core::patchNaNs_11()", "core::calcCovarMatrix_10()", "core::divide_15()", "core::randn_10()", "core::phase_11()", "core::circle_10()", "core::setErrorVerbosity_10()", "core::LUT_11()", "core::line_11()", "core::mulTransposed_12()", "core::fillConvexPoly_10()", "core::polarToCart_10()", "core::kmeans_11()", "core::checkRange_11()", "core::multiply_13()", "core::bitwise_1not_10()", "core::solve_10()", "core::getTickCount_10()", "core::bitwise_1xor_11()", "core::arrowedLine_10()", "core::ellipse_11()", "core::setMatVector_10()", "core::rectangle_10()", "imgproc::symEdge_10()", "imgproc::moments_10()", "imgproc::blur_11()", "imgproc::findContours_11()", "imgproc::integral_10()", "imgproc::undistortPoints_11()", "imgproc::Laplacian_11()", "imgproc::Canny_10()", "imgproc::HoughLinesP_10()", "imgproc::HoughLines_10()", "imgproc::pyrMeanShiftFiltering_10()", "imgproc::drawContours_12()", "imgproc::pyrDown_11()", "imgproc::bilateralFilter_10()", "imgproc::morphologyEx_12()", "imgproc::fitEllipse_10()", "imgproc::filter2D_10()", "imgproc::cornerHarris_10()", "imgproc::copyMakeBorder_10()", "imgproc::cornerMinEigenVal_10()", "imgproc::Sobel_10()", "imgproc::dilate_12()", "imgproc::copyMakeBorder_11()", "imgproc::preCornerDetect_10()", "imgproc::phaseCorrelateRes_11()", "imgproc::erode_12()", "imgproc::calcBackProject_10()", "imgproc::accumulateWeighted_10()", "imgproc::floodFill_10()", "imgproc::watershed_10()", "imgproc::phaseCorrelate_10()", "imgproc::GaussianBlur_12()", "imgproc::integral3_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.imgproc", "%s caught %s", "imgproc::cornerMinEigenVal_12()", "imgproc::getDerivKernels_11()", "imgproc::warpPerspective_12()", "imgproc::warpPerspective_10()", "imgproc::getGaborKernel_10()", "imgproc::minEnclosingCircle_10()", "imgproc::getEdgeList_10()", "imgproc::filter2D_12()", "imgproc::blur_10()", "imgproc::fitLine_10()", "imgproc::HoughCircles_10()", "imgproc::getStructuringElement_11()", "imgproc::calcHist_10()", "imgproc::pyrUp_12()", "imgproc::accumulateProduct_10()", "imgproc::drawContours_11()", "imgproc::distanceTransformWithLabels_11()", "imgproc::getRectSubPix_10()", "imgproc::contourArea_11()", "imgproc::boxFilter_12()", "imgproc::setTilesGridSize_10()", "imgproc::getVertex_10()", "imgproc::morphologyEx_11()", "imgproc::accumulate_11()", "imgproc::getAffineTransform_10()", "imgproc::dilate_11()", "imgproc::matchTemplate_10()", "imgproc::adaptiveThreshold_10()", "imgproc::createHanningWindow_10()", "imgproc::erode_11()", "imgproc::intersectConvexConvex_10()", "imgproc::adaptiveBilateralFilter_11()", "imgproc::setClipLimit_10()", "imgproc::GaussianBlur_11()", "imgproc::getDefaultNewCameraMatrix_10()", "imgproc::cornerEigenValsAndVecs_11()", "imgproc::arcLength_10()", "imgproc::boundingRect_10()", "imgproc::Scharr_11()", "imgproc::medianBlur_10()", "imgproc::insert_10()", "imgproc::Sobel_12()", "imgproc::goodFeaturesToTrack_10()", "imgproc::accumulateSquare_10()", "imgproc::undistort_11()", "imgproc::edgeDst_10()", "imgproc::nextEdge_10()", "imgproc::remap_11()", "imgproc::grabCut_11()", "imgproc::insert_11()", "imgproc::pyrUp_11()", "imgproc::erode_10()", "imgproc::findNearest_10()", "imgproc::distanceTransformWithLabels_10()", "imgproc::getGaussianKernel_11()", "imgproc::approxPolyDP_10()", "imgproc::contourArea_10()", "imgproc::edgeOrg_11()", "imgproc::locate_10()", "imgproc::pyrDown_12()", "imgproc::integral2_11()", "imgproc::sepFilter2D_12()", "imgproc::moments_11()", "imgproc::cvtColor_11()", "imgproc::distanceTransform_10()", "imgproc::blur_12()", "imgproc::findContours_10()", "imgproc::borderInterpolate_10()", "imgproc::undistortPoints_10()", "imgproc::Laplacian_10()", "imgproc::pyrMeanShiftFiltering_11()", "imgproc::Subdiv2D_11()", "imgproc::matchShapes_10()", "imgproc::pyrDown_10()", "imgproc::convertMaps_11()", "imgproc::getVertex_11()", "imgproc::pointPolygonTest_10()", "imgproc::getPerspectiveTransform_10()", "imgproc::phaseCorrelateRes_10()", "imgproc::floodFill_11()", "imgproc::HoughLines_11()", "imgproc::getTriangleList_10()", "imgproc::initDelaunay_10()", "imgproc::integral3_11()", "imgproc::Scharr_10()", "imgproc::warpAffine_10()", "imgproc::getRotationMatrix2D_10()", "imgproc::convertMaps_10()", "imgproc::getVoronoiFacetList_10()", "imgproc::cornerMinEigenVal_11()", "imgproc::getDerivKernels_10()", "imgproc::warpPerspective_11()", "imgproc::warpAffine_12()", "imgproc::findNearest_11()", "imgproc::convexHull_10()", "imgproc::cvtColor_10()", "imgproc::resize_11()", "imgproc::isContourConvex_10()", "imgproc::HoughCircles_11()", "imgproc::compareHist_10()", "imgproc::calcHist_11()", "imgproc::resize_10()", "imgproc::accumulateProduct_11()", "imgproc::Subdiv2D_10()", "imgproc::drawContours_10()", "imgproc::getRectSubPix_11()", "imgproc::initWideAngleProjMap_11()", "imgproc::phaseCorrelate_11()", "imgproc::boxFilter_11()", "imgproc::sepFilter2D_11()", "imgproc::Laplacian_12()", "imgproc::equalizeHist_10()", "imgproc::morphologyEx_10()", "imgproc::PSNR_10()", "imgproc::accumulateWeighted_11()", "imgproc::threshold_10()", "imgproc::getStructuringElement_10()", "imgproc::accumulate_10()", "imgproc::apply_10()", "imgproc::dilate_10()", "imgproc::bilateralFilter_11()", "imgproc::integral_11()", "imgproc::intersectConvexConvex_11()", "imgproc::adaptiveBilateralFilter_12()", "imgproc::cornerSubPix_10()", "imgproc::adaptiveBilateralFilter_10()", "imgproc::Canny_11()", "imgproc::HoughLinesP_11()", "imgproc::sepFilter2D_10()", "imgproc::getDefaultNewCameraMatrix_11()", "imgproc::GaussianBlur_10()", "imgproc::minAreaRect_10()", "imgproc::getEdge_10()", "imgproc::cornerEigenValsAndVecs_10()", "imgproc::convexHull_11()", "imgproc::filter2D_11()", "imgproc::cornerHarris_11()", "imgproc::warpAffine_11()", "imgproc::goodFeaturesToTrack_11()", "imgproc::Sobel_11()", "imgproc::accumulateSquare_11()", "imgproc::preCornerDetect_11()", "imgproc::edgeDst_11()", "imgproc::undistort_10()", "imgproc::initUndistortRectifyMap_10()", "imgproc::getGaborKernel_11()", "imgproc::remap_10()", "imgproc::grabCut_10()", "imgproc::pyrUp_10()", "imgproc::invertAffineTransform_10()", "imgproc::HuMoments_10()", "imgproc::Scharr_12()", "imgproc::convexityDefects_10()", "imgproc::getGaussianKernel_10()", "imgproc::boxFilter_10()", "imgproc::edgeOrg_10()", "imgproc::integral2_10()", "imgproc::initWideAngleProjMap_10()", "imgproc::Moments_10()", "imgproc::rotateEdge_10()", "objdetect::compute_10()", "objdetect::save_10()", "objdetect::detect_11()", "objdetect::HOGDescriptor_13()", "objdetect::CascadeClassifier_11()", "objdetect::setSVMDetector_10()", "objdetect::getDaimlerPeopleDetector_10()", "objdetect::empty_10()", "objdetect::checkDetectorSize_10()", "objdetect::detectMultiScale_13()", "objdetect::HOGDescriptor_12()", "objdetect::CascadeClassifier_10()", "objdetect::detectMultiScale_12()", "objdetect::getWinSigma_10()", "objdetect::load_10()", "objdetect::getDescriptorSize_10()", "objdetect::get_1blockSize_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.objdetect", "%s caught %s", "objdetect::computeGradient_11()", "objdetect::get_1svmDetector_10()", "objdetect::get_1winSize_10()", "objdetect::detectMultiScale_11()", "objdetect::computeGradient_10()", "objdetect::get_1blockStride_10()", "objdetect::getDefaultPeopleDetector_10()", "objdetect::HOGDescriptor_10()", "objdetect::detectMultiScale_11()", "objdetect::compute_11()", "objdetect::load_11()", "objdetect::detect_10()", "objdetect::save_11()", "objdetect::HOGDescriptor_11()", "objdetect::groupRectangles_11()", "objdetect::get_1cellSize_10()", "objdetect::detectMultiScale_10()", "objdetect::groupRectangles_10()", "objdetect::load_10()", "objdetect::detectMultiScale_10()", "features2d::knnMatch_13()", "features2d::write_10()", "features2d::clone_11()", "static cv::javaDescriptorMatcher* cv::javaDescriptorMatcher::create(int)", "features2d::detect_13()", "features2d::classify_10()", "features2d::compute_10()", "features2d::add_10()", "features2d::match_13()", "features2d::add_10()", "features2d::match_11()", "features2d::classify_11()", "features2d::knnMatch_10()", "features2d::compute_11()", "features2d::create_10()", "features2d::detect_12()", "features2d::read_10()", "features2d::match_12()", "features2d::match_10()", "features2d::read_10()", "features2d::knnMatch_13()", "features2d::detect_10()", "features2d::clone_11()", "static cv::javaGenericDescriptorMatcher* cv::javaGenericDescriptorMatcher::create(int)", "static cv::javaFeatureDetector* cv::javaFeatureDetector::create(int)", "features2d::detect_11()", "features2d::clear_10()", "features2d::knnMatch_12()", "features2d::empty_10()", "features2d::radiusMatch_13()", "features2d::getTrainDescriptors_10()", "features2d::radiusMatch_12()", "features2d::radiusMatch_10()", "features2d::clear_10()", "features2d::radiusMatch_11()", "features2d::drawMatches_10()", "features2d::create_10()", "features2d::drawMatches2_11()", "features2d::getTrainKeypoints_10()", "features2d::isMaskSupported_10()", "features2d::write_10()", "features2d::clone_10()", "features2d::descriptorType_10()", "features2d::clone_10()", "features2d::empty_10()", "features2d::drawMatches_11()", "features2d::match_12()", "features2d::match_10()", "features2d::descriptorSize_10()", "features2d::read_10()", "features2d::match_13()", "features2d::write_10()", "features2d::match_11()", "features2d::radiusMatch_12()", "features2d::radiusMatch_10()", "features2d::isMaskSupported_10()", "features2d::knnMatch_10()", "features2d::read_10()", "features2d::empty_10()", "features2d::empty_10()", "features2d::radiusMatch_11()", "features2d::create_10()", "features2d::knnMatch_11()", "features2d::create_10()", "features2d::write_10()", "features2d::train_10()", "features2d::getTrainImages_10()", "static cv::javaDescriptorExtractor* cv::javaDescriptorExtractor::create(int)", "features2d::drawMatches2_10()", "features2d::knnMatch_11()", "features2d::radiusMatch_13()", "features2d::train_10()", "features2d::drawKeypoints_10()", "features2d::knnMatch_12()", "Dynamic", "Pyramid", "Grid", "FAST", "STAR", "SIFT", "SURF", "MSER", "GFTT", "HARRIS", "SimpleBlob", "Dense", "BRISK", "Specified feature detector type is not supported.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/java/generator/src/cpp/features2d_manual.hpp", "FlannBased", "BruteForce", "BruteForce-L1", "BruteForce-Hamming", "BruteForce-HammingLUT", "BruteForce-SL2", "Specified descriptor matcher type is not supported.", "Opponent", "BRIEF", "FREAK", "Specified descriptor extractor type is not supported.", "ONEWAY", "FERN", "Specified generic descriptor matcher type is not supported.", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.features2d", "%s caught %s", "features2d::drawKeypoints_11()", "video::buildOpticalFlowPyramid_11()", "video::BackgroundSubtractorMOG2_12()", "video::BackgroundSubtractorMOG_11()", "video::calcOpticalFlowSF_10()", "video::correct_10()", "video::apply_11()", "video::calcMotionGradient_10()", "video::buildOpticalFlowPyramid_10()", "video::updateMotionHistory_10()", "video::calcOpticalFlowFarneback_10()", "video::BackgroundSubtractorMOG_10()", "video::apply_10()", "video::predict_11()", "video::KalmanFilter_11()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.video", "%s caught %s", "video::BackgroundSubtractorMOG2_11()", "video::calcOpticalFlowPyrLK_12()", "video::BackgroundSubtractorMOG2_10()", "video::CamShift_10()", "video::KalmanFilter_10()", "video::predict_10()", "video::calcGlobalOrientation_10()", "video::meanShift_10()", "video::calcOpticalFlowPyrLK_11()", "video::KalmanFilter_12()", "video::calcOpticalFlowPyrLK_10()", "video::segmentMotion_10()", "video::BackgroundSubtractorMOG_12()", "video::calcMotionGradient_11()", "video::calcOpticalFlowSF_11()", "video::estimateRigidTransform_10()", "highgui::imread_11()", "highgui::imread_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.highgui", "%s caught %s", "highgui::imencode_10()", "highgui::imwrite_10()", "highgui::imdecode_10()", "highgui::imwrite_11()", "highgui::imencode_11()", "ml::train_10()", "ml::CvSVM_11()", "ml::clear_10()", "ml::CvGBTrees_10()", "ml::isTrained_10()", "ml::CvANN_1MLP_1TrainParams_10()", "ml::CvGBTrees_12()", "ml::train_11()", "ml::train_11()", "ml::train_1auto_10()", "ml::predict_11()", "ml::predict_11()", "ml::clear_10()", "ml::prune_10()", "ml::CvKNearest_10()", "ml::train_11()", "ml::CvKNearest_12()", "ml::CvRTrees_10()", "ml::trainE_10()", "ml::clear_10()", "ml::train_11()", "ml::predict_11()", "ml::CvBoost_10()", "ml::create_10()", "ml::predict_1all_10()", "ml::predict_11()", "ml::CvGBTrees_11()", "ml::train_10()", "ml::predict_1prob_11()", "ml::CvSVMParams_10()", "ml::CvANN_1MLP_12()", "ml::train_11()", "ml::CvRTParams_10()", "ml::clear_10()", "ml::CvANN_1MLP_11()", "ml::CvBoostParams_10()", "ml::EM_11()", "ml::train_11()", "ml::CvKNearest_11()", "ml::getVarImportance_10()", "ml::get_1term_1crit_10()", "ml::train_10()", "ml::CvParamGrid_10()", "ml::CvBoost_12()", "ml::train_10()", "ml::CvNormalBayesClassifier_11()", "ml::CvNormalBayesClassifier_12()", "ml::save_10()", "ml::trainM_10()", "ml::getVarImportance_10()", "ml::get_1support_1vector_1count_10()", "ml::find_1nearest_10()", "ml::clear_10()", "ml::predict_1prob_10()", "ml::create_11()", "ml::train_10()", "ml::train_10()", "ml::clear_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.ml", "%s caught %s", "ml::predict_10()", "ml::load_11()", "ml::EM_10()", "ml::train_10()", "ml::save_11()", "ml::CvNormalBayesClassifier_10()", "ml::CvGBTreesParams_10()", "ml::trainM_11()", "ml::CvBoost_11()", "ml::clear_10()", "ml::train_11()", "ml::CvDTreeParams_10()", "ml::CvSVM_10()", "ml::train_11()", "ml::CvSVM_12()", "ml::predict_11()", "ml::trainE_11()", "ml::train_10()", "ml::CvANN_1MLP_10()", "ml::train_1auto_11()", "ml::predict_10()", "ml::CvDTree_10()", "ml::predict_10()", "ml::load_10()", "ml::train_10()", "ml::predict_11()", "ml::predict_10()", "ml::train_11()", "ml::get_1term_1crit_10()", "ml::predict_10()", "ml::predict_10()", "ml::get_1term_1crit_10()", "ml::CvERTrees_10()", "ml::train_10()", "ml::predict_10()", "ml::clear_10()", "ml::train_11()", "calib3d::projectPoints_10()", "calib3d::Rodrigues_10()", "calib3d::findChessboardCorners_10()", "calib3d::validateDisparity_10()", "calib3d::compute_10()", "calib3d::getOptimalNewCameraMatrix_10()", "calib3d::matMulDeriv_10()", "calib3d::findCirclesGridDefault_11()", "calib3d::findFundamentalMat_11()", "calib3d::computeCorrespondEpilines_10()", "calib3d::getOptimalNewCameraMatrix_11()", "calib3d::findFundamentalMat_12()", "calib3d::initCameraMatrix2D_11()", "calib3d::projectPoints_11()", "calib3d::StereoBM_12()", "calib3d::solvePnP_11()", "calib3d::StereoBM_10()", "calib3d::initCameraMatrix2D_10()", "calib3d::StereoSGBM_11()", "calib3d::StereoBM_11()", "calib3d::RQDecomp3x3_10()", "calib3d::reprojectImageTo3D_11()", "calib3d::StereoSGBM_12()", "calib3d::StereoSGBM_10()", "calib3d::RQDecomp3x3_11()", "calib3d::reprojectImageTo3D_12()", "calib3d::reprojectImageTo3D_10()", "calib3d::stereoRectifyUncalibrated_10()", "calib3d::solvePnPRansac_10()", "calib3d::compute_10()", "calib3d::convertPointsToHomogeneous_10()", "calib3d::findChessboardCorners_11()", "calib3d::calibrateCamera_10()", "calib3d::stereoRectifyUncalibrated_11()", "calib3d::solvePnPRansac_11()", "calib3d::compute_11()", "calib3d::calibrateCamera_11()", "calib3d::convertPointsFromHomogeneous_10()", "calib3d::getValidDisparityROI_10()", "calib3d::calibrateCamera_12()", "calib3d::estimateAffine3D_11()", "calib3d::stereoCalibrate_11()", "calib3d::stereoRectify_10()", "calib3d::estimateAffine3D_10()", "calib3d::stereoCalibrate_10()", "calib3d::Rodrigues_11()", "calib3d::stereoRectify_11()", "calib3d::findFundamentalMat_10()", "calib3d::filterSpeckles_10()", "calib3d::filterSpeckles_11()", "calib3d::solvePnP_10()", "calib3d::decomposeProjectionMatrix_10()", "calib3d::validateDisparity_11()", "calib3d::findCirclesGridDefault_10()", "calib3d::decomposeProjectionMatrix_11()", "calib3d::correctMatches_10()", "calib3d::triangulatePoints_10()", "calib3d::composeRT_10()", "calib3d::findHomography_11()", "calib3d::calibrationMatrixValues_10()", "calib3d::composeRT_11()", "calib3d::findHomography_12()", "calib3d::drawChessboardCorners_10()", "calib3d::findHomography_10()", "calib3d::rectify3Collinear_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.calib3d", "%s caught %s", "photo::inpaint_10()", "photo::fastNlMeansDenoisingMulti_11()", "photo::fastNlMeansDenoisingMulti_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.photo", "%s caught %s", "photo::fastNlMeansDenoising_10()", "photo::fastNlMeansDenoisingColored_10()", "photo::fastNlMeansDenoising_11()", "photo::fastNlMeansDenoisingColored_11()", "photo::fastNlMeansDenoisingColoredMulti_11()", "photo::fastNlMeansDenoisingColoredMulti_10()", "contrib::chamerMatching_11()", "contrib::predict_10()", "contrib::load_10()", "contrib::applyColorMap_10()", "contrib::chamerMatching_10()", "unknown exception", "std::exception", "cv::Exception", "org/opencv/core/CvException", "java/lang/Exception", "org.opencv.contrib", "%s caught %s", "contrib::compute_10()", "contrib::train_10()", "contrib::save_10()", "contrib::StereoVar_10()", "contrib::StereoVar_11()", "contrib::update_10()", "void cv::sorted_vector<_KeyTp, _ValueTp>::add(const _KeyTp&, const _ValueTp&) [with _KeyTp = std::basic_string<char>, _ValueTp = cv::Param]", "std::string cv::AlgorithmInfo::paramHelp(char const*) const", "void cv::AlgorithmInfo::write(const cv::Algorithm*, cv::FileStorage&) const", "void cv::AlgorithmInfo::set(cv::Algorithm*, char const*, int, void const*, bool) const", "void cv::AlgorithmInfo::addParam_(cv::Algorithm&, char const*, int, void*, bool, cv::Algorithm::Getter, cv::Algorithm::Setter, const string&)", "integer", "short", "boolean", "double", "string", "cv::Mat", "std::vector<cv::Mat>", "algorithm", "float", "unsigned int", "unsigned int64", "unsigned char", "Wrong argument type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/algorithm.cpp", "Argument error: the setter", " method was called for the parameter '", "' of the algorithm '", "', the parameter has ", " type, ", "so it should be set by integer, unsigned integer, uint64, unsigned char, boolean, float or double value, ", "so it should be set by integer value, ", "but the setter was called with ", " value", "Argument error: the getter", "so it should be get as integer, unsigned integer, uint64, boolean, unsigned char, float or double value, ", "so it should be get as integer, unsigned integer, uint64, unsigned char, float or double value, ", "so it should be get as integer value, ", "so it should be get as float or double value, ", "but the getter was called to get a ", "<NULL>", "No parameter '%s' is found", "Unknown/unsupported parameter type", "name", "unknown/unsupported type of '%s' parameter == %d", "Parameter '%s' is readonly", "Wrong argument type in the setter", "Wrong parameter type in the setter", "i == 0 || vec[i].first != vec[i-1].first", "argType == Param::INT || argType == Param::BOOLEAN || argType == Param::REAL || argType == Param::STRING || argType == Param::MAT || argType == Param::MAT_VECTOR || argType == Param::ALGORITHM || argType == Param::SHORT || argType == Param::FLOAT || argType == Param::UNSIGNED_INT || argType == Param::UINT64 || argType == Param::UCHAR", "vector::_M_fill_insert", "!nestedAlgo.empty()", "int cv::AlgorithmInfo::paramType(char const*) const", "void cv::sorted_vector<_KeyTp, _ValueTp>::add(const _KeyTp&, const _ValueTp&) [with _KeyTp = std::basic_string<char>, _ValueTp = cv::Algorithm* (*)()]", "void cv::AlgorithmInfo::get(const cv::Algorithm*, char const*, int, void*) const", "N2cv9AlgorithmE", "void cv::AlgorithmInfo::read(cv::Algorithm*, const cv::FileNode&) const", "std::string cv::getNameOfType(int)", "N2cv16TLSDataContainerE", "void cvGetModuleInfo(char const*, char const**, char const**)", "N2cv9ExceptionE", "int cvRegisterModule(const CvModuleInfo*)", "void* cv::TLSDataContainer::getData() const", "\nGeneral configuration for OpenCV 2.4.11 =====================================\n  Version control:               2.4.11-dirty\n\n  Platform:\n    Host:                        Linux 3.2.0-77-generic x86_64\n    Target:                      Linux 1 armv5te\n    CMake:                       2.8.12.1\n    CMake generator:             Ninja\n    CMake build tool:            /usr/local/bin/ninja\n    Configuration:               Release\n\n  C/C++:\n    Built as dynamic libs?:      NO\n    C++ Compiler:                /usr/bin/ccache /opt/android-ndk-r8c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/bin/arm-linux-androideabi-g++ (ver 4.6)\n    C++ flags (Release):         -fexceptions -frtti -fpic -Wno-psabi --sysroot=/opt/android-ndk-r8c/platforms/android-8/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv5te -mtune=xscale -msoft-float -fdata-sections -ffunction-sections -Wa,--noexecstack    -fsigned-char -W -Wall -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -fdiagnostics-show-option -fomit-frame-pointer -mthumb -fomit-frame-pointer -fno-strict-aliasing -O3 -DNDEBUG  -DNDEBUG\n    C++ flags (Debug):           -fexceptions -frtti -fpic -Wno-psabi --sysroot=/opt/android-ndk-r8c/platforms/android-8/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv5te -mtune=xscale -msoft-float -fdata-sections -ffunction-sections -Wa,--noexecstack    -fsigned-char -W -Wall -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -fdiagnostics-show-option -fomit-frame-pointer -marm -fno-omit-frame-pointer -fno-strict-aliasing -O0 -g -DDEBUG -D_DEBUG  -O0 -DDEBUG -D_DEBUG\n    C Compiler:                  /usr/bin/ccache /opt/android-ndk-r8c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/bin/arm-linux-androideabi-gcc\n    C flags (Release):           -fexceptions -fpic -Wno-psabi --sysroot=/opt/android-ndk-r8c/platforms/android-8/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv5te -mtune=xscale -msoft-float -fdata-sections -ffunction-sections -Wa,--noexecstack    -fsigned-char -W -Wall -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wno-narrowing -fdiagnostics-show-option -fomit-frame-pointer -mthumb -fomit-frame-pointer -fno-strict-aliasing -O3 -DNDEBUG  -DNDEBUG\n    C flags (Debug):             -fexceptions -fpic -Wno-psabi --sysroot=/opt/android-ndk-r8c/platforms/android-8/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv5te -mtune=xscale -msoft-float -fdata-sections -ffunction-sections -Wa,--noexecstack    -fsigned-char -W -Wall -Werror=return-type -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wno-narrowing -fdiagnostics-show-option -fomit-frame-pointer -marm -fno-omit-frame-pointer -fno-strict-aliasing -O0 -g -DDEBUG -D_DEBUG  -O0 -DDEBUG -D_DEBUG\n    Linker flags (Release):      -Wl,--no-undefined -Wl,--gc-sections -fuse-ld=gold -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now \n    Linker flags (Debug):        -Wl,--no-undefined -Wl,--gc-sections -fuse-ld=gold -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now \n    Precompiled headers:         NO\n\n  OpenCV modules:\n    To be built:                 core androidcamera flann imgproc highgui features2d calib3d ml objdetect video contrib photo java legacy ocl stitching superres ts videostab\n    Disabled:                    gpu nonfree world\n    Disabled by dependency:      -\n    Unavailable:                 dynamicuda python viz\n\n  Android: \n    Android ABI:                 armeabi\n    STL type:                    gnustl_static\n    Native API level:            android-8\n    SDK target:                  android-14\n    Android NDK:                 /opt/android-ndk-r8c (toolchain: arm-linux-androideabi-4.6)\n    android tool:                /hdd2/opt/tadp-3.0r3/android-sdk-linux/tools/android (Android SDK Tools, revision 23.0.2.)\n    Google Play package:         NO\n    Android examples:            YES\n\n  GUI: \n    GTK+ 2.x:                    NO\n    GThread :                    NO\n    GtkGlExt:                    NO\n    OpenGL support:              NO\n    VTK support:                 NO\n\n  Media I/O: \n    ZLib:                        z (ver 1.2.3)\n    JPEG:                        build (ver 62)\n    PNG:                         build (ver 1.5.12)\n    TIFF:                        build (ver 42 - 4.0.2)\n    JPEG 2000:                   build (ver 1.900.1)\n    OpenEXR:                     build (ver 1.7.1)\n\n  Video I/O:\n    AndroidNativeCamera:         YES, use prebuilt libraries\n\n  Other third-party libraries:\n    Use IPP:                     NO\n    Use Eigen:                   YES (ver 3.1.2)\n    Use TBB:                     NO\n    Use OpenMP:                  NO\n    Use GCD                      NO\n    Use Concurrency              NO\n    Use C=:                      NO\n    Use Cuda:                    NO\n    Use OpenCL:                  YES\n\n  OpenCL:\n    Version:                     dynamic\n    Include path:                /hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/3rdparty/include/opencl/1.2\n    Use AMD FFT:                 NO\n    Use AMD BLAS:                NO\n\n  Python:\n    Interpreter:                 /usr/bin/python2 (ver 2.7.3)\n\n  Java:\n    ant:                         /usr/bin/ant (ver 1.8.2)\n    Java tests:                  NO\n\n  Tests and samples:\n    Tests:                       NO\n    Performance tests:           NO\n    C/C++ Examples:              NO\n\n  Install path:                  /hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/build/builds/o4a/install\n\n  cvconfig.h is in:              /hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/build/builds/o4a\n-----------------------------------------------------------------\n\n", "%s:%d: error: (%d) %s in function %s\n", "%s:%d: error: (%d) %s\n", "OPENCV_TEMP_PATH", "__opencv_temp.XXXXXX", "/data/local/tmp/__opencv_temp.XXXXXX", "status", "error", "No Error", "Backtrace", "Unspecified error", "Internal error", "Insufficient memory", "Bad argument", "Iterations do not converge", "Autotrace call", "Incorrect size of input array", "Null pointer", "Division by zero occured", "Image step is wrong", "Inplace operation is not supported", "Requested object was not found", "Input image depth is not supported by function", "Formats of input arguments do not match", "Sizes of input arguments do not match", "One of arguments' values is out of range", "Unsupported format or combination of formats", "Input COI is not supported", "Bad number of channels", "Bad flag (parameter or structure field)", "Bad parameter of type CvPoint", "Bad type of mask argument", "Parsing error", "The function/feature is not implemented", "Memory block has been corrupted", "Assertion failed", "No GPU support", "Gpu API call", "No OpenGL support", "OpenGL API call", "Unknown %s code %d", "unknown function", "OpenCV Error: %s (%s) in %s, file %s, line %d", "cv::error()", "errcode == 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/system.cpp", "module != 0 && module->name != 0 && module->version != 0", "The module is not found", "%s: %s%s", "tlsContainers_[id] == pContainer", "vector::_M_fill_insert", "key_ >= 0", "cxcore", "2.4.11", "void cv::TLSContainerStorage::releaseKey(int, cv::TLSDataContainer*)", "void cv::makeKey()", "could not open directory: %s", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/glob.cpp", "basic_string::substr", "void glob_rec(const String&, const String&, std::vector<std::basic_string<char> >&, bool)", "void icvXMLEndWriteStruct(CvFileStorage*)", "void cvWriteString(CvFileStorage*, char const*, char const*, int)", "void* icvReadGraph(CvFileStorage*, CvFileNode*)", "void cvReadRawDataSlice(const CvFileStorage*, CvSeqReader*, int, void*, char const*)", "void* icvReadMat(CvFileStorage*, CvFileNode*)", "void cvRegisterType(const CvTypeInfo*)", "int icvDecodeSimpleFormat(char const*)", "void cvWrite(CvFileStorage*, char const*, void const*, CvAttrList)", "void icvXMLWriteString(CvFileStorage*, char const*, char const*, int)", "void cvWriteReal(CvFileStorage*, char const*, double)", "static std::string cv::FileStorage::getDefaultObjectName(const string&)", "void cvStartNextStream(CvFileStorage*)", "char* icvXMLParseValue(CvFileStorage*, char*, CvFileNode*, int)", "void icvYMLParse(CvFileStorage*)", "CvFileNode* cvGetFileNode(CvFileStorage*, CvFileNode*, const CvStringHashNode*, int)", "void icvReleaseGraph(void**)", "void cvSave(char const*, void const*, char const*, char const*, CvAttrList)", "void icvWriteImage(CvFileStorage*, char const*, void const*, CvAttrList)", "void* icvReadSeqTree(CvFileStorage*, CvFileNode*)", "void* cvClone(void const*)", "void cvStartWriteStruct(CvFileStorage*, char const*, int, char const*, CvAttrList)", "void* icvReadMatND(CvFileStorage*, CvFileNode*)", "void icvYMLWrite(CvFileStorage*, char const*, char const*)", "void icvYMLWriteString(CvFileStorage*, char const*, char const*, int)", "void icvWriteFileNode(CvFileStorage*, char const*, const CvFileNode*)", "char* icvXMLSkipSpaces(CvFileStorage*, char*, int)", "void* icvReadSeq(CvFileStorage*, CvFileNode*)", "CvFileNode* cvGetRootFileNode(const CvFileStorage*, int)", "void icvXMLStartWriteStruct(CvFileStorage*, char const*, int, char const*)", "void* cvRead(CvFileStorage*, CvFileNode*, CvAttrList*)", "N2cv11FileStorageE", "void icvProcessSpecialDouble(CvFileStorage*, char*, double*, char**)", "cv::FileNodeIterator& cv::FileNodeIterator::readRaw(const string&, uchar*, std::size_t)", "void* icvReadSparseMat(CvFileStorage*, CvFileNode*)", "char* icvXMLParseTag(CvFileStorage*, char*, CvStringHashNode**, CvAttrList**, int*)", "CvFileStorage* cvOpenFileStorage(char const*, CvMemStorage*, int, char const*)", "CvFileNode* cvGetFileNodeByName(const CvFileStorage*, const CvFileNode*, char const*)", "void cv::FileStorage::writeRaw(const string&, const uchar*, std::size_t)", "void cvWriteFileNode(CvFileStorage*, char const*, const CvFileNode*, int)", "void cv::read(const cv::FileNode&, cv::Mat&, const cv::Mat&)", "char* icvYMLSkipSpaces(CvFileStorage*, char*, int, int)", "void icvYMLStartWriteStruct(CvFileStorage*, char const*, int, char const*)", "char* icvYMLParseValue(CvFileStorage*, char*, CvFileNode*, int, int)", "void icvYMLWriteComment(CvFileStorage*, char const*, int)", "void cvWriteRawData(CvFileStorage*, void const*, int, char const*)", "char* icvGetFormat(const CvSeq*, char const*, CvAttrList*, int, char*)", "void cvReleaseFileStorage(CvFileStorage**)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const string&)", "void icvXMLParse(CvFileStorage*)", "void icvYMLEndWriteStruct(CvFileStorage*)", "void icvReleaseSeq(void**)", "void icvPuts(CvFileStorage*, char const*)", "void cvEndWriteStruct(CvFileStorage*)", "void* cvLoad(char const*, CvMemStorage*, char const*, char const**)", "void icvXMLWriteComment(CvFileStorage*, char const*, int)", "void cv::read(const cv::FileNode&, cv::SparseMat&, const cv::SparseMat&)", "void cvRelease(void**)", "void cvWriteComment(CvFileStorage*, char const*, int)", "int icvDecodeFormat(char const*, int*, int)", "char* icvYMLParseKey(CvFileStorage*, char*, CvFileNode*, CvFileNode**)", "void icvXMLWriteScalar(CvFileStorage*, char const*, char const*, int)", "ucwsifdr", "char* icvGets(CvFileStorage*, char*, int)", "void cvReadRawData(const CvFileStorage*, const CvFileNode*, void*, char const*)", "void* icvReadImage(CvFileStorage*, CvFileNode*)", "void icvWriteHeaderData(CvFileStorage*, const CvSeq*, CvAttrList*, int)", "void icvFSCreateCollection(CvFileStorage*, int, CvFileNode*)", "void cvStartReadRawData(const CvFileStorage*, const CvFileNode*, CvSeqReader*)", "void icvClose(CvFileStorage*, std::string*)", "The storage is not opened", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/persistence.cpp", "-.Inf", ".Inf", "%.16e", ".Nan", "%s(%d): %s", "Comments are not allowed here", "Invalid character in the stream", "Too long string or a last string w/o newline", "Tabs are prohibited in YAML!", "Invalid character", "Incorrect indentation", "Bad format of floating-point constant", "Invalid data type specification", "Too long data type specification", "Too complex format for the matrix", "Sequence element should not have name (use <_></_>)", "Unknown type of file node", "NULL double pointer", "Invalid filename", "unnamed", "The size of element calculated from \"dt\" and the elem_size do not match", "Size of sequence element (elem_size) is inconsistent with seq->flags", "%d%c", "ucwsifdr", "Invalid pointer to file storage", "Null key element", "The node is neither a map nor an empty collection", "Duplicated key", "Key may not start with '-'", "Missing ':'", "An empty key", "Null element name", "The file storage is opened for reading", "Null pointer to source file node or reader", "The file node should be a numerical scalar or a sequence", "Null pointer to reader or destination array", "The readed sequence is a scalar, thus len must be 1", "The sequence element is not a numerical scalar", "The sequence slice does not fit an integer number of records", "width", "height", "origin", "Some of essential image attributes are absent", "layout", "interleaved", "Only interleaved images can be read", "data", "The image data is not found in file storage", "The matrix size does not match to the number of stored elements", "Null pointers to source file node or destination array", "sizes", "Some of essential matrix attributes are absent", "Could not determine the matrix dimensionality", "The matrix data is not found in file storage", "rows", "cols", "Could not determine sparse matrix dimensionality", "Sparse matrix data is corrupted", "flags", "vertex_dt", "edge_dt", "vertex_count", "edge_count", "Some of essential graph attributes are absent", "The sequence flags are invalid", "oriented", "header_dt", "header_user_data", "One of \"header_dt\" and \"header_user_data\" is there, while the other is not", "Graph edges should start with 2 integers and a float", "%df%s", "vertices", "edges", "No edges data", "No vertices data", "Some of stored vertex indices are out of range", "Duplicated edge has occured", "count", "Some of essential sequence attributes are absent", "curve", "closed", "hole", "untyped", "rect", "Only one of \"header_user_data\", \"rect\" and \"origin\" tags may occur", "color", "The number of stored elements does not match to \"count\"", "Invalid type info", "Some of required function pointers (is_instance, release, read or write) are NULL", "Type name should start with a letter or _", "Type name should contain only letters, digits, - and _", "Map element should have a name", "Directive tags are not allowed here", "Empty tags are not supported", "type_id", "Mismatched closing tag", "There should be space between literals", "Invalid numeric value (inconsistent explicit type specification?)", "Literal \" is not allowed within a string. Use &quot;", "Closing \" is expected", "Literal ' or > are not allowed. Use &apos; or &gt;", "Invalid numeric value in the string", "Invalid character in the symbol entity name", "apos", "quot", "Too long string literal", "The actual type is different from the specified type", "Preliminary end of the stream", "Tag should start with '<'", "Unknown tag type", "Name should start with a letter or underscore", "Closing tag should not contain any attributes", "Attribute name should be followed by '='", "Attribute value should be put into single or double quotes", "Invalid closing tag for <?xml ...", "There should be space between attributes", "Empty type name", "float", "The wrong closing bracket", "Missing , between the elements", "Complex keys are not supported", "Multi-line text literals are not supported", "Block sequence elements must be preceded with '-'", "Unknown object type", "release function pointer is NULL", "NULL structure pointer", "clone function pointer is NULL", "The node does not represent a user object (unknown type?)", "sequences", "opencv-sequence-tree instance should contain a field \"sequences\" that should be a sequence", "level", "All the sequence tree nodes should contain \"level\" field", "Null pointer to the written object", "Unknown object", "The object does not have write function", "elem_size > 0", "Unknown array type", "CV_IS_SPARSE_MAT(m)", "vector::_M_insert_aux", "Extra closing '%c'", "The closing '%c' does not match the opening '%c'", "Incorrect element name %s", "Invalid fs.state", "An attempt to add element without a key to a map, or add element with key to sequence", "A single _ is a reserved tag name", "Closing tag should not include any attributes", "Key should start with a letter or _", "Key name may only contain alphanumeric characters [a-zA-Z0-9], '-' and '_'", "An extra closing tag", "elements with keys can not be written to sequence", "Null string pointer", "The written string is too long", "#x%02x", "The key is an empty", "The key is too long", "Key must start with a letter or _", "Key names may only contain alphanumeric characters [a-zA-Z0-9], '-', '_' and ' '", "Negative number of elements", "Null data pointer", "%.8e", "opencv-nd-matrix", "opencv-matrix", "top-left", "bottom-left", "planar", "Images with planar data layout are not supported", "opencv-image", "opencv-sparse-matrix", "The size of header calculated from \"header_dt\" is greater than header_size", "opencv-graph", "2if%s", "opencv-sequence", " closed", " hole", " curve", " untyped", "recursive", "false", "False", "FALSE", "opencv-sequence-tree", "len % elemSize == 0", "x%02x", "Some collection type - CV_NODE_SEQ or CV_NODE_MAP, must be specified", "!!%s %c", "!!%s", "Null comment", "EndWriteStruct w/o matching StartWriteStruct", "Double hyphen '--' is not allowed in the comments", "<!-- %s -->", "<!--", "Some collection type: CV_NODE_SEQ or CV_NODE_MAP must be specified", "NULL double pointer to file storage", "</opencv_storage>\n", "NULL or empty filename", "NULL or empty buffer", "CV_STORAGE_APPEND and CV_STORAGE_MEMORY are not currently compatible", "Appending data to compressed file is not implemented", ".xml", ".XML", ".Xml", "UTF-16", "utf-16", "Utf-16", "UTF-16 XML encoding is not supported! Use 8-bit encoding\n", "strlen(encoding) < 1000", "<?xml version=\"1.0\" encoding=\"%s\"?>\n", "<?xml version=\"1.0\"?>\n", "<opencv_storage>\n", "Could not find </opencv_storage> in the end of file.\n", " <!-- resumed -->", "%YAML:1.0\n", "...\n---\n", "%YAML:", "<?xml", "Valid XML should start with '<?xml ...?>'", "opencv_storage", "<opencv_storage> tag is missing", "</opencv_storage> tag is missing", "%YAML:1.", "Unsupported YAML version (it must be 1.x)", "The YAML streams must start with '---', except the first one", "Invalid or unsupported syntax", "Only collections as YAML streams are supported by this parser", "</opencv_storage>", "Could not find the/an object in file storage", "NULL memory storage is passed - the loaded dynamic structure can not be stored", "NULL object pointer", "Could not open the file storage. Check the path and permissions", "...\n", "---\n", "\n<!-- next stream -->\n", "void cvWriteInt(CvFileStorage*, char const*, int)", "void icvXMLWriteTag(CvFileStorage*, char const*, int, CvAttrList)", "N2cv16BatchDistInvokerE", "CvScalar cvSum(const CvArr*)", "int cv::normHamming(const uchar*, int, int)", "void cv::meanStdDev(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::InputArray)", "CvScalar cvAvg(void const*, void const*)", "double cv::norm(cv::InputArray, cv::InputArray, int, cv::InputArray)", "void cv::batchDistance(cv::InputArray, cv::InputArray, cv::OutputArray, int, cv::OutputArray, int, int, cv::InputArray, int, bool)", "bad cell size (not 1, 2 or 4) in normHamming", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/stat.cpp", "src.channels() == 1 && func != 0", "mask.empty() || mask.type() == CV_8U", "func != 0", "dst.type() == CV_64F && dst.isContinuous() && (dst.cols == 1 || dst.rows == 1) && dcn >= cn", "(cn == 1 && (mask.empty() || mask.type() == CV_8U)) || (cn >= 1 && mask.empty() && !minIdx && !maxIdx)", "img.dims <= 2", "src.type() == CV_8UC1", "idx.isContinuous()", "0 < coi && coi <= 4", "cn <= 4 && func != 0", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && src.type() == CV_8U)", "src1.size == src2.size && src1.type() == src2.type()", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2 || normType == NORM_L2SQR || ((normType == NORM_HAMMING || normType == NORM_HAMMING2) && src1.type() == CV_8U)", "type == src2.type() && src1.cols == src2.cols && (type == CV_32F || type == CV_8U)", "_nidx.needed() == (K > 0)", "(type == CV_8U && dtype == CV_32S) || dtype == CV_32F", "K == 1 && update == 0 && mask.empty()", "The combination of type=%d, dtype=%d and normType=%d is not supported", "int cv::countNonZero(cv::InputArray)", "void cv::minMaxLoc(cv::InputArray, double*, double*, cv::Point*, cv::Point*, cv::InputArray)", "cv::Scalar cv::mean(cv::InputArray, cv::InputArray)", "cv::Scalar cv::sum(cv::InputArray)", "double cv::norm(cv::InputArray, int, cv::InputArray)", "void cv::minMaxIdx(cv::InputArray, double*, double*, int*, int*, cv::InputArray)", "void cv::findNonZero(cv::InputArray, cv::OutputArray)", "void cvCopy(void const*, void*, void const*)", "void cv::Mat::copyTo(cv::OutputArray) const", "void cv::Mat::copyTo(cv::OutputArray, cv::InputArray) const", "void cvRepeat(const CvArr*, CvArr*)", "void cv::flip(cv::InputArray, cv::OutputArray, int)", "channels() == CV_MAT_CN(dtype)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/copy.cpp", "mask.depth() == CV_8U && (mcn == 1 || mcn == cn)", "size() == mask.size()", "checkScalar(value, type(), _value.kind(), _InputArray::MAT )", "mask.empty() || mask.type() == CV_8U", "src.dims <= 2", "ny > 0 && nx > 0", "maskarr == 0", "src.depth() == dst.depth() && src.size == dst.size", "(coi1 != 0 || src.channels() == 1) && (coi2 != 0 || dst.channels() == 1)", "src.channels() == dst.channels()", "src.type() == dst.type() && src.size() == dst.size()", "src.type() == dst.type() && dst.rows % src.rows == 0 && dst.cols % src.cols == 0", "cv::Mat& cv::Mat::setTo(cv::InputArray, cv::InputArray)", "void cv::repeat(cv::InputArray, int, int, cv::OutputArray)", "void cvFlip(const CvArr*, CvArr*, int)", "void cvPolarToCart(const CvArr*, const CvArr*, CvArr*, CvArr*, int)", "int cv::solveCubic(cv::InputArray, cv::OutputArray)", "void cvPow(const CvArr*, CvArr*, double)", "void cvCartToPolar(const CvArr*, const CvArr*, CvArr*, CvArr*, int)", "void cv::magnitude(cv::InputArray, cv::InputArray, cv::OutputArray)", "void cv::exp(cv::InputArray, cv::OutputArray)", "void cv::cartToPolar(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool)", "double cv::solvePoly(cv::InputArray, cv::OutputArray, int)", "void cvLog(const CvArr*, CvArr*)", "X.size == Y.size && type == Y.type() && (depth == CV_32F || depth == CV_64F)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/mathfuncs.cpp", "depth == CV_32F || depth == CV_64F", "func != 0", "the value at (%d, %d)=%g is out of range", "a.depth() == CV_32F", "src.type() == dst.type() && src.size == dst.size", "CV_MAT_DEPTH(ctype) >= CV_32F && CV_MAT_CN(ctype) <= 2", "coeffs0.rows == 1 || coeffs0.cols == 1", "_r.data == _r0.data", "Mag.empty() || (Angle.size == Mag.size && type == Mag.type() && (depth == CV_32F || depth == CV_64F))", "Mag.size() == Angle.size() && Mag.type() == Angle.type()", "X.size() == Angle.size() && X.type() == Angle.type()", "Y.size() == Angle.size() && Y.type() == Angle.type()", "Mag.size() == X.size() && Mag.type() == X.type()", "Angle.size() == X.size() && Angle.type() == X.type()", "ctype == CV_32F || ctype == CV_64F", "(coeffs.size() == Size(n0, 1) || coeffs.size() == Size(n0+1, 1) || coeffs.size() == Size(1, n0) || coeffs.size() == Size(1, n0+1))", "_roots.data == _roots0.data", "void cv::patchNaNs(cv::InputOutputArray, double)", "void cv::polarToCart(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool)", "void cvSolvePoly(const CvMat*, CvMat*, int, int)", "void cv::phase(cv::InputArray, cv::InputArray, cv::OutputArray, bool)", "void cv::log(cv::InputArray, cv::OutputArray)", "void cv::pow(cv::InputArray, double, cv::OutputArray)", "void cv::gemm(cv::InputArray, cv::InputArray, double, cv::InputArray, double, cv::OutputArray, int)", "void cv::calcCovarMatrix(cv::InputArray, cv::OutputArray, cv::InputOutputArray, int, int)", "void cv::calcCovarMatrix(const cv::Mat*, int, cv::Mat&, cv::Mat&, int, int)", "void cv::PCA::project(cv::InputArray, cv::OutputArray) const", "void cvBackProjectPCA(const CvArr*, const CvArr*, const CvArr*, CvArr*)", "void cvCalcPCA(const CvArr*, CvArr*, CvArr*, CvArr*, int)", "void cv::perspectiveTransform(cv::InputArray, cv::OutputArray, cv::InputArray)", "void cv::PCA::backProject(cv::InputArray, cv::OutputArray) const", "src1.type() == src2.type()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/matmul.cpp", "mat.type() == type() && mat.size == size && func != 0", "src1.size == dst.size && src1.type() == dst.type()", "type == B.type() && (type == CV_32FC1 || type == CV_64FC1 || type == CV_32FC2 || type == CV_64FC2)", "a_size.width == len", "a_size.height == len", "C.type() == type && (((flags&GEMM_3_T) == 0 && C.rows == d_size.height && C.cols == d_size.width) || ((flags&GEMM_3_T) != 0 && C.rows == d_size.width && C.cols == d_size.height))", "type == CV_64FC2", "(D.rows == ((flags & CV_GEMM_A_T) == 0 ? A.rows : A.cols)) && (D.cols == ((flags & CV_GEMM_B_T) == 0 ? B.cols : B.rows)) && D.type() == A.type()", "mean.data && eigenvectors.data && ((mean.rows == 1 && eigenvectors.rows == data.cols) || (mean.cols == 1 && eigenvectors.rows == data.rows))", "data.cols <= evects.rows && dst.rows == data.rows", "data.rows <= evects.rows && dst.cols == data.cols", "dst0.data == dst.data", "mean.data && eigenvectors.data && ((mean.rows == 1 && mean.cols == data.cols) || (mean.cols == 1 && mean.rows == data.rows))", "dst.cols <= evects.rows && dst.rows == data.rows", "dst.rows <= evects.rows && dst.cols == data.cols", "src.channels() == 1", "delta.channels() == 1 && (delta.rows == src.rows || delta.rows == 1) && (delta.cols == src.cols || delta.cols == 1)", "type == v2.type() && type == icovar.type() && sz == v2.size() && len == icovar.rows && len == icovar.cols", "scn + 1 == m.cols && (depth == CV_32F || depth == CV_64F)", "dst.type() == src.type() && dst.channels() == m.rows-1", "scn == m.cols || scn + 1 == m.cols", "func != 0", "dst.depth() == src.depth() && dst.channels() == m.rows", "src.size() > 0", "(*each).size() == size && (*each).type() == type", "_mean.size() == size", "((flags & CV_COVAR_ROWS) != 0) ^ ((flags & CV_COVAR_COLS) != 0)", "nsamples > 0", "mean.size() == size", "data.channels() == 1", "_mean.size() == mean_sz", "(evals0.cols == 1 || evals0.rows == 1) && ecount0 <= ecount && evects0.cols == evects.cols && evects0.rows == ecount0", "mean0.data == mean.data", "data && nsamples > 0", "data[i].size() == size && data[i].type() == type", "retainedVariance > 0 && retainedVariance <= 1", "vecarr != 0 && count >= 1", "void cvCalcCovarMatrix(const CvArr**, int, CvArr*, CvArr*, int)", "void cv::transform(cv::InputArray, cv::OutputArray, cv::InputArray)", "void cvProjectPCA(const CvArr*, const CvArr*, const CvArr*, CvArr*)", "cv::PCA& cv::PCA::computeVar(cv::InputArray, cv::InputArray, int, double)", "void cvScaleAdd(const CvArr*, CvScalar, const CvArr*, CvArr*)", "cv::PCA& cv::PCA::operator()(cv::InputArray, cv::InputArray, int, int)", "void cvPerspectiveTransform(const CvArr*, CvArr*, const CvMat*)", "double cv::Mat::dot(cv::InputArray) const", "void cv::mulTransposed(cv::InputArray, cv::OutputArray, bool, cv::InputArray, double, int)", "void cvGEMM(const CvArr*, const CvArr*, double, const CvArr*, double, CvArr*, int)", "void cvTransform(const CvArr*, CvArr*, const CvMat*, const CvMat*)", "void cv::scaleAdd(cv::InputArray, double, cv::InputArray, cv::OutputArray)", "void cv::GlCamera::setupModelViewMatrix() const", "void cv::GlBuffer::unmapDevice()", "cv::GlBuffer::GlBuffer(cv::Size, int, cv::GlBuffer::Usage)", "static cv::Ptr<cv::GlFont> cv::GlFont::get(const string&, int, cv::GlFont::Weight, cv::GlFont::Style)", "void cv::GlArrays::setTexCoordArray(cv::InputArray)", "cv::GlCamera::GlCamera()", "void cv::GlFont::draw(char const*, int) const", "void cv::GlArrays::setVertexArray(cv::InputArray)", "15CvOpenGlFuncTab", "void cv::GlCamera::setScale(cv::Point3d)", "cv::gpu::GpuMat cv::GlBuffer::mapDevice()", "cv::GlBuffer::GlBuffer(cv::GlBuffer::Usage)", "void cv::GlTexture::create(int, int, int)", "void cv::GlArrays::bind() const", "void cv::GlArrays::setColorArray(cv::InputArray, bool)", "cv::GlTexture::GlTexture(cv::Size, int)", "void cv::GlArrays::unbind() const", "void cv::GlBuffer::unbind() const", "void cv::GlTexture::unbind() const", "void cv::GlCamera::setPerspectiveProjection(double, double, double, double)", "void cv::GlArrays::setNormalArray(cv::InputArray)", "void cv::GlBuffer::create(int, int, int, cv::GlBuffer::Usage)", "cv::GlBuffer::GlBuffer(cv::InputArray, cv::GlBuffer::Usage)", "void cv::GlTexture::copyFrom(cv::InputArray, bool)", "void cv::GlTexture::bind() const", "cv::GlBuffer::GlBuffer(int, int, int, cv::GlBuffer::Usage)", "void cv::GlBuffer::bind() const", "void cv::GlCamera::lookAt(cv::Point3d, cv::Point3d, cv::Point3d)", "cv::Mat cv::GlBuffer::mapHost()", "void icvSetOpenGlFuncTab(const CvOpenGlFuncTab*)", "void cv::GlCamera::setOrthoProjection(double, double, double, double, double, double)", "cv::GlTexture::GlTexture(cv::InputArray, bool)", "void cv::GlCamera::setCameraPos(cv::Point3d, double, double, double)", "void cv::render(const string&, const cv::Ptr<cv::GlFont>&, cv::Scalar, cv::Point2d)", "void cv::GlCamera::setProjectionMatrix(const cv::Mat&, bool)", "void cv::render(const cv::GlArrays&, int, cv::Scalar)", "cv::GlFont::GlFont(const string&, int, cv::GlFont::Weight, cv::GlFont::Style)", "bool icvCheckGlError(char const*, int, char const*)", "void cv::render(const cv::GlTexture&, cv::Rect_<double>, cv::Rect_<double>)", "cv::GlTexture::GlTexture()", "cv::GlTexture::GlTexture(int, int, int)", "void cv::GlBuffer::unmapHost()", "void cv::GlCamera::setupProjectionMatrix() const", "This function in deprecated, do not use it", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/opengl_interop_deprecated.cpp", "void cv::GlBuffer::copyFrom(cv::InputArray)", "int cvSolve(const CvArr*, const CvArr*, CvArr*, int)", "static void cv::SVD::backSubst(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray)", "void cv::_SVDcompute(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int)", "double cvDet(const CvArr*)", "double cv::determinant(cv::InputArray)", "bool cv::solve(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "void cvSVBkSb(const CvArr*, const CvArr*, const CvArr*, const CvArr*, CvArr*, int)", "w.type() == u.type() && u.type() == vt.type() && u.data && vt.data && w.data", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/lapack.cpp", "u.cols >= nm && vt.rows >= nm && (w.size() == Size(nm, 1) || w.size() == Size(1, nm) || w.size() == Size(vt.rows, u.cols))", "rhs.data == 0 || (rhs.type() == type && rhs.rows == m)", "dst.data == dst0.data", "src.rows == src.cols", "type == CV_32F || type == CV_64F", "p == evects0.data", "p == evals0.data", "mat.rows == mat.cols && (type == CV_32F || type == CV_64F)", "rows == mat->cols", "w.type() == type && (w.size() == cv::Size(nm,1) || w.size() == cv::Size(1, nm) || w.size() == cv::Size(nm, nm) || w.size() == cv::Size(n, m))", "u.type() == type", "v.type() == type", "u.size() == svd.u.size()", "v.size() == svd.vt.size()", "m == n", "method == DECOMP_LU || method == DECOMP_CHOLESKY", "src.type() == dst.type() && src.rows == dst.cols && src.cols == dst.rows", "type == _src2.type() && (type == CV_32F || type == CV_64F)", "(method != DECOMP_LU && method != DECOMP_CHOLESKY) || is_normal || src.rows == src.cols", "The function can not solve under-determined linear systems", "A.type() == x.type() && A.cols == x.rows && x.cols == b.cols", "void cvSVD(CvArr*, CvArr*, CvArr*, CvArr*, int)", "void cvEigenVV(CvArr*, CvArr*, CvArr*, double, int, int)", "bool cv::eigen(cv::InputArray, bool, cv::OutputArray, cv::OutputArray)", "double cvInvert(const CvArr*, CvArr*, int)", "double cv::invert(cv::InputArray, cv::OutputArray, int)", "N2cv17MatOp_InitializerE", "N2cv11MatOp_AddExE", "N2cv11MatOp_SolveE", "virtual void cv::MatOp_Bin::assign(const cv::MatExpr&, cv::Mat&, int) const", "N2cv5MatOpE", "N2cv9MatOp_BinE", "virtual void cv::MatOp_Identity::assign(const cv::MatExpr&, cv::Mat&, int) const", "N2cv9MatOp_CmpE", "N2cv12MatOp_InvertE", "virtual void cv::MatOp_Initializer::assign(const cv::MatExpr&, cv::Mat&, int) const", "N2cv10MatOp_GEMME", "N2cv7MatOp_TE", "N2cv14MatOp_IdentityE", "Invalid matrix initializer type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/matop.cpp", "CV_MAT_CN(_type) == e.a.channels()", "Unknown operation", "void cv::DFT(const cv::Complex<_Tp>*, cv::Complex<_Tp>*, int, int, int const*, int const*, const cv::Complex<_Tp>*, int, void const*, cv::Complex<_Tp>*, int, double) [with T = float]", "void cvDCT(const CvArr*, CvArr*, int)", "void cv::DFT(const cv::Complex<_Tp>*, cv::Complex<_Tp>*, int, int, int const*, int const*, const cv::Complex<_Tp>*, int, void const*, cv::Complex<_Tp>*, int, double) [with T = double]", "factors[0] == factors[nf-1]", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/dxt.cpp", "type == CV_32FC1 || type == CV_32FC2 || type == CV_64FC1 || type == CV_64FC2", "This mode (using nonzero_rows with a single-column matrix) breaks the function's logic, so it is prohibited.\nFor fast convolution/correlation use 2-column matrix or single-row matrix instead", "type == srcB.type() && srcA.size() == srcB.size()", "type == CV_32FC1 || type == CV_64FC1", "Odd-size DCT's are not implemented", "src.size == dst.size", "dst.data == dst0.data", "srcA.size == dst.size && srcA.type() == dst.type()", "src.size == dst.size && src.type() == dst.type()", "void cvDFT(const CvArr*, CvArr*, int, int)", "0Y\r@:i\r", "PF SdF", " [@W:[", "?void cvMulSpectrums(const CvArr*, const CvArr*, CvArr*, int)", "void cv::dft(cv::InputArray, cv::OutputArray, int, int)", "void cv::RNG::fill(cv::InputOutputArray, int, cv::InputArray, cv::InputArray, bool)", "void cv::makeRNGKey()", "errcode == 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/rand.cpp", "_param1.channels() == 1 && (_param1.rows == 1 || _param1.cols == 1) && (_param1.rows + _param1.cols - 1 == cn || _param1.rows + _param1.cols - 1 == 1 || (_param1.size() == Size(1, 4) && _param1.type() == CV_64F && cn <= 4))", "_param2.channels() == 1 && (((_param2.rows == 1 || _param2.cols == 1) && (_param2.rows + _param2.cols - 1 == cn || _param2.rows + _param2.cols - 1 == 1 || (_param1.size() == Size(1, 4) && _param1.type() == CV_64F && cn <= 4))) || (_param2.rows == cn && _param2.cols == cn && disttype == NORMAL))", "func != 0", "scaleFunc != 0", "Unknown distribution type", "dst.elemSize() <= 32", "void cv::merge(const cv::Mat*, std::size_t, cv::OutputArray)", "void cvConvertScaleAbs(void const*, void*, double, double)", "void cv::split(const cv::Mat&, cv::Mat*)", "void cv::extractChannel(cv::InputArray, cv::OutputArray, int)", "void cv::convertScaleAbs(cv::InputArray, cv::OutputArray, double, double)", "void cvSplit(void const*, void*, void*, void*, void*)", "void cv::mixChannels(const cv::Mat*, std::size_t, cv::Mat*, std::size_t, int const*, std::size_t)", "void cv::normalize(cv::InputArray, cv::OutputArray, double, double, int, int, cv::InputArray)", "func != 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/convert.cpp", "interpolation == 0", "(lutcn == cn || lutcn == 1) && lut.total() == 256 && lut.isContinuous() && (src.depth() == CV_8U || src.depth() == CV_8S)", "Unknown/unsupported norm type", "src.size == dst.size && dst.type() == CV_8UC(src.channels())", "src.size == dst.size && src.channels() == dst.channels()", "dst.size() == src.size() && dst.type() == CV_MAKETYPE(lut.depth(), src.channels())", "dst.size() == src.size() && src.channels() == dst.channels()", "src && nsrcs > 0 && dst && ndsts > 0 && fromTo && npairs > 0", "j < nsrcs && src[j].depth() == depth", "i1 >= 0 && j < ndsts && dst[j].depth() == depth", "src.size == dst.size && src.depth() == dst.depth()", "0 <= coi && coi < dst.channels() && src.channels() == 1", "0 <= coi && coi < src.channels()", "fromTo.size()%2 == 0 && nsrc > 0 && ndst > 0", "!_mv.fixedType() || CV_MAT_TYPE(_mv.flags) == m.depth()", "mv && n > 0", "mv[i].size == mv[0].size && mv[i].depth() == depth", "0 < cn && cn <= CV_CN_MAX", "nz > 0", "svec[j].size == dst.size && svec[j].depth() == dst.depth() && svec[j].channels() == 1 && i < dst.channels()", "dvec[j].size() == src.size()", "dvec[j].depth() == src.depth()", "dvec[j].channels() == 1", "i < src.channels()", "void cvMerge(void const*, void const*, void const*, void const*, void*)", "void cv::Mat::convertTo(cv::OutputArray, int, double, double) const", "void cvConvertScale(void const*, void*, double, double)", "void cv::LUT(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "void cvNormalize(const CvArr*, CvArr*, double, double, int, const CvArr*)", "void cvLUT(void const*, void*, void const*)", "void cv::insertChannel(cv::InputArray, cv::InputOutputArray, int)", "void cv::split(cv::InputArray, cv::OutputArrayOfArrays)", "void cv::mixChannels(cv::InputArrayOfArrays, cv::InputArrayOfArrays, const std::vector<int>&)", "void cv::convertAndUnrollScalar(const cv::Mat&, int, uchar*, std::size_t)", "void cvNot(const CvArr*, CvArr*)", "void cvSubRS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvAdd(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvMinS(void const*, double, void*)", "void cvMax(void const*, void const*, void*)", "void cvAndS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvXorS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cv::arithm_op(cv::InputArray, cv::InputArray, cv::OutputArray, cv::InputArray, int, void (**)(const uchar*, size_t, const uchar*, size_t, uchar*, size_t, cv::Size, void*), bool, void*)", "void cvDiv(const CvArr*, const CvArr*, CvArr*, double)", "void cv::inRange(cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray)", "void cv::binary_op(cv::InputArray, cv::InputArray, cv::OutputArray, cv::InputArray, void (* const*)(const uchar*, size_t, const uchar*, size_t, uchar*, size_t, cv::Size, void*), bool)", "void cvAddWeighted(const CvArr*, double, const CvArr*, double, double, CvArr*)", "void cvSub(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvInRangeS(void const*, CvScalar, CvScalar, void*)", "scn == 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/arithm.cpp", "The lower bounary is neither an array of the same size and same type as src, nor a scalar", "The upper bounary is neither an array of the same size and same type as src, nor a scalar", "((int)lbScalar ^ (int)ubScalar) == 0", "lb.type() == ub.type()", "src1.size == dst.size && dst.type() == CV_8U", "op == CMP_LT || op == CMP_LE || op == CMP_EQ || op == CMP_NE || op == CMP_GE || op == CMP_GT", "The operation is neither 'array op array' (where arrays have the same size and the same type), nor 'array op scalar', nor 'scalar op array'", "The operation is neither 'array op array' (where arrays have the same size and the same number of channels), nor 'array op scalar', nor 'scalar op array'", "src2.type() == CV_64F && (src2.rows == 4 || src2.rows == 1)", "When the input arrays in add/subtract/multiply/divide functions have different types, the output array type must be explicitly specified", "(mask.type() == CV_8UC1 || mask.type() == CV_8SC1)", "mask.size == src1.size", "src1.size == dst.size && src1.channels() == dst.channels()", "src2.size == dst.size && src2.channels() == dst.channels()", "src1.size == dst.size && src1.type() == dst.type()", "The operation is neither 'array op array' (where arrays have the same size and type), nor 'array op scalar', nor 'scalar op array'", "src.size == dst.size && src.type() == dst.type()", "void cvCmpS(void const*, double, void*, int)", "void cvMin(void const*, void const*, void*)", "void cvMul(const CvArr*, const CvArr*, CvArr*, double)", "void cvInRange(void const*, void const*, void const*, void*)", "void cvOrS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvXor(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cv::compare(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "void cvAddS(const CvArr*, CvScalar, CvArr*, const CvArr*)", "void cvAbsDiff(const CvArr*, const CvArr*, CvArr*)", "void cvOr(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cvCmp(void const*, void const*, void*, int)", "void cvMaxS(void const*, double, void*)", "void cvAbsDiffS(const CvArr*, CvArr*, CvScalar)", "void cvAnd(const CvArr*, const CvArr*, CvArr*, const CvArr*)", "void cv::ogl::Arrays::setNormalArray(cv::InputArray)", "void cv::ogl::Arrays::setTexCoordArray(cv::InputArray)", "void cv::ogl::Arrays::setColorArray(cv::InputArray)", "The library is compiled without OpenGL support", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/opengl_interop.cpp", "cn >= 1 && cn <= 4", "depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "cn == 3", "depth == CV_8S || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F", "cn == 3 || cn == 4", "cn == 2 || cn == 3 || cn == 4", "void (anonymous namespace)::throw_nogl()", "void cv::ogl::Arrays::setVertexArray(cv::InputArray)", "MWRMNV RMVV PSTS", "MWOMOV OMSMUNUPSQ OQSQURUUSVOV", "MXVNTMRMPNOPOSPURVTVVU", "MWOMOV OMRMTNUPUSTURVOV", "MWOMOV OMUM OQSQ OVUV", "MVOMOV OMUM OQSQ", "MXVNTMRMPNOPOSPURVTVVUVR SRVR", "MWOMOV UMUV OQUQ", "PTRMRV", "NUSMSTRVPVOTOS", "MWOMOV UMOS QQUV", "MVOMOV OVUV", "LXNMNV NMRV VMRV VMVV", "MWOMOV OMUV UMUV", "MXRMPNOPOSPURVSVUUVSVPUNSMRM", "MWOMOV OMSMUNUQSROR", "MXRMPNOPOSPURVSVUUVSVPUNSMRM STVW", "MWOMOV OMSMUNUQSROR RRUV", "MWUNSMQMONOOPPTRUSUUSVQVOU", "MWRMRV NMVM", "MXOMOSPURVSVUUVSVM", "MWNMRV VMRV", "LXNMPV RMPV RMTV VMTV", "MWOMUV UMOV", "MWNMRQRV VMRQ", "MWUMOV OMUM OVUV", "MVOMOV OMUM", "MWRMNV RMVV NVVV", "MXRMPNOPOSPURVSVUUVSVPUNSMRM QQTR TQQR", "MWRMNV RMVV", "MWOMUM PQTR TQPR OVUV", "MWOMOV UMUV OMUM", "MWOMRQOV OMUM OVUV", "MWNONNOMPMQNRPRV VOVNUMTMSNRP", "LXRMRV PONPNSPTTTVSVPTOPO", "LXRMRV NOOPOSQTSTUSUPVO", "MXOVQVOROPPNRMSMUNVPVRTVVV", "MWSMMV SMUV OSTS", "MWQMNV QMTMVNVPSQPQ SQURUTTURVNV", "LXVPUNTMRMPNOONQNSOUPVRVTUUT", "MXQMNV QMUMVOVQUTTURVNV", "MVQMNV QMVM PQSQ NVSV", "MVQMNV QMVM PQSQ", "LXVPUNTMRMPNOONQNSOUPVRVTUUSRS", "MXQMNV WMTV PQUQ", "PUTMQV", "OVUMSSRUQVPVOUOT", "MVQMNV VMOS RQTV", "NVRMOV OVTV", "LYPMMV PMQV XMQV XMUV", "MXQMNV QMTV WMTV", "LXRMPNOONQNSOUPVRVTUUTVRVPUNTMRM", "MWQMNV QMUMVNVPUQSRPR", "LXRMPNOONQNSOUPVRVTUUTVRVPUNTMRM QVPUPTQSRSSTTVUWVW", "MWQMNV QMUMVNVPUQSRPR QRRUSVTVUU", "MWVNTMRMPNPPQQTRUSUUSVPVNU", "MVSMPV PMVM", "LXPMNSNUOVRVTUUSWM", "MWOMQV WMQV", "KXNMNV SMNV SMSV XMSV", "NWQMTV WMNV", "NWQMSQQV WMSQ", "MWQMWMNVTV", "LXNMRV VMRV NMVM", "MWNLVX", "LXRONU ROVU", "MWNVVV", "PVRMUQ", "MWMMOKQKTMVMWK", "NWQPTPUQUV URQSPTPUQVSVUU", "MWOMOV OSPURVTUUSTQRPPQOS", "MWUQSPRPPQOSPURVSVUU", "MWUMUV USTQRPPQOSPURVTUUS", "MWOSUSTQRPPQOSPURVTV", "NVUNTMSMRNRV PPTP", "MWUPUVTXRYPY USTQRPPQOSPURVTUUS", "MWOMOV OSPQRPTQUSUV", "PTRLQMRNSMRL RPRV", "PUSLRMSNTMSL SPSXRYQYPX", "NWPMPV UPPT RSUV", "KYMPMV MSNQOPPPQQRSRV RSSQTPUPVQWSWV", "MWOPOV OSPQRPTQUSUV", "MWRPPQOSPURVTUUSTQRP", "MWOPOY OSPURVTUUSTQRPPQOS", "MWUPUY USTQRPPQOSPURVTUUS", "NVPPPV PSQQSPTP", "NWUQTPQPPQPRQSTSUTUUTVQVPU", "NVRMRUSVTVUU PPTP", "MWUPUV OPOSPURVTUUS", "NVOPRV UPRV", "LXNPPV RPPV RPTV VPTV", "MWOPUV UPOV", "MWOPRV UPRVQXPYOY", "MWOPUPOVUV", "MXVPUSTURVPUOSPQRPTQUUVV", "MWOTQVSVTUTSSRPQRQTPUOUNTMRMQNPPOTNY", "MXNQOPQPRQRSQW VPURSTQWPY", "MWTNSMRMQNQORPTQUSTURVPUOSPQRP", "NWUQSPQPPQPRQS SSQSPTPUQVSVUU", "NWTMSNSOTP UPSPQQPSPUQVSWSXRYQY", "LXNQOPPPQQQSPV QSRQTPUPVQVSUVTY", "LXNQOPPPQQQURVSVTUUSVPVNUMTMSNSPTRUSWT", "OVRPQSQURVSVTU", "MWQPOV UPTPRQPS PSQUSVTV", "MWOMPMQNRPUV RPOV", "LYPPMY UPTSSUQVPVOUOS TSTUUVVVWU", "MWNPOPOV UPTSRUOV", "NWTMSNSOTP UPSPQQQRRSTS SSQTPUPVQWSXSYRZQZ", "MXOQQPVP QPQRPV TPTRUV", "MWOSPURVTUUSTQRPPQOSNY", "MXVPRPPQOSPURVTUUSTQRP", "MXOQQPVP SPRV", "KXMQNPOPPQPUQVSVTUUSVP", "MXPPOQOSPURVSVUUVSVQUPTPSQRSQY", "MWOPPPQQSXTYUY UPTRPWOY", "KYTMRY MQNPOPPQPUQVTVUUVSWP", "LXOPNRNTOVQVRTRR UPVRVTUVSVRT", "LWTSSQQPOQNSOUQVSUTS UPTSTUUVVV", "MWQMOSPURVTUUSTQRPPQOS", "MWUQSPRPPQOSPURVTV", "LWTSSQQPOQNSOUQVSUTS VMTSTUUVVV", "MWOSTSURUQSPRPPQOSPURVTV", "OVVMUMTNSPQVPXOYNY QPUP", "MXUSTQRPPQOSPURVTUUS VPTVSXRYPYOX", "MVQMNV OSPQQPSPTQTRSTSUTVUV", "PUSMSNTNTMSM QPRPSQSRRTRUSVTV", "OUSMSNTNTMSM QPRPSQSRRVQXPYOYNX", "NVRMOV UPTPRQPS PSQUSVTV", "OTSMQSQURVSV", "JYKPLPMQMSLV MSNQOPQPRQRSQV RSSQTPVPWQWRVTVUWVXV", "MWNPOPPQPSOV PSQQRPTPUQURTTTUUVVV", "MXNPOPPQPSNY PSQUSVUUVSUQSPQQPS", "MXUSTQRPPQOSPURVTUUS VPSY", "MVOPPPQQQSPV UQTPSPRQQS", "NVTQSPQPPQPRQSRSSTSURVPVOU", "NUSMQSQURVSV PPTP", "MWNPOPPQPROTOUPVRVSUTS UPTSTUUVVV", "MWNPOPPQPROTOUPVRVTUURUP", "KYLPMPNQNRMTMUNVPVQURSSP RSRUSVUVVUWRWP", "MWOQPPQPRQRUSVTVUU VQUPTPSQQUPVOVNU", "MWNPOPPQPROTOUPVRVSUTS UPSVRXQYOYNX", "NVUPOV PQQPSPTQ PUQVSVTU", "MWUSTQRPPQOSPURVTUUSUPTNRMQM", "MWUQSPRPPQOSPURVSVUU OSSS", "MWRMQNPPOSOVPWRWSVTTUQUNTMRM PRTR", "MWTMQY RPPQOSPURVSVUUVSUQSPRP", "MWUQSPQPOQOSPTRUSVSWRXQX", "KYTPTSUTVTWSWQVOUNSMQMONNOMQMSNUOVQWSWUV TQSPQPPQPSQTSTTS", "MWUNORUV", "MWONUROV", "OUTKQKQYTY", "OUPKSKSYPY", "OUTKSLRNROSQQRSSRURVSXTY", "OUPKQLRNROQQSRQSRURVQXPY", "LYPMQNQOPPOPNONNOMPMSNUNWMNV USTTTUUVVVWUWTVSUS", "MWRMPNOPOSPURVTUUSUPTNRM", "MWPORMRV", "MWONQMSMUNUPTROVUV", "MWONQMSMUNUPSQ RQSQURUUSVQVOU", "MWSMSV SMNSVS", "MWPMOQQPRPTQUSTURVQVOU PMTM", "MWTMRMPNOPOSPURVTUUSTQRPPQOS", "MWUMQV OMUM", "MWQMONOPQQSQUPUNSMQM QQOROUQVSVUUURSQ", "MWUPTRRSPROPPNRMTNUPUSTURVPV", "PURURVSVSURU", "PUSVRVRUSUSWRY", "PURPRQSQSPRP RURVSVSURU", "PURPRQSQSPRP SVRVRUSUSWRY", "PURMRR SMSR RURVSVSURU", "NWPNRMSMUNUPRQRRSRSQUP RURVSVSURU", "PTRMRQ", "NVPMPQ TMTQ", "NVQMPNPPQQSQTPTNSMQM", "MWRKRX UNSMQMONOPQQTRUSUUSVQVOU", "MWVLNX", "OUTKRNQQQSRVTY", "OUPKRNSQSSRVPY", "PTRKRY", "LXNRVR", "LXRNRV NRVR", "LXNPVP NTVT", "MWOOUU UOOU", "MWRORU OPUT UPOT", "PURQRRSRSQRQ", "PUSMRORQSQSPRP", "PUSNRNRMSMSORQ", "LXSOVRSU NRVR", "MXQLQY TLTY OQVQ OTVT", "LXVRURTSSURVOVNUNSORRQSPSNRMPMONOPQSSUUVVV", "LXNNOQOSNV VNUQUSVV NNQOSOVN NVQUSUVV", "LYRQQPOPNQNSOTQTRSSQTPVPWQWSVTTTSSRQ", "H\\NRMQLRMSNR VRWQXRWSVR", "H\\MPLQLRMSNSOROQNPMP MQMRNRNQMQ WPVQVRWSXSYRYQXPWP WQWRXRXQWQ", "I[KRYR", "H\\RUJPRTZPRU", "F^ISJQLPNPPQTTVUXUZT[Q ISJPLONOPPTSVTXTZS[Q IYJWLVNVPWTZV[X[ZZ[W IYJVLUNUPVTYVZXZZY[W", "F^ISJQLPNPPQTTVUXUZT[Q ISJPLONOPPTSVTXTZS[Q IW[W I[[[", "CaGO]OXI L[GU]U", "D`F^^^^FFFF^", "KYQVOUNSNQOOQNSNUOVQVSUUSVQV SVVS QVVQ OUUO NSSN NQQN", "H\\IR[R", "H\\IR[R IQ[Q", "LYPFSCSP RDRP OPVP MRXR OVOWNWNVOUQTTTVUWWVYTZQ[O\\N^Na TTUUVWUYTZ N`O_P_S`V`W_ P_SaVaW_W^", "LYPFSCSP RDRP OPVP MRXR OVOWNWNVOUQTTTVUWWVYTZ TTUUVWUYTZ RZTZV[W]W^V`TaQaO`N_N^O^O_ TZU[V]V^U`Ta", "LYPFSCSP RDRP OPVP MRXR VVVWWWWVVUTTRTPUOVNYN^O`QaTaV`W^W\\VZTYQYN[ RTPVOYO^P`Qa TaU`V^V\\UZTY", "LYPFSCSP RDRP OPVP MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYOEOFNFNEODQCTCVDWFVHTIQJOKNMNP TCUDVFUHTI NOONPNSOVOWN PNSPVPWNWM MRXR OVOWNWNVOUQTTTVUWWVYTZ TTUUVWUYTZ RZTZV[W]W^V`TaQaO`N_N^O^O_ TZU[V]V^U`Ta", "LYOEOFNFNEODQCTCVDWFVHTI TCUDVFUHTI RITIVJWLWMVOTPQPOONNNMOMON TIUJVLVMUOTP MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYOCNI OCVC ODSDVC NIOHQGTGVHWJWMVOTPQPOONNNMOMON TGUHVJVMUOTP MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYNCNG VERLPP WCTIQP NEPCRCUE NEPDRDUEVE MRXR QTOUNWOYQZTZVYWWVUTTQT QTPUOWPYQZ TZUYVWUUTT QZO[N]N^O`QaTaV`W^W]V[TZ QZP[O]O^P`Qa TaU`V^V]U[TZ", "LYOCNI OCVC ODSDVC NIOHQGTGVHWJWMVOTPQPOONNNMOMON TGUHVJVMUOTP MRXR VVVWWWWVVUTTRTPUOVNYN^O`QaTaV`W^W\\VZTYQYN[ RTPVOYO^P`Qa TaU`V^V\\UZTY", "LYPFSCSP RDRP OPVP MRXR SVSa TTTa TTM]X] QaVa", "LYOEOFNFNEODQCTCVDWFVHTI TCUDVFUHTI RITIVJWLWMVOTPQPOONNNMOMON TIUJVLVMUOTP MRXR SVSa TTTa TTM]X] QaVa", "F^YXWZU[R[PZMXKWIWHXHZI[K[MZOWPURQTKWGYFZF[G\\H[IZH[G[FZFYFWGVHTLRPPVNZMZ OPUP", "E^P[MZJXHUGRGOHLJIMGPFTFWGYI[L\\O\\R[UYXVZS[P[ NJNW OJOW LJSJVKWMWNVPSQOQ SJUKVMVNUPSQ LWQW SQTRUVVWWWXV SQURVVWW", "E^P[MZJXHUGRGOHLJIMGPFTFWGYI[L\\O\\R[UYXVZS[P[ UKVJVNUKSJPJNKMLLOLRMUNVPWSWUVVT PJNLMOMRNUPW", "E_IM[M IR[R IW[W K[YI", "CaHQGRHSIRHQ RQQRRSSRRQ \\Q[R\\S]R\\Q", "E_NWLTIRLPNM LPJRLT JRZR VWXT[RXPVM XPZRXT", "JZWNTLRIPLMN PLRJTL RJRZ WVTXR[PXMV PXRZTX", "F^ZJSJOKMLKNJQJSKVMXOYSZZZ SFS^", "F^JJQJUKWLYNZQZSYVWXUYQZJZ QFQ^", "F^JJQJUKWLYNZQZSYVWXUYQZJZ ORZR", "H\\LBL[ RBR[ XBX[", "I[RFJ[ RFZ[ MTWT", "G\\KFK[ KFTFWGXHYJYLXNWOTP KPTPWQXRYTYWXYWZT[K[", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZV", "G\\KFK[ KFRFUGWIXKYNYSXVWXUZR[K[", "H[LFL[ LFYF LPTP L[Y[", "HZLFL[ LFYF LPTP", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZVZS USZS", "G]KFK[ YFY[ KPYP", "NVRFR[", "JZVFVVUYTZR[P[NZMYLVLT", "G\\KFK[ YFKT POY[", "HYLFL[ L[X[", "F^JFJ[ JFR[ ZFR[ ZFZ[", "G]KFK[ KFY[ YFY[", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF", "G\\KFK[ KFTFWGXHYJYMXOWPTQKQ", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF SWY]", "G\\KFK[ KFTFWGXHYJYLXNWOTPKP RPY[", "H\\YIWGTFPFMGKIKKLMMNOOUQWRXSYUYXWZT[P[MZKX", "JZRFR[ KFYF", "G]KFKULXNZQ[S[VZXXYUYF", "I[JFR[ ZFR[", "F^HFM[ RFM[ RFW[ \\FW[", "H\\KFY[ YFK[", "I[JFRPR[ ZFRP", "H\\YFK[ KFYF K[Y[", "HYLFL[ LFXF", "I[RFJ[ RFZ[ J[Z[", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF OPUP", "I[RFJ[ RFZ[", "I[KFYF OPUP K[Y[", "G]KFK[ YFY[ KFYF", "I[KFRPK[ KFYF K[Y[", "I[KKKILGMFOFPGQIRMR[ YKYIXGWFUFTGSIRM", "H\\RFR[ PKMLLMKOKRLTMUPVTVWUXTYRYOXMWLTKPK", "H\\KFY[ K[YF", "G]RFR[ ILJLKMLQMSNTQUSUVTWSXQYMZL[L", "H\\K[O[LTKPKLLINGQFSFVGXIYLYPXTU[Y[", "G[G[IZLWOSSLVFV[UXSUQSNQLQKRKTLVNXQZT[Y[", "F]SHTITLSPRSQUOXMZK[J[IZIWJRKOLMNJPHRGUFXFZG[I[KZMYNWOTP SPTPWQXRYTYWXYWZU[R[PZOX", "H\\TLTMUNWNYMZKZIYGWFTFQGOIMLLNKRKVLYMZO[Q[TZVXWV", "G^TFRGQIPMOSNVMXKZI[G[FZFXGWIWKXMZP[S[VZXXZT[O[KZHYGWFTFRHRJSMUPWRZT\\U", "H\\VJVKWLYLZKZIYGVFRFOGNINLONPOSPPPMQLRKTKWLYMZP[S[VZXXYV", "H\\RLPLNKMINGQFTFXG[G]F XGVNTTRXPZN[L[JZIXIVJULUNV QPZP", "G^G[IZMVPQQNRJRGQFPFOGNINLONQOUOXNYMZKZQYVXXVZS[O[LZJXIVIT", "F^MMKLJJJIKGMFNFPGQIQKPONULYJ[H[GZGX MRVOXN[L]J^H^G]F\\FZHXLVRUWUZV[W[YZZY\\V", "IZWVUTSQROQLQIRGSFUFVGWIWLVQTVSXQZO[M[KZJXJVKUMUOV", "JYT^R[PVOPOJPGRFTFUGVJVMURR[PaOdNfLgKfKdLaN^P\\SZWX", "F^MMKLJJJIKGMFNFPGQIQKPONULYJ[H[GZGX ^I^G]F\\FZGXIVLTNROPO ROSQSXTZU[V[XZYY[V", "I\\MRORSQVOXMYKYHXFVFUGTISNRSQVPXNZL[J[IZIXJWLWNXQZT[V[YZ[X", "@aEMCLBJBICGEFFFHGIIIKHPGTE[ GTJLLHMGOFPFRGSISKRPQTO[ QTTLVHWGYFZF\\G]I]K\\PZWZZ[[\\[^Z_YaV", "E]JMHLGJGIHGJFKFMGNINKMPLTJ[ LTOLQHRGTFVFXGYIYKXPVWVZW[X[ZZ[Y]V", "H]TFQGOIMLLNKRKVLYMZO[Q[TZVXXUYSZOZKYHXGVFTFRHRKSNUQWSZU\\V", "F_SHTITLSPRSQUOXMZK[J[IZIWJRKOLMNJPHRGUFZF\\G]H^J^M]O\\PZQWQUPTO", "H^ULTNSOQPOPNNNLOIQGTFWFYGZIZMYPWSSWPYNZK[I[HZHXIWKWMXPZS[V[YZ[X", "F_SHTITLSPRSQUOXMZK[J[IZIWJRKOLMNJPHRGUFYF[G\\H]J]M\\O[PYQVQSPTQUSUXVZX[ZZ[Y]V", "H\\H[JZLXOTQQSMTJTGSFRFQGPIPKQMSOVQXSYUYWXYWZT[P[MZKXJVJT", "H[RLPLNKMINGQFTFXG[G]F XGVNTTRXPZN[L[JZIXIVJULUNV", "E]JMHLGJGIHGJFKFMGNINKMOLRKVKXLZN[P[RZSYUUXMZF XMWQVWVZW[X[ZZ[Y]V", "F]KMILHJHIIGKFLFNGOIOKNOMRLVLYM[O[QZTWVTXPYMZIZGYFXFWGVIVKWNYP[Q", "C_HMFLEJEIFGHFIFKGLILLK[ UFK[ UFS[ aF_G\\JYNVTS[", "F^NLLLKKKILGNFPFRGSISLQUQXRZT[V[XZYXYVXUVU ]I]G\\FZFXGVITLPUNXLZJ[H[GZGX", "F]KMILHJHIIGKFLFNGOIOKNOMRLVLXMZN[P[RZTXVUWSYM [FYMVWT]RbPfNgMfMdNaP^S[VY[V", "H]ULTNSOQPOPNNNLOIQGTFWFYGZIZMYPWTTWPZN[K[JZJXKWNWPXQYR[R^QaPcNfLgKfKdLaN^Q[TYZV", "I[JFR[ ZFR[ JFZF", "G]IL[b", "E_RJIZ RJ[Z", "I[J[Z[", "I[J[Z[ZZJZJ[", "I\\XMX[ XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "H[LFL[ LPNNPMSMUNWPXSXUWXUZS[P[NZLX", "I[XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "I\\XFX[ XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "I[LSXSXQWOVNTMQMONMPLSLUMXOZQ[T[VZXX", "MYWFUFSGRJR[ OMVM", "I\\XMX]W`VaTbQbOa XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "I\\MFM[ MQPNRMUMWNXQX[", "NVQFRGSFREQF RMR[", "MWRFSGTFSERF SMS^RaPbNb", "IZMFM[ WMMW QSX[", "CaGMG[ GQJNLMOMQNRQR[ RQUNWMZM\\N]Q][", "I\\MMM[ MQPNRMUMWNXQX[", "I\\QMONMPLSLUMXOZQ[T[VZXXYUYSXPVNTMQM", "H[LMLb LPNNPMSMUNWPXSXUWXUZS[P[NZLX", "I\\XMXb XPVNTMQMONMPLSLUMXOZQ[T[VZXX", "KXOMO[ OSPPRNTMWM", "J[XPWNTMQMNNMPNRPSUTWUXWXXWZT[Q[NZMX", "MYRFRWSZU[W[ OMVM", "I\\MMMWNZP[S[UZXW XMX[", "JZLMR[ XMR[", "G]JMN[ RMN[ RMV[ ZMV[", "J[MMX[ XMM[", "JZLMR[ XMR[P_NaLbKb", "J[XMM[ MMXM M[X[", "H]QMONMPLRKUKXLZN[P[RZUWWTYPZM QMSMTNUPWXXZY[Z[", "I\\UFSGQIOMNPMTLZKb UFWFYHYKXMWNUORO ROTPVRWTWWVYUZS[Q[OZNYMV", "I\\JPLNNMOMQNROSRSVR[ ZMYPXRR[P_Ob", "I[TMQMONMPLSLVMYNZP[R[TZVXWUWRVOTMRKQIQGRFTFVGXI", "JZWOVNTMQMONOPPRSS SSOTMVMXNZP[S[UZWX", "JYTFRGQHQIRJUKXK XKTMQONRMUMWNYP[S]T_TaSbQbP`", "H\\IQJOLMNMONOPNTL[ NTPPRNTMVMXOXRWWTb", "G\\HQIOKMMMNNNPMUMXNZO[Q[SZUWVUWRXMXJWGUFSFRHRJSMUPWRZT", "LWRMPTOXOZP[R[TYUW", "I[OMK[ YNXMWMUNQROSNS NSPTQUSZT[U[VZ", "JZKFMFOGPHX[ RML[", "H]OMIb NQMVMYO[Q[SZUXWT YMWTVXVZW[Y[[Y\\W", "I[LMOMNSMXL[ YMXPWRUURXOZL[", "JZTFRGQHQIRJUKXK UKRLPMOOOQQSTTVT TTPUNVMXMZO\\S^T_TaRbPb", "J[RMPNNPMSMVNYOZQ[S[UZWXXUXRWOVNTMRM", "G]PML[ UMVSWXX[ IPKNNM[M", "I[MSMVNYOZQ[S[UZWXXUXRWOVNTMRMPNNPMSIb", "I][MQMONMPLSLVMYNZP[R[TZVXWUWRVOUNSM", "H\\SMP[ JPLNOMZM", "H\\IQJOLMNMONOPMVMYO[Q[TZVXXTYPYM", "G]ONMOKQJTJWKYLZN[Q[TZWXYUZRZOXMVMTORSPXMb", "I[KMMMOOU`WbYb ZMYOWRM]K`Jb", "F]VFNb GQHOJMLMMNMPLULXMZO[Q[TZVXXUZP[M", "F]NMLNJQITIWJZK[M[OZQW RSQWRZS[U[WZYWZTZQYNXM", "L\\UUTSRRPRNSMTLVLXMZO[Q[SZTXVRUWUZV[W[YZZY\\V", "M[MVOSRNSLTITGSFQGPIOMNTNZO[P[RZTXUUURVVWWYW[V", "MXTTTSSRQROSNTMVMXNZP[S[VYXV", "L\\UUTSRRPRNSMTLVLXMZO[Q[SZTXZF VRUWUZV[W[YZZY\\V", "NXOYQXRWSUSSRRQROSNUNXOZQ[S[UZVYXV", "OWOVSQUNVLWIWGVFTGSIQQNZKaJdJfKgMfNcOZP[R[TZUYWV", "L[UUTSRRPRNSMTLVLXMZO[Q[SZTY VRTYPdOfMgLfLdMaP^S\\U[XY[V", "M\\MVOSRNSLTITGSFQGPIOMNSM[ M[NXOVQSSRURVSVUUXUZV[W[YZZY\\V", "PWSMSNTNTMSM PVRRPXPZQ[R[TZUYWV", "PWSMSNTNTMSM PVRRLdKfIgHfHdIaL^O\\Q[TYWV", "M[MVOSRNSLTITGSFQGPIOMNSM[ M[NXOVQSSRURVSVUTVQV QVSWTZU[V[XZYY[V", "OWOVQSTNULVIVGUFSGRIQMPTPZQ[R[TZUYWV", "E^EVGSIRJSJTIXH[ IXJVLSNRPRQSQTPXO[ PXQVSSURWRXSXUWXWZX[Y[[Z\\Y^V", "J\\JVLSNROSOTNXM[ NXOVQSSRURVSVUUXUZV[W[YZZY\\V", "LZRRPRNSMTLVLXMZO[Q[SZTYUWUUTSRRQSQURWTXWXYWZV", "KZKVMSNQMUGg MUNSPRRRTSUUUWTYSZQ[ MZO[R[UZWYZV", "L[UUTSRRPRNSMTLVLXMZO[Q[SZ VRUUSZPaOdOfPgRfScS\\U[XY[V", "MZMVOSPQPSSSTTTVSYSZT[U[WZXYZV", "NYNVPSQQQSSVTXTZR[ NZP[T[VZWYYV", "OXOVQSSO VFPXPZQ[S[UZVYXV PNWN", "L[LVNRLXLZM[O[QZSXUU VRTXTZU[V[XZYY[V", "L[LVNRMWMZN[O[RZTXUUUR URVVWWYW[V", "I^LRJTIWIYJ[L[NZPX RRPXPZQ[S[UZWXXUXR XRYVZW\\W^V", "JZJVLSNRPRQSQZR[U[XYZV WSVRTRSSOZN[L[KZ", "L[LVNRLXLZM[O[QZSXUU VRPdOfMgLfLdMaP^S\\U[XY[V", "LZLVNSPRRRTTTVSXQZN[P\\Q^QaPdOfMgLfLdMaP^S\\WYZV", "J\\K[NZQXSVUSWOXKXIWGUFSGRHQJPOPTQXRZT[V[XZYY", "I[WUWRVOUNSMQMONMPLSLVMYNZP[R[TZVXWUXPXKWHVGTFRFPGNI", "JZWNUMRMPNNPMSMVNYOZQ[T[VZ MTUT", "J[TFRGPJOLNOMTMXNZO[Q[SZUWVUWRXMXIWGVFTF NPWP", "H\\VFNb QMNNLPKSKVLXNZQ[S[VZXXYUYRXPVNSMQM", "I[XOWNTMQMNNMOLQLSMUOWSZT\\T^S_Q_", "DaWNVLTKQKOLNMMOMRNTOUQVTVVUWS WKWSXUYV[V\\U]S]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYY", "F^ZIJRZ[", "F^JIZRJ[", "KYOBOb OBVB ObVb", "KYUBUb NBUB NbUb", "KYTBQEPHPJQMSOSPORSTSUQWPZP\\Q_Tb", "KYPBSETHTJSMQOQPURQTQUSWTZT\\S_Pb", "F^[FYGVHSHPGNFLFJGIIIKKMMMOLPJPHNF [FI[ YTWTUUTWTYV[X[ZZ[X[VYT", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF", "H\\NJPISFS[", "H\\LKLJMHNGPFTFVGWHXJXLWNUQK[Y[", "H\\MFXFRNUNWOXPYSYUXXVZS[P[MZLYKW", "H\\UFKTZT UFU[", "H\\WFMFLOMNPMSMVNXPYSYUXXVZS[P[MZLYKW", "H\\XIWGTFRFOGMJLOLTMXOZR[S[VZXXYUYTXQVOSNRNOOMQLT", "H\\YFO[ KFYF", "H\\PFMGLILKMMONSOVPXRYTYWXYWZT[P[MZLYKWKTLRNPQOUNWMXKXIWGTFPF", "H\\XMWPURRSQSNRLPKMKLLINGQFRFUGWIXMXRWWUZR[P[MZLX", "MWRYQZR[SZRY", "MWSZR[QZRYSZS\\R^Q_", "MWRMQNROSNRM RYQZR[SZRY", "MWRMQNROSNRM SZR[QZRYSZS\\R^Q_", "MWRFRT RYQZR[SZRY", "I[LKLJMHNGPFTFVGWHXJXLWNVORQRT RYQZR[SZRY", "NVRFRM", "JZNFNM VFVM", "KYQFOGNINKOMQNSNUMVKVIUGSFQF", "H\\PBP_ TBT_ YIWGTFPFMGKIKKLMMNOOUQWRXSYUYXWZT[P[MZKX", "G][BIb", "KYVBTDRGPKOPOTPYR]T`Vb", "KYNBPDRGTKUPUTTYR]P`Nb", "NVRBRb", "E_IR[R", "E_RIR[ IR[R", "E_IO[O IU[U", "G]KKYY YKKY", "JZRLRX MOWU WOMU", "MWRQQRRSSRRQ", "MWSFRGQIQKRLSKRJ", "MWRHQGRFSGSIRKQL", "E_UMXP[RXTUW IR[R", "G]OFOb UFUb JQZQ JWZW", "E_\\O\\N[MZMYNXPVUTXRZP[L[JZIYHWHUISJRQNRMSKSIRGPFNGMIMKNNPQUXWZY[[[\\Z\\Y", "G]IIJKKOKUJYI[ [IZKYOYUZY[[ IIKJOKUKYJ[I I[KZOYUYYZ[[", "F_\\Q[OYNWNUOTPQTPUNVLVJUISIQJOLNNNPOQPTTUUWVYV[U\\S\\Q", "KYOBO[ UBU[", "F^RBR[ I[[[", "F^[BI[[[", "E_RIQJRKSJRI IYHZI[JZIY [YZZ[[\\Z[Y", "F^RHNLKPJSJUKWMXOXQWRU RHVLYPZSZUYWWXUXSWRU RUQYP\\ RUSYT\\ P\\T\\", "F^RNQKPINHMHKIJKJOKRLTNWR\\ RNSKTIVHWHYIZKZOYRXTVWR\\", "F^RGPJLOIR RGTJXO[R IRLUPZR] [RXUTZR]", "F^RTTWVXXXZW[U[SZQXPVPSQ SQUOVMVKUISHQHOINKNMOOQQ QQNPLPJQISIUJWLXNXPWRT RTQYP\\ RTSYT\\ P\\T\\", "F^RRR[Q\\ RVQ\\ RIQHOHNINKONRR RISHUHVIVKUNRR RRNOLNJNIOIQJR RRVOXNZN[O[QZR RRNULVJVIUISJR RRVUXVZV[U[SZR", "F^ISJSLTMVMXLZ ISIRJQLQMRNTNWMYLZ RGPIOLOOQUQXPZR\\ RGTIULUOSUSXTZR\\ [S[RZQXQWRVTVWWYXZ [SZSXTWVWXXZ KVYV", "PSSRRSQSPRPQQPRPSQSSRUQV QQQRRRRQQQ", "PTQPPQPSQTSTTSTQSPQP RQQRRSSRRQ", "NVPOTU TOPU NRVR", "MWRKQMOPMR RKSMUPWR RMOQ RMUQ ROPQ ROTQ QQSQ MRWR", "MWMRMQNOONQMSMUNVOWQWR PNTN OOUO NPVP NQVQ MRWR", "LRLFLRRRLF LIPQ LLOR LOMQ", "MWRKQMOPMR RKSMUPWR", "MWWRWQVOUNSMQMONNOMQMR", "G]]R]P\\MZJWHTGPGMHJJHMGPGR", "MWMRMSNUOVQWSWUVVUWSWR", "LXLPNRQSSSVRXP", "RURUTTURTPRO", "RVRRUPVNVLUKTK", "NRRROPNNNLOKPK", "MWWHVGTFQFOGNHMJMLNNOOUSVTWVWXVZU[S\\P\\N[MZ", "G]IWHVGTGQHOINKMMMONPOTUUVWWYW[V\\U]S]P\\N[M", "G]RRTUUVWWYW[V\\U]S]Q\\O[NYMWMUNTOPUOVMWKWIVHUGSGQHOINKMMMONPORR", "H\\KFK[ HF[FQP[Z ZV[Y\\[ ZVZY WYZY WYZZ\\[", "KYUARBPCNELHKLKRLUNWQXSXVWXUYR KPLMNKQJSJVKXMYPYVXZV]T_R`Oa", ">f>RfR", "D`D``D", "RRR>Rf", "D`DD``", "D`DR`R", "F^FY^K", "KYK^YF", "KYKFY^", "F^FK^Y", "KYKRYR", "MWMWWM", "MWMMWW", "D`DOGQKSPTTTYS]Q`O", "PUUDSGQKPPPTQYS]U`", "OTODQGSKTPTTSYQ]O`", "D`DUGSKQPPTPYQ]S`U", "KYRJYNKVRZ", "JZJRNKVYZR", "KYKVKNYVYN", "JZLXJPZTXL", "JZJ]L]O\\Q[TXUVVSVOULTJSIQIPJOLNONSOVPXS[U\\X]Z]", "I]]Z]X\\U[SXPVOSNONLOJPIQISJTLUOVSVVUXT[Q\\O]L]J", "JZZGXGUHSIPLONNQNUOXPZQ[S[TZUXVUVQUNTLQIOHLGJG", "G[GJGLHOIQLTNUQVUVXUZT[S[QZPXOUNQNNOLPISHUGXGZ", "E[EPFRHTJUMVQVUUXSZP[NZLWLSMQNNPLSKVKYL\\M^", "EYETHVKWPWSVVTXQYNYLXKVKSLPNNQMTMYN\\P_", "OUQOOQOSQUSUUSUQSOQO QPPQPSQTSTTSTQSPQP RQQRRSSRRQ", "D`DRJR ORUR ZR`R", "D`DUDO`O`U", "JZRDJR RDZR", "D`DR`R JYZY P`T`", "D`DR`R DRRb `RRb", "KYQKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK", "LXLLLXXXXLLL", "KYRJKVYVRJ", "LXRHLRR\\XRRH", "JZRIPOJOOSMYRUWYUSZOTORI", "KYRKRY KRYR", "MWMMWW WMMW", "MWRLRX MOWU WOMU", "NVQNOONQNSOUQVSVUUVSVQUOSNQN OQOS PPPT QOQU RORU SOSU TPTT UQUS", "NVNNNVVVVNNN OOOU POPU QOQU RORU SOSU TOTU UOUU", "MWRLMUWURL ROOT ROUT RRQT RRST", "LULRUWUMLR ORTU ORTO RRTS RRTQ", "MWRXWOMORX RUUP RUOP RRSP RRQP", "OXXROMOWXR URPO URPU RRPQ RRPS", "LXRLNWXPLPVWRL RRRL RRLP RRNW RRVW RRXP", "MWRLRX OOUO MUOWQXSXUWWU", "LXRLRX LQMOWOXQ PWTW", "KYMNWX WNMX OLLOKQ ULXOYQ", "I[NII[ VI[[ MM[[ WMI[ NIVI MMWM", "I[RGRV MJWP WJMP IVL\\ [VX\\ IV[V L\\X\\", "G[MJSV KPSL G\\[\\[RG\\", "LXPLPPLPLTPTPXTXTTXTXPTPTLPL", "KYYPXNVLSKQKNLLNKQKSLVNXQYSYVXXVYT YPWNUMSMQNPOOQOSPUQVSWUWWVYT", "KYRJKVYVRJ RZYNKNRZ", "G]PIPGQFSFTGTI GZHXJVKTLPLKMJOIUIWJXKXPYTZV\\X]Z GZ]Z QZP[Q\\S\\T[SZ", "JZRMRS RSQ\\ RSS\\ Q\\S\\ RMQJPHNG QJNG RMSJTHVG SJVG RMNKLKJM PLLLJM RMVKXKZM TLXLZM RMPNOOOR RMPOOR RMTNUOUR RMTOUR", "JZRIRK RNRP RSRU RYQ\\ RYS\\ Q\\S\\ RGQIPJ RGSITJ PJRITJ RKPNNOMN RKTNVOWN NOPORNTOVO RPPSNTLTKRKSLT RPTSVTXTYRYSXT NTPTRSTTVT RUPXOYMZLZKYJWJYLZ RUTXUYWZXZYYZWZYXZ MZOZRYUZWZ", "JZRYQ\\ RYS\\ Q\\S\\ RYUZXZZXZUYTWTYRZOYMWLUMVJUHSGQGOHNJOMMLKMJOKRMTKTJUJXLZOZRY", "JZRYQ\\ RYS\\ Q\\S\\ RYVXVVXUXRZQZLYIXHVHTGPGNHLHKIJLJQLRLUNVNXRY", "I[IPKR LKNP RGRO XKVP [PYR", "QSRQQRRSSRRQ", "PTQPPQPSQTSTTSTQSPQP", "NVQNOONQNSOUQVSVUUVSVQUOSNQN", "MWQMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM", "G]PGMHJJHMGPGTHWJZM\\P]T]W\\ZZ\\W]T]P\\MZJWHTGPG", "AcPALBJCGEEGCJBLAPATBXCZE]G_JaLbPcTcXbZa]__]aZbXcTcPbLaJ_G]EZCXBTAPA", "<hP<K=G?DAAD?G=K<P<T=Y?]A`DcGeKgPhThYg]e`cc`e]gYhThPgKeGcD`A]?Y=T<P<", "){O)I*E+@-;073370;-@+E*I)O)U*[+_-d0i3m7q;t@wEyIzO{U{[z_ydwitmqqmtiwdy_z[{U{OzIyEw@t;q7m3i0d-_+[*U)O)", ">fRAPCMDJDGCEA>H@JAMAZB]D_G`M`PaRc RATCWDZD]C_AfHdJcMcZb]`_]`W`TaRc", "AcRAPCMDJDGCEABGAKAPBTDXG\\L`Rc RATCWDZD]C_AbGcKcPbT`X]\\X`Rc BHbH", "H[WPVQWRXQXPVNTMQMNNLPKSKULXNZQ[S[VZXX QMONMPLSLUMXOZQ[ LbXF", "KYRKMX RNVX RKWX OTTT KXPX TXYX", "JZNKNX OKOX LKSKVLWNVPSQ SKULVNUPSQ OQSQVRWTWUVWSXLX SQURVTVUUWSX", "KYVLWKWOVLTKQKOLNMMPMSNVOWQXTXVWWU QKOMNPNSOVQX", "JZNKNX OKOX LKSKVLWMXPXSWVVWSXLX SKULVMWPWSVVUWSX", "JYNKNX OKOX SOSS LKVKVOUK OQSQ LXVXVTUX", "JXNKNX OKOX SOSS LKVKVOUK OQSQ LXQX", "K[VLWKWOVLTKQKOLNMMPMSNVOWQXTXVW QKOMNPNSOVQX TXUWVU VSVX WSWX TSYS", "J[NKNX OKOX VKVX WKWX LKQK TKYK OQVQ LXQX TXYX", "NWRKRX SKSX PKUK PXUX", "LXSKSURWQX TKTUSWQXPXNWMUNTOUNV QKVK", "JZNKNX OKOX WKOS QQVX RQWX LKQK TKYK LXQX TXYX", "KXOKOX PKPX MKRK MXWXWTVX", "I\\MKMX NNRX NKRU WKRX WKWX XKXX KKNK WKZK KXOX UXZX", "JZNKNX OMVX OKVV VKVX LKOK TKXK LXPX", "KZQKOLNMMPMSNVOWQXTXVWWVXSXPWMVLTKQK QKOMNPNSOVQX TXVVWSWPVMTK", "JYNKNX OKOX LKSKVLWNWOVQSROR SKULVNVOUQSR LXQX", "KZQKOLNMMPMSNVOWQXTXVWWVXSXPWMVLTKQK QKOMNPNSOVQX TXVVWSWPVMTK PWPUQTSTTUUZV[W[XZ TUUXVZW[", "JZNKNX OKOX LKSKVLWNWOVQSROR SKULVNVOUQSR LXQX SRTSUWVXWXXW SRUSVWWX", "KZVMWKWOVMULSKQKOLNMNOOPQQTRVSWT NNOOQPTQVRWSWVVWTXRXPWOVNTNXOV", "KZRKRX SKSX NKMOMKXKXOWK PXUX", "J[NKNUOWQXTXVWWUWK OKOUPWQX LKQK UKYK", "KYMKRX NKRU WKRX KKPK TKYK", "I[LKOX MKOT RKOX RKUX SKUT XKUX JKOK VKZK", "KZNKVX OKWX WKNX LKQK TKYK LXQX TXYX", "LYNKRRRX OKSR WKSRSX LKQK TKYK PXUX", "LYVKNX WKOX OKNONKWK NXWXWTVX", "KXOKOX PKPX MKWKWOVK MXRX", "KYRKLX RMWX RKXX MWVW LXXX", "KZQKOLNMMPMSNVOWQXTXVWWVXSXPWMVLTKQK QKOMNPNSOVQX TXVVWSWPVMTK QOQT TOTT QQTQ QRTR", "KYRKMX RNVX RKWX KXPX TXYX", "JZMJLM XJWM PPOS UPTS MVLY XVWY MKWK MLWL PQTQ PRTR MWWW MXWX", "J[NKNX OKOX VKVX WKWX LKYK LXQX TXYX", "K[MKRQ NKSQMX MKWKXOVK NWWW MXWXXTVX", "KZMONLOKPKQLRORX XOWLVKUKTLSOSX MONMOLPLQMRO XOWMVLULTMSO PXUX", "KZRKRX SKSX QNNOMQMRNTQUTUWTXRXQWOTNQN QNOONQNROTQU TUVTWRWQVOTN PKUK PXUX", "J[RKRX SKSX LPMONOOSQU TUVSWOXOYP MONROTQUTUVTWRXO PKUK PXUX", "KZMVNXQXMRMONMOLQKTKVLWMXOXRTXWXXV OUNRNOOMQK TKVMWOWRVU NWPW UWWW", "KYTKKX SMTX TKUX NTTT IXNX RXWX", "JYPKLX QKMX NKUKWLWNVPSQ UKVLVNUPSQ OQRQTRUSUUTWQXJX RQTSTUSWQX", "KXVLWLXKWNVLTKRKPLOMNOMRMUNWPXRXTWUU RKPMOONRNVPX", "JYPKLX QKMX NKTKVLWNWQVTUVTWQXJX TKULVNVQUTTVSWQX", "JYPKLX QKMX SORS NKXKWNWK OQRQ JXTXUUSX", "JXPKLX QKMX SORS NKXKWNWK OQRQ JXOX", "KYVLWLXKWNVLTKRKPLOMNOMRMUNWPXRXTWUVVS RKPMOONRNVPX RXTVUS SSXS", "J[PKLX QKMX XKTX YKUX NKSK VK[K OQVQ JXOX RXWX", "NWTKPX UKQX RKWK NXSX", "LXUKRUQWPX VKSURWPXOXMWLUMTNUMV SKXK", "JZPKLX QKMX YKOR RPTX SPUX NKSK VK[K JXOX RXWX", "KXQKMX RKNX OKTK KXUXVUTX", "I\\OKKX OMPX PKQV YKPX YKUX ZKVX MKPK YK\\K IXMX SXXX", "JZPKLX PKTX QKTU XKTX NKQK VKZK JXNX", "KYRKPLOMNOMRMUNWPXRXTWUVVTWQWNVLTKRK RKPMOONRNVPX RXTVUTVQVMTK", "JYPKLX QKMX NKUKWLXMXOWQTROR UKWMWOVQTR JXOX", "KYRKPLOMNOMRMUNWPXRXTWUVVTWQWNVLTKRK RKPMOONRNVPX RXTVUTVQVMTK OWOVPUQURVRZS[T[UZ RVSZT[", "JZPKLX QKMX NKUKWLXMXOWQTROR UKWMWOVQTR SRTWUXVXWW SRTSUWVX JXOX", "KZWLXLYKXNWLUKRKPLOMOOPPUSVT ONPOURVSVVUWSXPXNWMULXMWNW", "KZTKPX UKQX PKNNOKZKYNYK NXSX", "J[PKMUMWOXSXUWVUYK QKNUNWOX NKSK WK[K", "KYOKPX PKQV YKPX MKRK VK[K", "I[NKMX OKNV TKMX TKSX UKTV ZKSX LKQK XK\\K", "KZPKTX QKUX YKLX NKSK VK[K JXOX RXWX", "LYPKRQPX QKSQ YKSQQX NKSK VK[K NXSX", "LYXKLX YKMX QKONPKYK LXUXVUTX", "KZMHX\\", "JZRMLW RMXW", "LZQOPPPQOQOPQOTOVQVWWXXX TOUQUWWX URRSPTOUOWPXSXTWUU RSPUPWQX", "JYNKNX OKOX ORPPROTOVPWRWUVWTXRXPWOU TOUPVRVUUWTX LKOK", "LXVQUQURVRVQUPSOQOOPNRNUOWQXSXUWVV QOPPOROUPWQX", "L[VKVX WKWX VRUPSOQOOPNRNUOWQXSXUWVU QOPPOROUPWQX TKWK VXYX", "LXOSVSVRUPSOQOOPNRNUOWQXSXUWVV USUQSO QOPPOROUPWQX", "LWTKULUMVMVLTKRKPMPX RKQMQX NOSO NXSX", "LYQOOQOSQUSUUSUQSOQO QOPQPSQU SUTSTQSO TPUOVO PTOUOXPYTYVZ OWPXTXVYV[T\\P\\N[NYPX", "J[NKNX OKOX ORPPROTOVPWRWX TOUPVRVX LKOK LXQX TXYX", "NWRKRLSLSKRK RORX SOSX POSO PXUX", "NWSKSLTLTKSK SOSZR\\ TOTZR\\P\\O[OZPZP[O[ QOTO", "JZNKNX OKOX WOOU RSVX SSWX LKOK TOYO LXQX TXYX", "NWRKRX SKSX PKSK PXUX", "F_JOJX KOKX KRLPNOPORPSRSX POQPRRRX SRTPVOXOZP[R[X XOYPZRZX HOKO HXMX PXUX XX]X", "J[NONX OOOX ORPPROTOVPWRWX TOUPVRVX LOOO LXQX TXYX", "LYQOOPNRNUOWQXTXVWWUWRVPTOQO QOPPOROUPWQX TXUWVUVRUPTO", "JYNON\\ OOO\\ ORPPROTOVPWRWUVWTXRXPWOU TOUPVRVUUWTX LOOO L\\Q\\", "KYUOU\\ VOV\\ URTPROPONPMRMUNWPXRXTWUU POOPNRNUOWPX S\\X\\", "KXOOOX POPX PRQPSOUOVPVQUQUPVP MOPO MXRX", "LYTOUPUQVQVPTOQOOPORQSTTVU OQQRTSVTVWTXQXOWOVPVPWQX", "LWPKPVRXTXUWUV QKQVRX NOTO", "J[NONUOWQXSXUWVU OOOUPWQX VOVX WOWX LOOO TOWO VXYX", "KYNORX OORV VORX LOQO TOXO", "I[LOOX MOOU ROOX ROUX SOUU XOUX JOOO VOZO", "KYNOUX OOVX VONX LOQO TOXO LXPX SXXX", "KYNORX OORV VORXP[N\\M\\L[LZMZM[L[ LOQO TOXO", "LXUONX VOOX OONQNOVO NXVXVVUX", "K[QOOPNQMSMUNWPXQXSWUUWRXO QOOQNSNUOWPX QOSOUPWWXX SOTPVWXXYX", "KXRKPMOOMUK\\ QLPNNTL\\ RKTKVLVNUPRQ TKULUNTPRQ RQTRUTUVTWRXQXOWNT RQSRTTTVRX", "KYLQNOPORPSSSXR\\ LQNPPPRQSS WOVRSXQ\\", "KYSOQOOPNQMSMUNWPXRXTWUVVTVRUPRNQLQKRJTJUKVM QOOQNSNVPX RXTVUTUQSO QLRKTKVM", "LXVPTOQOOPOQPRRS QOPPPQRS RSOTNUNWPXSXUW RSPTOUOWPX", "LWRKQLQMSNVNVMSNPOOPNRNTOVPWRXSYS[R\\P\\O[ SNQOPPOROTPVRX", "IYJRKPLONOOPOQMX MONPNQLX OQPPROTOVPVRS\\ TOUPURR\\", "IYJSKQLPNPOQOVPX MPNQNUOWPXQXSWTVUTVQVNULTKRKQLQNRPURWS QXSVTTUQUNTK", "NWROPVPWQXSXUWVU SOQVQWRX", "KYOOLX POMX UOVPWPVOTORQOR ORPSRWTXVWWU ORQSSWTX", "LXLKNKPLWX NKOLVX RPMX RPNX", "KZOOK\\ POL\\ NUNWOXQXSWTV VOTVTWUXWXXWYU WOUVUWVX", "JYNOMX OONUMX VRVOWOVRTUQWNXMX LOOO", "MXRKQLQMSNVN TNQOPPPRRSUS TNROQPQRRS SSPTOUOWQXSYTZT[S\\Q\\ SSQTPUPWQX", "KXQOOPNQMSMUNWPXRXTWUVVTVRUPSOQO QOOQNSNVPX RXTVUTUQSO", "IZPPMX PPNX TPSX TPTX KQMOXO KQMPXP", "JXSOQOOPNQMSJ\\ QOOQNSK\\ SOUPVRVTUVTWRXPXNWMU SOUQUTTVRX", "K[YOQOOPNQMSMUNWPXRXTWUVVTVRUPYP QOOQNSNVPX RXTVUTUQSO", "KZSPQX SPRX MQOOXO MQOPXP", "JXKRLPMOOOPPPROUOWPX NOOPORNUNWPXQXSWUUVRVOUOVP", "KZOPNQMSMUNWPXRXUWWUXRXPWOUOTPSRRUO\\ MUNVPWRWUVWTXR XQWPUPSR RUQXP\\", "KXMONOPPS[T\\ NOOPR[T\\U\\ VOTRNYL\\", "I[TKQ\\ UKP\\ JRKPLONOOPOVPWSWUVWT MONPNTOWPXSXUWWTXRYO", "JZNPPPPONPMQLSLUMWNXPXQWRUSR LUNWPWRU RRRWSXUXWVXTXRWPVOVPWP RUSWUWWV", "KZVOTVTWUXWXXWYU WOUVUWVX USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX", "JXOKMR PKNRNVPX NROPQOSOUPVRVTUVTWRXPXNWMUMR SOUQUTTVRX MKPK", "KXUPUQVQUPSOQOOPNQMSMUNWPXRXTWUV QOOQNSNVPX", "KZWKTVTWUXWXXWYU XKUVUWVX USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX UKXK", "KWNURTTSURUPSOQOOPNQMSMUNWPXRXTWUV QOOQNSNVPX", "MXWKXLXKVKTLSNPYO[N\\ VKULTNQYP[N\\L\\L[M\\ POVO", "KYVOTVSYR[ WOUVTYR[P\\M\\L[M[N\\ USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX", "KZPKLX QKMX OQPPROTOVPVRUUUWVX TOUPURTUTWUXWXXWYU NKQK", "MWSKSLTLTKSK NROPPOROSPSRRURWSX QORPRRQUQWRXTXUWVU", "MWTKTLULUKTK ORPPQOSOTPTRRYQ[O\\M\\M[N\\ ROSPSRQYP[O\\", "KXPKLX QKMX VPUQVQVPUOTORQPROR ORPSQWRXTXUWVU ORQSRWSX NKQK", "NVSKPVPWQXSXTWUU TKQVQWRX QKTK", "F^GRHPIOKOLPLQJX JOKPKQIX LQMPOOQOSPSQQX QORPRQPX SQTPVOXOZPZRYUYWZX XOYPYRXUXWYX[X\\W]U", "J[KRLPMOOOPPPQNX NOOPOQMX PQQPSOUOWPWRVUVWWX UOVPVRUUUWVXXXYWZU", "JYKRLPMOOOPPPQM\\ NOOPOQL\\ PQROTOVPWRWTVVUWSXQXOVOT TOVQVTUVSX J\\O\\", "KYVOR\\ WOS\\ USUQSOQOOPNQMSMUNWPXRXTV QOOQNSNVPX P\\U\\", "LXMRNPOOQORPRQPX POQPQQOX RQSPUOVOWPWQVQWP", "LYVPVQWQVPTOQOOPORQSTTVU OQQRTSVTVWTXQXOWNVOVOW", "NWSKPVPWQXSXTWUU TKQVQWRX POUO", "IZJRKPLONOOPORNUNWOX MONPNRMUMWOXQXSWTV VOTVTWUXWXXWYU WOUVUWVX", "H\\IRJPKOMONPNRMUMWNX LOMPMRLULWNXOXQWRV TORVRWTX UOSVSWTXUXWWYUZRZOYOZP", "JZMRNPPOROSPSR QORPRRQUPWNXMXLWLVMVLW XPWQXQXPWOVOTPSRRURWSX QUQWRXTXVWWU", "IYJRKPLONOOPORNUNWOX MONPNRMUMWOXQXSWTV VOTVSYR[ WOUVTYR[P\\M\\L[M[N\\", "KYWOWPVQNVMWMX NQOOROUQ OPRPUQVQ NVOVRWUW OVRXUXVV", "H[RKSLSMTMTLRKOKMLLNLX OKNLMNMX XKYLYMZMZLXKVKTMTX VKUMUX JOWO JXOX RXWX", "J[UKVLWLWKQKOLNNNX QKPLONOX VOVX WOWX LOWO LXQX TXYX", "J[WKQKOLNNNX QKPLONOX UKVLVX WKWX LOVO LXQX TXYX", "F_PKQLQMRMRLPKMKKLJNJX MKLLKNKX YKZL[L[KUKSLRNRX UKTLSNSX ZOZX [O[X HO[O HXMX PXUX XX]X", "F_PKQLQMRMRLPKMKKLJNJX MKLLKNKX [KUKSLRNRX UKTLSNSX YKZLZX [K[X HOZO HXMX PXUX XX]X", "NWRORX SOSX POSO PXUX", "LXVPTOROPPOQNSNUOWQXSXUW ROPQOSOVQX OSSS", "LYSKQLPMOONRNUOWPXRXTWUVVTWQWNVLUKSK SKQMPOOSOVPX RXTVUTVPVMUK OQVQ", "KZTKQ\\ UKP\\ QONPMRMUNWQXTXWWXUXRWPTOQO QOOPNRNUOWQX TXVWWUWRVPTO", "LXUPVRVQUPSOQOOPNRNTOVRX QOOQOTPVRXSYS[R\\P\\", "I[VKWLXLVKSKQLPMOOLYK[J\\ SKQMPOMYL[J\\H\\H[I\\ ZK[L[KYKWLVNSYR[Q\\ YKXLWNTYS[Q\\O\\O[P\\ LOYO", "IZVKWLXLXKSKQLPMOOLYK[J\\ SKQMPOMYL[J\\H\\H[I\\ VOTVTWUXWXXWYU WOUVUWVX LOWO", "IZVKWL XKSKQLPMOOLYK[J\\ SKQMPOMYL[J\\H\\H[I\\ WKTVTWUXWXXWYU XKUVUWVX LOVO", "F^SKTLTM ULSKPKNLMMLOIYH[G\\ PKNMMOJYI[G\\E\\E[F\\ ZK[L\\L\\KWKUL TMSOPYO[N\\ WKUMTOQYP[N\\L\\L[M\\ ZOXVXWYX[X\\W]U [OYVYWZX IO[O", "F^SKTLTM ULSKPKNLMMLOIYH[G\\ PKNMMOJYI[G\\E\\E[F\\ ZK[L \\KWKUL TMSOPYO[N\\ WKUMTOQYP[N\\L\\L[M\\ [KXVXWYX[X\\W]U \\KYVYWZX IOZO", "MWNROPPOROSPSRRURWSX QORPRRQUQWRXTXUWVU", "LYQKOLNONTOWQXTXVWWTWOVLTKQK QKPLOOOTPWQX TXUWVTVOULTK", "LYPNSKSX RLRX OXVX", "LYOMONNNNMOLQKTKVLWNVPTQQROSNUNX TKULVNUPTQ NWOVPVSWVWWV PVSXVXWVWU", "LYOMONNNNMOLQKTKVLWNVPTQ TKULVNUPTQ RQTQVRWTWUVWTXQXOWNVNUOUOV TQURVTVUUWTX", "LYSMSX TKTX TKMTXT QXVX", "LYOKNQ OKVK OLSLVK NQOPQOTOVPWRWUVWTXQXOWNVNUOUOV TOUPVRVUUWTX", "LYVMVNWNWMVLTKRKPLOMNPNUOWQXTXVWWUWSVQTPQPNR RKPMOPOUPWQX TXUWVUVSUQTP", "LYNKNO VMRTPX WKTQQX NMPKRKUM NMPLRLUMVM", "LYQKOLNNOPQQTQVPWNVLTKQK QKPLONPPQQ TQUPVNULTK QQORNTNUOWQXTXVWWUWTVRTQ QQPROTOUPWQX TXUWVUVTURTQ", "LYOVOUNUNVOWQXSXUWVVWSWNVLTKQKOLNNNPORQSTSWQ SXUVVSVNULTK QKPLONOPPRQS", "NVRVQWRXSWRV", "NVSWRXQWRVSWSYQ[", "NVROQPRQSPRO RVQWRXSWRV", "NVROQPRQSPRO SWRXQWRVSWSYQ[", "NVRKQLRSSLRK RLRO RVQWRXSWRV", "LYNNONOONONNOLQKTKVLWNWOVQSRRSRTST TKVMVPUQSR RWRXSXSWRW", "OVRKRP SKRP", "LXOKOP PKOP UKUP VKUP", "MWQKPLPNQOSOTNTLSKQK", "MWRJRP OKUO UKOO", "KZXHM\\", "MWUHSJQMPPPTQWSZU\\ SJRLQPQTRXSZ", "MWOHQJSMTPTTSWQZO\\ QJRLSPSTRXQZ", "MWPHP\\ QHQ\\ PHUH P\\U\\", "MWSHS\\ THT\\ OHTH O\\T\\", "LWSHRIQKQMRORPPRRTRUQWQYR[S\\ RIQM QKRO RUQY QWR[", "MXQHRISKSMRORPTRRTRUSWSYR[Q\\ RISM SKRO RUSY SWR[", "MWTHPRT\\", "MWPHTRP\\", "OURHR\\", "MWPHP\\ THT\\", "I[LRXR", "I[RLRX LRXR", "JZRMRX MRWR MXWX", "JZRMRX MMWM MRWR", "JZMMWW WMMW", "NVRQQRRSSRRQ", "I[RLQMRNSMRL LRXR RVQWRXSWRV", "I[LPXP LTXT", "I[WLMX LPXP LTXT", "I[LNXN LRXR LVXV", "JZWLMRWX", "JZMLWRMX", "JZWKMOWS MTWT MXWX", "JZMKWOMS MTWT MXWX", "H[YUWUUTTSRPQOONNNLOKQKRLTNUOUQTRSTPUOWNYN", "JZLTLRMPOPUSWSXR LRMQOQUTWTXRXP", "JZMSRPWS MSRQWS", "NVSKPO SKTLPO", "NVQKTO QKPLTO", "LXNKOMQNSNUMVK NKONQOSOUNVK", "NVSLRMQLRKSLSNQP", "NVSKQMQORPSORNQO", "NVQLRMSLRKQLQNSP", "NVQKSMSORPQORNSO", "JZWMQMONNOMQMSNUOVQWWW", "JZMMMSNUOVQWSWUVVUWSWM", "JZMMSMUNVOWQWSVUUVSWMW", "JZMWMQNOONQMSMUNVOWQWW", "JZWMQMONNOMQMSNUOVQWWW MRUR", "I[TOUPXRUTTU UPWRUT LRWR", "MWRMRX OPPORLTOUP PORMTO", "I[POOPLROTPU OPMROT MRXR", "MWRLRW OTPURXTUUT PURWTU", "KYVSUPSOQOOPNQMSMUNWPXRXTWUVVTWQWNVLTKQKPLQLRK QOOQNSNVPX RXTVUTVQVNULTK", "JZLKRX MKRV XKRX LKXK NLWL", "G[IOLORW KORX [FRX", "I[XIXJYJYIXHVHTJSLROQUPYO[ UITKSORUQXPZN\\L\\K[KZLZL[", "I[XIXJYJYIXHVHTJSLROQUPYO[ UITKSORUQXPZN\\L\\K[KZLZL[ QNOONQNSOUQVSVUUVSVQUOSNQN", "H\\ZRYTWUVUTTSSQPPONNMNKOJQJRKTMUNUPTQSSPTOVNWNYOZQZR", "JZXKLX OKPLPNOOMOLNLLMKOKSLVLXK UTTUTWUXWXXWXUWTUT", "J[YPXPXQYQYPXOWOVPUTTVSWQXOXMWLVLTMSORRPSNSLRKPKOLONPQUWWXXXYW OXMVMTOR ONPPVWWX", "J[UPSOQOPQPRQTSTUS UOUSVTXTYRYQXNVLSKRKOLMNLQLRMUOWRXSXVW", "KZQHQ\\ THT\\ WLVLVMWMWLUKPKNLNNOPVSWT NNOOVRWTWVVWTXQXOWNVNUOUOVNV", "KYPKP[ TKT[ MQWQ MUWU", "LXTLSLSMTMTLSKQKPLPNQPTRUS PNQOTQUSUUSW QPOROTPVSXTY OTPUSWTYT[S\\Q\\P[PZQZQ[P[", "LXRKQLRMSLRK RMRQ RQQSRVSSRQ RVR\\ POONNOOPPOTOUNVOUPTO", "LXRMSLRKQLRMRQQRSURV RQSRQURVRZQ[R\\S[RZ POONNOOPPOTOUNVOUPTO PXOWNXOYPXTXUWVXUYTX", "LYVKVX NKVK QQVQ NXVX", "H\\QKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK RQQRRSSRRQ", "LYQKPLPMQN TKULUMTN RNPOOQORPTRUSUUTVRVQUOSNRN RURY SUSY OWVW", "LYRKPLONOOPQRRSRUQVOVNULSKRK RRRX SRSX OUVU", "H\\QKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK RKRY KRYR", "JYRRPQOQMRLTLUMWOXPXRWSUSTRR WMRR RMWMWR RMVNWR", "JZLLMKOKQLRNRPQRPSNT OKPLQNQQPS VKUX WKTX NTXT", "JYNKNU OKNR NROPQOSOUPVQVTTVTXUYVYWX SOUQUTTV LKOK", "LYONRKRQ VNSKSQ RQPROTOUPWRXSXUWVUVTURSQ RTRUSUSTRT", "JZRKRY MKMPNRPSTSVRWPWK LMMKNM QMRKSM VMWKXM OVUV", "JYNKNX OKOX LKSKVLWNWOVQSROR SKULVNVOUQSR LXVXVUUX", "LYWKTKQLONNQNSOVQXTYWY WKTLRNQQQSRVTXWY", "JZRRPQOQMRLTLUMWOXPXRWSUSTRR SLQQ WMRR XQSS", "KYPMTW TMPW MPWT WPMT", "J[OUMULVLXMYOYPXPVNTMRMONMOLQKTKVLWMXOXRWTUVUXVYXYYXYVXUVU NMPLULWM", "J[OOMOLNLLMKOKPLPNNPMRMUNWOXQYTYVXWWXUXRWPUNULVKXKYLYNXOVO NWPXUXWW", "F^KHK\\ LHL\\ XHX\\ YHY\\ HH\\H H\\O\\ U\\\\\\", "H]KHRQJ\\ JHQQ JHYHZMXH K[X[ J\\Y\\ZWX\\", "KYVBTDRGPKOPOTPYR]T`Vb TDRHQKPPPTQYR\\T`", "KYNBPDRGTKUPUTTYR]P`Nb PDRHSKTPTTSYR\\P`", "KYOBOb PBPb OBVB ObVb", "KYTBTb UBUb NBUB NbUb", "JYTBQEPHPJQMSOSPORSTSUQWPZP\\Q_Tb RDQGQKRN RVQYQ]R`", "KZPBSETHTJSMQOQPURQTQUSWTZT\\S_Pb RDSGSKRN RVSYS]R`", "KYU@RCPFOIOLPOSVTYT\\S_Ra RCQEPHPKQNTUUXU[T^RaOd", "KYO@RCTFUIULTOQVPYP\\Q_Ra RCSETHTKSNPUOXO[P^RaUd", "AXCRGRR` GSRa FSRb X:Rb", "F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` VDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia", "H\\RFK[ RFY[ RIX[ MUVU I[O[ U[[[", "G]LFL[ MFM[ IFUFXGYHZJZLYNXOUP UFWGXHYJYLXNWOUP MPUPXQYRZTZWYYXZU[I[ UPWQXRYTYWXYWZU[", "G\\XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXXYV QFOGMILKKNKSLVMXOZQ[", "G]LFL[ MFM[ IFSFVGXIYKZNZSYVXXVZS[I[ SFUGWIXKYNYSXVWXUZS[", "G\\LFL[ MFM[ SLST IFYFYLXF MPSP I[Y[YUX[", "G[LFL[ MFM[ SLST IFYFYLXF MPSP I[P[", "G^XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXX QFOGMILKKNKSLVMXOZQ[ XSX[ YSY[ US\\S", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F LPXP H[O[ U[\\[", "MXRFR[ SFS[ OFVF O[V[", "KZUFUWTZR[P[NZMXMVNUOVNW TFTWSZR[ QFXF", "F\\KFK[ LFL[ YFLS QOY[ POX[ HFOF UF[F H[O[ U[[[", "I[NFN[ OFO[ KFRF K[Z[ZUY[", "F_KFK[ LFRX KFR[ YFR[ YFY[ ZFZ[ HFLF YF]F H[N[ V[][", "G^LFL[ MFYY MHY[ YFY[ IFMF VF\\F I[O[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF QFOGMILKKOKRLVMXOZQ[ S[UZWXXVYRYOXKWIUGSF", "G]LFL[ MFM[ IFUFXGYHZJZMYOXPUQMQ UFWGXHYJYMXOWPUQ I[P[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF QFOGMILKKOKRLVMXOZQ[ S[UZWXXVYRYOXKWIUGSF NYNXOVQURUTVUXV_W`Y`Z^Z] UXV\\W^X_Y_Z^", "G]LFL[ MFM[ IFUFXGYHZJZLYNXOUPMP UFWGXHYJYLXNWOUP I[P[ RPTQURXYYZZZ[Y TQUSWZX[Z[[Y[X", "H\\XIYFYLXIVGSFPFMGKIKKLMMNOOUQWRYT KKMMONUPWQXRYTYXWZT[Q[NZLXKUK[LX", "I\\RFR[ SFS[ LFKLKFZFZLYF O[V[", "F^KFKULXNZQ[S[VZXXYUYF LFLUMXOZQ[ HFOF VF\\F", "H\\KFR[ LFRX YFR[ IFOF UF[F", "F^JFN[ KFNV RFN[ RFV[ SFVV ZFV[ GFNF WF]F", "H\\KFX[ LFY[ YFK[ IFOF UF[F I[O[ U[[[", "H]KFRQR[ LFSQS[ ZFSQ IFOF VF\\F O[V[", "H\\XFK[ YFL[ LFKLKFYF K[Y[YUX[", "I[NFN[ OFO[ KFZFZLYF K[R[", "H\\RFJ[ RFZ[ RIY[ KZYZ J[Z[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF QFOGMILKKOKRLVMXOZQ[ S[UZWXXVYRYOXKWIUGSF OMOT UMUT OPUP OQUQ", "H\\RFK[ RFY[ RIX[ I[O[ U[[[", "G]KEJJ ZEYJ ONNS VNUS KWJ\\ ZWY\\ KGYG KHYH OPUP OQUQ KYYY KZYZ", "F^KFK[ LFL[ XFX[ YFY[ HF\\F H[O[ U[\\[", "H]KFRPJ[ JFQP JFYFZLXF KZXZ J[Y[ZUX[", "I\\KKKILGMFOFPGQIRMR[ KIMGOGQI ZKZIYGXFVFUGTISMS[ ZIXGVGTI O[V[", "H]RFR[ SFS[ PKMLLMKOKRLTMUPVUVXUYTZRZOYMXLUKPK PKNLMMLOLRMTNUPV UVWUXTYRYOXMWLUK OFVF O[V[", "G^RFR[ SFS[ IMJLLMMQNSOTQU JLKMLQMSNTQUTUWTXSYQZM[L TUVTWSXQYM[L\\M OFVF O[V[", "G]JXK[O[MWKSJPJLKIMGPFTFWGYIZLZPYSWWU[Y[ZX MWLTKPKLLINGPF TFVGXIYLYPXTWW KZNZ VZYZ", "H\\UFH[ UFV[ THU[ LUUU F[L[ R[X[", "F^OFI[ PFJ[ LFWFZG[I[KZNYOVP WFYGZIZKYNXOVP MPVPXQYSYUXXVZR[F[ VPWQXSXUWXUZR[", "H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV TFRGPINLMOLSLVMYNZP[", "F]OFI[ PFJ[ LFUFXGYHZKZOYSWWUYSZO[F[ UFWGXHYKYOXSVWTYRZO[", "F]OFI[ PFJ[ TLRT LF[FZLZF MPSP F[U[WVT[", "F\\OFI[ PFJ[ TLRT LF[FZLZF MPSP F[M[", "H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT TFRGPINLMOLSLVMYNZP[ R[TZVXXT UT\\T", "E_NFH[ OFI[ [FU[ \\FV[ KFRF XF_F LPXP E[L[ R[Y[", "LYUFO[ VFP[ RFYF L[S[", "I[XFSWRYQZO[M[KZJXJVKULVKW WFRWQYO[ TF[F", "F]OFI[ PFJ[ ]FLS SOW[ ROV[ LFSF YF_F F[M[ S[Y[", "H\\QFK[ RFL[ NFUF H[W[YUV[", "E`NFH[ NFO[ OFPY \\FO[ \\FV[ ]FW[ KFOF \\F`F E[K[ S[Z[", "F_OFI[ OFVX OIV[ \\FV[ LFOF YF_F F[L[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF SFQGOIMLLOKSKVLYN[ Q[SZUXWUXRYNYKXHVF", "F]OFI[ PFJ[ LFXF[G\\I\\K[NYPUQMQ XFZG[I[KZNXPUQ F[M[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF SFQGOIMLLOKSKVLYN[ Q[SZUXWUXRYNYKXHVF LYLXMVOUPURVSXS_T`V`W^W] SXT^U_V_W^", "F^OFI[ PFJ[ LFWFZG[I[KZNYOVPMP WFYGZIZKYNXOVP RPTQURVZW[Y[ZYZX URWYXZYZZY F[M[", "G^ZH[H\\F[L[JZHYGVFRFOGMIMKNMONVRXT MKOMVQWRXTXWWYVZS[O[LZKYJWJUI[JYKY", "H]UFO[ VFP[ OFLLNF]F\\L\\F L[S[", "F_NFKQJUJXKZN[R[UZWXXU\\F OFLQKUKXLZN[ KFRF YF_F", "H\\NFO[ OFPY \\FO[ LFRF XF^F", "E_MFK[ NFLY UFK[ UFS[ VFTY ]FS[ JFQF ZF`F", "G]NFU[ OFV[ \\FH[ LFRF XF^F F[L[ R[X[", "H]NFRPO[ OFSPP[ ]FSP LFRF YF_F L[S[", "G][FH[ \\FI[ OFLLNF\\F H[V[XUU[", "H\\KILKXWYYY[ LLXX KIKKLMXYY[ PPLTKVKXLZK[ KVMZ LTLVMXMZK[ SSXN VIVLWNYNYLWKVI VIWLYN", "H\\QIK[ SIY[ RIX[ MUVU I[O[ U[[[ QBOCNENGOIQJSJUIVGVEUCSBQB", "G]IB[b", "F^RJIZ RJ[Z", "I]NONPMPMONNPMTMVNWOXQXXYZZ[ WOWXXZZ[[[ WQVRPSMTLVLXMZP[S[UZWX PSNTMVMXNZP[", "G\\LFL[ MFM[ MPONQMSMVNXPYSYUXXVZS[Q[OZMX SMUNWPXSXUWXUZS[ IFMF", "H[WPVQWRXQXPVNTMQMNNLPKSKULXNZQ[S[VZXX QMONMPLSLUMXOZQ[", "H]WFW[ XFX[ WPUNSMQMNNLPKSKULXNZQ[S[UZWX QMONMPLSLUMXOZQ[ TFXF W[[[", "H[LSXSXQWOVNTMQMNNLPKSKULXNZQ[S[VZXX WSWPVN QMONMPLSLUMXOZQ[", "KXUGTHUIVHVGUFSFQGPIP[ SFRGQIQ[ MMUM M[T[", "I\\QMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM ONNPNTOV UVVTVPUN VOWNYMYNWN NUMVLXLYM[P\\U\\X]Y^ LYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[", "G]LFL[ MFM[ MPONRMTMWNXPX[ TMVNWPW[ IFMF I[P[ T[[[", "MXRFQGRHSGRF RMR[ SMS[ OMSM O[V[", "MXSFRGSHTGSF TMT_SaQbObNaN`O_P`Oa SMS_RaQb PMTM", "G\\LFL[ MFM[ WMMW RSX[ QSW[ IFMF TMZM I[P[ T[Z[", "MXRFR[ SFS[ OFSF O[V[", "BcGMG[ HMH[ HPJNMMOMRNSPS[ OMQNRPR[ SPUNXMZM]N^P^[ ZM\\N]P][ DMHM D[K[ O[V[ Z[a[", "G]LML[ MMM[ MPONRMTMWNXPX[ TMVNWPW[ IMMM I[P[ T[[[", "H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM QMONMPLSLUMXOZQ[ S[UZWXXUXSWPUNSM", "G\\LMLb MMMb MPONQMSMVNXPYSYUXXVZS[Q[OZMX SMUNWPXSXUWXUZS[ IMMM IbPb", "H\\WMWb XMXb WPUNSMQMNNLPKSKULXNZQ[S[UZWX QMONMPLSLUMXOZQ[ Tb[b", "IZNMN[ OMO[ OSPPRNTMWMXNXOWPVOWN KMOM K[R[", "J[WOXMXQWOVNTMPMNNMOMQNRPSUUWVXW MPNQPRUTWUXVXYWZU[Q[OZNYMWM[NY", "KZPFPWQZS[U[WZXX QFQWRZS[ MMUM", "G]LMLXMZP[R[UZWX MMMXNZP[ WMW[ XMX[ IMMM TMXM W[[[", "I[LMR[ MMRY XMR[ JMPM TMZM", "F^JMN[ KMNX RMN[ RMV[ SMVX ZMV[ GMNM WM]M", "H\\LMW[ MMX[ XML[ JMPM TMZM J[P[ T[Z[", "H[LMR[ MMRY XMR[P_NaLbKbJaK`La JMPM TMZM", "I[WML[ XMM[ MMLQLMXM L[X[XWW[", "G^QMNNLPKRJUJXKZN[P[RZUWWTYPZM QMONMPLRKUKXLZN[ QMSMUNVPXXYZZ[ SMTNUPWXXZZ[[[", "G\\TFQGOIMMLPKTJZIb TFRGPINMMPLTKZJb TFVFXGYHYKXMWNTOPO VFXHXKWMVNTO POTPVRWTWWVYUZR[P[NZMYLV POSPURVTVWUYTZR[", "H\\IPKNMMOMQNROSRSVRZOb JOLNPNRO ZMYPXRSYP^Nb YMXPWRSY", "I\\VNTMRMONMQLTLWMYNZP[R[UZWWXTXQWOSJRHRFSEUEWFYH RMPNNQMTMXNZ R[TZVWWTWPVNTKSISGTFVFYH", "I[XPVNTMPMNNNPPRSS PMONOPQRSS SSNTLVLXMZP[S[UZWX SSOTMVMXNZP[", "I[TFRGQHQIRJUKZKZJWKSMPOMRLULWMYP[S]T_TaSbQbPa ULQONRMUMWNYP[", "G]HQIOKMNMONOPNTL[ MMNNNPMTK[ NTPPRNTMVMXNYOYRXWUb VMXOXRWWTb", "F]GQHOJMMMNNNPMUMXNZO[ LMMNMPLULXMZO[Q[SZUXWUXRYMYIXGVFTFRHRJSMUPWRZT SZUWVUWRXMXIWGVF", "LXRMPTOXOZP[S[UYVW SMQTPXPZQ[", "H\\NMJ[ OMK[ XMYNZNYMWMUNQROSMS OSQTSZT[ OSPTRZS[U[WZYW", "H\\KFMFOGPHQJWXXZY[ MFOHPJVXWZY[Z[ RMJ[ RMK[", "F]MMGb NMHb MPLVLYN[P[RZTXVU XMUXUZV[Y[[Y\\W YMVXVZW[", "H\\NML[ OMNSMXL[ YMXQVU ZMYPXRVUTWQYOZL[ KMOM", "IZTFRGQHQIRJUKXK UKQLOMNONQPSSTVT UKRLPMOOOQQSST STOUMVLXLZN\\S^T_TaRbPb STPUNVMXMZO\\S^", "I[RMONMQLTLWMYNZP[R[UZWWXTXQWOVNTMRM RMPNNQMTMXNZ R[TZVWWTWPVN", "G]PNL[ PNM[ VNV[ VNW[ IPKNNM[M IPKONN[N", "H[LVMYNZP[R[UZWWXTXQWOVNTMRMONMQLTHb R[TZVWWTWPVN RMPNNQMTIb", "H][MQMNNLQKTKWLYMZO[Q[TZVWWTWQVOUNSM QMONMQLTLXMZ Q[SZUWVTVPUN UN[N", "H\\SNP[ SNQ[ JPLNOMZM JPLOONZN", "H\\IQJOLMOMPNPPNVNYP[ NMONOPMVMYNZP[Q[TZVXXUYRYOXMWNXOYR XUYO", "G]ONMOKQJTJWKYLZN[Q[TZWXYUZRZOXMVMTORSPXMb JWLYNZQZTYWWYU ZOXNVNTPRSPYNb", "I[KMMMONPPU_VaWb MMNNOPT_UaWbYb ZMYOWRM]K`Jb", "F]UFOb VFNb GQHOJMMMNNNPMUMXOZRZTYWVYS LMMNMPLULXMZO[R[TZVXXUYS[M", "F]JQLOONNMLNJQITIWJZK[M[OZQWRT IWJYKZMZOYQW QTQWRZS[U[WZYWZTZQYNXMWNYOZQ QWRYSZUZWYYW", "H]XMVTUXUZV[Y[[Y\\W YMWTVXVZW[ VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ", "H[PFLSLVMYNZ QFMS MSNPPNRMTMVNWOXQXTWWUZR[P[NZMWMS VNWPWTVWTZR[ MFQF", "I[WPWQXQXPWNUMRMONMQLTLWMYNZP[R[UZWW RMPNNQMTMXNZ", "H]ZFVTUXUZV[Y[[Y\\W [FWTVXVZW[ VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ WF[F", "I[MVQUTTWRXPWNUMRMONMQLTLWMYNZP[R[UZWX RMPNNQMTMXNZ", "KZZGYHZI[H[GZFXFVGUHTJSMP[O_Na XFVHUJTNRWQ[P^O`NaLbJbIaI`J_K`Ja OMYM", "H\\YMU[T^RaObLbJaI`I_J^K_J` XMT[S^QaOb VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ", "H]PFJ[ QFK[ MTOPQNSMUMWNXOXQVWVZW[ UMWOWQUWUZV[Y[[Y\\W MFQF", "LYUFTGUHVGUF MQNOPMSMTNTQRWRZS[ RMSNSQQWQZR[U[WYXW", "LYVFUGVHWGVF NQOOQMTMUNUQR[Q^P`OaMbKbJaJ`K_L`Ka SMTNTQQ[P^O`Mb", "H\\PFJ[ QFK[ XNWOXPYOYNXMWMUNQROSMS OSQTSZT[ OSPTRZS[U[WZYW MFQF", "MYUFQTPXPZQ[T[VYWW VFRTQXQZR[ RFVF", "AbBQCOEMHMINIPHTF[ GMHNHPGTE[ HTJPLNNMPMRNSOSQP[ PMRORQO[ RTTPVNXMZM\\N]O]Q[W[Z\\[ ZM\\O\\QZWZZ[[^[`YaW", "F]GQHOJMMMNNNPMTK[ LMMNMPLTJ[ MTOPQNSMUMWNXOXQVWVZW[ UMWOWQUWUZV[Y[[Y\\W", "G\\HQIOKMNMONOPNTJb MMNNNPMTIb NTOQQNSMUMWNXOYQYTXWVZS[Q[OZNWNT WNXPXTWWUZS[ FbMb", "H\\XMRb YMSb VTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT QMONMQLTLXMZ ObVb", "IZJQKOMMPMQNQPPTN[ OMPNPPOTM[ PTRPTNVMXMYNYOXPWOXN", "J[XOXPYPYOXNUMRMONNONQORVVWW NPOQVUWVWYVZS[P[MZLYLXMXMY", "KYTFPTOXOZP[S[UYVW UFQTPXPZQ[ NMWM", "F]GQHOJMMMNNNQLWLYN[ LMMNMQKWKYLZN[P[RZTXVT XMVTUXUZV[Y[[Y\\W YMWTVXVZW[", "H\\IQJOLMOMPNPQNWNYP[ NMONOQMWMYNZP[Q[TZVXXUYQYMXMYO", "C`DQEOGMJMKNKQIWIYK[ IMJNJQHWHYIZK[M[OZQXRV TMRVRYSZU[W[YZ[X\\V]R]M\\M]O UMSVSYU[", "H\\KQMNOMRMSOSR QMRORRQVPXNZL[K[JZJYKXLYKZ QVQYR[U[WZYW YNXOYPZOZNYMXMVNTPSRRVRYS[", "G\\HQIOKMNMONOQMWMYO[ MMNNNQLWLYMZO[Q[SZUXWT ZMV[U^SaPbMbKaJ`J_K^L_K` YMU[T^RaPb", "H\\YMXOVQNWLYK[ LQMOOMRMVO MOONRNVOXO LYNYRZUZWY NYR[U[WYXW", "G^VGUHVIWHWGUFRFOGMILLL[ RFPGNIMLM[ \\G[H\\I]H]G\\FZFXGWIW[ ZFYGXIX[ IM[M I[P[ T[[[", "G]WGVHWIXHWGUFRFOGMILLL[ RFPGNIMLM[ WMW[ XMX[ IMXM I[P[ T[[[", "G]VGUHVIWHWGUF XFRFOGMILLL[ RFPGNIMLM[ WHW[ XFX[ IMWM I[P[ T[[[", "BcRGQHRISHRGPFMFJGHIGLG[ MFKGIIHLH[ ]G\\H]I^H]G[FXFUGSIRLR[ XFVGTISLS[ ]M][ ^M^[ DM^M D[K[ O[V[ Z[a[", "BcRGQHRISHRGPFMFJGHIGLG[ MFKGIIHLH[ \\G[H\\I]H]G[F ^FXFUGSIRLR[ XFVGTISLS[ ]H][ ^F^[ DM]M D[K[ O[V[ Z[a[", "MXRMR[ SMS[ OMSM O[V[", "IZWNUMRMONMPLSLVMYNZQ[T[VZ RMPNNPMSMVNYOZQ[ MTUT", "I\\TFQGOJNLMOLTLXMZO[Q[TZVWWUXRYMYIXGVFTF TFRGPJOLNOMTMXNZO[ Q[SZUWVUWRXMXIWGVF NPWP", "G]UFOb VFNb QMMNKPJSJVKXMZP[S[WZYXZUZRYPWNTMQM QMNNLPKSKVLXNZP[ S[VZXXYUYRXPVNTM", "I[TMVNXPXOWNTMQMNNMOLQLSMUOWSZ QMONNOMQMSNUSZT\\T^S_Q_", "G]LMKNJPJRKUOYP[ JRKTOXP[P]O`MbLbKaJ_J\\KXMTOQRNTMVMYNZPZTYXWZU[T[SZSXTWUXTY VMXNYPYTXXWZ", "E_YGXHYIZHYGWFTFQGOINKMNLRJ[I_Ha TFRGPIOKNNLWK[J^I`HaFbDbCaC`D_E`Da _G^H_I`H`G_F]F[GZHYJXMU[T_Sa ]F[HZJYNWWV[U^T`SaQbObNaN`O_P`Oa IM^M", "F^[GZH[I\\H[GXFUFRGPIOKNNMRK[J_Ia UFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea YMWTVXVZW[Z[\\Y]W ZMXTWXWZX[ JMZM", "F^YGXHYIZHZGXF \\FUFRGPIOKNNMRK[J_Ia UFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea [FWTVXVZW[Z[\\Y]W \\FXTWXWZX[ JMYM", "@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca OFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a `G_H`IaH`G]FZFWGUITKSNRRP[O_Na ZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja ^M\\T[X[Z\\[_[aYbW _M]T\\X\\Z][ DM_M", "@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca OFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a ^G]H^I_H_G]F aFZFWGUITKSNRRP[O_Na ZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja `F\\T[X[Z\\[_[aYbW aF]T\\X\\Z][ DM^M", "LYMQNOPMSMTNTQRWRZS[ RMSNSQQWQZR[U[WYXW", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF QFOGNHMJLOLRMWNYOZQ[ S[UZVYWWXRXOWJVHUGSF", "H\\NJPISFS[ RGR[ N[W[", "H\\LJMKLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ TFVGWHXJXLWNTPPR KYLXNXSZVZXYYX NXS[W[XZYXYV", "H\\LJMKLLKKKJLHMGPFTFWGXIXLWNTOQO TFVGWIWLVNTO TOVPXRYTYWXYWZT[P[MZLYKWKVLUMVLW WQXTXWWYVZT[", "H\\THT[ UFU[ UFJUZU Q[X[", "H\\MFKP KPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMVLW SMUNWPXSXUWXUZS[ MFWF MGRGWF", "H\\WIVJWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNRNOOMQLT RFPGNIMKLOLUMXOZQ[ S[UZWXXUXTWQUOSN", "H\\KFKL KJLHNFPFUIWIXHYF LHNGPGUI YFYIXLTQSSRVR[ XLSQRSQVQ[", "H\\PFMGLILLMNPOTOWNXLXIWGTFPF PFNGMIMLNNPO TOVNWLWIVGTF POMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO PONPMQLSLWMYNZP[ T[VZWYXWXSWQVPTO", "H\\XMWPURRSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNWMX QSORMPLMLLMIOGQF SFUGWIXLXRWVVXTZR[", "MWR[QZRYSZS\\R^Q_", "MWRMQNROSNRM R[QZRYSZS\\R^Q_", "MWRFQHRTSHRF RHRN RYQZR[SZRY", "I[MJNKMLLKLJMHNGPFSFVGWHXJXLWNVORQRT SFUGVHWJWLVNTP RYQZR[SZRY", "NVRFQM SFQM", "JZNFMM OFMM VFUM WFUM", "JZRFRR MIWO WIMO", "KYUBNRUb", "KYOBVROb", "KYOBOb UBUb", "F^RJR[ JRZR J[Z[", "F^RJR[ JJZJ JRZR", "MWQQQSSSSQQQ RQRS QRSR", "E_RIQJRKSJRI IR[R RYQZR[SZRY", "E_YIK[ IO[O IU[U", "E_IM[M IR[R IW[W", "F^ZFJMZT JVZV J[Z[", "F^JFZMJT JVZV J[Z[", "F_[WYWWVUTRPQOONMNKOJQJSKUMVOVQURTUPWNYM[M", "F^IUISJPLONOPPTSVTXTZS[Q ISJQLPNPPQTTVUXUZT[Q[O", "G]JTROZT JTRPZT", "LXTFOL TFUGOL", "LXPFUL PFOGUL", "H\\KFLHNJQKSKVJXHYF KFLINKQLSLVKXIYF", "MWRHSGRFQGQIRKSL", "MWQFRGSISKRLQKRJ", "E[HMLMRY KMR[ [BR[", "F^ZJSJOKMLKNJQJSKVMXOYSZZZ", "F^JJJQKULWNYQZSZVYXWYUZQZJ", "F^JJQJUKWLYNZQZSYVWXUYQZJZ", "F^JZJSKOLMNKQJSJVKXMYOZSZZ", "F^ZJSJOKMLKNJQJSKVMXOYSZZZ JRVR", "E_XP[RXT UMZRUW IRZR", "JZPLRITL MORJWO RJR[", "E_LPIRLT OMJROW JR[R", "JZPXR[TX MURZWU RIRZ", "I\\XRWOVNTMRMONMQLTLWMYNZP[R[UZWXXUYPYKXHWGUFRFPGOHOIPIPH RMPNNQMTMXNZ R[TZVXWUXPXKWHUF", "H\\JFR[ KFRY ZFR[ JFZF KGYG", "AbDMIMRY HNR[ b:R[", "F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` VDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia QKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK", "F_\\S[UYVWVUUTTQPPONNLNJOIQISJULVNVPUQTTPUOWNYN[O\\Q\\S", "F^[FI[ NFPHPJOLMMKMIKIIJGLFNFPGSHVHYG[F WTUUTWTYV[X[ZZ[X[VYTWT", "F_[NZO[P\\O\\N[MZMYNXPVUTXRZP[M[JZIXIUJSPORMSKSIRGPFNGMIMKNNPQUXWZZ[[[\\Z\\Y M[KZJXJUKSMQ MKNMVXXZZ[", "E`WNVLTKQKOLNMMPMSNUPVSVUUVS QKOMNPNSOUPV WKVSVUXVZV\\T]Q]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYZX XKWSWUXV", "H\\PBP_ TBT_ XIWJXKYJYIWGTFPFMGKIKKLMMNOOUQWRYT KKMMONUPWQXRYTYXWZT[P[MZKXKWLVMWLX", "JZUITJUKVJVIUGSFQFOGNINKOMQOVR OMTPVRWTWVVXTZ PNNPMRMTNVPXU[ NVSYU[V]V_UaSbQbOaN_N^O]P^O_", "JZRFQHRJSHRF RFRb RQQTRbSTRQ LMNNPMNLLM LMXM TMVNXMVLTM", "JZRFQHRJSHRF RFRT RPQRSVRXQVSRRP RTRb R^Q`RbS`R^ LMNNPMNLLM LMXM TMVNXMVLTM L[N\\P[NZL[ L[X[ T[V\\X[VZT[", "I\\XFX[ KFXF PPXP K[X[", "E`QFNGKIILHOHRIUKXNZQ[T[WZZX\\U]R]O\\LZIWGTFQF ROQPQQRRSRTQTPSORO RPRQSQSPRP", "J[PFNGOIQJ PFOGOI UFWGVITJ UFVGVI QJOKNLMNMQNSOTQUTUVTWSXQXNWLVKTJQJ RUR[ SUS[ NXWX", "I\\RFOGMILLLMMPORRSSSVRXPYMYLXIVGSFRF RSR[ SSS[ NWWW", "D`PFMGJIHLGOGSHVJYM[P\\T\\W[ZY\\V]S]O\\LZIWGTFPF RFR\\ GQ]Q", "G`PMMNKPJSJTKWMYPZQZTYVWWTWSVPTNQMPM ]GWG[HUN ]G]M\\IVO \\HVN", "F\\IIJGLFOFQGRIRLQOPQNSKU OFPGQIQMPPNS VFT[ WFS[ KUYU", "I\\MFMU NFMQ MQNOONQMTMWNXPXRWTUV TMVNWPWRTXTZU[W[YY KFNF", "I\\RNOOMQLTLUMXOZR[S[VZXXYUYTXQVOSNRN RHNJRFRN SHWJSFSN RSQTQURVSVTUTTSSRS RTRUSUSTRT", "G^QHRFR[ THSFS[ JHKFKMLPNRQSRS MHLFLNMQ [HZFZMYPWRTSSS XHYFYNXQ NWWW", "G]LFL[ MFM[ IFUFXGYHZJZMYOXPUQMQ UFWGXHYJYMXOWPUQ I[Y[YVX[", "H[YGUGQHNJLMKPKSLVNYQ[U\\Y\\ YGVHSJQMPPPSQVSYV[Y\\", "F_OQMQKRJSIUIWJYKZM[O[QZRYSWSURSQROQ SHPQ ZJRR \\QST", "H\\OKUY UKOY KOYU YOKU", "F^NVLUKUIVHXHYI[K\\L\\N[OYOXNVKRJOJMKJMHPGTGWHYJZMZOYRVVUXUYV[X\\Y\\[[\\Y\\X[VYUXUVV JMKKMIPHTHWIYKZM", "F^NMLNKNIMHKHJIHKGLGNHOJOKNMKQJTJVKYM[P\\T\\W[YYZVZTYQVMUKUJVHXGYG[H\\J\\K[MYNXNVM JVKXMZP[T[WZYXZV", "I[KYYK QLULYKXOXS ULXLXO", "I[YKKY LQLUKYOXSX LULXOX", "I[YYKK SLOLKKLOLS OLLLLO", "I[KKYY QXUXYYXUXQ UXXXXU", "F_JMILIJJHLGNGPHQIRKSP IJKHMHOIPJQLRPR[ [M\\L\\J[HYGWGUHTISKRP \\JZHXHVIUJTLSPS[", "F^IGJKKMMOPPTPWOYMZK[G IGJJKLMNPOTOWNYLZJ[G PONPMQLSLVMXOZQ[S[UZWXXVXSWQVPTO PPNQMSMVNY VYWVWSVQTP", "F^MJMV NKNU VKVU WJWV IGKIMJPKTKWJYI[G IYKWMVPUTUWVYW[Y", "F^[ILIJJILINJPLQNQPPQNQLPJ[J IMJOKPMQ QMPKOJMI IXXXZW[U[SZQXPVPTQSSSUTWIW [TZRYQWP STTVUWWX", "F]OUMTLTJUIWIXJZL[M[OZPXPWOUJPINIKJILHOGSGWHYJZLZOYRVUUWUYV[X[YZZX MSKPJNJKKILH SGVHXJYLYOXRVU", "G_HKKHMKMV JILLLV MKPHRKRU OIQLQU RKUHWKW[ TIVLV[ WKZH[J\\M\\P[SZUXWUYP[ YIZJ[M[PZSYUWWTYP[", "F^ISMSLRKOKMLJNHQGSGVHXJYMYOXRWS[S ITOTMRLOLMMJOHQG SGUHWJXMXOWRUT[T KXYX KYYY", "F_GLJIMLMX IJLMLX MLPISLSX OJRMRX SLVIYLYW[Y UJXMXXZZ]W", "G]ZIJY ZIWJQJ XKUKQJ ZIYLYR XKXNYR QRJR PSMSJR QRQY PSPVQY", "F^HOJKOU JMOWRPWPZO[M[KZIXHWHUITKTMUPVRWUWXUZ WHVIUKUMWQXTXWWYUZ", "F^IOLLPN KMOORLUN QMTOWLYN VMXO[L IULRPT KSOURRUT QSTUWRYT VSXU[R", "F^JHNJPLQOQRPUNWJY JHMIOJQLRO RRQUOWMXJY ZHWIUJSLRO RRSUUWWXZY ZHVJTLSOSRTUVWZY IP[P IQ[Q", "NVQQQSSSSQQQ QQSS SQQS", "JZMPQRTTVVWYW[V]U^ MQST MRPSTUVWWY", "JZWKVMTOPQMR SPMS UFVGWIWKVNTPQRMT", "H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM XNSM VMQNLP ONKR LVQW NWSVXT UVYR", "J[SMPNNPMRMTNVPWRWUVWTXRXPWNUMSM OPUM NRVN MTWO NUXP OVWR PWVT", "JZOGO^ UFU] MNWL MOWM MWWU MXWV", "JZNFNX VLV^ NNVL NOVM NWVU NXVV", "JZNBNW NNQLTLVMWOWQVSSUQVNW NNQMTMVN UMVOVQUSSU", "E_HIHL \\I\\L HI\\I HJ\\J HK\\K HL\\L", "JZMNMQ WNWQ MNWN MOWO MPWP MQWQ", "JZMLWX MLONQOTOVNWMWKUKUMTO ONTO QOWM VKVN ULWL WXUVSUPUNVMWMYOYOWPU UVPU SUMW NVNY MXOX", "JZPOOMOKMKMMNNPOSOUNWL NKNN MLOL MMSO POUN WLWY", "A^GfHfIeIdHcGcFdFfGhIiKiNhPfQdR`RUQ;Q4R/S-U,V,X-Y/Y3X6W8U;P?JCHEFHEJDNDREVGYJ[N\\R\\V[XZZW[T[PZMYKWITHPHMIKKJNJRKUMW GdGeHeHdGd U;Q?LCIFGIFKENERFVGXJ[ R\\U[WZYWZTZPYMXKVITH", "EfNSOUQVSVUUVSVQUOSNQNOONPMSMVNYP[S\\V\\Y[[Y\\W]T]P\\MZJXIUHRHOIMJKLIOHSHXI]KaMcPeTfYf]e`cba KLJNIRIXJ\\L`NbQdUeYe]d_cba POTO OPUP NQVQ NRVR NSVS OTUT PUTU aLaNcNcLaL bLbN aMcM aVaXcXcVaV bVbX aWcW", "D`H@Hd M@Md W@Wd \\@\\d MMWK MNWL MOWM MWWU MXWV MYWW", "H\\PMMNLOKQKSLUMVPWTWWVXUYSYQXOWNTMPM MNLPLSMUNVPW WVXTXQWOVNTM", "JZQCVMRTRU ULQS TITKPRRUUY W\\UYSXQXOYN[N]O_Ra W\\UZSYOYO]P_Ra SXPZN]", "JZPOOMOKMKMMNNPOSOUNWL NKNN MLOL MMSO POUN WLSY", "IjNQOOQNSNUOVQVSUUSVQVOUNTMQMNNKPISHWH[I^K`NaRaW`[_]]`ZcVfQiMk WHZI]K_N`R`W_[^]\\`YcTgQi POTO OPUP NQVQ NRVR NSVS OTUT PUTU eLeNgNgLeL fLfN eMgM eVeXgXgVeV fVfX eWgW", "D`H>Hf I>If M>Mf QBSBSDQDQAR?T>W>Y?[A\\D\\I[LYNWOUOSNRLQNOQNROSQVRXSVUUWUYV[X\\[\\`[cYeWfTfReQcQ`S`SbQb RBRD QCSC Y?ZA[D[IZLYN RLRNPQNRPSRVRX YVZX[[[`ZcYe R`Rb QaSa", "AcHBHb IBIb [B[b \\B\\b DB`B DbMb Wb`b", "BaGBQPFb FBPP EBPQ EB\\B^I[B Ga\\a Fb\\b^[[b", "I[X+U1R8P=OANFMNMVN^OcPgRlUsXy U1S6Q<P@OFNNNVO^PdQhSnUs", "I[L+O1R8T=UAVFWNWVV^UcTgRlOsLy O1Q6S<T@UFVNVVU^TdShQnOs", "I[M+MRMy N+NRNy M+X+ MyXy", "I[V+VRVy W+WRWy L+W+ LyWy", "H[V+R1P5O:O>PBTJTLSNROMRRUSVTXTZPbOfOjPoRsVy T.R2Q5P:P>QCRF R^QaPfPjQoRrTv", "I\\N+R1T5U:U>TBPJPLQNROWRRUQVPXPZTbUfUjToRsNy P.R2S5T:T>SCRF R^SaTfTjSoRrPv", "I[V.S1Q4O8N=NCOIPMSXT\\UbUgTlSoQs S1Q5P8O=OBPHQLTWU[VaVgUlSpQsNv", "I[N.Q1S4U8V=VCUITMQXP\\ObOgPlQoSs Q1S5T8U=UBTHSLPWO[NaNgOlQpSsVv", "7Z:RARRo @RQo ?RRr Z\"VJRr", "Ca].\\.[/[0\\1]1^0^.],[+Y+W,U.T0S3R:QJQjPsOv \\/\\0]0]/\\/ R:Rj U.T1S:SZRjQqPtOvMxKyIyGxFvFtGsHsItIuHvGv GtGuHuHtGt", "H\\RFJ[ RIK[J[ RIY[Z[ RFZ[ MUWU LVXV", "H\\LFL[ MGMZ LFTFWGXHYJYMXOWPTQ MGTGWHXJXMWOTP MPTPWQXRYTYWXYWZT[L[ MQTQWRXTXWWYTZMZ", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZV ZKYKXIWHUGQGOHMKLNLSMVOYQZUZWYXXYVZV", "H]LFL[ MGMZ LFSFVGXIYKZNZSYVXXVZS[L[ MGSGVHWIXKYNYSXVWXVYSZMZ", "I\\MFM[ NGNZ MFYF NGYGYF NPTPTQ NQTQ NZYZY[ M[Y[", "I[MFM[ NGN[M[ MFYF NGYGYF NPTPTQ NQTQ", "H]ZKYIWGUFQFOGMILKKNKSLVMXOZQ[U[WZYXZVZRUR ZKYKXIWHUGQGOHNIMKLNLSMVNXOYQZUZWYXXYVYSUSUR", "G]KFK[ KFLFL[K[ YFXFX[Y[ YFY[ LPXP LQXQ", "NWRFR[S[ RFSFS[", "J[VFVVUYSZQZOYNVMV VFWFWVVYUZS[Q[OZNYMV", "H]LFL[M[ LFMFM[ ZFYFMR ZFMS POY[Z[ QOZ[", "IZMFM[ MFNFNZ NZYZY[ M[Y[", "F^JFJ[ KKK[J[ KKR[ JFRX ZFRX YKR[ YKY[Z[ ZFZ[", "G]KFK[ LIL[K[ LIY[ KFXX XFXX XFYFY[", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF QGNHLKKNKSLVNYQZSZVYXVYSYNXKVHSGQG", "H\\LFL[ MGM[L[ LFUFWGXHYJYMXOWPUQMQ MGUGWHXJXMWOUPMP", "G]PFNGLIKKJNJSKVLXNZP[T[VZXXYVZSZNYKXIVGTFPF QGNHLKKNKSLVNYQZSZVYXVYSYNXKVHSGQG SXX]Y] SXTXY]", "H\\LFL[ MGM[L[ LFTFWGXHYJYMXOWPTQMQ MGTGWHXJXMWOTPMP RQX[Y[ SQY[", "H\\YIWGTFPFMGKIKKLMMNOOTQVRWSXUXXWYTZPZNYMXKX YIWIVHTGPGMHLILKMMONTPVQXSYUYXWZT[P[MZKX", "J[RGR[ SGS[R[ LFYFYG LFLGYG", "G]KFKULXNZQ[S[VZXXYUYF KFLFLUMXNYQZSZVYWXXUXFYF", "H\\JFR[ JFKFRX ZFYFRX ZFR[", "E_GFM[ GFHFMX RFMX RIM[ RIW[ RFWX ]F\\FWX ]FW[", "H\\KFX[Y[ KFLFY[ YFXFK[ YFL[K[", "I\\KFRPR[S[ KFLFSP ZFYFRP ZFSPS[", "H\\XFK[ YFL[ KFYF KFKGXG LZYZY[ K[Y[", "E\\XFVHTKQPOSLWIZG[E[DZDXEWFXEY XFWJUTT[ XFU[ T[TYSVRTPRNQLQKRKTLWOZR[V[XZ", "F^UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWIXHY OLNNMOKOJNJLKJMHOGRFXFZG[I[KZMXNTORO XFYGZIZKYMXN TOWPXQYSYVXYWZU[S[RZRXSU TOVPWQXSXVWYU[", "H]KHJJJLKNNOQOUNWMYKZIZGYFWFTGQJOMMQLULXMZP[R[UZWXXVXTWRURSSRU WFUGRJPMNQMUMXNZP[", "F]UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWJWLXNZP[S[UZWXYTZOZLYIWGUFPFMGKIJKJMKNMNNMOK", "I\\WIVJVLWMYMZKZIYGWFTFRGQHPJPLQNSO TFRHQJQMSO SOQONPLRKTKWLYMZO[R[UZWXXVXTWRURSSRU QOOPMRLTLXMZ", "G\\WHVJTORUQWOZM[ QLPNNOLOKMKKLINGQF[FXGWHVKTSSVRXPZM[K[IZHYHXIWJXIY SFWGXG OSPRRQVQXPZMXT", "G]JIIKIMJOLPOPROTNWKXHXGWFVFTGRIQKPNPQQSSTUTWSYQZO WFUGSIRKQNQRST ZOYSWWUYSZO[L[JZIXIWJVKWJX YSWVUXRZO[", "F^LLKKKILGOFRFOQMWLYKZI[G[FZFXGWHXGY RFOONRLWKYI[ JTKSMRVOXN[L]J^H^G]F\\FZGXJWLURTVTYV[W[YZ[X \\FZHXLVRUVUYV[", "IYWHUKSPQUPWNZL[ YLWNTOQOONNLNJOHQGUFYFWHVJTPRVQXOZL[J[IZIXJWKXJY", "IZYFWHUKSPPYN] YMWOTPQPOONMNKOIQGUFYFWIVKSTQXPZN]M^K_J^J\\KZMXOWRVVU", "F^LLKKKIMGPFRFOQMWLYKZI[G[FZFXGWHXGY RFOONRLWKYI[ ZGWKUMSNPO ]G\\H]I^H^G]F\\FZGWLVMTNPO POSPTRUYV[ PORPSRTYV[W[YZ[X", "I[MILKLMMOOPRPUOWNZK[H[GZFYFWGVHTKPUOWMZK[ VHTLRSQVPXNZK[I[HZHXIWKWMXPZR[U[WZYX", "D`RFNOKUIXGZE[C[BZBXCWDXCY RFPMOQNVNZP[ RFQJPOOVOZP[ [FWORXP[ [FYMXQWVWZY[Z[\\Z^X [FZJYOXVXZY[", "G^RFQJOPMULWJZH[F[EZEXFWGXFY RFRKSVT[ RFSKTVT[ `G_H`IaHaG`F^F\\GZJYLWQUWT[", "H]SFQGOIMLLNKRKVLYMZO[Q[TZVXXUYSZOZKYHXGWGUHSJQNPSPV QGOJMNLRLVMYO[", "F]UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWIXHY OLNNMOKOJNJLKJMHOGRFVFYGZH[J[MZOYPVQTQRP VFXGYHZJZMYOXPVQ", "H]UJULTNSOQPOPNNNLOIQGTFWFYGZIZMYPWSSWPYNZK[I[HZHXIWKWMXPZS[V[XZZX WFXGYIYMXPVSSVOYK[", "F^UGTHSJQOOUNWLZJ[ THSKQSPVOXMZJ[H[GZGXHWIXHY OLNNMOKOJNJLKJMHOGRFWFZG[I[KZMYNVORO WFYGZIZKYMXNVO ROUPVRWYX[ ROTPURVYX[Y[[Z]X", "H\\NIMKMMNOPPSPVOXN[K\\H\\G[FZFXGWHVJUMSTRWPZN[ VJUNTUSXQZN[K[IZHXHWIVJWIX", "I[YHXJVOTUSWQZO[ SLRNPONOMMMKNIPGSF\\FZGYHXKVSUVTXRZO[M[KZJYJXKWLXKY UFYGZG", "G]HJJGLFMFOHOKNNKVKYL[ MFNHNKKSJVJYL[N[PZSWUTVR ZFVRUVUYW[X[ZZ\\X [FWRVVVYW[", "G\\HJJGLFMFOHOKNOLVLYM[ MFNHNKLRKVKYM[N[QZTWVTXPYMZIZGYFXFWGVIVLWNYP[Q]Q", "F]ILHLGKGIHGJFNFMHLLKUJ[ LLLUK[ VFTHRLOUMYK[ VFUHTLSUR[ TLTUS[ `F^G\\IZLWUUYS[", "H\\PKOLMLLKLIMGOFQFSGTITLSPQUOXMZJ[H[GZGXHWIXHY QFRGSISLRPPUNXLZJ[ ]G\\H]I^H^G]F[FYGWIULSPRURXSZT[U[WZYX", "G]JJLGNFOFQGQIOOORPT OFPGPINONRPTRTUSWQYNZL \\FZLWTUX ]F[LYQWUUXSZP[L[JZIXIWJVKWJX", "G\\ZHYJWOVRUTSWQYOZL[ SLRNPONOMMMKNIPGSF]F[GZHYKXOVUTXQZL[H[GZGXHWJWLXOZQ[T[WZYX VFZG[G", "H\\WMW[X[ WMXMX[ WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "H\\LFL[M[ LFMFM[ MPONQMTMVNXPYSYUXXVZT[Q[OZMX MPQNTNVOWPXSXUWXVYTZQZMX", "I[XPVNTMQMONMPLSLUMXOZQ[T[VZXX XPWQVOTNQNOONPMSMUNXOYQZTZVYWWXX", "H\\WFW[X[ WFXFX[ WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "I[MTXTXQWOVNTMQMONMPLSLUMXOZQ[T[VZXX MSWSWQVOTNQNOONPMSMUNXOYQZTZVYWWXX", "LZWFUFSGRJR[S[ WFWGUGSH TGSJS[ OMVMVN OMONVN", "H\\XMWMW\\V_U`SaQaO`N_L_ XMX\\W_UaSbPbNaL_ WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "H\\LFL[M[ LFMFM[ MQPNRMUMWNXQX[ MQPORNTNVOWQW[X[", "NWRFQGQHRISITHTGSFRF RGRHSHSGRG RMR[S[ RMSMS[", "NWRFQGQHRISITHTGSFRF RGRHSHSGRG RMRbSb RMSMSb", "H[LFL[M[ LFMFM[ XMWMMW XMMX PTV[X[ QSX[", "CbGMG[H[ GMHMH[ HQKNMMPMRNSQS[ HQKOMNONQORQR[S[ SQVNXM[M]N^Q^[ SQVOXNZN\\O]Q][^[", "H\\LML[M[ LMMMM[ MQPNRMUMWNXQX[ MQPORNTNVOWQW[X[", "I\\QMONMPLSLUMXOZQ[T[VZXXYUYSXPVNTMQM QNOONPMSMUNXOYQZTZVYWXXUXSWPVOTNQN", "H\\LMLbMb LMMMMb MPONQMTMVNXPYSYUXXVZT[Q[OZMX MPQNTNVOWPXSXUWXVYTZQZMX", "H\\WMWbXb WMXMXb WPUNSMPMNNLPKSKULXNZP[S[UZWX WPSNPNNOMPLSLUMXNYPZSZWX", "KYOMO[P[ OMPMP[ PSQPSNUMXM PSQQSOUNXNXM", "J[XPWNTMQMNNMPNRPSUUWV VUWWWXVZ WYTZQZNY OZNXMX XPWPVN WOTNQNNO ONNPOR NQPRUTWUXWXXWZT[Q[NZMX", "MXRFR[S[ RFSFS[ OMVMVN OMONVN", "H\\LMLWMZO[R[TZWW LMMMMWNYPZRZTYWW WMW[X[ WMXMX[", "JZLMR[ LMMMRY XMWMRY XMR[", "F^IMN[ IMJMNX RMNX RPN[ RPV[ RMVX [MZMVX [MV[", "I[LMW[X[ LMMMX[ XMWML[ XMM[L[", "JZLMR[ LMMMRY XMWMRYNb XMR[ObNb", "I[VNL[ XMNZ LMXM LMLNVN NZXZX[ L[X[", "K[UUTSRRPRNSMTLVLXMZO[Q[SZTX PRNTMVMYO[ VRTXTZV[XZYY[V WRUXUZV[", "LZLVNSPO SFMXMZO[P[RZTXUUURVVWWXWZV TFNXNZO[", "LXTSSTTTTSSRQROSNTMVMXNZP[S[VYXV QROTNVNYP[", "K[UUTSRRPRNSMTLVLXMZO[Q[SZTX PRNTMVMYO[ ZFTXTZV[XZYY[V [FUXUZV[", "LXOYQXRWSUSSRRQROSNTMVMXNZP[S[VYXV QROTNVNYP[", "OXRRUOWLXIXGWFUGTIKdKfLgNfOcPZQ[S[UZVYXV TISNRRO[M`Kd", "K[UUTSRRPRNSMTLVLXMZO[Q[SZTX PRNTMVMYO[ VRPd WRT[R`PdOfMgLfLdMaO_R]V[YY[V", "L[LVNSPO SFL[ TFM[ OUQSSRTRVSVUUXUZV[ TRUSUUTXTZV[XZYY[V", "NVSLRMSNTMSL QROXOZQ[SZTYVV RRPXPZQ[", "NVSLRMSNTMSL QRKd RRO[M`KdJfHgGfGdHaJ_M]Q[TYVV", "LZLVNSPO SFL[ TFM[ URUSVSURTRRTOU OURVSZT[ OUQVRZT[U[XYZV", "NVNVPSRO UFOXOZQ[SZTYVV VFPXPZQ[", "E^EVGSIRKSKUI[ IRJSJUH[ KUMSORPRRSRUP[ PRQSQUO[ RUTSVRWRYSYUXXXZY[ WRXSXUWXWZY[[Z\\Y^V", "I[IVKSMROSOUM[ MRNSNUL[ OUQSSRTRVSVUUXUZV[ TRUSUUTXTZV[XZYY[V", "KYRRPRNSMTLVLXMZO[Q[SZTYUWUUTSRRQSQURWTXVXXWYV PRNTMVMYO[", "L[LVNSPO QLHg RLIg OUQSSRTRVSVUUXUZV[ TRUSUUTXTZV[XZYY[V", "K[UUTSRRPRNSMTLVLXMZO[Q[SZ PRNTMVMYO[ VRPdPfQgSfTcT[V[YY[V WRT[R`Pd", "LZLVNSPRRSRUP[ PRQSQUO[ RUTSVRWRVU VRVUWWXWZV", "NZNVPSQQQSTUUWUYTZR[ QSSUTWTYR[ NZP[U[XYZV", "NVNVPSRO UFOXOZQ[SZTYVV VFPXPZQ[ PNVN", "K[NRLXLZN[O[QZSXUU ORMXMZN[ VRTXTZV[XZYY[V WRUXUZV[", "KZNRMTLWLZN[O[RZTXUUUR ORNTMWMZN[ URVVWWXWZV", "H]LRJTIWIZK[L[NZPX MRKTJWJZK[ RRPXPZR[S[UZWXXUXR SRQXQZR[ XRYVZW[W]V", "JZJVLSNRPRQSQUPXOZM[L[KZKYLYKZ WSVTWTWSVRURSSRUQXQZR[U[XYZV QSRU SSQU PXQZ QXOZ", "K[NRLXLZN[O[QZSXUU ORMXMZN[ VRPd WRT[R`PdOfMgLfLdMaO_R]V[YY[V", "LYLVNSPRRRTSTVSXPZN[ RRSSSVRXPZ N[P\\Q^QaPdNfLgKfKdLaO^R\\VYYV N[O\\P^PaOdNf", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF OGMJLOLRMWOZ NYQZSZVY UZWWXRXOWJUG VHSGQGNH", "H\\NJPISFS[ NJNKPJRHR[S[", "H\\LKLJMHNGPFTFVGWHXJXLWNUQL[ LKMKMJNHPGTGVHWJWLVNTQK[ LZYZY[ K[Y[", "H\\MFXFQO MFMGWG WFPO QNSNVOXQYTYUXXVZS[P[MZLYKWLW POSOVPXS TOWQXTXUWXTZ XVVYSZPZMYLW OZLX", "H\\UIU[V[ VFV[ VFKVZV UILV LUZUZV", "H\\MFLO NGMN MFWFWG NGWG MNPMSMVNXPYSYUXXVZS[P[MZLYKWLW LOMOONSNVOXR TNWPXSXUWXTZ XVVYSZPZMYLW OZLX", "H\\VGWIXIWGTFRFOGMJLOLTMXOZR[S[VZXXYUYTXQVOSNRNOOMQ WHTGRGOH PGNJMOMTNXQZ MVOYRZSZVYXV TZWXXUXTWQTO XSVPSOROOPMS QONQMT", "H\\KFYFO[ KFKGXG XFN[O[", "H\\PFMGLILKMMNNPOTPVQWRXTXWWYTZPZMYLWLTMRNQPPTOVNWMXKXIWGTFPF NGMIMKNMPNTOVPXRYTYWXYWZT[P[MZLYKWKTLRNPPOTNVMWKWIVG WHTGPGMH LXOZ UZXX", "H\\WPURRSQSNRLPKMKLLINGQFRFUGWIXMXRWWUZR[P[MZLXMXNZ WMVPSR WNUQRRQRNQLN PRMPLMLLMIPG LKNHQGRGUHWK SGVIWMWRVWTZ UYRZPZMY", "MXRXQYQZR[S[TZTYSXRX RYRZSZSYRY", "MXTZS[R[QZQYRXSXTYT\\S^Q_ RYRZSZSYRY S[T\\ TZS^", "MXRMQNQORPSPTOTNSMRM RNROSOSNRN RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "MXRMQNQORPSPTOTNSMRM RNROSOSNRN TZS[R[QZQYRXSXTYT\\S^Q_ RYRZSZSYRY S[T\\ TZS^", "MXRFRTST RFSFST RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "I\\LKLJMHNGQFTFWGXHYJYLXNWOUPRQ LKMKMJNHQGTGWHXJXLWNUORP MIPG UGXI XMTP RPRTSTSP RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "MXTFRGQIQLRMSMTLTKSJRJQK RKRLSLSKRK RGQK QIRJ", "MXTHSIRIQHQGRFSFTGTJSLQM RGRHSHSGRG SITJ THSL", "F_\\MZMXNWPUVTXSYQZMZKYJWJUKSLRQOSMTKTISGQFPFNGMIMKNNPQUWXZZ[\\[ \\M\\NZNWP ZMXPVVUXSZQ[M[KZJYIWIUJSLQQNRMSKSIRG SHQGPGNH OGNINKONQQVWXYZZ\\Z\\[", "I\\RBR_S_ RBSBS_ WIYIWGTFQFNGLILKMMNNVRWSXUXWWYTZQZOYNX WIVHTGQGNHMIMKNMVQXSYUYWXYWZT[Q[NZLXNX XXUZ", "G^[BIbJb [B\\BJb", "KYUBSDQGOKNPNTOYQ]S`UbVb UBVBTDRGPKOPOTPYR]T`Vb", "KYNBPDRGTKUPUTTYR]P`NbOb NBOBQDSGUKVPVTUYS]Q`Ob", "JZRFQGSQRR RFRR RFSGQQRR MINIVOWO MIWO MIMJWNWO WIVINOMO WIMO WIWJMNMO", "F_JQ[Q[R JQJR[R", "F_RIRZSZ RISISZ JQ[Q[R JQJR[R", "F_JM[M[N JMJN[N JU[U[V JUJV[V", "NWSFRGRM SGRM SFTGRM", "I[NFMGMM NGMM NFOGMM WFVGVM WGVM WFXGVM", "KYQFOGNINKOMQNSNUMVKVIUGSFQF QFNIOMSNVKUGQF SFOGNKQNUMVISF", "F^ZIJRZ[ ZIZJLRZZZ[", "F^JIZRJ[ JIJJXRJZJ[", "G^OFObPb OFPFPb UFUbVb UFVFVb JP[P[Q JPJQ[Q JW[W[X JWJX[X", "F^[FYGVHSHPGNFLFJGIIIKKMMMOLPJPHNF [FH[I[ [F\\FI[ YTWTUUTWTYV[X[ZZ[X[VYT NFJGIKMMPJNF LFIIKMOLPHLF YTUUTYX[[XYT WTTWV[ZZ[VWT", "E`WMTKQKOLNMMOMRNTOUQVTVWT WMTLQLOMNONROTQUTUWT VKVSWUYVZV\\U]S]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[U[YZ VKWKWSXUZV YV[U\\S\\O[LZJYIWHTGQGNHLIKJJLIOIRJUKWLXNYQZUZYYYZ", "E_JPLONOPPSTTUVVXVZU[S[QZOXNVNTOSPPTNULUJT ZPXOVOTPQTPUNVLVJUISIQJOLNNNPOQPTTVUXUZT KOJQJSKU YUZSZQYO", "H]TFQGOIMLLOKSKVLYMZO[Q[TZVXXUYRZNZKYHXGVFTF TFRGPINLMOLSLVMYO[ Q[SZUXWUXRYNYKXHVF", "H]TJO[ VFP[ VFSIPKNL UIQKNL", "H]OJPKOLNKNJOHPGSFVFYGZIZKYMWOTQPSMUKWI[ VFXGYIYKXMVOPS JYKXMXRZUZWYXW MXR[U[WZXW", "H]OJPKOLNKNJOHPGSFVFYGZIZKYMVOSP VFXGYIYKXMVO QPSPVQWRXTXWWYVZS[O[LZKYJWJVKULVKW SPUQVRWTWWVYUZS[", "H]XGR[ YFS[ YFJUZU", "H]QFLP QF[F QGVG[F LPMOPNSNVOWPXRXUWXUZR[O[LZKYJWJVKULVKW SNUOVPWRWUVXTZR[", "H]YIXJYKZJZIYGWFTFQGOIMLLOKSKWLYMZO[R[UZWXXVXSWQVPTOQOOPMRLT TFRGPINLMOLSLXMZ R[TZVXWVWRVP", "H]NFLL [FZIXLSRQUPWO[ XLRRPUOWN[ MIPFRFWI NHPGRGWIYIZH[F", "H]SFPGOHNJNMOOQPTPXOYNZLZIYGVFSF SFQGPHOJOMPOQP TPWOXNYLYIXGVF QPMQKSJUJXKZN[R[VZWYXWXTWRVQTP QPNQLSKUKXLZN[ R[UZVYWWWSVQ", "H]YMXOVQTRQROQNPMNMKNIPGSFVFXGYHZJZNYRXUVXTZQ[N[LZKXKWLVMWLX OQNONKOIQGSF XGYIYNXRWUUXSZQ[", "MXPYOZP[QZPY", "MXP[OZPYQZQ[P]N_", "MXSMRNSOTNSM PYOZP[QZ", "MXSMRNSOTNSM P[OZPYQZQ[P]N_", "MXUFTGRS UGRS UFVGRS PYOZP[QZPY", "H]OJPKOLNKNJOHPGSFWFZG[I[KZMYNSPQQQSRTTT WFYGZIZKYMXNVO PYOZP[QZPY", "MXVFTHSJSKTLUKTJ", "MXUHTGUFVGVHUJSL", "E_\\N[O\\P]O]N\\M[MYNWPRXPZN[K[HZGXGVHTISKRPPROTMUKUITGRFPGOIOLPRQUSXUZW[Y[ZYZX K[IZHXHVITJSPP OLPQQTSWUYWZYZZY", "H]TBL_ YBQ_ ZJYKZL[K[JZHYGVFRFOGMIMKNMONVRXT MKOMVQWRXTXWWYVZS[O[LZKYJWJVKULVKW", "G]_BEb", "KZZBVESHQKOONTNXO]P`Qb VESIQMPPOUOZP_Qb", "JYSBTDUGVLVPUUSYQ\\N_Jb SBTEUJUOTTSWQ[N_", "J[TFTR OIYO YIOO", "NWUFSM VFSM", "I[PFNM QFNM YFWM ZFWM", "KZSFQGPIPKQMSNUNWMXKXIWGUFSF", "H]SFLb YFRb LQZQ KWYW", "E_^F\\GXHUHQGOFMFKGJIJKLMNMPLQJQHOF ^FF[ XTVTTUSWSYU[W[YZZXZVXT", "G]LFL[ MFM[ IFYFYLXF MPUPXQYRZTZWYYXZU[I[ UPWQXRYTYWXYWZU[", "F^NFNLMTLXKZJ[ XFX[ YFY[ KF\\F G[\\[ G[Gb H[Gb [[\\b \\[\\b", "CbRFR[ SFS[ OFVF GGHHGIFHFGGFHFIGJIKMLONPWPYOZM[I\\G]F^F_G_H^I]H^G NPLQKSJXIZH[ NPMQLSKXJZI[G[FZEX WPYQZS[X\\Z][ WPXQYSZX[Z\\[^[_Z`X O[V[", "H\\LIKFKLLINGPFTFWGXIXLWNTOQO TFVGWIWLVNTO TOVPXRYTYWXYWZT[O[MZLYKWKVLUMVLW WQXTXWWYVZT[", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F XHLY H[O[ U[\\[", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F XHLY H[O[ U[\\[ N@N?M?M@NBPCTCVBW@", "F^KFK[ LFL[ HFOF LPSPUOVMWIXGYFZF[G[HZIYHZG SPUQVSWXXZY[ SPTQUSVXWZX[Z[[Z\\X H[O[", "E^MFMLLTKXJZI[H[GZGYHXIYHZ XFX[ YFY[ JF\\F U[\\[", "H]KFRV LFSV ZFSVQYPZN[M[LZLYMXNYMZ IFOF VF\\F", "F_RFR[ SFS[ OFVF PILJJLIOIRJULWPXUXYW[U\\R\\O[LYJUIPI PIMJKLJOJRKUMWPX UXXWZU[R[OZLXJUI O[V[", "F^KFK[ LFL[ XFX[ YFY[ HFOF UF\\F H[\\[ [[\\b \\[\\b", "F]KFKQLSOTRTUSWQ LFLQMSOT WFW[ XFX[ HFOF TF[F T[[[", "BcGFG[ HFH[ RFR[ SFS[ ]F][ ^F^[ DFKF OFVF ZFaF D[a[", "BcGFG[ HFH[ RFR[ SFS[ ]F][ ^F^[ DFKF OFVF ZFaF D[a[ `[ab a[ab", "F`PFP[ QFQ[ IFHLHFTF QPXP[Q\\R]T]W\\Y[ZX[M[ XPZQ[R\\T\\W[YZZX[", "CaHFH[ IFI[ EFLF IPPPSQTRUTUWTYSZP[E[ PPRQSRTTTWSYRZP[ [F[[ \\F\\[ XF_F X[_[", "H]MFM[ NFN[ JFQF NPUPXQYRZTZWYYXZU[J[ UPWQXRYTYWXYWZU[", "H]LIKFKLLINGQFSFVGXIYKZNZSYVXXVZS[P[MZLYKWKVLUMVLW SFUGWIXKYNYSXVWXUZS[ PPYP", "CbHFH[ IFI[ EFLF E[L[ VFSGQIPKOOORPVQXSZV[X[[Z]X^V_R_O^K]I[GXFVF VFTGRIQKPOPRQVRXTZV[ X[ZZ\\X]V^R^O]K\\IZGXF IPOP", "G]WFW[ XFX[ [FOFLGKHJJJLKNLOOPWP OFMGLHKJKLLNMOOP RPPQORLYKZJZIY PQOSMZL[J[IYIX T[[[", "H\\XFWGQINKLNKQKULXNZQ[S[VZXXYUYSXPVNSMQMNNLPKS XFWHUIQJNLLN QMONMPLSLUMXOZQ[ S[UZWXXUXSWPUNSM", "H\\MMM[ NMN[ JMUMXNYPYQXSUT UMWNXPXQWSUT NTUTXUYWYXXZU[J[ UTWUXWXXWZU[", "HZMMM[ NMN[ JMXMXRWM J[Q[", "F]NMNQMWLZK[ WMW[ XMX[ KM[M I[H`H[[[[`Z[", "E`RMR[ SMS[ OMVM JNIOHNIMJMKNMRNSPTUTWSXRZN[M\\M]N\\O[N PTNUMVKZJ[ PTNVLZK[I[HZGX UTWUXVZZ[[ UTWVYZZ[\\[]Z^X O[V[", "I[MOLMLQMONNPMTMWNXPXQWSTT TMVNWPWQVSTT QTTTWUXWXXWZT[P[MZLXLWMVNWMX TTVUWWWXVZT[", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M I[P[ T[[[ WNMZ", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M I[P[ T[[[ WNMZ OGOFNFNGOIQJSJUIVG", "H\\MMM[ NMN[ JMQM NTPTSSTRVNWMXMYNXOWN PTSUTVVZW[ PTRUSVUZV[X[YZZX J[Q[", "G]NMNQMWLZK[J[IZJYKZ WMW[ XMX[ KM[M T[[[", "G^LML[ LMR[ MMRY XMR[ XMX[ YMY[ IMMM XM\\M I[O[ U[\\[", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M MTWT I[P[ T[[[", "G]LML[ MMM[ WMW[ XMX[ IM[M I[P[ T[[[", "I\\RMR[ SMS[ MMLRLMYMYRXM O[V[", "I[LMR[ MMRY XMR[P_NaLbKbJaK`La JMPM TMZM", "H]RFRb SFSb OFSF RPQNPMNMLNKQKWLZN[P[QZRX NMMNLQLWMZN[ WMXNYQYWXZW[ SPTNUMWMYNZQZWYZW[U[TZSX ObVb", "G]LML[ MMM[ WMW[ XMX[ IMPM TM[M I[[[[`Z[", "G]LMLTMVPWRWUVWT MMMTNVPW WMW[ XMX[ IMPM TM[M T[[[", "CbHMH[ IMI[ RMR[ SMS[ \\M\\[ ]M][ EMLM OMVM YM`M E[`[", "CbHMH[ IMI[ RMR[ SMS[ \\M\\[ ]M][ EMLM OMVM YM`M E[`[``_[", "H]QMQ[ RMR[ LMKRKMUM RTVTYUZWZXYZV[N[ VTXUYWYXXZV[", "E_JMJ[ KMK[ GMNM KTOTRUSWSXRZO[G[ OTQURWRXQZO[ YMY[ ZMZ[ VM]M V[][", "J[OMO[ PMP[ LMSM PTTTWUXWXXWZT[L[ TTVUWWWXVZT[", "I\\MOLMLQMONNPMSMVNXPYSYUXXVZS[P[NZLXLWMVNWMX SMUNWPXSXUWXUZS[ RTXT", "DaIMI[ JMJ[ FMMM F[M[ VMSNQPPSPUQXSZV[X[[Z]X^U^S]P[NXMVM VMTNRPQSQURXTZV[ X[ZZ\\X]U]S\\PZNXM JTPT", "G\\VMV[ WMW[ ZMOMLNKPKQLSOTVT OMMNLPLQMSOT TTQUPVNZM[ TTRUQVOZN[L[KZJX S[Z[", "H\\RFKZ QIW[ RIX[ RFY[ MUVU I[O[ T[[[ KZJ[ KZM[ WZU[ WYV[ XYZ[", "G]LFL[ MGMZ NFN[ IFUFXGYHZJZLYNXOUP XHYJYLXN UFWGXIXMWOUP NPUPXQYRZTZWYYXZU[I[ XRYTYWXY UPWQXSXXWZU[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "G\\XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXXYV MILKKNKSLVMX QFOGMJLNLSMWOZQ[", "G]LFL[ MGMZ NFN[ IFSFVGXIYKZNZSYVXXVZS[I[ WIXKYNYSXVWX SFUGWJXNXSWWUZS[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "G\\LFL[ MGMZ NFN[ IFYFYL NPTP TLTT I[Y[YU JFLG KFLH OFNH PFNG TFYG VFYH WFYI XFYL TLSPTT TNRPTR TOPPTQ LZJ[ LYK[ NYO[ NZP[ T[YZ V[YY W[YX X[YU", "G[LFL[ MGMZ NFN[ IFYFYL NPTP TLTT I[Q[ JFLG KFLH OFNH PFNG TFYG VFYH WFYI XFYL TLSPTT TNRPTR TOPPTQ LZJ[ LYK[ NYO[ NZP[", "G^XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXZY[YS MILKKNKSLVMX QFOGMJLNLSMWOZQ[ XTXY WSWYVZ TS\\S USWT VSWU ZSYU [SYT", "F^KFK[ LGLZ MFM[ WFW[ XGXZ YFY[ HFPF TF\\F MPWP H[P[ T[\\[ IFKG JFKH NFMH OFMG UFWG VFWH ZFYH [FYG KZI[ KYJ[ MYN[ MZO[ WZU[ WYV[ YYZ[ YZ[[", "LXQFQ[ RGRZ SFS[ NFVF N[V[ OFQG PFQH TFSH UFSG QZO[ QYP[ SYT[ SZU[", "JZSFSWRZQ[ TGTWSZ UFUWTZQ[O[MZLXLVMUNUOVOWNXMX MVMWNWNVMV PFXF QFSG RFSH VFUH WFUG", "F\\KFK[ LGLZ MFM[ XGMR PPW[ QPX[ QNY[ HFPF UF[F H[P[ T[[[ IFKG JFKH NFMH OFMG WFXG ZFXG KZI[ KYJ[ MYN[ MZO[ WYU[ WYZ[", "I[NFN[ OGOZ PFP[ KFSF K[Z[ZU LFNG MFNH QFPH RFPG NZL[ NYM[ PYQ[ PZR[ U[ZZ W[ZY X[ZX Y[ZU", "E_JFJZ JFQ[ KFQX LFRX XFQ[ XFX[ YGYZ ZFZ[ GFLF XF]F G[M[ U[][ HFJG [FZH \\FZG JZH[ JZL[ XZV[ XYW[ ZY[[ ZZ\\[", "F^KFKZ KFY[ LFXX MFYX YGY[ HFMF VF\\F H[N[ IFKG WFYG [FYG KZI[ KZM[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF MILKKNKSLVMX WXXVYSYNXKWI QFOGMJLNLSMWOZQ[ S[UZWWXSXNWJUGSF", "G]LFL[ MGMZ NFN[ IFUFXGYHZJZMYOXPUQNQ XHYJYMXO UFWGXIXNWPUQ I[Q[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF MILKKNKSLVMX WXXVYSYNXKWI QFOGMJLNLSMWOZQ[ S[UZWWXSXNWJUGSF NXOVQURUTVUXV^W`Y`Z^Z\\ V\\W^X_Y_ UXW]X^Y^Z]", "G]LFL[ MGMZ NFN[ IFUFXGYHZJZLYNXOUPNP XHYJYLXN UFWGXIXMWOUP RPTQUSWYX[Z[[Y[W WWXYYZZZ TQURXXYYZY[X I[Q[ JFLG KFLH OFNH PFNG LZJ[ LYK[ NYO[ NZP[", "H\\XIYFYLXIVGSFPFMGKIKLLNOPURWSXUXXWZ LLMNOOUQWRXT MGLILKMMONUPXRYTYWXYWZT[Q[NZLXKUK[LX", "H\\JFJL QFQ[ RGRZ SFS[ ZFZL JFZF N[V[ KFJL LFJI MFJH OFJG UFZG WFZH XFZI YFZL QZO[ QYP[ SYT[ SZU[", "F^KFKULXNZQ[S[VZXXYUYG LGLVMX MFMVNYOZQ[ HFPF VF\\F IFKG JFKH NFMH OFMG WFYG [FYG", "H\\KFR[ LFRXR[ MFSX YGR[ IFPF UF[F JFLH NFMH OFMG WFYG ZFYG", "F^JFN[ KFNVN[ LFOV RFOVN[ RFV[ SFVVV[ TFWV ZGWVV[ GFOF RFTF WF]F HFKG IFKH MFLH NFLG XFZG \\FZG", "H\\KFW[ LFX[ MFY[ XGLZ IFPF UF[F I[O[ T[[[ JFMH NFMH OFMG VFXG ZFXG LZJ[ LZN[ WZU[ WYV[ WYZ[", "G]JFQQQ[ KFRQRZ LFSQS[ YGSQ HFOF VF\\F N[V[ IFKG NFLG WFYG [FYG QZO[ QYP[ SYT[ SZU[", "H\\YFKFKL WFK[ XFL[ YFM[ K[Y[YU LFKL MFKI NFKH PFKG T[YZ V[YY W[YX X[YU", "I[NFN[ OGOZ PFP[ KFZFZL K[S[ LFNG MFNH QFPH RFPG UFZG WFZH XFZI YFZL NYM[ NZL[ PYQ[ PZR[", "H\\RFJ[ QIX[ RIY[ RFZ[ KYXY KZXZ J[Z[", "G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF MILKKNKSLVMX WXXVYSYNXKWI QFOGMJLNLSMWOZQ[ S[UZWWXSXNWJUGSF OMOT UMUT OPUP OQUQ ONPP OOQP UNTP UOSP PQOS QQOR SQUR TQUS", "H\\RFKZ QIW[ RIX[ RFY[ I[O[ T[[[ KZJ[ KZM[ WZU[ WYV[ XYZ[", "G]JEJL ZEZL OMOT UMUT JUJ\\ ZUZ\\ JGZG JHZH JIZI OPUP OQUQ JXZX JYZY JZZZ JFMH ZFWH KIJK LIJJ XIZJ YIZK ONPP OOQP UNTP UOSP PQOS QQOR SQUR TQUS JVKX JWLX ZWXX ZVYX MYJ[ WYZ[", "F^KFK[ LGLZ MFM[ WFW[ XGXZ YFY[ HF\\F H[P[ T[\\[ IFKG JFKH NFMH OFMG UFWG VFWH ZFYH [FYG KZI[ KYJ[ MYN[ MZO[ WZU[ WYV[ YYZ[ YZ[[", "G]IFPPQQ JFQP KFRPI[ IFYFZLYIWF VFYH TFYG KYYY JZYZ I[Y[ZUYXWY", "H\\JMKILGMFOFPGQIRM LHMGOGPH JMKJMHOHPIQMQ[ RMR[ ZMYJWHUHTISMS[ XHWGUGTH ZMYIXGWFUFTGSIRM N[V[ QYP[ QZO[ SZU[ SYT[", "G]QFQ[ RGRZ SFS[ NFVF N[V[ OFQG PFQH TFSH UFSG QZO[ QYP[ SYT[ SZU[ OKLLKMJOJRKTLUOVUVXUYTZRZOYMXLUKOK LMKOKRLT XTYRYOXM OKMLLOLRMUOV UVWUXRXOWLUK", "F^QFQ[ RGRZ SFS[ NFVF N[V[ OFQG PFQH TFSH UFSG QZO[ QYP[ SYT[ SZU[ HMIMJNKQLSMTPUTUWTXSYQZN[M\\M LRKNJLILKN HMIKJKKLLPMSNTPU YN[LZLYNXR TUVTWSXPYLZK[K\\M", "G]NYKYJWK[O[MVKRJOJLKIMGPFTFWGYIZLZOYRWVU[Y[ZWYYVY LSKOKLLI XIYLYOXS O[MULPLKMHNGPF TFVGWHXKXPWUU[ KZNZ VZYZ", "H\\UFIZ SJT[ THUZ UFUHVYV[ LUTU F[L[ Q[X[ IZG[ IZK[ TZR[ TYS[ VYW[", "F^OFI[ PFJ[ QFK[ LFWFZG[I[KZNYOVP YGZIZKYNXO WFXGYIYKXNVP NPVPXQYSYUXXVZR[F[ WQXSXUWXUZ VPWRWUVXTZR[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV QHOJNLMOLSLWMY TFRGPJOLNOMSMXNZP[", "F]OFI[ PFJ[ QFK[ LFUFXGYHZKZOYSWWUYSZO[F[ WGXHYKYOXSVWTY UFWHXKXOWSUWRZO[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "F]OFI[ PFJ[ QFK[ ULST LF[FZL NPTP F[U[WV MFPG NFOH RFPH SFPG WFZG XFZH YFZI ZFZL ULSPST TNRPSR TOQPSQ JZG[ JYH[ KYL[ JZM[ P[UZ R[UY UYWV", "F\\OFI[ PFJ[ QFK[ ULST LF[FZL NPTP F[N[ MFPG NFOH RFPH SFPG WFZG XFZH YFZI ZFZL ULSPST TNRPSR TOQPSQ JZG[ JYH[ KYL[ JZM[", "H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT QHOJNLMOLSLWMY VXWWXT TFRGPJOLNOMSMXNZP[ R[TZVWWT TT\\T UTWU VTWW ZTXV [TXU", "E_NFH[ OFI[ PFJ[ ZFT[ [FU[ \\FV[ KFSF WF_F LPXP E[M[ Q[Y[ LFOG MFNH QFOH RFOG XF[G YFZH ]F[H ^F[G IZF[ IYG[ JYK[ IZL[ UZR[ UYS[ VYW[ UZX[", "KYTFN[ UFO[ VFP[ QFYF K[S[ RFUG SFTH WFUH XFUG OZL[ OYM[ PYQ[ OZR[", "I\\WFRWQYO[ XFTSSVRX YFUSSXQZO[M[KZJXJVKULUMVMWLXKX KVKWLWLVKV TF\\F UFXG VFWH ZFXH [FXG", "F]OFI[ PFJ[ QFK[ \\GMR QOU[ ROV[ SNWZ LFTF YF_F F[N[ R[Y[ MFPG NFOH RFPH SFPG ZF\\G ^F\\G JZG[ JYH[ KYL[ JZM[ UZS[ UYT[ VYX[", "H\\QFK[ RFL[ SFM[ NFVF H[W[YU OFRG PFQH TFRH UFRG LZI[ LYJ[ MYN[ LZO[ R[WZ T[XX V[YU", "D`MFGZ MGNYN[ NFOY OFPX [FPXN[ [FU[ \\FV[ ]FW[ JFOF [F`F D[J[ R[Z[ KFMG LFMH ^F\\H _F\\G GZE[ GZI[ VZS[ VYT[ WYX[ VZY[", "F_OFIZ OFV[ PFVX QFWX \\GWXV[ LFQF YF_F F[L[ MFPG NFPH ZF\\G ^F\\G IZG[ IZK[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF OIMLLOKSKWLY UXWUXRYNYJXH SFQGOJNLMOLSLXMZN[ Q[SZUWVUWRXNXIWGVF", "F]OFI[ PFJ[ QFK[ LFXF[G\\I\\K[NYPUQMQ ZG[I[KZNXP XFYGZIZKYNWPUQ F[N[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF OIMLLOKSKWLY UXWUXRYNYJXH SFQGOJNLMOLSLXMZN[ Q[SZUWVUWRXNXIWGVF LXMVOUPURVSXT]U^V^W] T^U_V_ SXS_T`V`W]W\\", "F^OFI[ PFJ[ QFK[ LFWFZG[I[KZNYOVPNP YGZIZKYNXO WFXGYIYKXNVP RPTQURWXXYYYZX WYXZYZ URVZW[Y[ZXZW F[N[ MFPG NFOH RFPH SFPG JZG[ JYH[ KYL[ JZM[", "G^ZH[H\\F[L[JZHYGVFRFOGMIMLNNPPVSWUWXVZ NLONVRWT OGNINKOMUPWRXTXWWYVZS[O[LZKYJWJUI[JYKY", "G]TFN[ UFO[ VFP[ MFKL ]F\\L MF]F K[S[ NFKL PFLI RFMG YF\\G ZF\\H [F\\I \\F\\L OZL[ OYM[ PYQ[ OZR[", "F_NFKQJUJXKZN[R[UZWXXU\\G OFLQKUKYLZ PFMQLULYN[ KFSF YF_F LFOG MFNH QFOH RFOG ZF\\G ^F\\G", "H\\NFNHOYO[ OGPX PFQW [GO[ LFSF XF^F MFNH QFPH RFOG YF[G ]F[G", "E_MFMHKYK[ NGLX OFMW UFMWK[ UFUHSYS[ VGTX WFUW ]GUWS[ JFRF UFWF ZF`F KFNG LFMH PFNI QFNG [F]G _F]G", "G]NFT[ OFU[ PFV[ [GIZ LFSF XF^F F[L[ Q[X[ MFOH QFPH RFPG YF[G ]F[G IZG[ IZK[ TZR[ TYS[ UYW[", "G]MFQPN[ NFRPO[ OFSPP[ \\GSP KFRF YF_F K[S[ LFNG PFOH QFNG ZF\\G ^F\\G OZL[ OYM[ PYQ[ OZR[", "G]ZFH[ [FI[ \\FJ[ \\FNFLL H[V[XU OFLL PFMI RFNG R[VZ T[WX U[XU", "H\\JFR[ KFRX LFSX JFZFR[ LGYG LHYH", "I]NPNOOOOQMQMONNPMTMVNWOXQXXYZZ[ VOWQWXXZ TMUNVPVXWZZ[[[ VRUSPTMULWLXMZP[S[UZVX NUMWMXNZ USQTOUNWNXOZP[", "G\\LFL[MZOZ MGMY IFNFNZ NPONQMSMVNXPYSYUXXVZS[Q[OZNX WPXRXVWX SMUNVOWRWVVYUZS[ JFLG KFLH", "H[WQWPVPVRXRXPVNTMQMNNLPKSKULXNZQ[S[VZXX MPLRLVMX QMONNOMRMVNYOZQ[", "H]VFV[[[ WGWZ SFXFX[ VPUNSMQMNNLPKSKULXNZQ[S[UZVX MPLRLVMX QMONNOMRMVNYOZQ[ TFVG UFVH XYY[ XZZ[", "H[MSXSXQWOVNSMQMNNLPKSKULXNZQ[S[VZXX WRWQVO MPLRLVMX VSVPUNSM QMONNOMRMVNYOZQ[", "KYWHWGVGVIXIXGWFTFRGQHPKP[ RHQKQZ TFSGRIR[ MMVM M[U[ PZN[ PYO[ RYS[ RZT[", "I\\XNYOZNYMXMVNUO QMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM OONQNSOU UUVSVQUO QMPNOPOTPVQW SWTVUTUPTNSM NUMVLXLYM[N\\Q]U]X^Y_ N[Q\\U\\X] LYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[ ObMaL_L^M\\O[", "G^LFL[ MGMZ IFNFN[ NQOOPNRMUMWNXOYRY[ WOXRXZ UMVNWQW[ I[Q[ T[\\[ JFLG KFLH LZJ[ LYK[ NYO[ NZP[ WZU[ WYV[ YYZ[ YZ[[", "LXQFQHSHSFQF RFRH QGSG QMQ[ RNRZ NMSMS[ N[V[ OMQN PMQO QZO[ QYP[ SYT[ SZU[", "KXRFRHTHTFRF SFSH RGTG RMR^QaPb SNS]R` OMTMT]S`RaPbMbLaL_N_NaMaM` PMRN QMRO", "G]LFL[ MGMZ IFNFN[ WNNW RSY[ RTX[ QTW[ TM[M I[Q[ T[[[ JFLG KFLH UMWN ZMWN LZJ[ LYK[ NYO[ NZP[ WYU[ VYZ[", "LXQFQ[ RGRZ NFSFS[ N[V[ OFQG PFQH QZO[ QYP[ SYT[ SZU[", "AcFMF[ GNGZ CMHMH[ HQIOJNLMOMQNROSRS[ QORRRZ OMPNQQQ[ SQTOUNWMZM\\N]O^R^[ \\O]R]Z ZM[N\\Q\\[ C[K[ N[V[ Y[a[ DMFN EMFO FZD[ FYE[ HYI[ HZJ[ QZO[ QYP[ SYT[ SZU[ \\ZZ[ \\Y[[ ^Y_[ ^Z`[", "G^LML[ MNMZ IMNMN[ NQOOPNRMUMWNXOYRY[ WOXRXZ UMVNWQW[ I[Q[ T[\\[ JMLN KMLO LZJ[ LYK[ NYO[ NZP[ WZU[ WYV[ YYZ[ YZ[[", "H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM MPLRLVMX WXXVXRWP QMONNOMRMVNYOZQ[ S[UZVYWVWRVOUNSM", "G\\LMLb MNMa IMNMNb NPONQMSMVNXPYSYUXXVZS[Q[OZNX WPXRXVWX SMUNVOWRWVVYUZS[ IbQb JMLN KMLO LaJb L`Kb N`Ob NaPb", "H\\VNVb WOWa UNWNXMXb VPUNSMQMNNLPKSKULXNZQ[S[UZVX MPLRLVMX QMONNOMRMVNYOZQ[ Sb[b VaTb V`Ub X`Yb XaZb", "IZNMN[ ONOZ KMPMP[ WOWNVNVPXPXNWMUMSNQPPS K[S[ LMNN MMNO NZL[ NYM[ PYQ[ PZR[", "J[WOXMXQWOVNTMPMNNMOMQNSPTUUWVXY NNMQ NRPSUTWU XVWZ MONQPRUSWTXVXYWZU[Q[OZNYMWM[NY", "KZPHPVQYRZT[V[XZYX QHQWRY PHRFRWSZT[ MMVM", "G^LMLVMYNZP[S[UZVYWW MNMWNY IMNMNWOZP[ WMW[\\[ XNXZ TMYMY[ JMLN KMLO YYZ[ YZ[[", "I[LMR[ MMRY NMSY XNSYR[ JMQM TMZM KMNO PMNN VMXN YMXN", "F^JMN[ KMNX LMOX RMOXN[ RMV[ SMVX RMTMWX ZNWXV[ GMOM WM]M HMKN NMLN XMZN \\MZN", "H\\LMV[ MMW[ NMX[ WNMZ JMQM TMZM J[P[ S[Z[ KMMN PMNN UMWN YMWN MZK[ MZO[ VZT[ WZY[", "H[LMR[ MMRY NMSY XNSYP_NaLbJbIaI_K_KaJaJ` JMQM TMZM KMNO PMNN VMXN YMXN", "I[VML[ WMM[ XMN[ XMLMLQ L[X[XW MMLQ NMLP OMLO QMLN S[XZ U[XY V[XX W[XW", "G^[MZQYTWXUZR[P[MZKXJUJSKPMNPMRMUNVOWQYXZZ[[\\[ ZMYQXTWVUYTZR[ LXKVKRLP P[NZMYLVLRMONNPM RMTNUOVQXXYZ[[", "G\\QFNGMHLJKNKb NHMJLNLa QFOGNIMNMb QFSFVGWHXJXLWNVOSP PPTPWQXRYTYWXYWZT[Q[OZNYMW VHWJWLVN WRXTXWWY SFUGVIVMUOSP TPVQWSWXVZT[ KbMb", "F\\HRINKMMMONPOQRRYSb IOKNMNOOPP HRIPKOMOOPPQQTRYRa XMWPVRTUSWR[Qb YMWQ ZMYOWRTVSXR[ XMZM QbSb", "H\\SMQMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMPLNKMJMHNGPFSFWH MPLSLUMX WXXUXSWP QMONNOMRMVNYOZQ[ S[UZVYWVWRVOUNOKNJNIOHQGTGWH", "I[SMUNVOWOVNSMQMMNLOLQMRQS SSQSMTKVKXMZP[S[VZXXWXVZ NNMOMQNR MULVLXMY QMONNONQORQS QSNTMVMXNZP[", "I[QHRGRFQFPGPIQJTKXKYKYJXJUKSLPNNPMRLULWMYNZP[S\\U]V_VaUbSbRaR`S`Sa POOPNRMUMWNYOZ UKRMQNOQNTNWOYQ[S\\", "G]JMKNLPL[ KMLNMPMZ HPINJMLMMNNPN[ UMVNWQWb WOXRXa NQOOPNRMUMWNXOYRYb L[N[ WbYb", "F]IMJNKPKTLWMYNZQ[S[VZWYXWYRYOXJVGTFRFPGOIOKPMSOVP[Q JMKNLPLTMWNY VYWWXRXOWJVHTG GPHNIMKMLNMPMTNXOZQ[ S[UZVXWSWNVJUHSGQGOI", "KZNMONPPPXQZS[U[WZXX OMPNQPQXRZ LPMNNMPMQNRPRXSZT[", "G]JMKNLPL[ KMLNMPMZ HPINJMLMMNNPN[ SOUNWNXOXPZPZNXMVMTNQQOTNW XNYOYP PSQSWYYYZX TWWZYZ RTUZV[X[YZZX L[N[", "H\\JGKFMFOGQIXXYZZ[ OHPIWXXY MFNGOIVXXZZ[[[ RMJZJ[K[RM", "G]KMKb LNLa MMMb VMVXWZX[Z[[Z\\X WNWXXZY[ XMXXYZZ[ MXNZP[R[TZUYVW KMMM VMXM KbMb", "G]JMKNLPMTN[ KMLNMPNTOZ HPINJMLMMNNPOTPZ VVWTXQXMYMZNYQXSVVTXQZN[ XRYOYM", "JZPGSFRFPGOHOIPJSKVLWKVJSKPLNMMOMQNRPSSTVUWTVSSTOUMVLXLZM[O\\S]U^V_VaTbRbOaPaRb OMNONQOR NVMXMZN[ VKSKQLPMOOOQQSST VTSTPUOVNXNZP\\S]", "G]IQJOKNMM[M KOMNZN IQJPLO[O OONZM[LZMWOO UOVZW[XZWWUO [M[O OOMZ UOWZ", "G\\QMNNLPKTKb MPLTLa QMONNOMSMb MWNYOZQ[S[VZXXYUYSXPVNSMQM WXXVXRWP S[UZVYWVWRVOUNSM KbMb", "G]PMMNKPJSJUKXMZP[R[UZWXXUXSWPUNRM LPKRKVLX VXWVWRVP PMNNMOLRLVMYNZP[ R[TZUYVVVRUOTNRM RMZO[N[MPM RMZN", "H\\JQKOLNNMZM LONNYN JQKPMOZO ROQZR[SZRO ZMZO RORZ", "G\\JMKNLPLUMXOZQ[S[UZWXXVYRYNXMWMXPXSWWUZ KMLNMPMUNX WMXNXO HPINJMLMMNNPNVOYQ[", "G]RQQNPMNMLNKOJRJUKXMZP[T[WZYXZUZRYOXNVMTMSNRQ LOKRKULX XXYUYRXO NMMNLQLVMYNZP[ T[VZWYXVXQWNVM RQQb RQRa RQSb QbSb", "H\\LMMNNPT_VaXbZb[a NOOPU_V` INJMLMNNPPV_WaXb VSXPYMZMYOVSN\\K`JbKbL_N\\", "F]HNINJPJUKXMZP[T[VZXXYVZRZNYMXMYPYSXWVZ JNKPKULX XMYNYO GPHNIMJMKNLPLVMYNZP[ QFSb RGRa SFQb QFSF QbSb", "F^NMLNJPISIWJYKZM[O[QZRYSWSTRSQTQWRYSZU[W[YZZY[W[SZPXNVM KPJSJWKY RTRX YYZWZSYP NMLOKRKWLZM[ W[XZYWYRXOVM", "G]WMUTUXVZW[Y[[Y\\W XMVTVZ WMYMWTVX UTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT NNLQKTKWLY PMNOMQLTLWMZN[", "I\\PFNMMSMWNYOZQ[S[VZXWYTYRXOWNUMSMQNPOOQNT QFOMNQNWOZ VYWWXTXQWO MFRFPMNT S[UYVWWTWQVNUM NFQG OFPH", "I[WQWPVPVRXRXPWNUMRMONMQLTLVMYNZP[R[UZWW OONQMTMWNY RMPOOQNTNWOZP[", "G]YFVQUUUXVZW[Y[[Y\\W ZFWQVUVZ VF[FWTVX UTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT MOLQKTKWLY PMNOMQLTLWMZN[ WFZG XFYH", "I[MVQUTTWRXPWNUMRMONMQLTLVMYNZP[R[UZWX OONQMTMWNY RMPOOQNTNWOZP[", "JZZHZGYGYI[I[GZFXFVGTISKRNQRO[N^M`Kb TJSMRRP[O^ XFVHUJTMSRQZP]O_MaKbIbHaH_J_JaIaI` NMYM", "H]XMT[S^QaOb YMU[S_ XMZMV[T_RaObLbJaI`I^K^K`J`J_ VTVQUNSMQMNNLQKTKVLYMZO[Q[SZTYUWVT NOMQLTLWMY QMOONQMTMWNZO[", "G]OFI[K[ PFJ[ LFQFK[ MTOPQNSMUMWNXPXSVX WNWRVVVZ WPUUUXVZW[Y[[Y\\W MFPG NFOH", "KXTFTHVHVFTF UFUH TGVG LQMOOMQMRNSPSSQX RNRRQVQZ RPPUPXQZR[T[VYWW", "KXUFUHWHWFUF VFVH UGWG MQNOPMRMSNTPTSRZQ]P_NaLbJbIaI_K_KaJaJ` SNSSQZP]O_ SPRTP[O^N`Lb", "G]OFI[K[ PFJ[ LFQFK[ YOYNXNXPZPZNYMWMUNQROS MSOSQTRUTYUZWZ QUSYTZ OSPTRZS[U[WZYW MFPG NFOH", "LXTFQQPUPXQZR[T[VYWW UFRQQUQZ QFVFRTQX RFUG SFTH", "@cAQBODMFMGNHPHSF[ GNGSE[ GPFTD[F[ HSJPLNNMPMRNSPSSQ[ RNRSP[ RPQTO[Q[ SSUPWNYM[M]N^P^S\\X ]N]R\\V\\Z ]P[U[X\\Z][_[aYbW", "F^GQHOJMLMMNNPNSL[ MNMSK[ MPLTJ[L[ NSPPRNTMVMXNYPYSWX XNXRWVWZ XPVUVXWZX[Z[\\Y]W", "H\\QMNNLQKTKVLYMZP[S[VZXWYTYRXOWNTMQM NOMQLTLWMY VYWWXTXQWO QMOONQMTMWNZP[ S[UYVWWTWQVNTM", "G]HQIOKMMMNNOPOSNWKb NNNSMWJb NPMTIb OTPQQORNTMVMXNYOZRZTYWWZT[R[PZOWOT XOYQYTXWWY VMWNXQXTWWVYT[ FbNb JaGb J`Hb K`Lb JaMb", "G\\WMQb XMRb WMYMSb UTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT MOLQKTKWLY PMNOMQLTLWMZN[ NbVb RaOb R`Pb S`Tb RaUb", "I[JQKOMMOMPNQPQTO[ PNPTN[ PPOTM[O[ YOYNXNXPZPZNYMWMUNSPQT", "J[XPXOWOWQYQYOXNUMRMONNONQOSQTTUVVWX ONNQ ORQSTTVU WVVZ NOOQQRTSVTWVWXVZS[P[MZLYLWNWNYMYMX", "KYTFQQPUPXQZR[T[VYWW UFRQQUQZ TFVFRTQX NMXM", "F^GQHOJMLMMNNPNSLX MNMRLVLZ MPKUKXLZN[P[RZTXVU XMVUVXWZX[Z[\\Y]W YMWUWZ XMZMXTWX", "H\\IQJOLMNMONPPPSNX ONORNVNZ OPMUMXNZP[R[TZVXXUYQYMXMXNYP", "CaDQEOGMIMJNKPKSIX JNJRIVIZ JPHUHXIZK[M[OZQXRU TMRURXSZU[W[YZ[X]U^Q^M]M]N^P UMSUSZ TMVMTTSX", "G]JQLNNMPMRNSPSR PMQNQRPVOXMZK[I[HZHXJXJZIZIY RORRQVQY ZOZNYNYP[P[NZMXMVNTPSRRVRZS[ PVPXQZS[U[WZYW", "G]HQIOKMMMNNOPOSMX NNNRMVMZ NPLULXMZO[Q[SZUXWT YMU[T^RaPb ZMV[T_ YM[MW[U_SaPbMbKaJ`J^L^L`K`K_", "H\\YMXOVQNWLYK[ XOOOMPLR VORNONNO VORMOMMOLR LYUYWXXV NYRZUZVY NYR[U[WYXV", "H\\WQVOUNSMQMNNLPKSKULXNZQ[S[VZWYXWYSYNXJWHVGSFQFNGMHNHOGQF MPLRLVMX VYWWXSXNWJVH QMONNOMRMVNYOZQ[ S[UZVXWTWMVIUGSF", "I[UMWNXOYOXNUMRMONMPLSLUMXOZR[U[XZYYXYWZU[ NPMSMUNX RMPNOONRNVOYPZR[ NTTUUTTSNT NTTT", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF NHMJLNLSMWNY VYWWXSXNWJVH QFOGNIMNMSNXOZQ[ S[UZVXWSWNVIUGSF LPXQ LQXP", "G]PMMNKPJSJUKXMZP[T[WZYXZUZSYPWNTMPM LPKSKULX XXYUYSXP PMNNMOLRLVMYNZP[T[VZWYXVXRWOVNTM QFSb RGRa SFQb QFSF QbSb", "H\\TMVNXPYPYOWNTMPMMNLOKQKSLUNWPXRYSZT\\T^S_Q_O^P^Q_ MOLQLSMUOW PMNNMPMSNURY YPXO", "H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF NHMJLNLSMWNY VYWWXSXNWJVH QFOGNIMNMSNXOZQ[ S[UZVXWSWNVIUGSF", "H\\QHQ[ RHRZ SFS[ SFPINJ M[W[ QZO[ QYP[ SYT[ SZU[", "H\\LJLKMKMJLJ LIMINJNKMLLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ WHXJXLWN TFVGWJWLVNTPPR KYLXNXSYWYYX NXSZWZXY NXS[W[XZYXYV", "H\\LJLKMKMJLJ LIMINJNKMLLLKKKJLHMGPFTFWGXIXLWNTO VGWIWLVN SFUGVIVLUNSO QOTOVPXRYTYWXYWZT[P[MZLYKWKVLUMUNVNWMXLX WRXTXWWY SOUPVQWTWWVZT[ LVLWMWMVLV", "H\\SIS[ THTZ UFU[ UFJUZU P[X[ SZQ[ SYR[ UYV[ UZW[", "H\\MFKPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMUNVNWMXLX WPXRXVWX SMUNVOWRWVVYUZS[ LVLWMWMVLV MFWF MGUG MHQHUGWF", "H\\VIVJWJWIVI WHVHUIUJVKWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNQNOONPMR NIMKLOLUMXNY WXXVXSWQ RFPGOHNJMNMUNXOZQ[ S[UZVYWVWSVPUOSN", "H\\KFKL YFYIXLTQSSRWR[ SRRTQWQ[ XLSQQTPWP[R[ KJLHNFPFUIWIXHYF MHNGPGRH KJLINHPHUI", "H\\PFMGLILLMNPOTOWNXLXIWGTFPF NGMIMLNN VNWLWIVG PFOGNINLONPO TOUNVLVIUGTF POMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO MQLSLWMY WYXWXSWQ PONPMSMWNZP[ T[VZWWWSVPTO", "H\\MWMXNXNWMW WOVQURSSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNVOWOXNYMY MPLNLKMI VHWIXLXRWVVX QSORNQMNMKNHOGQF SFUGVIWLWSVWUYTZR[", "MXRFQGQIRQ RFRTST RFSFST SFTGTISQ RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "I\\MKMJNJNLLLLJMHNGPFTFWGXHYJYLXNWOSQ WHXIXMWN TFVGWIWMVOUP RQRTSTSQRQ RXQYQZR[S[TZTYSXRX RYRZSZSYRY", "E_[O[NZNZP\\P\\N[MZMYNXPVUTXRZP[L[JZIXIUJSPORMSKSIRGPFNGMIMLNOPRTWWZY[[[\\Y\\X KZJXJUKSLR RMSI SKRG NGMK NNPQTVWYYZ N[LZKXKULSPO MINMQQUVXYZZ[Z\\Y", "H\\PBP_ TBT_ XKXJWJWLYLYJXHWGTFPFMGKIKLLNOPURWSXUXXWZ LLMNOOUQWRXT MGLILKMMONUPXRYTYWXYWZT[P[MZLYKWKUMUMWLWLV", "KYUBSDQGOKNPNTOYQ]S`Ub QHPKOOOUPYQ\\ SDRFQIPOPUQ[R^S`", "KYOBQDSGUKVPVTUYS]Q`Ob SHTKUOUUTYS\\ QDRFSITOTUS[R^Q`", "F^[FYGVHSHPGNFLFJGIIIKKMMMOLPJPHNF [FH[ [FI[ [FJ[ YTWTUUTWTYV[X[ZZ[X[VYT OGLFIIJLMMPJOG NFJGIK KMOLPH ZUWTTWUZX[[XZU YTUUTY V[ZZ[V H[J[", "E`VNULSKQKOLNMMOMRNTOUQVSVUUVS OMNONROT QKPLOOORPUQV VKVSWUYVZV\\U]R]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYXYWZ WLWSXU VKXKXSYUZV", "H]TFQGOIMLLOKSKVLYMZO[Q[TZVXXUYRZNZKYHXGVFTF QHOJNLMOLSLWMY TYVWWUXRYNYJXH TFRGPJOLNOMSMXNZO[ Q[SZUWVUWRXNXIWGVF", "H]TJO[Q[ WFUJP[ WFQ[ WFTIQKOL TJRKOL", "H]OKOJPJPLNLNJOHPGSFVFYGZIZKYMWOMUKWI[ XGYIYKXMVOSQ VFWGXIXKWMUOMU JYKXMXRYWYXX MXRZWZ MXR[U[WZXXXW", "H]OKOJPJPLNLNJOHPGSFVFYGZIZKYMXNVOSP XGYIYKXMWN VFWGXIXKWMUOSP QPSPVQWRXTXWWYUZR[O[LZKYJWJULULWKWKV VRWTWWVY SPUQVSVWUYTZR[", "H]WJR[T[ ZFXJS[ ZFT[ ZFJUZU", "H]QFLP QF[F QGYG PHUHYG[F LPMOPNSNVOWPXRXUWXUZQ[N[LZKYJWJULULWKWKV VPWRWUVXTZ SNUOVQVUUXSZQ[", "H]YJYIXIXKZKZIYGWFTFQGOIMLLOKSKVLYMZO[R[UZWXXVXSWQVPTOQOOPNQMS PINLMOLSLWMY VXWVWSVQ TFRGPJOLNOMSMXNZO[ R[TZUYVVVRUPTO", "H]NFLL [FZIXLTQRTQWP[ RSPWO[ XLRRPUOWN[P[ MIPFRFWI OGRGWI MIOHRHWIYIZH[F", "H]SFPGOHNJNMOOQPTPWOYNZLZIYGWFSF UFPG PHOJONPO OORP SPWO XNYLYIXG YGUF SFQHPJPNQP TPVOWNXLXHWF QPMQKSJUJXKZN[R[VZWYXWXTWRVQTP RPMQ NQLSKUKXLZ KZP[VZ VYWWWTVR VQSP QPOQMSLULXMZN[ R[TZUYVWVSUQTP", "H]XNWPVQTRQROQNPMNMKNIPGSFVFXGYHZKZNYRXUVXTZQ[N[LZKXKVMVMXLXLW OPNNNKOI XHYJYNXRWUUX QRPQOOOKPHQGSF VFWGXIXNWRVUUWSZQ[", "MXPXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "MXQ[P[OZOYPXQXRYR[Q]P^N_ PYPZQZQYPY Q[Q\\P^", "MXSMRNROSPTPUOUNTMSM SNSOTOTNSN PXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "MXSMRNROSPTPUOUNTMSM SNSOTOTNSN Q[P[OZOYPXQXRYR[Q]P^N_ PYPZQZQYPY Q[Q\\P^", "MXVFUFTGRT VGUGRT VGVHRT VFWGWHRT PXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "H]OKOJPJPLNLNJOHPGSFWFZG[I[KZMYNWOSPQQQSSTTT UFZG YGZIZKYMXNVO WFXGYIYKXMWNSPRQRSST PXOYOZP[Q[RZRYQXPX PYPZQZQYPY", "MXWFUGTHSJSLTMUMVLVKUJTJ UGTITJ TKTLULUKTK", "MXVIUITHTGUFVFWGWIVKULSM UGUHVHVGUG VIVJUL", "E_\\O\\N[N[P]P]N\\M[MYNWPRXPZN[K[HZGXGVHTISKRPPROTMUKUITGRFPGOIOLPRQURWTZV[X[YYYX L[HZ IZHXHVITJSLR PPQSTYVZ K[JZIXIVJTKSMRRO OLPOQRSVUYWZXZYY", "H]TBL_ YBQ_ ZKZJYJYL[L[JZHYGVFRFOGMIMLNNPPVSWUWXVZ NLONVRWT OGNINKOMUPWRXTXWWYVZS[O[LZKYJWJULULWKWKV", "G^_BEbFb _B`BFb", "JZZBXCUERHPKNOMSMXN\\O_Qb SHQKOONTN\\ ZBWDTGRJQLPOOSN\\ NTO]P`Qb", "JZSBUEVHWLWQVUTYR\\O_LaJb VHVPUUSYQ\\ SBTDUGVP VHUQTUSXRZP]M`Jb", "J[TFSGUQTR TFTR TFUGSQTR OIPIXOYO OIYO OIOJYNYO YIXIPOOO YIOO YIYJONOO", "MWUFTGRM UGRM UFVGRM", "H\\PFOGMM PGMM PFQGMM ZFYGWM ZGWM ZF[GWM", "KZSFQGPIPKQMSNUNWMXKXIWGUFSF SFPIQMUNXKWGSF UFQGPKSNWMXIUF", "G^SFKbLb SFTFLb YFQbRb YFZFRb KP\\P\\Q KPKQ\\Q IWZWZX IWIXZX", "E^^F\\GXHUHQGOFMFKGJIJKLMNMPLQJQHOF ^FE[ ^FF[ ^FG[ XTVTTUSWSYU[W[YZZXZVXT PGMFJIKLNMQJPG OFKGJK LMPLQH YUVTSWTZW[ZXYU XTTUSY U[YZZV E[G[", "E`UQUNTLRKPKNLMMLPLSMUOVQVSUTTUQ OLNMMPMSNU RKPLOMNPNSOUPV VKUQUSVUXVZV\\U]R]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYXYWZ WKVQVSWU VKXKWQWSXUZV", "N2cv9FormatterE", "N2cv12CSVFormatterE", "N2cv14NumpyFormatterE", "N2cv15PythonFormatterE", "N2cv15MatlabFormatterE", "void cv::writeMat(std::ostream&, const cv::Mat&, char, char, bool)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/out.cpp", "m.dims <= 2", "array([", "], type='", "PYTHON", "NUMPY", "Unknown formatter", "MATLAB", "uint8", "int8", "uint16", "int16", "int32", "float32", "float64", "uint64", "void cv::writeElems(std::ostream&, void const*, int, int, char)", "static const cv::Formatter* cv::Formatter::get(char const*)", "basic_string::erase", "false", "true", ", --", "void cvSetData(CvArr*, void*, int)", "CvMat* cvCreateMatHeader(int, int, int)", "uchar* cvPtr3D(const CvArr*, int, int, int, int*)", "CvSparseNode* cvInitSparseMatIterator(const CvSparseMat*, CvSparseMatIterator*)", "CvMatND* cvInitMatNDHeader(CvMatND*, int, int const*, int, void*)", "int cvGetElemType(const CvArr*)", "void cvRawDataToScalar(void const*, int, CvScalar*)", "double cvGetRealND(const CvArr*, int const*)", "void cvReleaseSparseMat(CvSparseMat**)", "void cvReleaseMat(CvMat**)", "IplImage* cvInitImageHeader(IplImage*, CvSize, int, int, int, int)", "CvMatND* cvCloneMatND(const CvMatND*)", "void cvSetReal2D(CvArr*, int, int, double)", "int cvGetDims(const CvArr*, int*)", "uchar* cvPtr1D(const CvArr*, int, int*)", "Either all the pointers should be null or they all should be non-null", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/array.cpp", "Non-positive width or height", "Invalid matrix type", "Non-positive cols or rows", "NULL matrix header pointer", "invalid array data type", "NULL <sizes> pointer", "non-positive or too large number of dimensions", "one of dimesion sizes is non-positive", "The array is too big", "bad number of dimensions", "Invalid sparse array header", "Invalid sparse matrix header", "NULL iterator pointer", "One of indices is out of range", "Data is already allocated", "Too big buffer is allocated", "unrecognized or unsupported array type", "Bad CvMatND header", "src->dims <= CV_MAX_DIM", "_dst.data == data0", "Bad CvMat header", "For multidimensional array only CV_AUTOSTEP is allowed here", "bad dimension index", "Array should be CvMat or IplImage", "The number of channels must be 1, 2, 3 or 4", "index is out of range", "COI must be non-null in case of planar images", "Only continuous nD arrays are supported here", "NULL pointer to indices", "cvGetReal* support only single-channel arrays", "cvSetReal* support only single-channel arrays", "NULL array pointer is passed", "The matrix has NULL data pointer", "The image has NULL data pointer", "Images with planar data layout should be used with COI selected", "The image is interleaved and has over CV_CN_MAX channels", "Pixel order should be used with coi == 0", "Input array has NULL data pointer", "Unrecognized or unsupported array type", "Incorrect number of arrays", "Some of required array pointers is NULL", "Iterator pointer is NULL", "COI set is not allowed here", "Number of dimensions is the same for all arrays", "Data type is not the same for all arrays", "Number of channels is not the same for all arrays", "Depth is not the same for all arrays", "Mask should have 8uC1 or 8sC1 data type", "Dimension sizes are the same for all arrays", "NULL pointer to array or destination header", "None of array parameters is changed: dummy call?", "Non-positive or too large number of dimensions", "New dimension sizes are not specified", "The output header should be CvMat or CvMatND", "The matrix is not continuous so the number of rows can not be changed", "The total number of matrix elements is not divisible by the new number of rows", "The total matrix width is not divisible by the new number of columns", "The output header should be CvMatND", "The input array must be CvMatND", "The last dimension full size is not divisible by new number of channels", "Simultaneous change of shape and number of channels is not supported. Do it by 2 separate calls", "Non-continuous nD arrays are not supported", "One of new dimension sizes is non-positive", "Number of elements in the original and reshaped array is different", "COI is not supported by this operation", "COI is not supported", "The matrix is not continuous, thus its number of rows can not be changed", "Bad new number of rows", "The total width is not divisible by the new number of channels", "null pointer to header", "Bad input roi", "Unsupported format", "Bad input origin", "Bad input align", "rect.width >= 0 && rect.height >= 0 && rect.x < image->width && rect.y < image->height && rect.x + rect.width >= (int)(rect.width > 0) && rect.y + rect.height >= (int)(rect.height > 0)", "Null pointer to image", "Bad image header", "Unknown type of term criteria", "Iterations flag is set and maximum number of iterations is <= 0", "Accuracy flag is set and epsilon is < 0", "Neither accuracy nor maximum iterations number flags are set in criteria type", "GRAY", "BGRA", "IplImage* cvGetImage(const CvArr*, IplImage*)", "int cvGetDimSize(const CvArr*, int)", "void cvSetImageCOI(IplImage*, int)", "CvMatND* cvCreateMatNDHeader(int, int const*, int)", "double cvGetReal3D(const CvArr*, int, int, int)", "CvSparseMat* cvCreateSparseMat(int, int const*, int)", "void cvSetRealND(CvArr*, int const*, double)", "CvMat* cvGetMat(const CvArr*, CvMat*, int*, int)", "void cvScalarToRawData(const CvScalar*, void*, int, int)", "void icvDeleteNode(CvSparseMat*, int const*, unsigned int*)", "CvMat* cvInitMatHeader(CvMat*, int, int, int, void*, int)", "CvSize cvGetSize(const CvArr*)", "void cvSetImageROI(IplImage*, CvRect)", "void cvReleaseImageHeader(IplImage**)", "void cvSetIPLAllocators(Cv_iplCreateImageHeader, Cv_iplAllocateImageData, Cv_iplDeallocate, Cv_iplCreateROI, Cv_iplCloneImage)", "void cvReleaseData(CvArr*)", "double cvGetReal1D(const CvArr*, int)", "CvMat* cvGetSubRect(const CvArr*, CvMat*, CvRect)", "void cvSet1D(CvArr*, int, CvScalar)", "void cvGetRawData(const CvArr*, uchar**, int*, CvSize*)", "void cvSetReal3D(CvArr*, int, int, int, double)", "int cvGetImageCOI(const IplImage*)", "uchar* cvPtr2D(const CvArr*, int, int, int*)", "CvArr* cvReshapeMatND(const CvArr*, int, CvArr*, int, int, int*)", "CvMat* cvGetCols(const CvArr*, CvMat*, int, int)", "CvMatND* cvGetMatND(const CvArr*, CvMatND*, int*)", "int cvInitNArrayIterator(int, CvArr**, const CvArr*, CvMatND*, CvNArrayIterator*, int)", "CvSparseMat* cvCloneSparseMat(const CvSparseMat*)", "CvMat* cvGetDiag(const CvArr*, CvMat*, int)", "void cvSetReal1D(CvArr*, int, double)", "CvScalar cvGet1D(const CvArr*, int)", "IplImage* cvCloneImage(const IplImage*)", "uchar* cvPtrND(const CvArr*, int const*, int*, int, unsigned int*)", "void cvResetImageROI(IplImage*)", "uchar* icvGetNodePtr(CvSparseMat*, int const*, int*, int, unsigned int*)", "void cvCreateData(CvArr*)", "CvMat* cvCloneMat(const CvMat*)", "CvScalar cvGet2D(const CvArr*, int, int)", "CvTermCriteria cvCheckTermCriteria(CvTermCriteria, double, int)", "CvMat* cvReshape(const CvArr*, CvMat*, int, int)", "double cvGetReal2D(const CvArr*, int, int)", "CvRect cvGetImageROI(const IplImage*)", "CvMat* cvGetRows(const CvArr*, CvMat*, int, int, int)", "void cvReleaseImage(IplImage**)", "void cvSet2D(CvArr*, int, int, CvScalar)", "N2cv16ParallelLoopBodyE", "/sys/devices/system/cpu/possible", "%d-%d", "void cvPutText(CvArr*, char const*, CvPoint, const CvFont*, CvScalar)", "void cvGetTextSize(char const*, const CvFont*, CvSize*, int*)", "void cv::fillConvexPoly(cv::InputOutputArray, cv::InputArray, const Scalar&, int, int)", "void cv::rectangle(cv::Mat&, cv::Rect, const Scalar&, int, int, int)", "void cv::rectangle(cv::Mat&, cv::Point, cv::Point, const Scalar&, int, int, int)", "void cv::fillConvexPoly(cv::Mat&, const Point*, int, const Scalar&, int, int)", "void cv::polylines(cv::Mat&, const Point**, int const*, int, bool, const Scalar&, int, int, int)", "void cv::line(cv::Mat&, cv::Point, cv::Point, const Scalar&, int, int, int)", "void cv::ellipse(cv::Mat&, cv::Point, cv::Size, double, double, double, const Scalar&, int, int, int)", "void cv::circle(cv::Mat&, cv::Point, int, const Scalar&, int, int, int)", "Unknown font type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/drawing.cpp", "connectivity == 8 || connectivity == 4", "vector::reserve", "0 <= shift && shift <= XY_SHIFT", "points.checkVector(2, CV_32S) >= 0", "pt1 && pt2", "iterator != 0", "font != 0 && hscale > 0 && vscale > 0 && thickness >= 0", "text != 0 && _font != 0", "vector::_M_insert_aux", "0 <= thickness && thickness <= 255", "0 <= shift && shift <= XY_SHIFT && thickness >= 0", "pts && npts && ncontours >= 0 && 0 <= thickness && thickness <= 255 && 0 <= shift && shift <= XY_SHIFT", "p.checkVector(2, CV_32S) >= 0", "thickness <= 255", "radius >= 0 && thickness <= 255 && 0 <= shift && shift <= XY_SHIFT", "axes.width >= 0 && axes.height >= 0 && thickness <= 255 && 0 <= shift && shift <= XY_SHIFT", "box.size.width >= 0 && box.size.height >= 0 && thickness <= 255", "pts && npts && ncontours >= 0 && 0 <= shift && shift <= XY_SHIFT", "elem_type == CV_32SC2", "void cv::polylines(cv::InputOutputArray, cv::InputArrayOfArrays, bool, const Scalar&, int, int, int)", "void cvInitFont(CvFont*, int, double, double, double, int, int)", "int cvInitLineIterator(const CvArr*, CvPoint, CvPoint, CvLineIterator*, int, int)", "cv::LineIterator::LineIterator(const cv::Mat&, cv::Point, cv::Point, int, bool)", "void cv::fillPoly(cv::Mat&, const Point**, int const*, int, const Scalar&, int, int, cv::Point)", "void cv::ellipse(cv::Mat&, const cv::RotatedRect&, const Scalar&, int, int)", "void cv::fillPoly(cv::InputOutputArray, cv::InputArrayOfArrays, const Scalar&, int, int, cv::Point)", "int cvClipLine(CvSize, CvPoint*, CvPoint*)", "void cv::PolyLine(cv::Mat&, const Point*, int, bool, void const*, int, int, int)", "24EmptyDeviceInfoFuncTable", "19DeviceInfoFuncTable", "14EmptyFuncTable", "12GpuFuncTable", "virtual void EmptyFuncTable::copyWithMask(const cv::gpu::GpuMat&, cv::gpu::GpuMat&, const cv::gpu::GpuMat&) const", "virtual int EmptyDeviceInfoFuncTable::multiProcessorCount(int) const", "virtual std::size_t EmptyDeviceInfoFuncTable::freeMemory(int) const", "virtual void EmptyFuncTable::copy(const cv::gpu::GpuMat&, cv::gpu::GpuMat&) const", "virtual std::string EmptyDeviceInfoFuncTable::name(int) const", "virtual bool EmptyDeviceInfoFuncTable::supports(int, cv::gpu::FeatureSet) const", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrGreaterPtx(int, int) const", "virtual std::size_t EmptyDeviceInfoFuncTable::sharedMemPerBlock(int) const", "virtual void EmptyFuncTable::setTo(cv::gpu::GpuMat&, cv::Scalar, const cv::gpu::GpuMat&, cudaStream_t) const", "virtual bool EmptyDeviceInfoFuncTable::hasBin(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrGreaterBin(int, int) const", "virtual void EmptyDeviceInfoFuncTable::queryMemory(int, std::size_t&, std::size_t&) const", "virtual void EmptyDeviceInfoFuncTable::setDevice(int) const", "virtual void EmptyDeviceInfoFuncTable::resetDevice() const", "virtual void EmptyFuncTable::copy(const cv::gpu::GpuMat&, cv::Mat&) const", "virtual bool EmptyDeviceInfoFuncTable::builtWith(cv::gpu::FeatureSet) const", "virtual int EmptyDeviceInfoFuncTable::getDevice() const", "virtual bool EmptyDeviceInfoFuncTable::hasPtx(int, int) const", "The library is compiled without CUDA support", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/dynamicuda/include/opencv2/dynamicuda/dynamicuda.hpp", "0 <= _rowRange.start && _rowRange.start <= _rowRange.end && _rowRange.end <= m.rows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/gpumat.cpp", "0 <= _colRange.start && _colRange.start <= _colRange.end && _colRange.end <= m.cols", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows", "The matrix is not continuous, thus its number of rows can not be changed", "Bad new number of rows", "The total number of matrix elements is not divisible by the new number of rows", "The total width is not divisible by the new number of channels", "mask.empty() || mask.type() == CV_8UC1", "unknown function", "OpenCV Error: ", ") in ", ", file ", ", line ", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrLessPtx(int, int) const", "virtual void EmptyFuncTable::convert(const cv::gpu::GpuMat&, cv::gpu::GpuMat&) const", "cv::gpu::GpuMat cv::gpu::GpuMat::reshape(int, int) const", "virtual bool EmptyDeviceInfoFuncTable::hasEqualOrGreater(int, int) const", "virtual int EmptyDeviceInfoFuncTable::minorVersion(int) const", "virtual bool EmptyDeviceInfoFuncTable::deviceSupports(cv::gpu::FeatureSet) const", "cv::gpu::GpuMat& cv::gpu::GpuMat::setTo(cv::Scalar, const cv::gpu::GpuMat&)", "virtual void EmptyFuncTable::mallocPitch(void**, std::size_t*, std::size_t, std::size_t) const", "virtual bool EmptyDeviceInfoFuncTable::has(int, int) const", "cv::gpu::GpuMat::GpuMat(const cv::gpu::GpuMat&, cv::Rect)", "virtual std::size_t EmptyDeviceInfoFuncTable::totalMemory(int) const", "cv::gpu::GpuMat::GpuMat(const cv::gpu::GpuMat&, cv::Range, cv::Range)", "virtual int EmptyDeviceInfoFuncTable::majorVersion(int) const", "virtual void EmptyFuncTable::convert(const cv::gpu::GpuMat&, cv::gpu::GpuMat&, double, double, cudaStream_t) const", "virtual bool EmptyDeviceInfoFuncTable::isCompatible(int) const", "virtual void EmptyFuncTable::copy(const cv::Mat&, cv::gpu::GpuMat&) const", "The library is compiled without OpenGL support", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/gl_core_3_1.cpp", "void* IntGetProcAddress(char const*)", "void* cv::OutOfMemoryError(std::size_t)", "Failed to allocate %lu bytes", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/alloc.cpp", "Custom memory allocator is not supported", "void cvSetMemoryManager(CvAllocFunc, CvFreeFunc, void*)", "void cvStartReadSeq(const CvSeq*, CvSeqReader*, int)", "schar* cvSeqInsert(CvSeq*, int, void const*)", "void* cvMemStorageAlloc(CvMemStorage*, std::size_t)", "void cvRestoreMemStoragePos(CvMemStorage*, CvMemStoragePos*)", "CvGraph* cvCreateGraph(int, int, int, int, CvMemStorage*)", "void cvFlushSeqWriter(CvSeqWriter*)", "CvGraphEdge* cvFindGraphEdge(const CvGraph*, int, int)", "void cvReleaseMemStorage(CvMemStorage**)", "int cvGraphVtxDegree(const CvGraph*, int)", "void icvSeqElemsClearFlags(CvSeq*, int, int)", "void cvChangeSeqBlock(void*, int)", "void cvCreateSeqBlock(CvSeqWriter*)", "void cvStartAppendToSeq(CvSeq*, CvSeqWriter*)", "void cvSeqPopFront(CvSeq*, void*)", "void cvGraphRemoveEdgeByPtr(CvGraph*, CvGraphVtx*, CvGraphVtx*)", "CvGraph* cvCloneGraph(const CvGraph*, CvMemStorage*)", "CvSeq* cvMakeSeqHeaderForArray(int, int, int, void*, int, CvSeq*, CvSeqBlock*)", "void cvRemoveNodeFromTree(void*, void*)", "void cv::KDTree::getPoints(cv::InputArray, cv::OutputArray, cv::OutputArray) const", "void cvInitTreeNodeIterator(CvTreeNodeIterator*, void const*, int)", "CvSeq* cvCreateSeq(int, std::size_t, std::size_t, CvMemStorage*)", "int cvSetAdd(CvSet*, CvSetElem*, CvSetElem**)", "void cvClearSeq(CvSeq*)", "void cvGraphRemoveEdge(CvGraph*, int, int)", "void cvSeqPopMulti(CvSeq*, void*, int, int)", "schar* cvSeqSearch(CvSeq*, void const*, CvCmpFunc, int, int*, void*)", "void cvSetSeqReaderPos(CvSeqReader*, int, int)", "int cvGraphRemoveVtxByPtr(CvGraph*, CvGraphVtx*)", "void cvInsertNodeIntoTree(void*, void*, void*)", "schar* cvSeqPush(CvSeq*, void const*)", "CvSet* cvCreateSet(int, int, int, CvMemStorage*)", "void icvGoNextMemBlock(CvMemStorage*)", "void cvReleaseGraphScanner(CvGraphScanner**)", "void icvInitMemStorage(CvMemStorage*, int)", "void cvSetRemove(CvSet*, int)", "void* cvCvtSeqToArray(const CvSeq*, void*, CvSlice)", "float const* cv::KDTree::getPoint(int, int*) const", "float cv::medianPartition(std::size_t*, int, int, float const*)", "schar* cvSeqPushFront(CvSeq*, void const*)", "void cv::KDTree::findOrthoRange(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray) const", "int cv::KDTree::findNearest(cv::InputArray, int, int, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray) const", "void* cvNextTreeNode(CvTreeNodeIterator*)", "void cvSeqRemove(CvSeq*, int)", "CvMemStorage* cvCreateChildMemStorage(CvMemStorage*)", "void icvDestroyMemStorage(CvMemStorage*)", "int cvGraphRemoveVtx(CvGraph*, int)", "CvSeq* cvSeqSlice(const CvSeq*, CvSlice, CvMemStorage*, int)", "int cvGraphVtxDegreeByPtr(const CvGraph*, const CvGraphVtx*)", "CvGraphScanner* cvCreateGraphScanner(CvGraph*, CvGraphVtx*, int)", "void cvClearGraph(CvGraph*)", "void cvSeqPop(CvSeq*, void*)", "void cvSetSeqBlockSize(CvSeq*, int)", "void cvSeqSort(CvSeq*, CvCmpFunc, void*)", "void icvGrowSeq(CvSeq*, int)", "int cvGraphAddEdge(CvGraph*, int, int, const CvGraphEdge*, CvGraphEdge**)", "void cv::KDTree::build(cv::InputArray, cv::InputArray, bool)", "void* cvPrevTreeNode(CvTreeNodeIterator*)", "int cvSeqElemIdx(const CvSeq*, void const*, CvSeqBlock**)", "CvSeq* cvEndWriteSeq(CvSeqWriter*)", "void cvSaveMemStoragePos(const CvMemStorage*, CvMemStoragePos*)", "CvSeq* cvTreeToNodeSeq(void const*, int, CvMemStorage*)", "void cvSeqInsertSlice(CvSeq*, int, const CvArr*)", "int cvNextGraphItem(CvGraphScanner*)", "CvGraphEdge* cvFindGraphEdgeByPtr(const CvGraph*, const CvGraphVtx*, const CvGraphVtx*)", "int cvGetSeqReaderPos(CvSeqReader*)", "void cvClearMemStorage(CvMemStorage*)", "int cvGraphAddEdgeByPtr(CvGraph*, CvGraphVtx*, CvGraphVtx*, const CvGraphEdge*, CvGraphEdge**)", "int cvSeqPartition(const CvSeq*, CvMemStorage*, CvSeq**, CvCmpFunc, void*)", "void cvSeqPushMulti(CvSeq*, void const*, int, int)", "schar* icvSeqFindNextElem(CvSeq*, int, int, int, int*)", "int cvGraphAddVtx(CvGraph*, const CvGraphVtx*, CvGraphVtx**)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/datastructs.cpp", "NULL storage pointer", "Too large memory block is requested", "requested size is negative or too big", "Storage block size is too small to fit the sequence elements", "The sequence has NULL storage pointer", "Specified element size doesn't match to the size of the specified element type (try to use 0 for element type)", "Element size doesn't match to the size of predefined element type (try to use 0 for sequence element type)", "Invalid index", "NULL sequence pointer", "number of removed elements is negative", "Invalid sequence header", "Bad sequence slice", "start slice index is out of range", "Invalid destination sequence header", "Source is not a sequence nor matrix", "The source array must be 1d coninuous vector", "Source and destination sequence element sizes are different.", "Bad input sequence", "Null compare function", "Null element pointer", "graph pointer is NULL", "vertex pointers coinside (or set to NULL)", "The vertex is not found", "The vertex does not belong to the graph", "Null graph pointer", "graph->storage != 0", "Null double pointer to graph scanner", "Null graph scanner", "Invalid graph pointer", "frame node could not be deleted", "NULL iterator pointer", "idxmat.isContinuous() && idxmat.type() == CV_32S && (idxmat.cols == 1 || idxmat.rows == 1)", "labelsmat.isContinuous()", "(unsigned)k < (unsigned)points.rows", "vecmat.isContinuous() && vecmat.type() == CV_32F && vecmat.total() == (size_t)points.cols", "K > 0 && (normType == NORM_L2 || normType == NORM_L1)", "(unsigned)ptidx < (unsigned)points.rows", "vector::_M_insert_aux", "lowerBound.size == upperBound.size && lowerBound.isContinuous() && upperBound.isContinuous() && lowerBound.type() == upperBound.type() && lowerBound.type() == CV_32F && lowerBound.total() == (size_t)ptdims", "vector::_M_fill_insert", "_points.type() == CV_32F && !_points.empty()", "nlabels == n", "vals[ofs[k]] <= pivot", "vals[ofs[k]] >= pivot", "std::abs(more - less) <= 1", "void cvStartWriteSeq(int, int, int, CvMemStorage*, CvSeqWriter*)", "N2cv22KMeansDistanceComputerE", "N2cv24KMeansPPDistanceComputerE", "virtual void cv::_OutputArray::clear() const", "void cv::extractImageCOI(const CvArr*, cv::OutputArray, int)", "void cv::completeSymm(cv::InputOutputArray, bool)", "void cvReduce(const CvArr*, CvArr*, int, int)", "void cv::normalize(const cv::SparseMat&, cv::SparseMat&, double, int)", "void cv::reduce(cv::InputArray, cv::OutputArray, int, int, int)", "virtual cv::GlTexture cv::_InputArray::getGlTexture() const", "void cvSort(const CvArr*, CvArr*, CvArr*, int)", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = signed char]", "void cv::SparseMat::create(int, int const*, int)", "void (* cv::getConvertScaleElem(int, int))(void const*, void*, int, double, double)", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = int]", "void cv::insertImageCOI(cv::InputArray, CvArr*, int)", "void cv::Mat::resize(std::size_t)", "cv::Mat::Mat(const IplImage*, bool)", "uchar* cv::SparseMat::ptr(int, int, int, bool, std::size_t*)", "N2cv11_InputArrayE", "cv::ogl::Texture2D& cv::_OutputArray::getOGlTexture2DRef() const", "cv::Mat::operator IplImage() const", "virtual std::size_t cv::_InputArray::total(int) const", "cv::ogl::Buffer& cv::_OutputArray::getOGlBufferRef() const", "void cv::minMaxLoc(const cv::SparseMat&, double*, double*, int*, int*)", "virtual cv::gpu::GpuMat cv::_InputArray::getGpuMat() const", "cv::Mat cv::Mat::cross(cv::InputArray) const", "void cv::SparseMat::convertTo(cv::SparseMat&, int, double) const", "cv::Mat::Mat(const cv::Mat&, const Rect&)", "void (* cv::getConvertElem(int, int))(void const*, void*, int)", "cv::ogl::Texture2D cv::_InputArray::getOGlTexture2D() const", "double cv::kmeans(cv::InputArray, int, cv::InputOutputArray, cv::TermCriteria, int, int, cv::OutputArray)", "void cv::SparseMat::copyTo(cv::Mat&) const", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = short unsigned int]", "void cv::Mat::create(int, int const*, int)", "void cvCrossProduct(const CvArr*, const CvArr*, CvArr*)", "void cv::sort(cv::InputArray, cv::OutputArray, int)", "cv::Mat::Mat(const cv::Mat&, const cv::Range&, const cv::Range&)", "void cv::Mat::push_back(const cv::Mat&)", "virtual cv::Size cv::_InputArray::size(int) const", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = float]", "virtual cv::Mat cv::_InputArray::getMat(int) const", "virtual int cv::_InputArray::type(int) const", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = short int]", "void cv::SparseMat::erase(int const*, std::size_t*)", "virtual void cv::_OutputArray::create(int, int const*, int, int, bool, int) const", "void cvTranspose(const CvArr*, CvArr*)", "void cv::sortIdx(cv::InputArray, cv::OutputArray, int)", "N2cv12_OutputArrayE", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = unsigned char]", "virtual void cv::_OutputArray::create(cv::Size, int, int, bool, int) const", "cv::Mat cv::Mat::diag(int) const", "void cv::transpose(cv::InputArray, cv::OutputArray)", "void cv::sortIdx_(const cv::Mat&, cv::Mat&, int) [with T = double]", "This function in deprecated, do not use it", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/src/matrix.cpp", "k == GPU_MAT", "0 <= _dims && _dims <= CV_MAX_DIM", "s >= 0", "The total matrix size does not fit to \"size_t\" type", "i < 0", "i < (int)vv.size()", "k == MAT", "k == STD_VECTOR_MAT", "i < (int)v.size()", "This method is not implemented for oclMat yet", "0 <= d && d <= CV_MAX_DIM && _sizes", "step[dims-1] == (size_t)CV_ELEM_SIZE(flags)", "!fixedSize() || ((Mat*)obj)->size.operator()() == _sz", "!fixedType() || ((Mat*)obj)->type() == mtype", "!fixedSize() || ((gpu::GpuMat*)obj)->size() == _sz", "!fixedType() || ((gpu::GpuMat*)obj)->type() == mtype", "!fixedSize() || ((ogl::Buffer*)obj)->size() == _sz", "!fixedType() || ((ogl::Buffer*)obj)->type() == mtype", "!fixedSize() || ((Mat*)obj)->size.operator()() == Size(cols, rows)", "!fixedSize() || ((gpu::GpuMat*)obj)->size() == Size(cols, rows)", "!fixedSize() || ((ogl::Buffer*)obj)->size() == Size(cols, rows)", "!fixedSize()", "m.dims <= 2", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows", "ranges", "r == Range::all() || (0 <= r.start && r.start < r.end && r.end <= m.size[i])", "dims <= 2", "dims <= 2 && step[0] > 0", "The matrix is not continuous, thus its number of rows can not be changed", "Bad new number of rows", "The total number of matrix elements is not divisible by the new number of rows", "The total width is not divisible by the new number of channels", "cn <= 4", "k == OPENGL_BUFFER", "k == OPENGL_TEXTURE", "img->dataOrder == IPL_DATA_ORDER_PIXEL", "img->dataOrder == IPL_DATA_ORDER_PIXEL || img->roi->coi != 0", "COI is not supported by the function", "seq->total > 0 && CV_ELEM_SIZE(seq->flags) == seq->elem_size", "Unknown array type", "CV_IS_IMAGE(arr)", "ch.size == mat.size && ch.depth() == mat.depth() && 0 <= coi && coi < mat.channels()", "0 <= coi && coi < mat.channels()", "!src[i].empty() && src[i].dims <= 2 && src[i].rows == src[0].rows && src[i].type() == src[0].type()", "!src[i].empty() && src[i].dims <= 2 && src[i].cols == src[0].cols && src[i].type() == src[0].type()", "src.dims <= 2 && esz <= (size_t)32", "src.size() == dst.size() && (src.cols == 1 || src.rows == 1)", "func != 0", "m.dims <= 2 && m.rows == m.cols", "dims <= 2 && m.dims <= 2 && size() == m.size() && tp == m.type() && ((rows == 3 && cols == 1) || (cols*channels() == 3 && rows == 1))", "src.dims <= 2", "op == CV_REDUCE_SUM || op == CV_REDUCE_MAX || op == CV_REDUCE_MIN || op == CV_REDUCE_AVG", "src.channels() == dst.channels()", "Unsupported combination of input and output array formats", "src.dims <= 2 && src.channels() == 1 && func != 0", "src.rows == dst.cols && src.cols == dst.rows && src.type() == dst.type()", "srcA.size() == dst.size() && srcA.type() == dst.type()", "The reduced dimensionality index is out of range", "The output array size is incorrect", "Input and output arrays must have the same number of channels", "The function only supports 32sC1 and 32fC1 datatypes", "src.size() == idx.size() && idx.type() == CV_32S && src.data != idx.data", "idx0.data == idx.data", "src.size() == dst.size() && src.type() == dst.type()", "dst0.data == dst.data", "_arrays && (_ptrs || _planes)", "narrays <= 1000", "arrays[i] != 0", "A.size == arrays[i0]->size", "A.step[d-1] == A.elemSize()", "m != 0 && _idx", "hdr && hdr->dims == 3", "hdr && hdr->dims == 2", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2", "Only 32f and 64f are supported", "data0.dims <= 2 && type == CV_32F && K > 0", "N >= K", "(best_labels.cols == 1 || best_labels.rows == 1) && best_labels.cols*best_labels.rows == N && best_labels.type() == CV_32S && best_labels.isContinuous()", "(unsigned)labels[i] < (unsigned)K", "counters[k] != 0", "!centers.empty()", "centers.rows == cluster_count", "centers.cols == data.cols", "centers.depth() == data.depth()", "labels.isContinuous() && labels.type() == CV_32S && (labels.cols == 1 || labels.rows == 1) && labels.cols + labels.rows - 1 == data.rows", "m.dims >= 2", "0 <= _rowRange.start && _rowRange.start <= _rowRange.end && _rowRange.end <= m.rows", "0 <= _colRange.start && _colRange.start <= _colRange.end && _colRange.end <= m.cols", "0 <= i && i < (int)vv.size()", "0 <= i && i < (int)v.size()", "nelems <= (size_t)size.p[0]", "(int)nelems >= 0", "vector::_M_fill_insert", "hdr && hdr->dims == 1", "_sizes && 0 < d && d <= CV_MAX_DIM", "_sizes[i] > 0", "hdr != 0", "Unknown/unsupported norm type", "!fixedType() && !fixedSize()", "CV_MAT_TYPE(mtype) == m.type()", "m.dims == dims", "m.size[j] == sizes[j]", "mtype == type0 || (CV_MAT_CN(mtype) == 1 && ((1 << type0) & fixedDepthMask) != 0)", "dims == 2 && ((sizes[0] == sz.height && sizes[1] == sz.width) || (allowTransposed && sizes[0] == sz.width && sizes[1] == sz.height))", "dims == 2 && (sizes[0] == 1 || sizes[1] == 1 || sizes[0]*sizes[1] == 0)", "!fixedSize() || len == vv.size()", "mtype == type0 || (CV_MAT_CN(mtype) == CV_MAT_CN(type0) && ((1 << type0) & fixedDepthMask) != 0)", "!fixedSize() || len == ((vector<uchar>*)v)->size() / esz", "Vectors with element size %d are not supported. Please, modify OutputArray::create()\n", "create() called for the missing output array", "!fixedSize() || len == len0", "v[j].empty()", "!fixedType() || (CV_MAT_CN(mtype) == m.channels() && ((1 << CV_MAT_TYPE(flags)) & fixedDepthMask) != 0)", "src.data != dst.data", "cv::Scalar cv::trace(cv::InputArray)", "void cv::Mat::locateROI(cv::Size&, cv::Point&) const", "void cv::SparseMat::erase(int, int, int, std::size_t*)", "virtual bool cv::_InputArray::empty() const", "void cv::SparseMat::erase(int, int, std::size_t*)", "void cv::Mat::pop_back(std::size_t)", "double cv::norm(const cv::SparseMat&, int)", "void cv::SparseMat::convertTo(cv::Mat&, int, double, double) const", "virtual cv::Mat& cv::_OutputArray::getMatRef(int) const", "int cvKMeans2(const CvArr*, int, CvArr*, CvTermCriteria, int, CvRNG*, int, CvArr*, double*)", "void cv::NAryMatIterator::init(const cv::Mat**, cv::Mat*, uchar**, int)", "uchar* cv::SparseMat::ptr(int, int, bool, std::size_t*)", "cv::SparseMat::SparseMat(const CvSparseMat*)", "cv::gpu::GpuMat& cv::_OutputArray::getGpuMatRef() const", "cv::Mat cv::Mat::reshape(int, int) const", "cv::Mat cv::cvarrToMat(const CvArr*, bool, bool, int)", "void cv::Mat::reserve(std::size_t)", "void cv::setIdentity(cv::InputOutputArray, const Scalar&)", "void cv::vconcat(const cv::Mat*, std::size_t, cv::OutputArray)", "void cv::hconcat(const cv::Mat*, std::size_t, cv::OutputArray)", "void cv::scalarToRawData(const Scalar&, void*, int, int)", "void cv::MatConstIterator::pos(int*) const", "cv::Mat& cv::Mat::adjustROI(int, int, int, int)", "cv::ogl::Buffer cv::_InputArray::getOGlBuffer() const", "virtual void cv::_OutputArray::create(int, int, int, int, bool, int) const", "uchar* cv::SparseMat::ptr(int, bool, std::size_t*)", "virtual cv::GlBuffer cv::_InputArray::getGlBuffer() const", "CvArr* cvRange(CvArr*, double, double)", "cv::Mat::Mat(const cv::Mat&, const cv::Range*)", "uchar* cv::SparseMat::ptr(int const*, bool, std::size_t*)", "void cv::setSize(cv::Mat&, int, int const*, const size_t*, bool)", "virtual void cv::_OutputArray::release() const", "cv::Mat cv::Mat::reshape(int, int, int const*) const", "virtual void cv::_InputArray::getMatVector(std::vector<cv::Mat>&) const", "N7cvflann7anyimpl12bad_any_castE", "N7cvflann17flann_algorithm_tE", "N7cvflann5IndexINS_11HammingLUT2EEE", "N7cvflann7NNIndexINS_11HammingLUT2EEE", "N7cvflann21RadiusUniqueResultSetIiEE", "N7cvflann15UniqueResultSetIiEE", "N7cvflann9ResultSetIiEE", "N7cvflann18KNNUniqueResultSetIiEE", "N7cvflann14FLANNExceptionE", "N7cvflann8LshIndexINS_11HammingLUT2EEE", "N7cvflann27HierarchicalClusteringIndexINS_11HammingLUT2EEE", "N7cvflann20flann_centers_init_tE", "N7cvflann5IndexINS_2L2IfEEEE", "N7cvflann7NNIndexINS_2L2IfEEEE", "N7cvflann21RadiusUniqueResultSetIfEE", "N7cvflann15UniqueResultSetIfEE", "N7cvflann9ResultSetIfEE", "N7cvflann18KNNUniqueResultSetIfEE", "N7cvflann11LinearIndexINS_2L2IfEEEE", "N7cvflann17KDTreeSingleIndexINS_2L2IfEEEE", "N7cvflann18KNNSimpleResultSetIfEE", "N7cvflann11KDTreeIndexINS_2L2IfEEEE", "N7cvflann11KMeansIndexINS_2L2IfEEEE", "N7cvflann14CompositeIndexINS_2L2IfEEEE", "N7cvflann14AutotunedIndexINS_2L2IfEEEE", "N7cvflann12KNNResultSetIfEE", "N7cvflann27HierarchicalClusteringIndexINS_2L2IfEEEE", "N7cvflann8LshIndexINS_2L2IfEEEE", "N7cvflann5IndexINS_2L1IfEEEE", "N7cvflann7NNIndexINS_2L1IfEEEE", "N7cvflann11LinearIndexINS_2L1IfEEEE", "N7cvflann17KDTreeSingleIndexINS_2L1IfEEEE", "N7cvflann11KDTreeIndexINS_2L1IfEEEE", "N7cvflann11KMeansIndexINS_2L1IfEEEE", "N7cvflann14CompositeIndexINS_2L1IfEEEE", "N7cvflann14AutotunedIndexINS_2L1IfEEEE", "N7cvflann27HierarchicalClusteringIndexINS_2L1IfEEEE", "N7cvflann8LshIndexINS_2L1IfEEEE", "N7cvflann7anyimpl16small_any_policyIPPNS_11KDTreeIndexINS_2L2IfEEE4NodeEEE", "N7cvflann7anyimpl21typed_base_any_policyIPPNS_11KDTreeIndexINS_2L2IfEEE4NodeEEE", "PPN7cvflann11KDTreeIndexINS_2L2IfEEE4NodeE", "PN7cvflann11KDTreeIndexINS_2L2IfEEE4NodeE", "N7cvflann11KDTreeIndexINS_2L2IfEEE4NodeE", "N7cvflann7anyimpl14big_any_policyIdEE", "N7cvflann7anyimpl21typed_base_any_policyIdEE", "N7cvflann7anyimpl14big_any_policyISsEE", "N7cvflann7anyimpl21typed_base_any_policyISsEE", "N7cvflann7anyimpl16small_any_policyIjEE", "N7cvflann7anyimpl21typed_base_any_policyIjEE", "N7cvflann7anyimpl14big_any_policyINS_20flann_centers_init_tEEE", "N7cvflann7anyimpl21typed_base_any_policyINS_20flann_centers_init_tEEE", "N7cvflann7anyimpl14big_any_policyINS_17flann_algorithm_tEEE", "N7cvflann7anyimpl21typed_base_any_policyINS_17flann_algorithm_tEEE", "N7cvflann7anyimpl16small_any_policyIbEE", "N7cvflann7anyimpl21typed_base_any_policyIbEE", "N7cvflann7anyimpl16small_any_policyIfEE", "N7cvflann7anyimpl21typed_base_any_policyIfEE", "N7cvflann7anyimpl16small_any_policyIiEE", "N7cvflann7anyimpl21typed_base_any_policyIiEE", "N7cvflann7anyimpl16small_any_policyIPKcEE", "N7cvflann7anyimpl21typed_base_any_policyIPKcEE", "N7cvflann7anyimpl14big_any_policyINS0_9empty_anyEEE", "N7cvflann7anyimpl21typed_base_any_policyINS0_9empty_anyEEE", "N7cvflann7anyimpl9empty_anyE", "N7cvflann7anyimpl15base_any_policyE", "N7cvflann7anyimpl16small_any_policyIPPNS_11KDTreeIndexINS_2L1IfEEE4NodeEEE", "PPN7cvflann11KDTreeIndexINS_2L1IfEEE4NodeE", "PN7cvflann11KDTreeIndexINS_2L1IfEEE4NodeE", "N7cvflann11KDTreeIndexINS_2L1IfEEE4NodeE", "N7cvflann7anyimpl21typed_base_any_policyIPPNS_11KDTreeIndexINS_2L1IfEEE4NodeEEE", "void cvflann::lsh::LshTable<ElementType>::initialize(std::size_t) [with ElementType = unsigned char, std::size_t = unsigned int]", "virtual void cv::flann::Index::build(cv::InputArray, const cv::flann::IndexParams&, cvflann::flann_distance_t)", "void cv::flann::runKnnSearch_(void*, const cv::Mat&, cv::Mat&, cv::Mat&, int, const cv::flann::SearchParams&) [with Distance = cvflann::L1<float>, IndexType = cvflann::Index<cvflann::L1<float> >]", "void cv::flann::runKnnSearch_(void*, const cv::Mat&, cv::Mat&, cv::Mat&, int, const cv::flann::SearchParams&) [with Distance = cvflann::L2<float>, IndexType = cvflann::Index<cvflann::L2<float> >]", "int cv::flann::runRadiusSearch_(void*, const cv::Mat&, cv::Mat&, cv::Mat&, double, const cv::flann::SearchParams&) [with Distance = cvflann::L2<float>, IndexType = cvflann::Index<cvflann::L2<float> >]", "void cv::flann::buildIndex_(void*&, const cv::Mat&, const cv::flann::IndexParams&, const Distance&) [with Distance = cvflann::L1<float>, IndexType = cvflann::Index<cvflann::L1<float> >]", "virtual void cv::flann::Index::release()", "virtual void cv::flann::Index::save(const string&) const", "bool cv::flann::loadIndex_(cv::flann::Index*, void*&, const cv::Mat&, FILE*, const Distance&) [with Distance = cvflann::L2<float>, IndexType = cvflann::Index<cvflann::L2<float> >, FILE = __sFILE]", "void cv::flann::buildIndex_(void*&, const cv::Mat&, const cv::flann::IndexParams&, const Distance&) [with Distance = cvflann::HammingLUT2, IndexType = cvflann::Index<cvflann::HammingLUT2>]", "int cv::flann::runRadiusSearch_(void*, const cv::Mat&, cv::Mat&, cv::Mat&, double, const cv::flann::SearchParams&) [with Distance = cvflann::L1<float>, IndexType = cvflann::Index<cvflann::L1<float> >]", "virtual void cv::flann::Index::knnSearch(cv::InputArray, cv::OutputArray, cv::OutputArray, int, const cv::flann::SearchParams&)", "int cv::flann::runRadiusSearch_(void*, const cv::Mat&, cv::Mat&, cv::Mat&, double, const cv::flann::SearchParams&) [with Distance = cvflann::HammingLUT2, IndexType = cvflann::Index<cvflann::HammingLUT2>]", "[empty_any]", "Unknown/unsupported distance type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/flann/src/miniflann.cpp", "Building kmeans tree...\n", "Building kdtree tree...\n", "Invalid index file, cannot read", "FLANN_INDEX", "Invalid index file, wrong signature", "Failed to allocate memory.\n", "Invalid key_size (=", "). Valid values for your system are ", " <= key_size < ", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/flann/include/opencv2/flann/lsh_table.h", "query.type() == type && indices.type() == CV_32S && dists.type() == dtype", "query.isContinuous() && indices.isContinuous() && dists.isContinuous()", "maxResults > 0", "LSH index does not support radiusSearch operation", "vector::_M_insert_aux", "vector::_M_fill_insert", "Can not open file %s for writing FLANN index\n", "algorithm", "checks", "sorted", "filename", "table_number", "key_size", "multi_probe_level", "branching", "centers_init", "trees", "leaf_size", "iterations", "cb_index", "target_precision", "build_weight", "memory_weight", "sample_fraction", "matches.cols=%d, nn=%d\n", "Ground truth is not computed for as many neighbors as requested", "%8d %10.4g %10.5g %10.5g %10.5g\n", "  Nodes  Precision(%)   Time(s)   Time/vec(ms)  Mean dist\n", "---------------------------------------------------------\n", "Got as close as I can\n", "Start linear estimation\n", "No need for linear estimation\n", "Missing parameter '", "' in the parameters given", "leaf_max_size", "reorder", "I can only search one feature at a time for range search\n", "Unknown algorithm for choosing initial centers.", "Unknown index type", "Datatype of saved index is different than of the one to be created.", "The index saved belongs to a different dataset", "type=%d\n", "Only continuous arrays are supported", "DataType<ElementType>::type == data.type() && data.isContinuous()", "Cannot read from file", "Reading FLANN index error: the saved data size (%d, %d) or type (%d) is different from the passed one (%d, %d), %d\n", "Reading FLANN index error: unsupported feature type %d for the index type %d\n", "Reading FLANN index error: unsupported distance type %d\n", "LSH is not implemented for that type", "vector::reserve", "Computing ground truth\n", "Estimating number of checks\n", "KMeans algorithm, estimating cluster border factor\n", "Optimum cb_index: %g\n", "Required number of checks: %d \n", "It doesn't make any sense to use more than one tree for exact search", "Branching factor must be at least 2", "KD-TREE, Step 1: Exploring parameter space\n", "KDTree using params: trees=%d\n", "KDTree buildTime=%g, searchTime=%g\n", "KMEANS, Step 1: Exploring parameter space\n", "KMeansTree using params: max_iterations=%d, branching=%d\n", "KMeansTree buildTime=%g, searchTime=%g, build_weight=%g\n", "Entering autotuning, dataset size: %d, sampleSize: %d, testSampleSize: %d, target precision: %g\n", "Choosing linear, dataset too small\n", "Computing ground truth... \n", "Autotuning parameters...\n", "----------------------------------------------------\n", "Autotuned parameters:\n", "Search parameters:\n", "void cv::flann::buildIndex_(void*&, const cv::Mat&, const cv::flann::IndexParams&, const Distance&) [with Distance = cvflann::L2<float>, IndexType = cvflann::Index<cvflann::L2<float> >]", "bool cv::flann::loadIndex_(cv::flann::Index*, void*&, const cv::Mat&, FILE*, const Distance&) [with Distance = cvflann::HammingLUT2, IndexType = cvflann::Index<cvflann::HammingLUT2>, FILE = __sFILE]", "bool cv::flann::loadIndex_(cv::flann::Index*, void*&, const cv::Mat&, FILE*, const Distance&) [with Distance = cvflann::L1<float>, IndexType = cvflann::Index<cvflann::L1<float> >, FILE = __sFILE]", "void cv::flann::runKnnSearch_(void*, const cv::Mat&, cv::Mat&, cv::Mat&, int, const cv::flann::SearchParams&) [with Distance = cvflann::HammingLUT2, IndexType = cvflann::Index<cvflann::HammingLUT2>]", "N2cv5flann5IndexE", "virtual int cv::flann::Index::radiusSearch(cv::InputArray, cv::OutputArray, cv::OutputArray, double, int, const cv::flann::SearchParams&)", "[empty_any]", "[WARNING] The cvflann::set_distance_type function is deperecated, use cv::flann::GenericIndex<Distance> instead.", "[ERROR] cvflann::set_distance_type only provides backwards compatibility for the L1 and L2 distances. For other distance types you must use cv::flann::GenericIndex<Distance>", "Input sequence must consist of 2d points or pointers to 2d points", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/rotcalipers.cpp", "CvBox2D cvMinAreaRect2(const CvArr*, CvMemStorage*)", "CvSeq* cvApproxChains(CvSeq*, CvMemStorage*, int, double, int, int)", "CvSeq* icvApproximateChainTC89(CvChain*, int, CvMemStorage*, int)", "CV_IS_SEQ_CHAIN_CONTOUR( chain )", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/approx.cpp", "header_size >= (int)sizeof(CvContour)", "Unsupported sequence type", "NULL storage pointer ", "header_size is negative. Pass 0 to make the destination header_size == input header_size", "Input curves are not polygonal. Use cvApproxChains first", "Input curves have uknown type", "New header size must be non-less than sizeof(CvContour)", "Unknown approximation method", "Accuracy must be non-negative", "Invalid approximation method", "CvSeq* cvApproxPoly(void const*, int, CvMemStorage*, int, double, int)", "void cv::accumulateProduct(cv::InputArray, cv::InputArray, cv::InputOutputArray, cv::InputArray)", "void cv::accumulateSquare(cv::InputArray, cv::InputOutputArray, cv::InputArray)", "void cv::accumulate(cv::InputArray, cv::InputOutputArray, cv::InputArray)", "dst.size == src.size && dst.channels() == cn", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/accum.cpp", "mask.empty() || (mask.size == src.size && mask.type() == CV_8U)", "func != 0", "src2.size && src1.size && src2.type() == src1.type()", "dst.size == src1.size && dst.channels() == cn", "mask.empty() || (mask.size == src1.size && mask.type() == CV_8U)", "void cv::accumulateWeighted(cv::InputArray, cv::InputOutputArray, double, cv::InputArray)", "@void cv::getScharrKernels(cv::OutputArray, cv::OutputArray, int, int, bool, int)", "void cvLaplace(void const*, void*, int)", "ktype == CV_32F || ktype == CV_64F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/deriv.cpp", "dx >= 0 && dy >= 0 && dx+dy == 1", "The kernel size must be odd and not larger than 31", "dx >= 0 && dy >= 0 && dx+dy > 0", "ksize > order", "src.size() == dst.size() && src.channels() == dst.channels()", "void cv::getSobelKernels(cv::OutputArray, cv::OutputArray, int, int, int, bool, int)", "void cvSobel(void const*, void*, int, int, int)", "N2cv18ResizeArea_InvokerIddEE", "N2cv22resizeAreaFast_InvokerIddNS_19ResizeAreaFastNoVecIddEEEE", "N2cv22resizeAreaFast_InvokerIffNS_19ResizeAreaFastNoVecIffEEEE", "N2cv22resizeAreaFast_InvokerIsfNS_17ResizeAreaFastVecIsEEEE", "N2cv22resizeAreaFast_InvokerItfNS_17ResizeAreaFastVecItEEEE", "N2cv22resizeAreaFast_InvokerIhiNS_17ResizeAreaFastVecIhEEEE", "N2cv18ResizeArea_InvokerIffEE", "N2cv18ResizeArea_InvokerIsfEE", "N2cv18ResizeArea_InvokerItfEE", "N2cv18ResizeArea_InvokerIhfEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIddfEENS_12VResizeCubicIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIfffEENS_12VResizeCubicIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIsffEENS_12VResizeCubicIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicItffEENS_12VResizeCubicItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIhisEENS_12VResizeCubicIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IddfEENS_15VResizeLanczos4IddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IfffEENS_15VResizeLanczos4IfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IsffEENS_15VResizeLanczos4IsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4ItffEENS_15VResizeLanczos4ItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IhisEENS_15VResizeLanczos4IhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIddfLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIfffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIsffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearItffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIhisLi2048ENS_12HResizeNoVecEEENS_13VResizeLinearIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv15resizeNNInvokerE", "N2cv12RemapInvokerE", "N2cv17warpAffineInvokerE", "N2cv22warpPerspectiveInvokerE", "void cv::warpPerspective(cv::InputArray, cv::OutputArray, cv::InputArray, cv::Size, int, int, const Scalar&)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<float, float, float>, VResize = cv::VResizeCubic<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<short int, float, float>, VResize = cv::VResizeCubic<short int, float, float, cv::Cast<float, short int>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "void cv::remap(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, int, int, const Scalar&)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, void const*, int, const Scalar&) [with CastOp = cv::FixedPtCast<int, unsigned char, 15>, VecOp = cv::RemapNoVec, AT = short int, cv::Scalar = cv::Scalar_<double>]", "CvMat* cvGetPerspectiveTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<double, double, float>, VResize = cv::VResizeCubic<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "void cv::warpAffine(cv::InputArray, cv::OutputArray, cv::InputArray, cv::Size, int, int, const Scalar&)", "void cvWarpAffine(const CvArr*, CvArr*, const CvMat*, int, CvScalar)", "void cvLinearPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<short unsigned int, float, float>, VResize = cv::VResizeLanczos4<short unsigned int, float, float, cv::Cast<float, short unsigned int>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, void const*, int, const Scalar&) [with CastOp = cv::Cast<float, float>, VecOp = cv::RemapNoVec, AT = float, cv::Scalar = cv::Scalar_<double>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<unsigned char, int, short int>, VResize = cv::VResizeCubic<unsigned char, int, short int, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = short int, cv::Size = cv::Size_<int>]", "void const* cv::initInterTab2D(int, bool)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, void const*, int, const Scalar&) [with CastOp = cv::Cast<float, short int>, VecOp = cv::RemapNoVec, AT = float, cv::Scalar = cv::Scalar_<double>]", "void cvResize(const CvArr*, CvArr*, int)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, void const*, int, const Scalar&) [with CastOp = cv::Cast<double, double>, VecOp = cv::RemapNoVec, AT = float, cv::Scalar = cv::Scalar_<double>]", "cv::Mat cv::getAffineTransform(cv::InputArray, cv::InputArray)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<short int, float, float>, VResize = cv::VResizeLanczos4<short int, float, float, cv::Cast<float, short int>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<float, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "cv::Mat cv::getPerspectiveTransform(cv::InputArray, cv::InputArray)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<float, float, float>, VResize = cv::VResizeLanczos4<float, float, float, cv::Cast<float, float>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "void cv::convertMaps(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, int, bool)", "CvMat* cvGetAffineTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)", "CvMat* cv2DRotationMatrix(CvPoint2D32f, double, double, CvMat*)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<short int, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<short int, float, float, cv::Cast<float, short int>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<double, double, float>, VResize = cv::VResizeLanczos4<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<unsigned char, int, short int, 2048, cv::HResizeNoVec>, VResize = cv::VResizeLinear<unsigned char, int, short int, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = short int, cv::Size = cv::Size_<int>]", "void cv::invertAffineTransform(cv::InputArray, cv::OutputArray)", "void cv::remapBilinear(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, void const*, int, const Scalar&) [with CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::RemapNoVec, AT = float, cv::Scalar = cv::Scalar_<double>]", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<short unsigned int, float, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<short unsigned int, float, float, cv::Cast<float, short unsigned int>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "void cvLogPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)", "void cvRemap(const CvArr*, CvArr*, const CvArr*, const CvArr*, int, CvScalar)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeCubic<short unsigned int, float, float>, VResize = cv::VResizeCubic<short unsigned int, float, float, cv::Cast<float, short unsigned int>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "void cvWarpPerspective(const CvArr*, CvArr*, const CvMat*, int, CvScalar)", "void cv::resize(cv::InputArray, cv::OutputArray, cv::Size, double, double, int)", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLanczos4<unsigned char, int, short int>, VResize = cv::VResizeLanczos4<unsigned char, int, short int, cv::FixedPtCast<int, unsigned char, 22>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = short int, cv::Size = cv::Size_<int>]", "cn <= 4 && ssize.area() > 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/imgwarp.cpp", "(m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) || (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) || (m1type == CV_32FC1 && m2type == CV_32FC1) || (m1type == CV_32FC2 && !m2->data)", "dstm1type == CV_16SC2 || dstm1type == CV_32FC1 || dstm1type == CV_32FC2", "Unsupported combination of input/output matrices", "src.cols > 0 && src.rows > 0", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 3 && M0.cols == 3", "matM.rows == 2 && matM.cols == 3", "src.checkVector(2, CV_32F) == 4 && dst.checkVector(2, CV_32F) == 4", "src.checkVector(2, CV_32F) == 3 && dst.checkVector(2, CV_32F) == 3", "src.type() == dst.type()", "M.size() == M0.size()", "Unknown/unsupported interpolation type", "Unknown interpolation method", "map1.size().area() > 0", "!map2.data || (map2.size() == map1.size())", "nnfunc != 0", "ifunc != 0", "((map1.type() == CV_32FC2 || map1.type() == CV_16SC2) && !map2.data) || (map1.type() == CV_32FC1 && map2.type() == CV_32FC1)", "src.type() == dst.type() && dst.size() == mapx.size()", "dst0.data == dst.data", "(M0.type() == CV_32F || M0.type() == CV_64F) && M0.rows == 2 && M0.cols == 3", "ssize.area() > 0", "dsize.area() || (inv_scale_x > 0 && inv_scale_y > 0)", "dsize.area()", "func != 0", "func != 0 && cn <= 4", "ksize <= MAX_ESIZE", "M should be >0", "cv::resizeGeneric_Invoker<HResize, VResize>::resizeGeneric_Invoker(const cv::Mat&, cv::Mat&, int const*, int const*, const AT*, const AT*, const Size&, const Size&, int, int, int) [with HResize = cv::HResizeLinear<double, double, float, 1, cv::HResizeNoVec>, VResize = cv::VResizeLinear<double, double, float, cv::Cast<double, double>, cv::VResizeNoVec>, cv::resizeGeneric_Invoker<HResize, VResize>::AT = float, cv::Size = cv::Size_<int>]", "void cv::initInterTab1D(int, float*, int)", "vector::_M_fill_insert", "Number of channels in input image must be 1 or 3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/floodfill.cpp", "Connectivity must be 4, 0(=4) or 8", "lo_diff and up_diff must be non-negative", "Seed point is outside of image", "mask must be 2 pixel wider and 2 pixel taller than filled image", "void cvFloodFill(CvArr*, CvPoint, CvScalar, CvScalar, CvScalar, CvConnectedComp*, int, CvArr*)", "void (anonymous namespace)::GHT_Guil_Full::calcOrientation()", "*N12_GLOBAL__N_120GHT_Ballard_PosScale6WorkerE", "virtual void (anonymous namespace)::GHT_Ballard_Pos::calcHist()", "*N12_GLOBAL__N_120GHT_Ballard_PosScaleE", "N2cv16GeneralizedHoughE", "*N12_GLOBAL__N_115GHT_Ballard_PosE", "vector::reserve", "imageEdges.type() == CV_8UC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/generalized_hough.cpp", "imageDx.type() == CV_32FC1 && imageDx.size() == imageSize", "imageDy.type() == imageDx.type() && imageDy.size() == imageSize", "levels > 0 && r_table.size() == static_cast<size_t>(levels + 1)", "dp > 0.0", "minScale > 0.0 && minScale < maxScale", "scaleStep > 0.0", "minAngle >= 0.0 && minAngle < maxAngle && maxAngle <= 360.0", "angleStep > 0.0 && angleStep < 360.0", "GeneralizedHough.POSITION", "GeneralizedHough.POSITION_SCALE", "GeneralizedHough.POSITION_ROTATION", "GeneralizedHough.POSITION_SCALE_ROTATION", "levels > 0", "edges.type() == CV_8UC1", "dx.type() == CV_32FC1 && dx.size == edges.size", "dy.type() == dx.type() && dy.size == edges.size", "vector::_M_fill_insert", "Minimum distance between the centers of the detected objects.", "minDist", "R-Table levels.", "levels", "The accumulator threshold for the template centers at the detection stage. The smaller it is, the more false positions may be detected.", "votesThreshold", "Inverse ratio of the accumulator resolution to the image resolution.", "Minimal scale to detect.", "minScale", "Maximal scale to detect.", "maxScale", "Scale step.", "scaleStep", "Minimal rotation angle to detect in degrees.", "minAngle", "Maximal rotation angle to detect in degrees.", "maxAngle", "Angle step in degrees.", "angleStep", "Maximal size of inner buffers.", "maxSize", "Angle difference in degrees between two points in feature.", "Feature table levels.", "Maximal difference between angles that treated as equal.", "angleEpsilon", "Angle threshold.", "angleThresh", "Scale threshold.", "scaleThresh", "Position threshold.", "posThresh", "!GHT_Ballard_Pos_info_auto.name().empty()", "!GHT_Ballard_PosScale_info_auto.name().empty()", "!GHT_Ballard_PosRotation_info_auto.name().empty()", "!GHT_Guil_Full_info_auto.name().empty()", "Unsupported method", "templ.type() == CV_8UC1", "cannyThreshold > 0", "image.type() == CV_8UC1", "templFeatures.size() == static_cast<size_t>(levels + 1)", "imageFeatures.size() == templFeatures.size()", "posThresh > 0", "votesThreshold > 0", "angleThresh > 0", "scaleThresh > 0", "!hasVotes || voteOutBuf.size() == oldSize", "!hasVotes || voteOutBuf.size() == posOutBuf.size()", "templEdges.type() == CV_8UC1", "templDx.type() == CV_32FC1 && templDx.size() == templSize", "templDy.type() == templDx.type() && templDy.size() == templSize", "void (anonymous namespace)::GHT_Guil_Full::calcPosition(double, int, double, int)", "void (anonymous namespace)::GHT_Guil_Full::calcScale(double)", "*N12_GLOBAL__N_123GHT_Ballard_PosRotationE", "void (anonymous namespace)::GHT_Pos::filterMinDist()", "void cv::GeneralizedHough::setTemplate(cv::InputArray, int, cv::Point)", "virtual void (anonymous namespace)::GHT_Ballard_PosScale::findPosInHist()", "void (anonymous namespace)::GHT_Guil_Full::getContourPoints(const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<(anonymous namespace)::GHT_Guil_Full::ContourPoint>&)", "static cv::Ptr<cv::GeneralizedHough> cv::GeneralizedHough::create(int)", "*N12_GLOBAL__N_123GHT_Ballard_PosRotation6WorkerE", "void (anonymous namespace)::GHT_Guil_Full::buildFeatureList(const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<std::vector<(anonymous namespace)::GHT_Guil_Full::Feature> >&, cv::Point2d)", "virtual void (anonymous namespace)::GHT_Ballard_Pos::findPosInHist()", "void cv::GeneralizedHough::detect(cv::InputArray, cv::OutputArray, cv::OutputArray, int)", "virtual void (anonymous namespace)::GHT_Ballard_PosScale::calcHist()", "virtual void (anonymous namespace)::GHT_Ballard_PosRotation::findPosInHist()", "virtual void (anonymous namespace)::GHT_Ballard_Pos::processTempl()", "*N12_GLOBAL__N_113GHT_Guil_FullE", "void (anonymous namespace)::GHT_Pos::convertTo(cv::OutputArray, cv::OutputArray)", "*N12_GLOBAL__N_17GHT_PosE", "virtual void (anonymous namespace)::GHT_Ballard_PosRotation::calcHist()", "N2cv6RowSumIddEE", "N2cv6RowSumIfdEE", "N2cv6RowSumIsdEE", "N2cv6RowSumIiiEE", "N2cv6RowSumIsiEE", "N2cv6RowSumItdEE", "N2cv6RowSumItiEE", "N2cv6RowSumIhdEE", "N2cv6RowSumIhiEE", "N2cv9ColumnSumIddEE", "N2cv9ColumnSumIidEE", "N2cv9ColumnSumIdfEE", "N2cv9ColumnSumIifEE", "N2cv9ColumnSumIiiEE", "N2cv9ColumnSumIdsEE", "N2cv9ColumnSumIisEE", "N2cv9ColumnSumIdtEE", "N2cv9ColumnSumIitEE", "N2cv9ColumnSumIdhEE", "N2cv9ColumnSumIihEE", "N2cv26BilateralFilter_8u_InvokerE", "N2cv27BilateralFilter_32f_InvokerE", "N2cv34adaptiveBilateralFilter_8u_InvokerE", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = float, uchar = unsigned char]", "void cv::adaptiveBilateralFilter(cv::InputArray, cv::OutputArray, cv::Size, double, double, cv::Point, int)", "void cv::medianBlur(cv::InputArray, cv::OutputArray, int)", "cv::Ptr<cv::BaseRowFilter> cv::getRowSumFilter(int, int, int, int)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = unsigned char, uchar = unsigned char]", "void cv::adaptiveBilateralFilter_8u(const cv::Mat&, cv::Mat&, cv::Size, double, double, cv::Point, int)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = short unsigned int, uchar = unsigned char]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = double, uchar = unsigned char]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = double, uchar = unsigned char]", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = short int, uchar = unsigned char]", "cv::Ptr<cv::BaseColumnFilter> cv::getColumnSumFilter(int, int, int, int, double)", "cv::Mat cv::getGaussianKernel(int, double, int)", "=CV_MAT_CN(sumType) == CV_MAT_CN(srcType)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/smooth.cpp", "Unsupported combination of source format (=%d), and buffer format (=%d)", "CV_MAT_CN(sumType) == CV_MAT_CN(dstType)", "Unsupported combination of sum format (=%d), and destination format (=%d)", "ktype == CV_32F || ktype == CV_64F", "ksize.width > 0 && ksize.width % 2 == 1 && ksize.height > 0 && ksize.height % 2 == 1", "ksize % 2 == 1", "src.depth() == CV_8U && (cn == 1 || cn == 3 || cn == 4)", "(src.type() == CV_8UC1 || src.type() == CV_8UC3) && src.type() == dst.type() && src.size() == dst.size() && src.data != dst.data", "(src.type() == CV_32FC1 || src.type() == CV_32FC3) && src.type() == dst.type() && src.size() == dst.size() && src.data != dst.data", "Bilateral filtering is only implemented for 8u and 32f images", "dst.size() == src.size() && (smooth_type == CV_BLUR_NO_SCALE || dst.type() == src.type())", "The destination image does not have the proper type", "vector::_M_fill_insert", "sumCount == ksize-1", "(ksize.width & 1) && (ksize.height & 1)", "src.type() == CV_8UC1 || src.type() == CV_8UC3", "anchor.inside(Rect(0, 0, ksize.width, ksize.height))", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/precomp.hpp", "Adaptive Bilateral filtering is only implemented for 8u images", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = int, T = int, uchar = unsigned char]", "void cv::bilateralFilter_32f(const cv::Mat&, cv::Mat&, int, double, double, int)", "void cv::bilateralFilter_8u(const cv::Mat&, cv::Mat&, int, double, double, int)", "virtual void cv::ColumnSum<int, unsigned char>::operator()(const uchar**, uchar*, int, int, int)", "cv::adaptiveBilateralFilter_8u_Invoker::adaptiveBilateralFilter_8u_Invoker(cv::Mat&, const cv::Mat&, cv::Size, double, double, cv::Point)", "cv::Ptr<cv::FilterEngine> cv::createGaussianFilter(int, cv::Size, double, double, int)", "cv::Point cv::normalizeAnchor(cv::Point, cv::Size)", "void cv::ColumnSum<ST, T>::operator()(const uchar**, uchar*, int, int, int) [with ST = double, T = float, uchar = unsigned char]", "void cvSmooth(void const*, void*, int, int, int, double, double)", "virtual void cv::ColumnSum<int, short unsigned int>::operator()(const uchar**, uchar*, int, int, int)", "void cv::bilateralFilter(cv::InputArray, cv::OutputArray, int, double, double, int)", "virtual void cv::ColumnSum<int, short int>::operator()(const uchar**, uchar*, int, int, int)", "int cv::Subdiv2D::findNearest(cv::Point2f, cv::Point2f*)", "int cv::Subdiv2D::insert(cv::Point2f)", "Subdivision is empty", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/subdivision2d.cpp", "edge > 0", "Subdiv2D::locate returned invalid location = %d", "edgeDst(edge, &t) > 0", "edgeOrg( edge, &t ) > 0", "edgeOrg(e) == edgeOrg(o_next)", "edgeOrg(e) == edgeOrg(o_prev)", "edgeDst(e) == edgeDst(d_next)", "edgeDst(e) == edgeDst(d_prev)", "edgeDst(o_next) == edgeOrg(d_prev)", "edgeDst(o_prev) == edgeOrg(d_next)", "getEdge(getEdge(getEdge(e,NEXT_AROUND_LEFT),NEXT_AROUND_LEFT),NEXT_AROUND_LEFT) == e", "getEdge(getEdge(getEdge(e,NEXT_AROUND_RIGHT),NEXT_AROUND_RIGHT),NEXT_AROUND_RIGHT) == e", "int cv::Subdiv2D::locate(cv::Point2f, int&, int&)", "void cv::Subdiv2D::checkSubdiv() const", "double cv::contourArea(cv::InputArray, bool)", "cv::Seq<_Tp>::Seq(const CvSeq*) [with _Tp = CvConvexityDefect, CvSeq = CvSeq]", "void cv::minEnclosingCircle(cv::InputArray, cv::Point2f&, float&)", "double cv::pointPolygonTest(cv::InputArray, cv::Point2f, bool)", "void cv::findContours(cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArray, int, int, cv::Point)", "void cv::convexityDefects(cv::InputArray, cv::InputArray, cv::OutputArray)", "_CvContourScanner* cvStartFindContours(void*, CvMemStorage*, int, int, int, CvPoint)", "cv::Seq<_Tp>::Seq(const CvSeq*) [with _Tp = CvSeq*, CvSeq = CvSeq]", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/contours.cpp", "[Start]FindContours support only 8uC1 and 32sC1 images", "vector::_M_fill_insert", "0 <= contourIdx && contourIdx < (int)last", "npoints > 0", "hierarchy.total() == ncontours && hierarchy.type() == CV_32SC4", "curve.checkVector(2) >= 0 && (curve.depth() == CV_32F || curve.depth() == CV_32S)", "points.checkVector(2) >= 0 && (points.depth() == CV_32F || points.depth() == CV_32S)", "contour.checkVector(2) >= 0 && (contour.depth() == CV_32F || contour.depth() == CV_32S)", "contour1.checkVector(2) >= 0 && contour2.checkVector(2) >= 0 && (contour1.depth() == CV_32F || contour1.depth() == CV_32S) && contour1.depth() == contour2.depth()", "nelems >= 0 && (depth == CV_32F || depth == CV_32S)", "(is2d || is3d) && (points.depth() == CV_32F || points.depth() == CV_32S)", "l.isContinuous()", "!_seq || _seq->elem_size == sizeof(_Tp)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "ptnum > 3", "hull.checkVector(1, CV_32S) > 2", "0 <= idx0 && idx0 < ptnum", "0 <= idx1 && idx1 < ptnum", "0 <= idx2 && idx2 < ptnum", "d.depth >= 0", "npoints >= 0 && (depth == CV_32S || depth == CV_32F)", "NULL double CvSeq pointer", "Nonzero offset is not supported in CV_LINK_RUNS yet", "NULL storage pointer", "Contour header size must be >= sizeof(CvContour)", "Input array must be 8uC1 or 8sC1", "ci.isContinuous()", "CvSeq* cvFindNextContour(CvContourScanner)", "void cvStartReadChainPoints(CvChain*, CvChainPtReader*)", "CvPoint cvReadChainPoint(CvChainPtReader*)", "int icvFindContoursInInterval(const CvArr*, CvMemStorage*, CvSeq**, int)", "CvSeq* cvEndFindContours(_CvContourScanner**)", "cv::Rect cv::boundingRect(cv::InputArray)", "void cv::convexHull(cv::InputArray, cv::OutputArray, bool, bool)", "cv::RotatedRect cv::fitEllipse(cv::InputArray)", "double cv::arcLength(cv::InputArray, bool)", "void cv::approxPolyDP(cv::InputArray, cv::OutputArray, double, bool)", "bool cv::isContourConvex(cv::InputArray)", "double cv::matchShapes(cv::InputArray, cv::InputArray, int, double)", "void cv::drawContours(cv::InputOutputArray, cv::InputArrayOfArrays, int, const Scalar&, int, int, cv::InputArray, int, cv::Point)", "void cvSubstituteContour(CvContourScanner, CvSeq*)", "int cvFindContours(void*, CvMemStorage*, CvSeq**, int, int, int, CvPoint)", "cv::RotatedRect cv::minAreaRect(cv::InputArray)", "void cv::fitLine(cv::InputArray, cv::OutputArray, int, double, double, double)", "void cvPyrMeanShiftFiltering(const CvArr*, CvArr*, double, double, int, CvTermCriteria)", "void cvWatershed(const CvArr*, CvArr*)", "Only 8-bit, 3-channel input images are supported", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/segmentation.cpp", "Only 32-bit, 1-channel output images are supported", "The input and output images must have the same size", "The number of pyramid levels is too large or negative", "Only 8-bit, 3-channel images are supported", "The input and output images must have the same type", "N2cv14MorphRowFilterINS_5MaxOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIhEENS_13MorphRowNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIhEENS_16MorphColumnNoVecEEE", "N2cv11MorphFilterINS_5MinOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIdEENS_10MorphNoVecEEE", "N2cv16MorphologyRunnerE", "void cv::morphologyEx(cv::InputArray, cv::OutputArray, int, cv::InputArray, cv::Point, int, int, const Scalar&)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<float>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "void cvErode(const CvArr*, CvArr*, IplConvKernel*, int)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<unsigned char>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "void cvReleaseStructuringElement(IplConvKernel**)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<double>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<short int>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<float>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "void cvMorphologyEx(void const*, void*, void*, IplConvKernel*, int, int)", "cv::Point cv::normalizeAnchor(cv::Point, cv::Size)", "IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)", "void cv::morphOp(int, cv::InputArray, cv::OutputArray, cv::InputArray, cv::Point, int, int, const Scalar&)", "cv::Ptr<cv::FilterEngine> cv::createMorphologyFilter(int, int, cv::InputArray, cv::Point, int, int, const Scalar&)", "anchor.inside(Rect(0, 0, ksize.width, ksize.height))", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/precomp.hpp", "op == MORPH_ERODE || op == MORPH_DILATE", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/morph.cpp", "Unsupported data type (=%d)", "shape == MORPH_RECT || shape == MORPH_CROSS || shape == MORPH_ELLIPSE", "unknown morphological operation", "cols > 0 && rows > 0 && anchor.inside(cv::Rect(0,0,cols,rows)) && (shape != CV_SHAPE_CUSTOM || values != 0)", "src.size() == dst.size() && src.type() == dst.type()", "vector::_M_fill_insert", "_kernel.type() == CV_8U", "depth == CV_8U || depth == CV_16U || depth == CV_16S || depth == CV_32F || depth == CV_64F", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<short int>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<double>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "cv::Ptr<cv::BaseRowFilter> cv::getMorphologyRowFilter(int, int, int, int)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MaxOp<short unsigned int>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<unsigned char>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "void cvDilate(const CvArr*, CvArr*, IplConvKernel*, int)", "cv::Mat cv::getStructuringElement(int, cv::Size, cv::Point)", "cv::Ptr<cv::BaseFilter> cv::getMorphologyFilter(int, int, cv::InputArray, cv::Point)", "cv::MorphFilter<Op, VecOp>::MorphFilter(const cv::Mat&, cv::Point) [with Op = cv::MinOp<short unsigned int>, VecOp = cv::MorphNoVec, cv::Point = cv::Point_<int>]", "cv::Ptr<cv::BaseColumnFilter> cv::getMorphologyColumnFilter(int, int, int, int)", "float cvCalcEMD2(const CvArr*, const CvArr*, int, CvDistanceFunction, const CvArr*, CvArr*, float*, void*)", "int icvInitEMD(float const*, int, float const*, int, int, CvDistanceFunction, void*, float const*, int, CvEMDState*, float*, cv::AutoBuffer<char>&)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/emd.cpp", "The arrays must have equal number of columns (which is number of dimensions but 1)", "The array must have equal types", "The signatures must be 32fC1", "The flow matrix size does not match to the signatures' sizes", "The flow matrix must be 32fC1", "Only one of cost matrix or distance function should be non-NULL in case of user-defined distance", "The lower boundary can not be calculated if the cost matrix is used", "The cost matrix size does not match to the signatures' sizes", "The cost matrix must be 32fC1", "In case of user-defined distance Distance function is undefined", "Number of dimensions can be 0 only if a user-defined metric is used", "Bad or unsupported metric type", "double cvArcLength(void const*, CvSlice, int)", "double cvContourArea(void const*, CvSlice, int)", "Unsupported sequence type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/shapedescr.cpp", "Null center or radius pointers", "The passed sequence is not a valid contour", "Only curves with integer coordinates are supported in case of contour slice", "(icvContourSecArea( contour, slice, &area )) >= 0", "Number of points should be >= 5", "The image/matrix format is not supported by the function", "CvRect cvBoundingRect(CvArr*, int)", "CvBox2D cvFitEllipse2(const CvArr*)", "int cvMinEnclosingCircle(void const*, CvPoint2D32f*, float*)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<double, 6>, VecOp = cv::NoVec<double, double>]", "void cvReleasePyramid(CvMat***, int)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short unsigned int, 6>, VecOp = cv::NoVec<int, short unsigned int>]", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<double, 8>, VecOp = cv::NoVec<double, double>]", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short int, 8>, VecOp = cv::NoVec<int, short int>]", "CvMat** cvCreatePyramid(const CvArr*, int, double, const CvSize*, CvArr*, int, int)", "void cv::buildPyramid(cv::InputArray, cv::OutputArrayOfArrays, int, int)", "void cv::pyrDown(cv::InputArray, cv::OutputArray, const Size&, int)", "void cvPyrUp(void const*, void*, int)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short int, 6>, VecOp = cv::NoVec<int, short int>]", "borderType != BORDER_CONSTANT", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/pyramids.cpp", "borderType == BORDER_DEFAULT", "_filter == CV_GAUSSIAN_5x5 && src.type() == dst.type()", "The number of extra layers must be non negative", "The buffer is too small to fit the pyramid", "std::abs(dsize.width - ssize.width*2) == dsize.width % 2 && std::abs(dsize.height - ssize.height*2) == dsize.height % 2", "!_src.empty()", "std::abs(dsize.width*2 - ssize.width) <= 2 && std::abs(dsize.height*2 - ssize.height) <= 2", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<float, 8>, VecOp = cv::NoVec<float, float>]", "void cvPyrDown(void const*, void*, int)", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<short unsigned int, 8>, VecOp = cv::NoVec<int, short unsigned int>]", "void cv::pyrDown_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<unsigned char, 8>, VecOp = cv::NoVec<int, unsigned char>]", "void cv::pyrUp(cv::InputArray, cv::OutputArray, const Size&, int)", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FltCast<float, 6>, VecOp = cv::NoVec<float, float>]", "void cv::pyrUp_(const cv::Mat&, cv::Mat&, int) [with CastOp = cv::FixPtCast<unsigned char, 6>, VecOp = cv::NoVec<int, unsigned char>]", "double cvPointPolygonTest(const CvArr*, CvPoint2D32f, int)", "NULL vertex array pointer", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/geometry.cpp", "Chains are not supported. Convert them to polygonal representation using cvApproxChains()", "Input contour is neither a valid sequence nor a matrix", "p1.depth() == CV_32S || p1.depth() == CV_32F", "p2.depth() == CV_32S || p2.depth() == CV_32F", "n >= 0 && m >= 0", "temp.ptr<Point2f>() == dst", "float cv::intersectConvexConvex(cv::InputArray, cv::InputArray, cv::OutputArray, bool)", "void cvBoxPoints(CvBox2D, CvPoint2D32f*)", "N2cv12DTRowInvokerE", "N2cv15DTColumnInvokerE", "void icvTrueDistTrans(const CvMat*, CvMat*)", "void icvDistanceATS_L1_8u(const CvMat*, CvMat*)", "source image must be 8uC1 and the distance map must be 32fC1 (or 8uC1 in case of simple L1 distance transform)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/distransform.cpp", "the source and the destination images must be of the same size", "Mask size should be 3 or 5 or 0 (presize)", "The input image must have 8uC1 type and the output one must have 32fC1 type", "the output array of labels must be 32sC1", "the array of labels has a different size", "3x3 mask can not be used for \"labeled\" distance transform. Use 5x5 mask", "CV_IS_MASK_ARR( src ) && CV_MAT_TYPE( dst->type ) == CV_8UC1", "CV_ARE_SIZES_EQ( src, dst )", "void cvDistTransform(void const*, void*, int, int, float const*, void*, int)", "void cvIntegral(const CvArr*, CvArr*, CvArr*, CvArr*)", "void cv::integral(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/sumpixels.cpp", "sum.data == sum0.data && sqsum.data == sqsum0.data && tilted.data == tilted0.data", "NULL pointer to line parameters", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/linefit.cpp", "The sequence has no points", "Input sequence must consist of 2d points or 3d points", "Input array is not a sequence nor matrix", "Input array must be 1d continuous array of 2d or 3d points", "Both reps and aeps must be non-negative", "User-defined distance is not allowed", "(icvFitLine2D( (CvPoint2D32f*)points, ptseq->total, dist, (float)param, (float)reps, (float)aeps, line )) >= 0", "(icvFitLine3D( (CvPoint3D32f*)points, ptseq->total, dist, (float)param, (float)reps, (float)aeps, line )) >= 0", "void cvFitLine(const CvArr*, int, double, double, double, float*)", "void cv::crossCorr(const cv::Mat&, const cv::Mat&, cv::Mat&, cv::Size, int, cv::Point, double, int)", "void cvMatchTemplate(const CvArr*, const CvArr*, CvArr*, int)", "void cv::matchTemplate(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "img.dims <= 2 && templ.dims <= 2 && corr.dims <= 2", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/templmatch.cpp", "depth == tdepth || tdepth == CV_32F", "corrsize.height <= img.rows + templ.rows - 1 && corrsize.width <= img.cols + templ.cols - 1", "ccn == 1 || delta == 0", "the input arrays are too big", "CV_TM_SQDIFF <= method && method <= CV_TM_CCOEFF_NORMED", "(img.depth() == CV_8U || img.depth() == CV_32F) && img.type() == templ.type()", "img.rows >= templ.rows && img.cols >= templ.cols", "result.size() == cv::Size(std::abs(img.cols - templ.cols) + 1, std::abs(img.rows - templ.rows) + 1) && result.type() == CV_32F", "void cv::undistort(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray)", "float cv::initWideAngleProjMap(cv::InputArray, cv::InputArray, cv::Size, int, int, cv::OutputArray, cv::OutputArray, int, double)", "void cvUndistortPoints(const CvMat*, CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*)", "Unknown projection type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/undistort.cpp", "CV_IS_MAT(_src) && CV_IS_MAT(_dst) && (_src->rows == 1 || _src->cols == 1) && (_dst->rows == 1 || _dst->cols == 1) && _src->cols + _src->rows - 1 == _dst->rows + _dst->cols - 1 && (CV_MAT_TYPE(_src->type) == CV_32FC2 || CV_MAT_TYPE(_src->type) == CV_64FC2) && (CV_MAT_TYPE(_dst->type) == CV_32FC2 || CV_MAT_TYPE(_dst->type) == CV_64FC2)", "CV_IS_MAT(_cameraMatrix) && _cameraMatrix->rows == 3 && _cameraMatrix->cols == 3", "CV_IS_MAT(_distCoeffs) && (_distCoeffs->rows == 1 || _distCoeffs->cols == 1) && (_distCoeffs->rows*_distCoeffs->cols == 4 || _distCoeffs->rows*_distCoeffs->cols == 5 || _distCoeffs->rows*_distCoeffs->cols == 8)", "CV_IS_MAT(matR) && matR->rows == 3 && matR->cols == 3", "CV_IS_MAT(matP) && matP->rows == 3 && (matP->cols == 3 || matP->cols == 4)", "src.isContinuous() && (src.depth() == CV_32F || src.depth() == CV_64F) && ((src.rows == 1 && src.channels() == 2) || src.cols*src.channels() == 2)", "(distCoeffs0.cols == 1 || distCoeffs0.rows == 1) && (ndcoeffs == 4 || ndcoeffs == 5 || ndcoeffs == 8)", "cameraMatrix0.size() == Size(3,3)", "avg iters = %g\n", "m1type == CV_16SC2 || m1type == CV_32FC1 || m1type == CV_32FC2", "A.size() == Size(3,3) && A.size() == R.size()", "Ar.size() == Size(3,3) || Ar.size() == Size(4, 3)", "distCoeffs.size() == Size(1, 4) || distCoeffs.size() == Size(4, 1) || distCoeffs.size() == Size(1, 5) || distCoeffs.size() == Size(5, 1) || distCoeffs.size() == Size(1, 8) || distCoeffs.size() == Size(8, 1)", "mapx0.data == mapx.data && mapy0.data == mapy.data", "dst.data != src.data", "src.size() == dst.size() && src.type() == dst.type()", "cv::Point2f cv::mapPointSpherical(const Point2f&, float, cv::Vec4d*, int)", "void cv::initUndistortRectifyMap(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::Size, int, cv::OutputArray, cv::OutputArray)", "void cv::undistortPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray)", "void cvInitUndistortMap(const CvMat*, const CvMat*, CvArr*, CvArr*)", "void cvUndistort2(const CvArr*, CvArr*, const CvMat*, const CvMat*, const CvMat*)", "void cvInitUndistortRectifyMap(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvArr*, CvArr*)", "void checkMask(const cv::Mat&, const cv::Mat&)", "void GMM::calcInverseCovAndDeterm(int)", "void GCGraph<TWeight>::addTermWeights(int, TWeight, TWeight) [with TWeight = double]", "double GMM::operator()(int, cv::Vec3d) const", "GMM::GMM(cv::Mat&)", "mask is empty", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/grabcut.cpp", "mask must have CV_8UC1 type", "mask must have as many rows and cols as img", "mask element value must be equelGC_BGD or GC_FGD or GC_PR_BGD or GC_PR_FGD", "covDeterms[ci] > std::numeric_limits<double>::epsilon()", "dtrm > std::numeric_limits<double>::epsilon()", "_model must have CV_64FC1 type, rows == 1 and cols == 13*componentsCount", "i>=0 && i<(int)vtcs.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/gcgraph.hpp", "vector::reserve", "vector::_M_insert_aux", "j>=0 && j<(int)vtcs.size()", "w>=0 && revw>=0", "i != j", "vector::_M_fill_insert", "image is empty", "image mush have CV_8UC3 type", "!bgdSamples.empty() && !fgdSamples.empty()", "void GCGraph<TWeight>::addEdges(int, int, TWeight, TWeight) [with TWeight = double]", "bool GCGraph<TWeight>::inSourceSegment(int) [with TWeight = double]", "void cv::grabCut(cv::InputArray, cv::InputOutputArray, cv::Rect, cv::InputOutputArray, cv::InputOutputArray, int, int)", "void icvCalcAndWritePtIndices(CvPoint**, int*, int, int, CvSeq*, CvSeqWriter*)", "CvSeq* cvConvexHull2(const CvArr*, void*, int, int)", "int cvCheckContourConvexity(const CvArr*)", "Internal error", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/convhull.cpp", "Unsupported sequence type", "Destination must be valid memory storage or matrix", "The hull matrix should be continuous and have a single row or a single column", "The hull matrix size might be not enough to fit the hull", "The hull matrix must have the same type as input or 32sC1 (integers)", "Point sequence can not be empty if the output is matrix", "Input sequence is not a sequence of points", "Floating-point coordinates are not supported here", "Convex hull must represented as a sequence of indices or sequence of pointers", "Convex hull is neither sequence nor matrix", "The matrix should be 1-dimensional and continuous array of int's", "Convex hull is larger than the point sequence", "NULL storage pointer", "Input sequence must be polygon (closed 2d curve)", "CV_SEQ_ELTYPE(contour) == CV_32FC2", "CvSeq* cvConvexityDefects(const CvArr*, const CvArr*, CvMemStorage*)", "void cvCopyMakeBorder(const CvArr*, CvArr*, CvPoint, int, CvScalar)", "CvSeq* cvPointSeqFromMat(int, const CvArr*, CvContour*, CvSeqBlock*)", "double cv::PSNR(cv::InputArray, cv::InputArray)", "void cv::copyMakeBorder(cv::InputArray, cv::OutputArray, int, int, int, int, int, const Scalar&)", "arr != 0 && contour_header != 0 && block != 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/utils.cpp", "Input array is not a valid matrix", "The matrix can not be converted to point sequence because of inappropriate element type", "The matrix converted to point sequence must be 1-dimensional and continuous", "top >= 0 && bottom >= 0 && left >= 0 && right >= 0", "value[0] == value[1] && value[0] == value[2] && value[0] == value[3]", "src1.depth() == CV_8U", "dst.type() == src.type()", "void cvFindCornerSubPix(void const*, CvPoint2D32f*, int, CvSize, CvSize, CvTermCriteria)", "The source image must be 8-bit single-channel (CV_8UC1)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/cornersubpix.cpp", "(icvGetRectSubPix_8u32f_C1R( (uchar*)src->data.ptr, src->step, size, src_buffer, (win_w + 2) * sizeof( src_buffer[0] ), cvSize( win_w + 2, win_h + 2 ), cI )) >= 0", "ncorners >= 0 && corners.depth() == CV_32F", "void cv::cornerSubPix(cv::InputArray, cv::InputOutputArray, cv::Size, cv::Size, cv::TermCriteria)", "void cv::magSpectrums(cv::InputArray, cv::OutputArray)", "cv::Point2d cv::weightedCentroid(cv::InputArray, cv::Point, cv::Size, double*)", "cv::Point2d cv::phaseCorrelateRes(cv::InputArray, cv::InputArray, cv::InputArray, double*)", "void cv::divSpectrums(cv::InputArray, cv::InputArray, cv::OutputArray, int, bool)", "type == srcB.type() && srcA.size() == srcB.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/phasecorr.cpp", "type == CV_32FC1 || type == CV_32FC2 || type == CV_64FC1 || type == CV_64FC2", "type == CV_32FC1 || type == CV_64FC1", "src1.type() == src2.type()", "src1.type() == CV_32FC1 || src1.type() == CV_64FC1", "src1.size == src2.size", "src1.type() == window.type()", "src1.size == window.size", "void cv::createHanningWindow(cv::OutputArray, cv::Size, int)", "23EqualizeHistLut_Invoker", "28EqualizeHistCalcHist_Invoker", "void cvClearHist(CvHistogram*)", "CvHistogram* cvCreateHist(int, int*, CvHistType, float**, int)", "void cvReleaseHist(CvHistogram**)", "void cvThreshHist(CvHistogram*, double)", "double cvCompareHist(const CvHistogram*, const CvHistogram*, int)", "void cv::calcHist(const cv::Mat*, int, int const*, cv::InputArray, cv::OutputArray, int, int const*, float const**, bool, bool)", "double cv::compareHist(cv::InputArray, cv::InputArray, int)", "void cv::calcBackProject(cv::InputArrayOfArrays, const std::vector<int>&, cv::InputArray, cv::OutputArray, const std::vector<float>&, double)", "void* icvReadHist(CvFileStorage*, CvFileNode*)", "void cvSetHistBinRanges(CvHistogram*, float**, int)", "double cv::compareHist(const cv::SparseMat&, const cv::SparseMat&, int)", "void cv::histPrepareImages(const cv::Mat*, int, int const*, const cv::Mat&, int, int const*, float const**, bool, std::vector<unsigned char*>&, std::vector<int>&, cv::Size&, std::vector<double>&)", "void cv::calcHist(const cv::Mat*, int, int const*, const cv::Mat&, cv::SparseMat&, int, int const*, float const**, bool, bool, bool)", "void cvCalcArrHist(CvArr**, CvHistogram*, int, const CvArr*)", "void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)", "void cvCopyHist(const CvHistogram*, CvHistogram**)", "void cvCalcProbDensity(const CvHistogram*, const CvHistogram*, CvHistogram*, double)", "void cv::equalizeHist(cv::InputArray, cv::OutputArray)", "void cvCalcBayesianProb(CvHistogram**, int, CvHistogram**)", "void cvNormalizeHist(CvHistogram*, double)", "void cv::calcHist(cv::InputArrayOfArrays, const std::vector<int>&, cv::InputArray, cv::OutputArray, const std::vector<int>&, const std::vector<float>&, bool)", "void cv::calcBackProject(const cv::Mat*, int, int const*, const cv::SparseMat&, cv::OutputArray, float const**, double, bool)", "void cv::calcBackProject(const cv::Mat*, int, int const*, cv::InputArray, cv::OutputArray, float const**, double, bool)", "void cvCalcArrBackProjectPatch(CvArr**, CvArr*, CvSize, CvHistogram*, int, double)", "void cvCalcArrBackProject(CvArr**, CvArr*, const CvHistogram*)", "CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)", "opencv-hist", "type", "is_uniform", "have_ranges", "bins", "thresh", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/histogram.cpp", "Invalid histogram header", "Expected CvMatND", "Unknown Histogram type", "'thresh' node is missing", "H1.type() == H2.type() && H1.type() == CV_32F", "it.planes[0].isContinuous() && it.planes[1].isContinuous()", "Unknown comparison method", "dims > 0 && dims == H2.dims() && H1.type() == H2.type() && H1.type() == CV_32F", "H1.size(i) == H2.size(i)", "Invalid histogram header[s]", "One of histograms is sparse and other is not", "The histograms have different numbers of dimensions", "The histograms have different sizes", "NULL ranges pointer", "One of <ranges> elements is NULL", "Bin ranges should go in ascenting order", "Null histogram header pointer", "Null data pointer", "Only uniform bin ranges can be used here (to avoid memory allocation)", "Number of dimensions is out of range", "Null <sizes> pointer", "Invalid histogram type", "Destination double pointer is NULL", "NULL histogram array pointer", "Too small number of histograms", "The function supports dense histograms only", "scale must be positive", "Invalid histogram pointer[s]", "All histograms must have 32fC1 type", "src.type() == CV_8UC1", "vector::_M_fill_insert", "channels != 0 || nimages == dims", "images[j].channels() == 1", "c >= 0", "j < nimages", "images[j].size() == imsize && images[j].depth() == depth", "mask.size() == imsize && mask.channels() == 1", "depth == CV_8U", "ranges[i] && ranges[i][0] < ranges[i][1]", "ranges[i][k] < ranges[i][k+1]", "dims > 0 && histSize", "!mask.data || mask.type() == CV_8UC1", "nimages > 0 && dims > 0", "rsz == dims*2 || (rsz == 0 && images.depth(0) == CV_8U)", "csz == 0 || csz == dims", "dims > 0 && hist.data", "H0.isContinuous()", "nimages > 0", "rsz == dims*2 || (rsz == 2 && _1d) || (rsz == 0 && images.depth(0) == CV_8U)", "csz == 0 || csz == dims || (csz == 1 && _1d)", "dims > 0", "Bad histogram pointer", "Null double array pointer", "_dst.size() == images[0].size() && _dst.depth() == images[0].depth()", "Bad normalization factor (set it to 1.0 if unsure)", "The patch width and height must be positive", "Resultant image must have 32fC1 type", "The output map must be (W-w+1 x H-h+1), where the input images are (W x H) each and the patch is (w x h)", "void cv::preCornerDetect(cv::InputArray, cv::OutputArray, int, int)", "void cvCornerHarris(const CvArr*, CvArr*, int, int, double)", "void cv::cornerEigenValsVecs(const cv::Mat&, cv::Mat&, int, int, int, double, int)", "void cvCornerEigenValsAndVecs(void const*, void*, int, int)", "void cvPreCornerDetect(void const*, void*, int)", "src.type() == CV_8UC1 || src.type() == CV_32FC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/corner.cpp", "src.size() == dst.size() && dst.type() == CV_32FC1", "src.rows == dst.rows && src.cols*6 == dst.cols*dst.channels() && dst.depth() == CV_32F", "void cvCornerMinEigenVal(const CvArr*, CvArr*, int, int)", "N2cv5CLAHEE", "*N12_GLOBAL__N_124CLAHE_Interpolation_BodyE", "CLAHE", "clipLimit", "tilesX", "tilesY", "src.type() == CV_8UC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/clahe.cpp", "virtual void (anonymous namespace)::CLAHE_Impl::apply(cv::InputArray, cv::OutputArray)", "*N12_GLOBAL__N_118CLAHE_CalcLut_BodyE", "*N12_GLOBAL__N_110CLAHE_ImplE", "double cvMatchShapes(void const*, void const*, int, double)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/matchcontours.cpp", "Unknown comparison method", "N2cv15ThresholdRunnerE", "double cv::threshold(cv::InputArray, cv::OutputArray, double, double, int)", "void cvAdaptiveThreshold(void const*, void*, double, int, int, int, double)", "void cv::thresh_32f(const cv::Mat&, cv::Mat&, float, float, int)", "void cv::adaptiveThreshold(cv::InputArray, cv::OutputArray, double, int, int, int, double)", "Unknown threshold type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/thresh.cpp", "src.type() == CV_8UC1", "blockSize % 2 == 1 && blockSize > 1", "Unknown/unsupported adaptive threshold method", "Unknown/unsupported threshold type", "src.size == dst.size && src.channels() == dst.channels() && (src.depth() == dst.depth() || dst.depth() == CV_8U)", "src.size == dst.size && src.type() == dst.type()", "double cvThreshold(void const*, void*, double, double, int)", "void cv::thresh_16s(const cv::Mat&, cv::Mat&, short int, short int, int)", "void cv::thresh_8u(const cv::Mat&, cv::Mat&, uchar, uchar, int)", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_10RGB2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_10RGB5x52RGBEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIhEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayItEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB5x52GrayEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIhEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11Gray2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_fEEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi1EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi1EEE", "N2cv21YUV420p2RGB888InvokerILi0EEE", "N2cv21YUV420p2RGB888InvokerILi2EEE", "N2cv23YUV420p2RGBA8888InvokerILi0EEE", "N2cv23YUV420p2RGBA8888InvokerILi2EEE", "N2cv22RGB888toYUV420pInvokerILi0EEE", "N2cv22RGB888toYUV420pInvokerILi2EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi1EEE", "N2cv20CvtColorLoop_InvokerINS_10RGBA2mRGBAIhEEEE", "N2cv20CvtColorLoop_InvokerINS_10mRGBA2RGBAIhEEEE", "cv::RGB2Lab_b::RGB2Lab_b(int, int, float const*, float const*, bool)", "void cvCvtColor(const CvArr*, CvArr*, int)", "cv::RGB2Lab_f::RGB2Lab_f(int, int, float const*, float const*, bool)", "cv::RGB2Luv_f::RGB2Luv_f(int, int, float const*, float const*, bool)", "coeffs[i*3] >= 0 && coeffs[i*3+1] >= 0 && coeffs[i*3+2] >= 0 && coeffs[i*3] + coeffs[i*3+1] + coeffs[i*3+2] < 1.5f", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/color.cpp", "hrange == 180 || hrange == 256", "depth == CV_8U || depth == CV_16U || depth == CV_32F", "scn == 3 || scn == 4", "(scn == 3 || scn == 4) && depth == CV_8U", "(dcn == 3 || dcn == 4) && scn == 2 && depth == CV_8U", "scn == 2 && depth == CV_8U", "scn == 1 && (dcn == 3 || dcn == 4)", "scn == 1 && depth == CV_8U", "scn == 3 && (dcn == 3 || dcn == 4)", "(scn == 3 || scn == 4) && (depth == CV_8U || depth == CV_32F)", "scn == 3 && (dcn == 3 || dcn == 4) && (depth == CV_8U || depth == CV_32F)", "coeffs[i] >= 0 && coeffs[i*3+1] >= 0 && coeffs[i*3+2] >= 0 && coeffs[i*3] + coeffs[i*3+1] + coeffs[i*3+2] < 2*(1 << lab_shift)", "coeffs[j] >= 0 && coeffs[j + 1] >= 0 && coeffs[j + 2] >= 0 && coeffs[j] + coeffs[j + 1] + coeffs[j + 2] < 1.5f*LabCbrtTabScale", "scn == 1 && dcn == 1", "Bayer->Gray demosaicing only supports 8u and 16u types", "scn == 1 && dcn == 3", "Bayer->RGB demosaicing only supports 8u and 16u types", "depth == CV_8U", "dcn == 3 || dcn == 4", "sz.width % 2 == 0 && sz.height % 3 == 0 && depth == CV_8U", "Unknown/unsupported color conversion code", "dcn == 1", "sz.width % 2 == 0 && sz.height % 2 == 0", "scn == 4 && dcn == 4", "Unsupported image depth", "src.depth() == dst.depth()", "dst.data == dst0.data", "cv::RGB2HSV_b::RGB2HSV_b(int, int, int)", "vector::_M_fill_insert", "src.depth() == CV_8U", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/canny.cpp", "src.size == dst.size && src.depth() == CV_8U && dst.type() == CV_8U", "void cvCanny(const CvArr*, CvArr*, double, double, int)", "void cv::Canny(cv::InputArray, cv::OutputArray, double, double, int, bool)", "void cvGoodFeaturesToTrack(void const*, void*, void*, CvPoint2D32f*, int*, double, double, void const*, int, int, double)", "qualityLevel > 0 && minDistance >= 0 && maxCorners >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/featureselect.cpp", "mask.empty() || (mask.type() == CV_8UC1 && mask.size() == image.size())", "_corners && _corner_count", "void cv::goodFeaturesToTrack(cv::InputArray, cv::OutputArray, int, double, double, cv::InputArray, int, bool, double)", "N2cv9RowFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_8RowNoVecEEE", "N2cv9RowFilterIhfNS_8RowNoVecEEE", "N2cv9RowFilterIhdNS_8RowNoVecEEE", "N2cv9RowFilterItfNS_8RowNoVecEEE", "N2cv9RowFilterItdNS_8RowNoVecEEE", "N2cv9RowFilterIsfNS_8RowNoVecEEE", "N2cv9RowFilterIsdNS_8RowNoVecEEE", "N2cv9RowFilterIffNS_8RowNoVecEEE", "N2cv9RowFilterIfdNS_8RowNoVecEEE", "N2cv9RowFilterIddNS_8RowNoVecEEE", "N2cv12ColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv8Filter2DIhNS_4CastIfhEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIfNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIdNS_4CastIddEENS_11FilterNoVecEEE", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, double>, VecOp = cv::ColumnNoVec]", "cv::Ptr<cv::BaseRowFilter> cv::getLinearRowFilter(int, int, cv::InputArray, int, int)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, double>, VecOp = cv::ColumnNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = float, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = double, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::Point cv::normalizeAnchor(cv::Point, cv::Size)", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = int, VecOp = cv::RowNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = double, DT = double, VecOp = cv::RowNoVec]", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, short int>, VecOp = cv::ColumnNoVec]", "cv::Ptr<cv::FilterEngine> cv::createLinearFilter(int, int, cv::InputArray, cv::Point, double, int, int, const Scalar&)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, short int>, VecOp = cv::ColumnNoVec]", "cv::SymmRowSmallFilter<ST, DT, VecOp>::SymmRowSmallFilter(const cv::Mat&, int, int, const VecOp&) [with ST = float, DT = float, VecOp = cv::SymmRowSmallNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short unsigned int, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "virtual void cv::FilterEngine::apply(const cv::Mat&, cv::Mat&, const Rect&, cv::Point, bool)", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short unsigned int, DT = double, VecOp = cv::RowNoVec]", "srcRoi.x >= 0 && srcRoi.y >= 0 && srcRoi.width >= 0 && srcRoi.height >= 0 && srcRoi.x + srcRoi.width <= src.cols && srcRoi.y + srcRoi.height <= src.rows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/filter.cpp", "src.type() == srcType && dst.type() == dstType", "dstOfs.x >= 0 && dstOfs.y >= 0 && dstOfs.x + srcRoi.width <= dst.cols && dstOfs.y + srcRoi.height <= dst.rows", "anchor.inside(Rect(0, 0, ksize.width, ksize.height))", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/precomp.hpp", "Unknown/unsupported border type", "kernel.type() == DataType<ST>::type && (kernel.rows == 1 || kernel.cols == 1)", "(symmetryType & (KERNEL_SYMMETRICAL | KERNEL_ASYMMETRICAL)) != 0", "wholeSize.width > 0 && wholeSize.height > 0", "src && dst && count > 0", "srcY >= startY", "dstY <= roi.height", "_kernel.channels() == 1", "kernel.type() == DataType<DT>::type && (kernel.rows == 1 || kernel.cols == 1)", "cn == CV_MAT_CN(bufType) && ddepth >= std::max(sdepth, CV_32S) && kernel.type() == ddepth", "(symmetryType & (KERNEL_SYMMETRICAL | KERNEL_ASYMMETRICAL)) != 0 && this->ksize <= 5", "Unsupported combination of source format (=%d), and buffer format (=%d)", "vector::_M_fill_insert", "ktype == CV_8U || ktype == CV_32S || ktype == CV_32F || ktype == CV_64F", "columnBorderType != BORDER_WRAP", "!rowFilter.empty() && !columnFilter.empty()", "bufType == srcType", "0 <= anchor.x && anchor.x < ksize.width && 0 <= anchor.y && anchor.y < ksize.height", "_kernel.type() == DataType<KT>::type", "cn == CV_MAT_CN(dstType) && ddepth >= sdepth", "Unsupported combination of source format (=%d), and destination format (=%d)", "cn == CV_MAT_CN(_dstType)", "src.size() == dst.size() && src.channels() == dst.channels()", "roi.x >= 0 && roi.y >= 0 && roi.width >= 0 && roi.height >= 0 && roi.x + roi.width <= wholeSize.width && roi.y + roi.height <= wholeSize.height", "this->ksize == 3", "cn == CV_MAT_CN(bufType) && sdepth >= std::max(ddepth, CV_32S) && kernel.type() == sdepth", "Unsupported combination of buffer format (=%d), and destination format (=%d)", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, short int>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::SymmColumnSmallNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, short unsigned int>, VecOp = cv::ColumnNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = float, DT = float, VecOp = cv::RowNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::SymmColumnSmallFilter<CastOp, VecOp>::SymmColumnSmallFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::SymmColumnSmallNoVec]", "void cv::FilterEngine::init(const cv::Ptr<cv::BaseFilter>&, const cv::Ptr<cv::BaseRowFilter>&, const cv::Ptr<cv::BaseColumnFilter>&, int, int, int, int, int, const Scalar&)", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = int, VecOp = cv::SymmRowSmallNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = double, VecOp = cv::RowNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short int, DT = double, VecOp = cv::RowNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, unsigned char>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short int, CastOp = cv::Cast<float, short int>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "void cv::preprocess2DKernel(const cv::Mat&, std::vector<cv::Point_<int> >&, std::vector<unsigned char>&)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::Ptr<cv::BaseFilter> cv::getLinearFilter(int, int, cv::InputArray, cv::Point, double, int)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short unsigned int, CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short int, DT = float, VecOp = cv::RowNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = short unsigned int, DT = float, VecOp = cv::RowNoVec]", "int cv::getKernelType(cv::InputArray, cv::Point)", "cv::Ptr<cv::BaseColumnFilter> cv::getLinearColumnFilter(int, int, cv::InputArray, int, int, double, int)", "int cv::borderInterpolate(int, int, int)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short int, CastOp = cv::Cast<float, float>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = unsigned char, DT = float, VecOp = cv::RowNoVec]", "virtual int cv::FilterEngine::proceed(const uchar*, int, int, uchar*, int)", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, short int>, VecOp = cv::ColumnNoVec]", "virtual int cv::FilterEngine::start(const cv::Mat&, const Rect&, bool, int)", "cv::SymmRowSmallFilter<ST, DT, VecOp>::SymmRowSmallFilter(const cv::Mat&, int, int, const VecOp&) [with ST = unsigned char, DT = int, VecOp = cv::SymmRowSmallNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short unsigned int, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = float, DT = double, VecOp = cv::RowNoVec]", "cv::SymmColumnSmallFilter<CastOp, VecOp>::SymmColumnSmallFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::SymmColumnSmallNoVec]", "N2cv10BaseFilterE", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, short int>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::FixedPtCastEx<int, unsigned char>, VecOp = cv::ColumnNoVec]", "void cvFilter2D(const CvArr*, CvArr*, const CvMat*, CvPoint)", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = short int, CastOp = cv::Cast<double, double>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<int, short int>, VecOp = cv::ColumnNoVec]", "N2cv13BaseRowFilterE", "N2cv16BaseColumnFilterE", "cv::SymmColumnSmallFilter<CastOp, VecOp>::SymmColumnSmallFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::SymmColumnSmallNoVec]", "cv::Filter2D<ST, CastOp, VecOp>::Filter2D(const cv::Mat&, cv::Point, double, const CastOp&, const VecOp&) [with ST = unsigned char, CastOp = cv::Cast<float, short unsigned int>, VecOp = cv::FilterNoVec, cv::Point = cv::Point_<int>]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::ColumnNoVec]", "cv::RowFilter<ST, DT, VecOp>::RowFilter(const cv::Mat&, int, const VecOp&) [with ST = float, DT = float, VecOp = cv::SymmRowSmallNoVec]", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, short unsigned int>, VecOp = cv::ColumnNoVec]", "cv::SymmColumnFilter<CastOp, VecOp>::SymmColumnFilter(const cv::Mat&, int, double, int, const CastOp&, const VecOp&) [with CastOp = cv::Cast<float, float>, VecOp = cv::ColumnNoVec]", "cv::Ptr<cv::FilterEngine> cv::createSeparableLinearFilter(int, int, cv::InputArray, cv::InputArray, cv::Point, double, int, int, const Scalar&)", "cv::ColumnFilter<CastOp, VecOp>::ColumnFilter(const cv::Mat&, int, double, const CastOp&, const VecOp&) [with CastOp = cv::Cast<double, unsigned char>, VecOp = cv::ColumnNoVec]", "virtual int cv::FilterEngine::start(cv::Size, cv::Rect, int)", "N2cv12FilterEngineE", "void icvHoughLinesProbabilistic(CvMat*, float, float, int, int, int, CvSeq*, int)", "void icvHoughLinesStandard(const CvMat*, float, float, int, CvSeq*, int)", "CV_IS_MAT(img) && CV_MAT_TYPE(img->type) == CV_8UC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/hough.cpp", "vector::_M_fill_insert", "The source image must be 8-bit, single-channel", "NULL destination", "rho, theta and threshold must be positive", "The destination matrix should be continuous and have a single row or a single column", "The destination matrix data type is inappropriate, see the manual", "Destination is not CvMemStorage* nor CvMat*", "linesMax > 0 && rho > 0 && theta > 0", "CV_IS_MAT(image) && CV_MAT_TYPE(image->type) == CV_8UC1", "Unrecognized method id", "dp, min_dist, canny_threshold and acc_threshold must be all positive numbers", "CvSeq* cvHoughLines2(CvArr*, void*, int, double, double, int, double, double)", "void icvHoughLinesSDiv(const CvMat*, float, float, int, int, int, CvSeq*, int)", "CvSeq* cvHoughCircles(CvArr*, void*, int, double, double, double, double, int, int)", "cv::Mat cv::getGaborKernel(cv::Size, double, double, double, double, double, int)", "ktype == CV_32F || ktype == CV_64F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/gabor.cpp", "void cv::HuMoments(const cv::Moments&, cv::OutputArray)", "double cvGetSpatialMoment(CvMoments*, int, int)", "The passed sequence is not a valid contour", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/moments.cpp", "Invalid image type", "hu.isContinuous()", "void cvMoments(void const*, CvMoments*, int)", "double cvGetCentralMoment(CvMoments*, int, int)", "void cvGetHuMoments(CvMoments*, CvHuMoments*)", "void cvGetQuadrangleSubPix(void const*, void*, const CvMat*)", "void cvGetRectSubPix(void const*, void*, CvPoint2D32f)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/imgproc/src/samplers.cpp", "(func( src->data.ptr, src_step, src_size, dst->data.ptr, dst_step, dst_size, center )) >= 0", "map matrix is not valid", "Transformation matrix must be 2x3", "The transformation matrix should have 32fC1 or 64fC1 type", "(func( src->data.ptr, src->step, src_size, dst->data.ptr, dst->step, dst_size, m )) >= 0", "int cvSampleLine(void const*, CvPoint, CvPoint, void*, int)", "N2cv11VideoWriterE", "13CvVideoWriter", "9CvCapture", "20CvVideoWriter_Images", "16CvCapture_Images", "bool cv::imencode(const string&, cv::InputArray, std::vector<unsigned char>&, const std::vector<int>&)", "bool cv::imwrite_(const string&, const cv::Mat&, const std::vector<int>&, bool)", "IplImage* cvDecodeImage(const CvMat*, int)", "void* cv::imdecode_(const cv::Mat&, int, int, cv::Mat*)", "buf.data && buf.isContinuous()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/highgui/src/loadsave.cpp", "_buf && CV_IS_MAT_CONT(_buf->type)", "image.channels() == 1 || image.channels() == 3 || image.channels() == 4", "could not find a writer for the specified extension", "encoder->isFormatSupported(CV_8U)", "vector::_M_fill_insert", "channels == 1 || channels == 3 || channels == 4", "could not find encoder for the specified extension", "code", "f != 0", "CvMat* cvDecodeImageM(const CvMat*, int)", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/highgui/src/utils.cpp", "Source image must have 1, 3 or 4 channels", "Destination image must be 8u", "Destination image must have 1 or 3 channels", "Unsupported combination of input/output formats", "void cv::pointCloudShow(const string&, const cv::GlCamera&, cv::InputArray, cv::InputArray)", "void cv::displayStatusBar(const string&, const string&, int)", "void cv::pointCloudShow(const string&, const cv::GlCamera&, const cv::GlArrays&)", "void cv::stopLoop()", "void cv::addText(const cv::Mat&, const string&, cv::Point, CvFont)", "void cv::loadWindowParameters(const string&)", "This function in deprecated, do not use it", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/highgui/src/window.cpp", "The library is compiled without OpenGL support", "The library is compiled without QT support", "cvNamedWindow", "The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Carbon support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script", "cvDestroyWindow", "cvDestroyAllWindows", "cvShowImage", "size.width>0 && size.height>0", "cvResizeWindow", "cvMoveWindow", "cvCreateTrackbar", "cvCreateTrackbar2", "cvSetMouseCallback", "cvGetTrackbarPos", "cvSetTrackbarPos", "cvSetTrackbarMax", "cvGetWindowHandle", "cvGetWindowName", "cvWaitKey", "cvInitSystem", "cvStartWindowThread", "cvAddText", "cvDisplayStatusBar", "cvStartLoop", "cvStopLoop", "cvSaveWindowParameters", "cvCreateButton", "CvFont cv::fontQt(const string&, int, cv::Scalar, int, int, int)", "void cvUpdateWindow(char const*)", "void cv::saveWindowParameters(const string&)", "void cvSetOpenGlContext(char const*)", "int cv::createButton(const string&, cv::ButtonCallback, void*, int, bool)", "void cv::imshow(const string&, cv::InputArray)", "void cvSetOpenGlDrawCallback(char const*, CvOpenGlDrawCallback, void*)", "void cv::displayOverlay(const string&, const string&, int)", "int cv::startLoop(int (*)(int, char**), int, char**)", "28HighguiAndroidCameraActivity", "bool CvCapture_Android::convertYUV2BGR(int, int, unsigned char const*, cv::Mat&, bool, bool)", "virtual bool CvCapture_Android::setProperty(int, double)", "Failed attempt to GET unsupported camera property.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/highgui/src/cap_android.cpp", "OpenCV::camera", "FRAMES received: %d  grabbed: %d", "CvCapture_Android::CvCapture_Android(%i)", "Native_camera returned opening error: %d", "CvCapture_Android::grabFrame(): camera is not opened", "CvCapture_Android::grabFrame: NO new frame", "Error in CvCapture_Android::grabFrame: pthread_mutex_unlock returned %d --- probably, this object has been destroyed", "Failed attempt to SET unsupported camera property.", "CvCapture_Android::prepareCacheForYUV: Changing size of buffers: from width=%d height=%d to width=%d height=%d", "ERROR reading YUV buffer: width=%d, height=%d, size=%d, receivedSize=%d", "width % 2 == 0 && height % 2 == 0", "yuv420sp", "yvu420sp", "Unsupported frame output format: %d", "Output frame format is not supported.", "17CvCapture_Android", "virtual double CvCapture_Android::getProperty(int)", "virtual IplImage* CvCapture_Android::retrieveFrame(int)", "Windows bitmap (*.bmp;*.dib)", "N2cv10BmpDecoderE", "N2cv10BmpEncoderE", "N2cv11JpegEncoderE", "N2cv11JpegDecoderE", "JPEG files (*.jpeg;*.jpg;*.jpe)", "vector::_M_fill_insert", "N2cv5._557E", "N2cv10PxMEncoderE", "N2cv10PxMDecoderE", "Portable image format (*.pbm;*.pgm;*.ppm;*.pxm;*.pnm)", "P%c\n%d %d\n%d\n", "% 4d", "% 6d", "N2cv10PngEncoderE", "N2cv10PngDecoderE", "1.5.12", "decoder", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/highgui/src/grfmt_png.cpp", "PNG input buffer is incomplete", "Portable Network Graphics files (*.png)", "vector::_M_fill_insert", "encoder && encoder->m_buf", "static void cv::PngEncoder::writeDataToBuf(void*, uchar*, std::size_t)", "static void cv::PngDecoder::readDataFromBuf(void*, uchar*, std::size_t)", "N2cv16BaseImageEncoderE", "N2cv16BaseImageDecoderE", "Raw image encoder error: ", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/highgui/src/grfmt_base.cpp", "virtual void cv::BaseImageEncoder::throwOnEror() const", "N2cv11TiffEncoderE", "N2cv11TiffDecoderE", "TIFF Files (*.tiff;*.tif)", "N2cv16SunRasterDecoderE", "Sun raster files (*.sr;*.ras)", "N2cv16SunRasterEncoderE", "N2cv13Jpeg2KDecoderE", "JPEG 2000 LOADER ERROR: cannot convert colorspace\n", "JPEG 2000 LOADER ERROR: unable to create colorspace\n", "JPEG2000 LOADER ERROR: colorspace conversion failed\n", "JPEG-2000 files (*.jp2)", "N2cv13Jpeg2KEncoderE", "OpenEXR Image files (*.exr)", "N2cv10ExrEncoderE", "N2cv10ExrDecoderE", "N2cv12WMByteStreamE", "N2cv11RBaseStreamE", "N2cv11WBaseStreamE", "N2cv12RLByteStreamE", "N2cv12WLByteStreamE", "buf.isContinuous()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/highgui/src/bitstrm.cpp", "vector::_M_fill_insert", "virtual bool cv::RBaseStream::open(const cv::Mat&)", "N2cv12RMByteStreamE", "virtual void cv::SimpleBlobDetector::detectImpl(const cv::Mat&, std::vector<cv::KeyPoint>&, const cv::Mat&) const", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "thresholdStep", "minThreshold", "maxThreshold", "minRepeatability", "minDistBetweenBlobs", "filterByColor", "blobColor", "filterByArea", "minArea", "maxArea", "filterByCircularity", "minCircularity", "maxCircularity", "filterByInertia", "minInertiaRatio", "maxInertiaRatio", "filterByConvexity", "minConvexity", "maxConvexity", "Blob detector only supports 8-bit images!", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/blobdetector.cpp", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = float]", "N2cv18SimpleBlobDetectorE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "static void cv::KeyPointsFilter::runByKeypointSize(std::vector<cv::KeyPoint>&, float, float)", "vector::_M_fill_insert", "keypointIndexes has element < 0. TODO: process this case", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/keypoint.cpp", "vector::_M_insert_aux", "minSize >= 0", "maxSize >= 0", "minSize <= maxSize", "static void cv::KeyPoint::convert(const std::vector<cv::KeyPoint>&, std::vector<cv::Point_<float> >&, const std::vector<int>&)", "void cv::makeOffsets(int*, int, int)", "pixel && offsets", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/fast_score.cpp", "void cv::extractMSER(CvArr*, CvArr*, CvSeq**, CvMemStorage*, cv::MSERParams)", "!_seq || _seq->elem_size == sizeof(_Tp)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "vector::_M_fill_insert", "src != 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/mser.cpp", "CV_MAT_TYPE(src->type) == CV_8UC1 || CV_MAT_TYPE(src->type) == CV_8UC3", "mask == 0 || (CV_ARE_SIZES_EQ(src, mask) && CV_MAT_TYPE(mask->type) == CV_8UC1)", "storage != 0", "N2cv15AdjusterAdapterE", "SURF", "hessianThreshold", "FAST", "STAR", "N2cv29DynamicAdaptedFeatureDetectorE", "N2cv12StarAdjusterE", "N2cv12FastAdjusterE", "N2cv12SurfAdjusterE", "void cv::computeIntegralImages(const cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/stardetector.cpp", "matI.type() == CV_8U", "int cv::StarDetectorComputeResponses(const cv::Mat&, cv::Mat&, cv::Mat&, int)", "const cv::Mat cv::DescriptorMatcher::DescriptorCollection::getDescriptor(int) const", "const cv::Mat cv::DescriptorMatcher::DescriptorCollection::getDescriptor(int, int) const", "void cv::GenericDescriptorMatcher::KeyPointCollection::getLocalIdx(int, int&, int&) const", "void cv::DescriptorMatcher::radiusMatch(const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, float, const std::vector<cv::Mat>&, bool)", "void cv::convertMatches(const std::vector<std::vector<cv::DMatch> >&, std::vector<cv::DMatch>&)", "virtual cv::Ptr<cv::DescriptorMatcher> cv::FlannBasedMatcher::clone(bool) const", "cv::FlannBasedMatcher::FlannBasedMatcher(const cv::Ptr<cv::flann::IndexParams>&, const cv::Ptr<cv::flann::SearchParams>&)", "N2cv23VectorDescriptorMatcherE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = unsigned char]", "virtual void cv::FlannBasedMatcher::read(const cv::FileNode&)", "N2cv17DescriptorMatcherE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = double]", "virtual void cv::BFMatcher::knnMatchImpl(const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, int, const std::vector<cv::Mat>&, bool)", "void cv::DescriptorMatcher::DescriptorCollection::getLocalIdx(int, int&, int&) const", "void cv::DescriptorMatcher::checkMasks(const std::vector<cv::Mat>&, int) const", "N2cv17FlannBasedMatcherE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = short unsigned int]", "virtual void cv::GenericDescriptorMatcher::add(const std::vector<cv::Mat>&, std::vector<std::vector<cv::KeyPoint> >&)", "void cv::DescriptorMatcher::DescriptorCollection::set(const std::vector<cv::Mat>&)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = char]", "const cv::Mat& cv::GenericDescriptorMatcher::KeyPointCollection::getImage(int) const", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = float]", "const cv::KeyPoint& cv::GenericDescriptorMatcher::KeyPointCollection::getKeyPoint(int, int) const", "cv::VectorDescriptorMatcher::VectorDescriptorMatcher(const cv::Ptr<cv::DescriptorExtractor>&, const cv::Ptr<cv::DescriptorMatcher>&)", "N2cv17DescriptorMatcher20DescriptorCollectionE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = short int]", "const std::vector<cv::KeyPoint>& cv::GenericDescriptorMatcher::KeyPointCollection::getKeypoints(int) const", "N2cv9BFMatcherE", "void cv::DescriptorMatcher::knnMatch(const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, int, const std::vector<cv::Mat>&, bool)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "N2cv24GenericDescriptorMatcherE", "virtual void cv::BFMatcher::radiusMatchImpl(const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, float, const std::vector<cv::Mat>&, bool)", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "indexParams", "name", "type", "value", "typename", "searchParams", "globalDescIdx < size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/matchers.cpp", "imgIdx < (int)startIdxs.size()", "globalIdx < (int)size()", "(globalDescIdx>=0) && (globalDescIdx < size())", "masks.size() == imageCount", "masks[i].rows == queryDescriptorsCount && masks[i].cols == trainDescCollection[i].rows && masks[i].type() == CV_8UC1", "knn > 0", "maxDistance > std::numeric_limits<float>::epsilon()", "imgIdx < (int)imageCount()", "imgIdx < (int)images.size()", "localPointIdx < (int)keypoints[imgIdx].size()", "globalPointIdx < (int)keypointCount()", "DescriptorMatcher.", "vector::reserve", "knnMatches[i].size() <= 1", "ip.type() == FileNode::SEQ", "ip[i].type() == FileNode::MAP", "sp.type() == FileNode::SEQ", "sp[i].type() == FileNode::MAP", "!_indexParams.empty()", "!_searchParams.empty()", "deep clone functionality is not implemented, because Flann::Index has not copy constructor or clone method ", "FlannBased", "BruteForce", "BruteForce-SL2", "BruteForce-L1", "BruteForce-Hamming", "BruteForce-HammingLUT", "Unknown matcher name", "BruteForce-Hamming(2)", "!extractor.empty() && !matcher.empty()", "vector::_M_fill_insert", "imageCount > 0", "descriptors[i].cols == dim && descriptors[i].type() == type", "vector::_M_insert_aux", "queryDescriptors.type() == trainDescCollection[0].type()", "(int64)imgCount*IMGIDX_ONE < INT_MAX", "trainDescCollection[iIdx].rows < IMGIDX_ONE", "vector::_M_range_insert", "!_images.empty()", "_images.size() == _points.size()", "!images.empty()", "images.size() == keypoints.size()", "!images[i].empty()", "static cv::Ptr<cv::DescriptorMatcher> cv::DescriptorMatcher::create(const string&)", "cv::OpponentColorDescriptorExtractor::OpponentColorDescriptorExtractor(const cv::Ptr<cv::DescriptorExtractor>&)", "N2cv19DescriptorExtractorE", "void cv::DescriptorExtractor::compute(const std::vector<cv::Mat>&, std::vector<std::vector<cv::KeyPoint> >&, std::vector<cv::Mat>&) const", "vector::reserve", "!descriptorExtractor.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/descriptors.cpp", "Opponent", "basic_string::substr", "Feature2D.", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_range_insert", "imageCollection.size() == pointCollection.size()", "input image must be an BGR image of type CV_8UC3", "void cv::convertBGRImageToOpponentColorSpace(const cv::Mat&, std::vector<cv::Mat>&)", "N2cv32OpponentColorDescriptorExtractorE", "N2cv26GridAdaptedFeatureDetectorE", "vector::reserve", "mask.empty() || (mask.type() == CV_8UC1 && mask.size() == image.size())", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/detectors.cpp", "Grid", "basic_string::substr", "Pyramid", "Dynamic", "HARRIS", "GFTT", "useHarrisDetector", "Feature2D.", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_range_insert", "*N2cv12_GLOBAL__N_133GridAdaptedFeatureDetectorInvokerE", "void cv::FeatureDetector::detect(const cv::Mat&, std::vector<cv::KeyPoint>&, const cv::Mat&) const", "N2cv15FeatureDetectorE", "N2cv29PyramidAdaptedFeatureDetectorE", "void cv::BOWTrainer::add(const cv::Mat&)", "N2cv16BOWKMeansTrainerE", "!descriptors.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/bagofwords.cpp", "!_descriptors.empty()", "descriptors[0].cols == _descriptors.cols", "descriptors[0].type() == _descriptors.type()", "vector::_M_fill_insert", "queryIdx == (int)i", "N2cv10BOWTrainerE", "void cv::BOWImgDescriptorExtractor::compute(const cv::Mat&, std::vector<cv::KeyPoint>&, cv::Mat&, std::vector<std::vector<int> >*, cv::Mat*)", "N2cv25BOWImgDescriptorExtractorE", "virtual cv::Mat cv::BOWKMeansTrainer::cluster() const", "N2cv5FREAKE", "std::vector<int> cv::FREAK::selectPairs(const std::vector<cv::Mat>&, std::vector<std::vector<cv::KeyPoint> >&, double, bool)", "Input vector does not match the required size", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/freak.cpp", "bitset::set", "Number of images: ", "number of keypoints: ", "correlation threshold too small (restrictive)", "void cv::FREAK::buildPattern()", "cv::BriefDescriptorExtractor::BriefDescriptorExtractor(int)", "N2cv24BriefDescriptorExtractorE", "descriptorSize", "descriptorSize must be 16, 32, or 64", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/brief.cpp", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "bytes must be 16, 32, or 64", "virtual void cv::BriefDescriptorExtractor::read(const cv::FileNode&)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "void cv::drawMatches(const cv::Mat&, const std::vector<cv::KeyPoint>&, const cv::Mat&, const std::vector<cv::KeyPoint>&, const std::vector<cv::DMatch>&, cv::Mat&, const Scalar&, const Scalar&, const std::vector<char>&, int)", "void cv::_prepareImgAndDrawKeypoints(const cv::Mat&, const std::vector<cv::KeyPoint>&, const cv::Mat&, const std::vector<cv::KeyPoint>&, cv::Mat&, cv::Mat&, cv::Mat&, const Scalar&, int)", "void cv::_drawKeypoint(cv::Mat&, const cv::KeyPoint&, const Scalar&, int)", "!img.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/draw.cpp", "Incorrect type of input image.\n", "!outImage.empty()", "outImg has size less than need to draw img1 and img2 together", "matchesMask must have the same size as matches1to2", "i1 >= 0 && i1 < static_cast<int>(keypoints1.size())", "i2 >= 0 && i2 < static_cast<int>(keypoints2.size())", "void cv::drawMatches(const cv::Mat&, const std::vector<cv::KeyPoint>&, const cv::Mat&, const std::vector<cv::KeyPoint>&, const std::vector<std::vector<cv::DMatch> >&, cv::Mat&, const Scalar&, const Scalar&, const std::vector<std::vector<char> >&, int)", "void cv::drawKeypoints(const cv::Mat&, const std::vector<cv::KeyPoint>&, cv::Mat&, const Scalar&, int)", "void cv::evaluateFeatureDetector(const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<cv::KeyPoint>*, std::vector<cv::KeyPoint>*, float&, int&, const cv::Ptr<cv::FeatureDetector>&)", "void cv::computeRecallPrecisionCurve(const std::vector<std::vector<cv::DMatch> >&, const std::vector<std::vector<unsigned char> >&, std::vector<cv::Point_<float> >&)", "miny < maxy", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/evaluation.cpp", "dr > FLT_EPSILON", "vector::reserve", "vector::_M_fill_insert", "vector::_M_insert_aux", "fdetector must not be empty when keypoints1 or keypoints2 is empty", "matches1to2.size() == correctMatches1to2Mask.size()", "keypoints1 must not be empty", "dmatch must not be empty when matches1to2 is empty", "void IntersectAreaCounter::operator()(const cv::BlockedRange&)", "void cv::evaluateGenericDescriptorMatcher(const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<cv::KeyPoint>&, std::vector<cv::KeyPoint>&, std::vector<std::vector<cv::DMatch> >*, std::vector<std::vector<unsigned char> >*, std::vector<cv::Point_<float> >&, const cv::Ptr<cv::GenericDescriptorMatcher>&)", "N2cv9Feature2DE", "N2cv3ORBE", "void cv::HarrisResponses(const cv::Mat&, std::vector<cv::KeyPoint>&, int, float)", "void cv::computeOrbDescriptor(const cv::KeyPoint&, const cv::Mat&, const Point*, uchar*, int, int)", "void cv::computeDescriptors(const cv::Mat&, std::vector<cv::KeyPoint>&, cv::Mat&, const std::vector<cv::Point_<int> >&, int, int)", "virtual void cv::ORB::operator()(cv::InputArray, cv::InputArray, std::vector<cv::KeyPoint>&, cv::OutputArray, bool) const", "img.type() == CV_8UC1 && blockSize*blockSize <= 2048", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/features2d/src/orb.cpp", "image.type() == CV_8UC1", "Wrong WTA_K. It can be only 2, 3 or 4.", "vector::reserve", "vector::_M_insert_aux", "vector::_M_range_insert", "vector::_M_fill_insert", "patchSize >= 2", "WTA_K == 2 || WTA_K == 3 || WTA_K == 4", "N2cv20FastFeatureDetector2E", "N2cv19FastFeatureDetectorE", "N2cv12GFTTDetectorE", "Feature2D.BRISK", "Feature2D.BRIEF", "Feature2D.FAST", "threshold", "nonmaxSuppression", "Feature2D.FASTX", "type", "Feature2D.STAR", "maxSize", "responseThreshold", "lineThresholdProjected", "lineThresholdBinarized", "suppressNonmaxSize", "Feature2D.MSER", "delta", "minArea", "maxArea", "maxVariation", "minDiversity", "maxEvolution", "areaThreshold", "minMargin", "edgeBlurSize", "Feature2D.ORB", "Feature2D.FREAK", "Feature2D.GFTT", "nfeatures", "qualityLevel", "minDistance", "useHarrisDetector", "Feature2D.SimpleBlob", "Feature2D.HARRIS", "Feature2D.Dense", "initFeatureScale", "featureScaleLevels", "featureScaleMul", "initXyStep", "initImgBound", "varyXyStepWithScale", "varyImgBoundWithScale", "Feature2D.Grid", "DescriptorMatcher.BFMatcher", "DescriptorMatcher.FlannBasedMatcher", "Feature2D.", "thres", "octaves", "bytes", "nFeatures", "scaleFactor", "nLevels", "firstLevel", "edgeThreshold", "patchSize", "WTA_K", "scoreType", "orientationNormalized", "scaleNormalized", "patternScale", "nbOctave", "thresholdStep", "minThreshold", "maxThreshold", "minRepeatability", "minDistBetweenBlobs", "filterByColor", "blobColor", "filterByArea", "filterByCircularity", "maxCircularity", "filterByInertia", "maxInertiaRatio", "filterByConvexity", "maxConvexity", "normType", "crossCheck", "detector", "maxTotalKeypoints", "gridRows", "gridCols", "N2cv4MSERE", "14HarrisDetector", "N2cv20DenseFeatureDetectorE", "N2cv12StarDetectorE", "N2cv5BRISKE", "@Athreshold", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_range_check", "std::size_t CirclesGridFinder::findLongestPath(std::vector<Graph>&, Path&)", "CirclesGridFinder::CirclesGridFinder(cv::Size, const std::vector<cv::Point_<float> >&, const CirclesGridFinderParameters&)", "static void CirclesGridFinder::insertWinner(float, float, float, bool, const std::vector<unsigned int>&, const std::vector<unsigned int>&, std::vector<std::vector<unsigned int> >&)", "void CirclesGridFinder::findBasis(const std::vector<cv::Point_<float> >&, std::vector<cv::Point_<float> >&, std::vector<Graph>&)", "bool CirclesGridFinder::isDetectionCorrect()", "std::size_t CirclesGridFinder::getFirstCorner(std::vector<cv::Point_<int> >&, std::vector<cv::Point_<int> >&, std::vector<cv::Point_<int> >&, std::vector<cv::Point_<int> >&) const", "void CirclesGridClusterFinder::findCorners(const std::vector<cv::Point_<float> >&, std::vector<cv::Point_<float> >&)", "vector::reserve", "vector::_M_insert_aux", "samples is empty", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/circlesgrid.cpp", "filteredSamples is empty", "vector::_M_range_check", "sortedIndices.type() == CV_32SC1", "sortedIndices.cols == 1", "Unknown pattern type", "_patternSize.height >= 0 && _patternSize.width >= 0", "Centers are not new", "vector::_M_fill_insert", "maxLoc.x >= 0 && maxLoc.y >= 0", "h >= 2 && w >= 2", "largeSegments.size() == cornersCount", "largeHoles != 0 && smallHoles != 0", "Basis size is not 2", "degenerate basis", "Number of basis graphs is not 2", "Unkown pattern type", "bool CirclesGridFinder::findHoles()", "void CirclesGridFinder::getCornerSegments(const std::vector<std::vector<unsigned int> >&, std::vector<std::vector<CirclesGridFinder::Segment> >&, std::vector<cv::Point_<int> >&, std::vector<cv::Point_<int> >&, std::vector<cv::Point_<int> >&) const", "void CirclesGridFinder::filterOutliersByDensity(const std::vector<cv::Point_<float> >&, std::vector<cv::Point_<float> >&)", "void CirclesGridFinder::getAsymmetricHoles(std::vector<cv::Point_<float> >&) const", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/quadsubpix.cpp", "bool cv::find4QuadCornerSubpix(cv::InputArray, cv::InputOutputArray, cv::Size)", "cvCheckChessboard", "supports single-channel images only", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/checkchessboard.cpp", "supports depth=8 images only", "void cvTriangulatePoints(CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)", "void cvCorrectMatches(CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)", "Some of parameters is a NULL pointer", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/triangulate.cpp", "Input parameters must be matrices", "Number of points must be more than zero", "Number of points must be the same", "Number of proj points coordinates must be == 2", "Number of world points coordinates must be == 4", "Size of projection matrices must be 3x4", "The fundamental matrix must be a 3x3 matrix", "The fundamental matrix must be a single-channel matrix", "The point-matrices must have one row, and an equal number of columns", "The first set of points must contain two channels; one for x and one for y", "The second set of points must contain two channels; one for x and one for y", "CV_IS_MAT(new_points1)", "The first output matrix must have the same dimensions as the input matrices", "The first output matrix must have two channels; one for x and one for y", "CV_IS_MAT(new_points2)", "The second output matrix must have the same dimensions as the input matrices", "The second output matrix must have two channels; one for x and one for y", "virtual void cv::StereoSGBM::operator()(cv::InputArray, cv::InputArray, cv::OutputArray)", "void cv::validateDisparity(cv::InputOutputArray, cv::InputArray, int, int, int)", "void cv::filterSpeckles(cv::InputOutputArray, double, int, double, cv::InputOutputArray)", "img.type() == CV_8UC1 || img.type() == CV_16SC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/stereosgbm.cpp", "left.size() == right.size() && left.type() == right.type() && left.depth() == DataType<PixType>::depth", "D % 16 == 0", "numberOfDisparities > 0 && disp.type() == CV_16S && (costType == CV_16S || costType == CV_32S) && disp.size() == cost.size()", "void cv::computeDisparitySGBM(const cv::Mat&, const cv::Mat&, cv::Mat&, const cv::StereoSGBM&, cv::Mat&)", "N2cv10StereoSGBME", "CvPOSITObject* cvCreatePOSITObject(CvPoint3D32f*, int)", "(icvCreatePOSITObject( points, numPoints, &pObject )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/posit.cpp", "(icvPOSIT( pObject, imagePoints,(float) focalLength, criteria, rotation, translation )) >= 0", "void cvPOSIT(CvPOSITObject*, CvPoint2D32f*, double, CvTermCriteria, float*, float*)", "cv::Mat cv::internal::NormalizePixels(const cv::Mat&, const cv::internal::IntrinsicParams&)", "void cv::internal::ComputeJacobians(cv::InputArrayOfArrays, cv::InputArrayOfArrays, const cv::internal::IntrinsicParams&, cv::InputArray, cv::InputArray, int const&, double const&, cv::Mat&, cv::Mat&)", "void cv::fisheye::initUndistortRectifyMap(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, const Size&, int, cv::OutputArray, cv::OutputArray)", "cv::internal::IntrinsicParams& cv::internal::IntrinsicParams::operator=(const cv::Mat&)", "void cv::internal::EstimateUncertainties(cv::InputArrayOfArrays, cv::InputArrayOfArrays, const cv::internal::IntrinsicParams&, cv::InputArray, cv::InputArray, cv::internal::IntrinsicParams&, cv::Vec2d&, double, int, double&)", "void cv::internal::projectPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, const cv::internal::IntrinsicParams&, cv::OutputArray)", "void cv::internal::InitExtrinsics(const cv::Mat&, const cv::Mat&, const cv::internal::IntrinsicParams&, cv::Mat&, cv::Mat&)", "void cv::internal::CalibrateExtrinsics(cv::InputArrayOfArrays, cv::InputArrayOfArrays, const cv::internal::IntrinsicParams&, int, double, cv::InputOutputArray, cv::InputOutputArray)", "cv::Mat::operator cv::Matx<_Tp, m, n>() const [with _Tp = double, int m = 3, int n = 3]", "cv::internal::IntrinsicParams cv::internal::IntrinsicParams::operator+(const cv::Mat&)", "cv::Mat::operator cv::Matx<_Tp, m, n>() const [with _Tp = float, int m = 3, int n = 3]", "void cv::fisheye::projectPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, double, cv::OutputArray)", "src.type() == CV_64FC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/fisheye.cpp", "data && dims <= 2 && rows == m && cols == n && channels() == 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/mat.hpp", "undistorted.type() == CV_32FC2 || undistorted.type() == CV_64FC2", "K.size() == Size(3,3) && (K.type() == CV_32F || K.type() == CV_64F) && D.total() == 4", "a.type() == CV_64FC1", "A.getMat().cols == B.getMat().rows", "A.type() == CV_64FC1 && B.type() == CV_64FC1", "row.type() == CV_64FC1", "!row.empty() && row.rows == 1", "m.depth() == CV_64F && m.getMat().rows == 1", "data && dims <= 2 && (rows == 1 || cols == 1) && rows + cols - 1 == n && channels() == 1", "m1type == CV_16SC2 || m1type == CV_32F || m1type <=0", "(K.depth() == CV_32F || K.depth() == CV_64F) && (D.depth() == CV_32F || D.depth() == CV_64F)", "(P.depth() == CV_32F || P.depth() == CV_64F) && (R.depth() == CV_32F || R.depth() == CV_64F)", "K.size() == Size(3, 3) && (D.empty() || D.total() == 4)", "R.empty() || R.size() == Size(3, 3) || R.total() * R.channels() == 3", "P.empty() || P.size() == Size(3, 3) || P.size() == Size(4, 3)", "objectPoints.type() == CV_32FC3 || objectPoints.type() == CV_64FC3", "_rvec.total() * _rvec.channels() == 3 && (_rvec.depth() == CV_32F || _rvec.depth() == CV_64F)", "_tvec.total() * _tvec.channels() == 3 && (_tvec.depth() == CV_32F || _tvec.depth() == CV_64F)", "_tvec.getMat().isContinuous() && _rvec.getMat().isContinuous()", "_K.size() == Size(3,3) && (_K.type() == CV_32F || _K.type() == CV_64F) && _D.type() == _K.type() && _D.total() == 4", "!objectPoints.empty() && objectPoints.type() == CV_64FC3", "!imagePoints.empty() && imagePoints.type() == CV_64FC2", "distorted.type() == CV_32FC2 || distorted.type() == CV_64FC2", "D.total() == 4 && K.size() == Size(3, 3) && (K.depth() == CV_32F || K.depth() == CV_64F)", "!_objectPoints.empty() && _objectPoints.type() == CV_64FC3", "!_imagePoints.empty() && _imagePoints.type() == CV_64FC2", "!objectPoints.empty() && (objectPoints.type() == CV_32FC3 || objectPoints.type() == CV_64FC3)", "!imagePoints.empty() && (imagePoints.type() == CV_32FC2 || imagePoints.type() == CV_64FC2)", "omc.type() == CV_64FC3 || Tc.type() == CV_64FC3", "svd.w.at<double>(0) / svd.w.at<double>((int)svd.w.total() - 1) < thresh_cond", "K.size() == Size(3, 3) && (K.depth() == CV_32F || K.depth() == CV_64F)", "(D.empty() || D.total() == 4) && (D.depth() == CV_32F || D.depth() == CV_64F || D.empty())", "(_R.size() == Size(3, 3) || _R.total() * _R.channels() == 3) && (_R.depth() == CV_32F || _R.depth() == CV_64F)", "vector::_M_fill_insert", "!omc.empty() && omc.type() == CV_64FC3", "!Tc.empty() && Tc.type() == CV_64FC3", "svd.w.at<double>(0) / svd.w.at<double>(svd.w.rows - 1) < thresh_cond", "!objectPoints.empty() && !imagePoints.empty() && objectPoints.total() == imagePoints.total()", "imagePoints.type() == CV_32FC2 || imagePoints.type() == CV_64FC2", "(!K.empty() && K.size() == Size(3,3)) || K.empty()", "(!D.empty() && D.total() == 4) || D.empty()", "(!rvecs.empty() && rvecs.channels() == 3) || rvecs.empty()", "(!tvecs.empty() && tvecs.channels() == 3) || tvecs.empty()", "((flags & CALIB_USE_INTRINSIC_GUESS) && !K.empty() && !D.empty()) || !(flags & CALIB_USE_INTRINSIC_GUESS)", "vector::_M_range_insert", "!objectPoints.empty() && !imagePoints1.empty() && !imagePoints2.empty()", "objectPoints.total() == imagePoints1.total() || imagePoints1.total() == imagePoints2.total()", "imagePoints1.type() == CV_32FC2 || imagePoints1.type() == CV_64FC2", "imagePoints2.type() == CV_32FC2 || imagePoints2.type() == CV_64FC2", "(!K1.empty() && K1.size() == Size(3,3)) || K1.empty()", "(!D1.empty() && D1.total() == 4) || D1.empty()", "(!K2.empty() && K1.size() == Size(3,3)) || K2.empty()", "(!D2.empty() && D1.total() == 4) || D2.empty()", "((flags & CALIB_FIX_INTRINSIC) && !K1.empty() && !K2.empty() && !D1.empty() && !D2.empty()) || !(flags & CALIB_FIX_INTRINSIC)", "abs_max < threshold", "void cv::fisheye::undistortPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray)", "void cv::fisheye::estimateNewCameraMatrixForUndistortRectify(cv::InputArray, cv::InputArray, const Size&, cv::InputArray, cv::OutputArray, double, const Size&, double)", "void cv::internal::ComputeExtrinsicRefine(const cv::Mat&, const cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&, int, const cv::internal::IntrinsicParams&, double)", "cv::Mat::operator cv::Vec<_Tp, cn>() const [with _Tp = double, int n = 3]", "void cv::fisheye::distortPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, double)", "cv::Vec3d cv::internal::median3d(cv::InputArray)", "void cv::fisheye::stereoRectify(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, const Size&, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, const Size&, double, double)", "double cv::fisheye::calibrate(cv::InputArrayOfArrays, cv::InputArrayOfArrays, const Size&, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, int, cv::TermCriteria)", "void cv::(anonymous namespace)::subMatrix(const cv::Mat&, cv::Mat&, const std::vector<int>&, const std::vector<int>&)", "void cv::internal::dAB(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray)", "double cv::internal::median(const cv::Mat&)", "N2cv24FindStereoCorrespInvokerE", "void cvReleaseStereoBMState(CvStereoBMState**)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/stereobm.cpp", "All the images must have the same size", "Both input images must have CV_8UC1", "Disparity image must have CV_16SC1 or CV_32FC1 format", "Stereo BM state is NULL.", "preFilterType must be = CV_STEREO_BM_NORMALIZED_RESPONSE", "preFilterSize must be odd and be within 5..255", "preFilterCap must be within 1..63", "SADWindowSize must be odd, be within 5..255 and be not larger than image width or height", "numberOfDisparities must be positive and divisble by 16", "texture threshold must be non-negative", "uniqueness ratio must be non-negative", "disptype == CV_16S || disptype == CV_32F", "void cv::findStereoCorrespondenceBM(const cv::Mat&, const cv::Mat&, cv::Mat&, CvStereoBMState*)", "void cv::StereoBM::operator()(cv::InputArray, cv::InputArray, cv::OutputArray, int)", "void cv::computeCorrespondEpilines(cv::InputArray, int, cv::InputArray, cv::OutputArray)", "cv::Mat cv::findHomography(cv::InputArray, cv::InputArray, int, double, cv::OutputArray)", "void cv::convertPointsFromHomogeneous(cv::InputArray, cv::OutputArray)", "int cvFindFundamentalMat(const CvMat*, const CvMat*, CvMat*, int, double, double, CvMat*)", "cv::Mat cv::findFundamentalMat(cv::InputArray, cv::InputArray, int, double, double, cv::OutputArray)", "void cv::convertPointsToHomogeneous(cv::InputArray, cv::OutputArray)", "13CvFMEstimator", "void cvConvertPointsHomogeneous(const CvMat*, CvMat*)", "(_m1->cols == 1 || _m1->rows == 1) && CV_ARE_SIZES_EQ(_m1, _m2)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/fundam.cpp", "points parameter is not a valid matrix", "The format of point matrix is unsupported", "points->rows == 1 || points->cols == 1", "The point matrix does not have a proper layout (2xn, 3xn, nx2 or nx3)", "The dimensionality of points must be 2 or 3", "fmatrix is not a valid matrix", "fundamental matrix must have 32fC1 or 64fC1 type", "fundamental matrix must be 3x3", "lines parameter is not a valid matrix", "The format of the matrix of lines is unsupported", "lines->rows == 1 || lines->cols == 1", "The lines matrix does not have a proper layout (3xn or nx3)", "The numbers of points and lines are different", "npoints >= 0 && (points.depth() == CV_32F || points.depth() == CV_32S)", "The input parameter is not a valid matrix", "The output parameter is not a valid matrix", "Invalid inplace operation", "Either the number of channels or columns or rows must be =1", "Either the number of channels or columns or rows in the input matrix must be =1", "Either the number of channels or columns or rows in the output matrix must be =1", "Both matrices must have the same number of points", "Both matrices must be floating-point (single or double precision)", "Both input and output point dimensionality must be 2, 3 or 4", "The dimensionalities of input and output point sets differ too much", "npoints >= 0 && (src.depth() == CV_32F || src.depth() == CV_32S)", "_dst.fixedType()", "CV_IS_MAT(points1) && CV_IS_MAT(points2) && CV_ARE_SIZES_EQ(points1, points2)", "CV_IS_MAT(fmatrix) && fmatrix->cols == 3 && (fmatrix->rows == 3 || (fmatrix->rows == 9 && method == CV_FM_7POINT))", "CV_IS_MASK_ARR(mask) && CV_IS_MAT_CONT(mask->type) && (mask->rows == 1 || mask->cols == 1) && mask->rows*mask->cols == count", "npoints >= 0 && points2.checkVector(2) == npoints && points1.type() == points2.type()", "CV_IS_MAT(imagePoints) && CV_IS_MAT(objectPoints)", "count >= 4", "void cvComputeCorrespondEpilines(const CvMat*, int, const CvMat*, CvMat*)", "virtual int CvFMEstimator::run8Point(const CvMat*, const CvMat*, CvMat*)", "int cvFindHomography(const CvMat*, const CvMat*, CvMat*, int, double, CvMat*)", "21CvHomographyEstimator", "void cv::convertPointsHomogeneous(cv::InputArray, cv::OutputArray)", "virtual bool cv::Affine3DEstimator::checkSubset(const CvMat*, int)", "virtual bool CvModelEstimator2::runRANSAC(const CvMat*, const CvMat*, CvMat*, CvMat*, double, double, int)", "virtual bool CvModelEstimator2::runLMeDS(const CvMat*, const CvMat*, CvMat*, CvMat*, double, int)", "int cvRANSACUpdateNumIters(double, double, int, int)", "17CvModelEstimator2", "N2cv17Affine3DEstimatorE", "CV_MAT_TYPE(ms1->type) == CV_64FC3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/modelest.cpp", "CV_ARE_SIZES_EQ(m1, m2) && CV_ARE_SIZES_EQ(m1, mask)", "the number of model points should be positive", "count >= 0 && to.checkVector(3) == count", "int cv::estimateAffine3D(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, double, double)", "npoints >= 0 && npoints == std::max(ipoints.checkVector(2, CV_32F), ipoints.checkVector(2, CV_64F))", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/solvepnp.cpp", "npoints == 4", "The flags argument must be one of CV_ITERATIVE or CV_EPNP", "vector::_M_fill_insert", "vector::_M_insert_aux", "objectPoints.depth() == CV_64F || objectPoints.depth() == CV_32F", "imagePoints.depth() == CV_64F || imagePoints.depth() == CV_32F", "opoints.isContinuous()", "opoints.depth() == CV_32F || opoints.depth() == CV_64F", "(opoints.rows == 1 && opoints.channels() == 3) || opoints.cols*opoints.channels() == 3", "ipoints.isContinuous()", "ipoints.depth() == CV_32F || ipoints.depth() == CV_64F", "(ipoints.rows == 1 && ipoints.channels() == 2) || ipoints.cols*ipoints.channels() == 2", "bool cv::solvePnP(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool, int)", "void cv::pnpransac::pnpTask(int, const std::vector<char>&, const cv::Mat&, const cv::Mat&, const cv::pnpransac::Parameters&, std::vector<int>&, int&, cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&, cv::Mutex&)", "void cv::solvePnPRansac(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool, int, float, int, cv::OutputArray, int)", "double cvCalibrateCamera2(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, CvMat*, CvMat*, CvMat*, int, CvTermCriteria)", "void cvRQDecomp3x3(const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvPoint3D64f*)", "void cvInitIntrinsicParams2D(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, double)", "int cvStereoRectifyUncalibrated(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, CvMat*, double)", "int cvRodrigues2(const CvMat*, CvMat*, CvMat*)", "void cvReprojectImageTo3D(const CvArr*, CvArr*, const CvMat*, int)", "void cvDecomposeProjectionMatrix(const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvPoint3D64f*)", "void cvFindExtrinsicCameraParams2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, int)", "bool CvLevMarq::updateAlt(const CvMat*&, CvMat*&, CvMat*&, double*&)", "void cv::projectPoints(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, double)", "err.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/calibration.cpp", "CV_IS_MAT(A) && CV_IS_MAT(B)", "CV_ARE_TYPES_EQ(A, B) && (CV_MAT_TYPE(A->type) == CV_32F || CV_MAT_TYPE(A->type) == CV_64F)", "A->cols == B->rows", "CV_ARE_TYPES_EQ(A, dABdA) && dABdA->rows == A->rows*B->cols && dABdA->cols == A->rows*A->cols", "CV_ARE_TYPES_EQ(A, dABdB) && dABdB->rows == A->rows*B->cols && dABdB->cols == B->rows*B->cols", "Input argument is not a valid matrix", "The first output argument is not a valid matrix", "The matrices must have 32f or 64f data type", "All the matrices must have the same data type", "Jacobian is not a valid matrix", "Jacobian must have 32fC1 or 64fC1 datatype", "Jacobian must be 3x9 or 9x3", "Input matrix must be 1x3, 3x1 or 3x3", "Output matrix must be 3x3, single-channel floating point matrix", "Output matrix must be 1x3 or 3x1", "CV_IS_MAT(_rvec1) && CV_IS_MAT(_rvec2)", "CV_MAT_TYPE(_rvec1->type) == CV_32F || CV_MAT_TYPE(_rvec1->type) == CV_64F", "_rvec1->rows == 3 && _rvec1->cols == 1 && CV_ARE_SIZES_EQ(_rvec1, _rvec2)", "CV_IS_MAT(_tvec1) && CV_IS_MAT(_tvec2)", "CV_ARE_SIZES_EQ(_tvec1, _tvec2) && CV_ARE_SIZES_EQ(_tvec1, _rvec1)", "Some of parameters is a NULL pointer!", "Input parameters must be a matrices!", "Size of matrices must be 3x3!", "stype == CV_8UC1 || stype == CV_16SC1 || stype == CV_32SC1 || stype == CV_32FC1", "Q.size() == Size(4,4)", "dtype == CV_16SC3 || dtype == CV_32SC3 || dtype == CV_32FC3", "cols >= 0", "disp.size() == _3dimg.size()", "CV_IS_MAT(matrixM) && CV_IS_MAT(matrixR) && CV_IS_MAT(matrixQ) && matrixM->cols == 3 && matrixM->rows == 3 && CV_ARE_SIZES_EQ(matrixM, matrixR) && CV_ARE_SIZES_EQ(matrixM, matrixQ)", "Size of projection matrix must be 3x4!", "Size of calibration and rotation matrices must be 3x3!", "Size of position vector must be 4x1!", "cvDet(&tmpMatrixM) != 0.0", "CV_IS_MAT(_points1) && CV_IS_MAT(_points2) && (_points1->rows == 1 || _points1->cols == 1) && (_points2->rows == 1 || _points2->cols == 1) && CV_ARE_SIZES_EQ(_points1, _points2)", "Both object points and image points must be 2D", "object points and image points must be a single-row matrices", "One of required arguments is not a valid matrix", "Homogeneous coordinates are not supported", "Rotation must be represented by 1x3 or 3x1 floating-point rotation vector, or 3x3 rotation matrix", "Translation vector must be 1x3 or 3x1 floating-point vector", "Instrinsic parameters must be 3x3 floating-point matrix", "Distortion coefficients must be 1x4, 4x1, 1x5, 5x1, 1x8 or 8x1 floating-point vector", "dp/drot must be 2Nx3 floating-point matrix", "dp/dT must be 2Nx3 floating-point matrix", "dp/df must be 2Nx2 floating-point matrix", "dp/dc must be 2Nx2 floating-point matrix", "dp/df must be 2Nx8, 2Nx5, 2Nx4 or 2Nx2 floating-point matrix", "distCoeffs is NULL while dpdk is not", "npoints >= 0 && (depth == CV_32F || depth == CV_64F)", "CV_IS_MAT(objectPoints) && CV_IS_MAT(imagePoints) && CV_IS_MAT(A) && CV_IS_MAT(rvec) && CV_IS_MAT(tvec)", "(CV_MAT_DEPTH(rvec->type) == CV_64F || CV_MAT_DEPTH(rvec->type) == CV_32F) && (rvec->rows == 1 || rvec->cols == 1) && rvec->rows*rvec->cols*CV_MAT_CN(rvec->type) == 3", "(CV_MAT_DEPTH(tvec->type) == CV_64F || CV_MAT_DEPTH(tvec->type) == CV_32F) && (tvec->rows == 1 || tvec->cols == 1) && tvec->rows*tvec->cols*CV_MAT_CN(tvec->type) == 3", "One of required vector arguments is not a valid matrix", "image width and height must be positive", "the array of point counters must be 1-dimensional integer vector", "the output array of rotation vectors must be 3-channel 1xn or nx1 array or 1-channel nx3 or nx9 array, where n is the number of views", "the output array of translation vectors must be 3-channel 1xn or nx1 array or 1-channel nx3 array, where n is the number of views", "Intrinsic parameters must be 3x3 floating-point matrix", "The number of points in the view #%d is < 4", "Focal length (fx and fy) must be positive", "Principal point must be within the image", "Non-zero skew is not supported by the function", "The intrinsic matrix must have [fx 0 cx; 0 fy cy; 0 0 1] shape", "The specified aspect ratio (= cameraMatrix[0][0] / cameraMatrix[1][1]) is incorrect", "For non-planar calibration rigs the initial intrinsic matrix must be specified", "CV_IS_MAT(_imagePoints1) && CV_IS_MAT(_imagePoints2) && CV_IS_MAT(_objectPoints) && CV_IS_MAT(_npoints) && CV_IS_MAT(matR) && CV_IS_MAT(matT)", "CV_ARE_TYPES_EQ(_imagePoints1, _imagePoints2) && CV_ARE_DEPTHS_EQ(_imagePoints1, _objectPoints)", "(_npoints->cols == 1 || _npoints->rows == 1) && CV_MAT_TYPE(_npoints->type) == CV_32SC1", "(CV_MAT_DEPTH(_imagePoints1->type) == CV_32F || CV_MAT_DEPTH(_imagePoints1->type) == CV_64F) && ((_imagePoints1->rows == pointsTotal && _imagePoints1->cols*cn == 2) || (_imagePoints1->rows == 1 && _imagePoints1->cols == pointsTotal && cn == 2))", "nimages > 0 && nimages == (int)imagePoints1.total() && (!imgPtMat2 || nimages == (int)imagePoints2.total())", "ni >= 0", "ni > 0 && ni == ni1", "ni == ni2", "nimages > 0", "ni1 > 0 && ni1 == ni3", "void cv::collectCalibrationData(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Mat&, cv::Mat&, cv::Mat*, cv::Mat&)", "void cvProjectPoints2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, double)", "void cvCalcMatMulDeriv(const CvMat*, const CvMat*, CvMat*, CvMat*)", "void cvComposeRT(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)", "double cv::calibrateCamera(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Size, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, int, cv::TermCriteria)", "void cv::reprojectImageTo3D(cv::InputArray, cv::OutputArray, cv::InputArray, bool, int)", "void cv::adjust3rdMatrix(cv::InputArrayOfArrays, cv::InputArrayOfArrays, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, cv::Mat&)", "double cvStereoCalibrate(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvSize, CvMat*, CvMat*, CvMat*, CvMat*, CvTermCriteria, int)", "bool cv::findCirclesGrid(cv::InputArray, cv::Size, cv::OutputArray, int, const cv::Ptr<cv::FeatureDetector>&)", "int cvFindChessboardCorners(void const*, CvSize, CvPoint2D32f*, int*, int)", "void cv::drawChessboardCorners(cv::InputOutputArray, cv::Size, cv::InputArray, bool)", "Number of channels must be 1, 3 or 4", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/calib3d/src/calibinit.cpp", "Only 8-bit, 16-bit or floating-point 32-bit images are supported", "nelems >= 0", "Only 8-bit grayscale or color images are supported", "Both width and height of the pattern should have bigger than 2", "Null pointer to corners", "vector::_M_insert_aux", "isAsymmetricGrid ^ isSymmetricGrid", "Unkown pattern type", "vector::_M_fill_insert", "void cvDrawChessboardCorners(CvArr*, CvSize, CvPoint2D32f*, int, int)", "11CvStatModel", "CvStatModel::read", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/inner_functions.cpp", "CvStatModel::write", "The function supports only single-channel arrays", "Unsupported combination of input and output vectors", "Inner function failed.", "Could not open the file storage. Check the path and permissions", "my_stat_model", "Invalid index array", "the index array must be 1-dimensional", "Component mask should contain as many elements as the total number of input variables", "No components/input_variables is selected!", "index array may not contain more elements than the total number of input variables", "Unsupported index array data type (it should be 8uC1, 8sC1 or 32sC1)", "the index array elements are out of range", "There are duplicated index array elements", "Invalid or absent var_type array", "var_type array must be 1-dimensional", "type mask must be 8uC1 or 8sC1 array", "type mask must be of <input var count> + 1 size", "var index array should be continuous 1-dimensional integer vector", "var index array is too large", "Invalid response array", "Response array must be 1-dimensional", "Response array must contain as many elements as the total number of samples", "Unsupported response type", "sample index array should be continuous 1-dimensional integer vector", "sample index array is too large", "out_response_map pointer is NULL", "response #%d is not integral", "There is only a single class", "Invalid or NULL training data matrix", "train data must be floating-point matrix", "missing value mask must be 8-bit matrix of the same size as training data", "Unknown training data layout (must be CV_ROW_SAMPLE or CV_COL_SAMPLE)", "output pointer to train samples is NULL", "output response pointer is NULL", "INTERNAL ERROR: some of the args are NULL pointers", "classes array must be a single row of integers", "The sample is not a valid vector", "Input sample must have 32fC1 type", "Input sample must be 1-dimensional vector", "The sample size is different from what has been used for training", "INTERNAL ERROR: The row_sample pointer is NULL", "INTERNAL ERROR: invalid comp_idx", "The output matrix of probabilities is invalid", "The matrix of probabilities must be 1-dimensional vector of 32fC1 type", "The vector of probabilities must contain as many elements as the number of classes in the training set", "Array of output labels is not a valid matrix", "Array of cluster centers is not a valid matrix", "Probability matrix is not valid", "Assertion: sample_idx->rows == 1 && CV_MAT_TYPE(sample_idx->type) == CV_32SC1 failed", "Assertion: comp_idx->rows == 1 && CV_MAT_TYPE(comp_idx->type) == CV_32SC1 failed", "NULL labels", "Assertion: labels->rows == 1 failed", "Array of output labels should be 1d vector", "Size of vector of output labels is not equal to the total number of input samples", "Assertion: labels->cols == samples_selected failed", "NULL centers", "Invalid number of rows in matrix of output centers", "Number of columns in matrix of output centers is not equal to the total number of components in the input samples", "Assertion: centers->cols == dims_selected failed", "NULL probs", "Invalid number of columns in output probability matrix", "Number of rows in output probability matrix is not equal to the total number of input samples", "Assertion: probs->rows == samples_selected failed", "Some of input arguments is not the CvMat", "Assertion: free_response == out_n failed", "Assertion: ICV_IS_MAT_OF_TYPE(probs, CV_64FC1) failed", "Assertion: ICV_IS_MAT_OF_TYPE(labels, CV_32SC1) failed", "Assertion: nsamples == labels->cols failed", "Assertion: prob_vector failed", "Assertion: (int)cvSum(counts).val[0] == nsamples failed", "Assertion: maxprob_loc >= 0 failed", "8CvMLData", "void CvMLData::set_train_test_split(const CvTrainTestSplit*)", "data is empty", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/data.cpp", "delimited, miss_character and flt_separator must be different", "var_idx is not correct", "type is not correct", "it`s impossible to assign CV_VAR_ORDERED type to categorical variable", "types string is not correct", "train samples count is not correct", "test_sample_count > 0", "variable index is not correct", "idx value is not correct", "10rprop_loop", "9CvANN_MLP", "virtual float CvANN_MLP::predict(const CvMat*, CvMat*) const", "virtual float CvANN_MLP::predict(const cv::Mat&, cv::Mat&) const", "Some of new output training vector components run exceed the original range too much", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/ann_mlp.cpp", "Unknown activation function", "layer_sizes", "Inner function failed.", "input_scale", "input_scale tag is not found or is invalid", "output_scale", "output_scale tag is not found or is invalid", "inv_output_scale", "inv_output_scale tag is not found or is invalid", "weights", "weights tag is not found or is invalid", "opencv-ml-ann-mlp", "SIGMOID_SYM", "IDENTITY", "GAUSSIAN", "activation_function", "f_param1", "f_param2", "min_val", "max_val", "min_val1", "max_val1", "training_params", "train_method", "BACKPROP", "dw_scale", "moment_scale", "RPROP", "dw_plus", "dw_minus", "dw_min", "dw_max", "term_criteria", "epsilon", "iterations", "The array of layer neuron counters must be an integer vector", "there should be at least one input and one output and every hidden layer must have more than 1 neuron", "The network has not been created. Use method create or the appropriate constructor", "input training data should be a floating-point matrix withthe number of rows equal to the number of training samples and the number of columns equal to the size of 0-th (input) layer", "output training data should be a floating-point matrix withthe number of rows equal to the number of training samples and the number of columns equal to the size of last (output) layer", "The numbers of input and output samples do not match", "sample_weights (if passed) must be a valid matrix", "sample_weights must be 1d floating-point vector containing weights of all or selected training samples", "some of sample weights are negative", "The network has not been initialized", "Both input and output must be floating-point matrices of the same type and have the same number of rows", "input matrix must have the same number of columns as the number of neurons in the input layer", "output matrix must have the same number of columns as the number of neurons in the output layer", "layer_sizes != 0", "my_nn", "N2cv25ForestTreeBestSplitFinderE", "virtual void CvRTrees::read(CvFileStorage*, CvFileNode*)", "12CvForestTree", "virtual bool CvRTrees::train(const CvMat*, int, const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvRTParams)", "virtual CvDTreeSplit* CvForestTree::find_best_split(CvDTreeNode*)", "opencv-ml-random-trees", "0 <= class_idx && class_idx < nclasses", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/rtrees.cpp", "This function works for binary classification problems only...", "Invalid CvRTrees object", "nclasses", "nsamples", "nactive_vars", "oob_error", "var_importance", "ntrees", "trees", "This method is not supported for regression problems", "<nactive_vars> must be non-negative", "(active_var_mask->cols >= 1) && (params.nactive_vars > 0) && (params.nactive_vars <= active_var_mask->cols)", "Some <nclasses>, <nsamples>, <var_count>, <nactive_vars>, <oob_error>, <ntrees> of tags are missing", "<trees> tag is missing", "<ntrees> is not equal to the number of trees saved in file", "my_random_trees", "var_count == data->var_count", "vector::_M_fill_insert", "virtual float CvRTrees::predict(const CvMat*, const CvMat*) const", "virtual void CvRTrees::write(CvFileStorage*, char const*) const", "8CvRTrees", "virtual float CvRTrees::predict_prob(const CvMat*, const CvMat*) const", "virtual float CvRTrees::get_train_error()", "12predict_body", "virtual float CvNormalBayesClassifier::predict(const CvMat*, CvMat*) const", "opencv-ml-bayesian", "var_count", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/nbayes.cpp", "var_all", "var_idx", "cls_labels", "count", "productsum", "inv_eigen_values", "cov_rotate_mats", "The new training data is inconsistent with the original training data", "In the current implementation the new training data must have absolutely the same set of class labels as used in the original training data", "No \"cls_labels\" in NBayes classifier", "Number of classes is less 1", "The field \"var_count\" of NBayes classifier is missing", "The input samples must be 32f matrix with the number of columns = var_all", "When the number of input samples is >1, the output vector of results must be passed", "The output array must be integer or floating-point vector with the number of elements = number of rows in the input matrix", "my_nb", "23CvNormalBayesClassifier", "17CvERTreeTrainData", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/ertrees.cpp", "opencv-ml-extremely-randomized-trees", "CvERTrees do not support surrogate splits", "CvERTrees do not support data update", "The array of _responses must be an integer or floating-point vector containing as many elements as the total number of samples in the training data matrix", "The memory buffer cannot be allocated since its size exceeds integer fields limit", "The many folds in cross-validation for such a small dataset", "%d-th value of %d-th (categorical) variable is not an integer", "%d-th value of %d-th (categorical) variable is too large", "%d-th value of %d-th (ordered) variable (=%g) is too large", "Every class weight should be positive", "No training data has been set", "_subsample_idx must be null for extra-trees", "<nactive_vars> must be non-negative", "(active_var_mask->cols >= 1) && (params.nactive_vars > 0) && (params.nactive_vars <= active_var_mask->cols)", "9CvERTrees", "virtual void CvERTreeTrainData::set_data(const CvMat*, int, const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvDTreeParams&, bool, bool, bool)", "virtual bool CvERTrees::train(const CvMat*, int, const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvRTParams)", "14CvForestERTree", "cv::Vec2d cv::EM::computeProbabilities(const cv::Mat&, cv::Mat*) const", "void cv::checkTrainData(int, const cv::Mat&, int, int, const cv::Mat*, const cv::Mat*, const std::vector<cv::Mat>*, const cv::Mat*)", "void cv::EM::clusterTrainSamples()", "bool cv::EM::doTrain(int, cv::OutputArray, cv::OutputArray, cv::OutputArray)", "N2cv2EME", "d.cols == 1 || d.rows == 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/mat.hpp", "!covsEigenValues.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/em.cpp", "!means.empty()", "sample.type() == CV_64FC1", "sample.rows == 1", "sample.cols == means.cols", "isTrained()", "!sample.empty()", "vector::_M_fill_insert", "!covs.empty()", "!covs[clusterIndex].empty()", "meansFlt.type() == CV_32FC1", "!clusterSamples.empty()", "weights.empty()", "invCovsEigenValues.empty()", "!samples.empty()", "samples.channels() == 1", "nclusters > 0", "nclusters <= nsamples", "startStep == EM::START_AUTO_STEP || startStep == EM::START_E_STEP || startStep == EM::START_M_STEP", "covMatType == EM::COV_MAT_GENERIC || covMatType == EM::COV_MAT_DIAGONAL || covMatType == EM::COV_MAT_SPHERICAL", "!probs || (!probs->empty() && probs->rows == nsamples && probs->cols == nclusters && (probs->type() == CV_32FC1 || probs->type() == CV_64FC1))", "!weights || (!weights->empty() && (weights->cols == 1 || weights->rows == 1) && static_cast<int>(weights->total()) == nclusters && (weights->type() == CV_32FC1 || weights->type() == CV_64FC1))", "!means || (!means->empty() && means->rows == nclusters && means->cols == dim && means->channels() == 1)", "!covs || (!covs->empty() && static_cast<int>(covs->size()) == nclusters)", "!m.empty() && m.size() == covSize && (m.channels() == 1)", "means", "probs", "void cv::EM::decomposeCovs()", "void cv::EM::computeLogWeightDivDet()", "cv::Vec2d cv::EM::predict(cv::InputArray, cv::OutputArray) const", "Invalid type parameter", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/testset.cpp", "samples parameter must be not NULL", "responses parameter must be not NULL", "num_samples parameter must be positive", "num_features parameter must be positive", "num_classes parameter must be positive", "Inner function failed.", "14Tree_predictor", "16Sample_predictor", "9CvGBTrees", "AbsoluteLoss", "SquaredLoss", "HuberLoss", "DevianceLoss", "loss_function", "ensemble_length", "shrinkage", "subsample_portion", "class_labels", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/gbt.cpp", "Unknown loss function", "class_labels must stored as a matrix", "opencv-ml-gradient-boosting-trees", "The model has not been trained yet", "base_value", "class_count", "trees_", "<trees_x> tag is missing", "The number of trees stored does not match <ntrees> tag value", "my_boost_tree", "Response should be a 32fC1 or 32sC1 vector.", "_sample_idx should be a 32sC1, 8sC1 or 8uC1 vector.", "vector::_M_fill_insert", "virtual bool CvGBTrees::train(const CvMat*, int, const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvGBTreesParams, bool)", "virtual void CvDTreeTrainData::set_data(const CvMat*, int, const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvDTreeParams&, bool, bool, bool)", "virtual CvDTreeNode* CvDTree::predict(const CvMat*, const CvMat*, bool) const", "16CvDTreeTrainData", "7CvDTree", "params.max_categories should be >= 2", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/tree.cpp", "params.max_depth should be >= 0", "params.cv_folds should be =0 (the tree is not pruned) or n>0 (tree is pruned using n-fold cross-validation)", "params.regression_accuracy should be >= 0", "Inner function failed.", "best_tree_idx", "nodes", "opencv-ml-tree", "depth", "sample_count", "value", "norm_class_idx", "complexity", "alpha", "node_risk", "tree_risk", "tree_error", "splits", "is_classifier", "var_all", "var_count", "ord_var_count", "cat_var_count", "training_params", "use_surrogates", "max_categories", "regression_accuracy", "max_depth", "min_sample_count", "cross_validation_folds", "use_1se_rule", "truncate_pruned_tree", "priors", "var_idx", "var_type", "cat_count", "cat_map", "some of the tree elements are not stored properly", "incorrect node depth", "splits tag must stored as a sequence", "nodes tag is missing", "The tree has not been trained yet", "the input sample must be 1d floating-point vector with the same number of elements as the total number of variables used for training", "the missing data mask must be 8-bit vector of the same size as input sample", "one of input categorical variable is not an integer", "root->left", "root->right", "priors must stored as a matrix", "var_idx (if exist) must be valid 1d integer vector containing <var_count> elements", "some of var_idx elements are out of range", "var_type must exist and be a sequence of 0's and 1's", "Both cat_count and cat_map must exist and be valid 1d integer vectors of an appropriate size", "some of cat_count elements are out of range", "cat_map vector length is not equal to the total number of categories in all categorical vars", "some of the splits are not stored properly", "Split variable index is out of range", "not_in", "Either 'in' or 'not_in' tags should be inside a categorical split data", "some of in/not_in elements are out of range", "quality", "The new training data must have the same types and the input and output variables and the same categories for categorical variables", "The array of _responses must be an integer or floating-point vector containing as many elements as the total number of samples in the training data matrix", "The memory buffer cannot be allocated since its size exceeds integer fields limit", "The many folds in cross-validation for such a small dataset", "%d-th value of %d-th (categorical) variable is not an integer", "%d-th value of %d-th (categorical) variable is too large", "%d-th value of %d-th (ordered) variable (=%g) is too large", "Every class weight should be positive", "my_tree", "No training data has been set", "vector::_M_fill_insert", "N2cv20DTreeBestSplitFinderE", "virtual bool CvDTree::do_train(const CvMat*)", "16predict_body_svm", "11CvSVMKernel", "virtual float CvSVM::predict(float const*, int, bool) const", "11CvSVMSolver", "virtual bool CvSVM::do_train(int, int, int, float const**, const CvMat*, CvMemStorage*, double*)", "5CvSVM", "opencv-ml-svm", "var_all", "var_count", "class_count", "class_labels", "class_weights", "var_idx", "sv_total", "support_vectors", "decision_functions", "sv_count", "alpha", "index", "Assertion: sv_count == sv_total failed", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/svm.cpp", "SVM model data is invalid, check sv_count, var_* and class_count tags", "NU_SVC", "C_SVC", "ONE_CLASS", "EPS_SVR", "NU_SVR", "POLY", "LINEAR", "SIGMOID", "svm_type", "kernel", "type", "degree", "gamma", "coef0", "term_criteria", "epsilon", "iterations", "The SVM should be trained first", "Inner function failed.", "Too small storage block size", "CvSVM::train", "Unknown/unsupported kernel type", "gamma parameter of the kernel must be positive", "The kernel parameter <coef0> must be positive or zero", "The kernel parameter <degree> must be positive", "Unknown/unsupported SVM type", "The parameter C must be positive", "The parameter nu must be between 0 and 1", "The parameter p must be positive", "INTERNAL ERROR: Unknown SVM type, the SVM structure is probably corrupted", "Lower bound of the grid must be less then the upper one", "Lower bound of the grid must be positive", "Grid step must greater then 1", "Parameter <k_fold> must be > 1", "CvSVM::train_auto", "CvSVM::get_default_grid", "Invalid type of parameter (use one of CvSVM::C, CvSVM::GAMMA et al.)", "svm_type tag is not found", "SVM kernel tag is not found", "SVM kernel type tag is not found", "Missing of invalid SVM type", "Missing of invalid SVM kernel type", "my_svm", "The requested element is not found", "Array of class labels is missing or invalid", "var_idx array is missing or invalid", "Missing or invalid sequence of support vectors", "Assertion: var_count == 1 || (CV_NODE_IS_SEQ(sv_elem->tag) && sv_elem->data.seq->total == var_count) failed", "decision_functions is missing or is not a collection or has a wrong number of elements", "sv_count is missing or non-positive", "rho is missing", "alpha is missing in the decision function", "Assertion: sv_count == 1 || (CV_NODE_IS_SEQ(alpha_node->tag) && alpha_node->data.seq->total == sv_count) failed", "index is missing in the decision function", "Assertion: sv_count == 1 || (CV_NODE_IS_SEQ(index_node->tag) && index_node->data.seq->total == sv_count) failed", "optimize_linear", "sv_count != 0", "params.class_weights must be 1d floating-point vector containing as many elements as the number of classes", "While cross-validation one or more of the classes have been fell out of the sample. Try to enlarge <CvSVMParams::k_fold>", "11CvBoostTree", "7CvBoost", "Unknown/unsupported boosting type", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/boost.cpp", "opencv-ml-boost-tree", "The classifier has not been trained yet", "trees", "RealAdaboost", "DiscreteAdaboost", "LogitBoost", "GentleAdaboost", "Gini", "Default", "Misclassification", "SquaredErr", "boosting_type", "splitting_criteria", "ntrees", "weight_trimming_rate", "The boosted tree ensemble has not been trained yet", "Inner function failed.", "Unknown boosting type", "the input sample must be 1d floating-point vector with the same number of elements as the total number of variables or as the number of variables used for training", "the missing data mask must be 8-bit vector of the same size as input sample", "The output matrix of weak classifier responses must be valid floating-point vector of the same number of components as the length of input slice", "one of input categorical variable is not an integer", "In raw mode the input vectors must be continuous", "<trees> tag is missing", "The number of trees stored does not match <ntrees> tag value", "Boosted trees can only be used for 2-class classification.", "my_boost_tree", "vector::_M_fill_insert", "StatModel.EM", "nclusters", "covMatType", "maxIters", "epsilon", "weights", "means", "covs", "virtual float CvKNearest::find_nearest(const CvMat*, int, CvMat*, float const**, CvMat*, CvMat*) const", "CvKNearest::train", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ml/src/knearest.cpp", "Could not allocate memory for responses", "The newly added data have different dimensionality", "max_k must be a positive number", "The search tree must be constructed first using train method", "Input samples must be floating-point matrix (<num_samples>x<var_count>)", "The results must be 1d vector containing as much elements as the number of samples", "The results must be floating-point or integer (in case of classification) vector", "k must be within 1..max_k range", "The neighbor responses (if present) must be floating-point matrix of <num_samples> x <k> size", "The distances from the neighbors (if present) must be floating-point matrix of <num_samples> x <k> size", "10CvKNearest", "Initial image", "void cv::drawDataMatrixCodes(cv::InputOutputArray, const std::vector<std::basic_string<char> >&, cv::InputArray)", "corners.depth() == CV_32S && corners.cols*corners.channels() == 8 && n == (int)codes.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/objdetect/src/datamatrix.cpp", "vector::_M_fill_insert", "bool cv::LatentSvmDetector::load(const std::vector<std::basic_string<char> >&, const std::vector<std::basic_string<char> >&)", "N2cv17LatentSvmDetectorE", "vector::reserve", "_classNames.empty() || _classNames.size() == filenames.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/objdetect/src/latentsvmdetector.cpp", "basic_string::substr", ".xml", "N2cv24CascadeClassifierInvokerE", "virtual int cv::CascadeClassifier::runAt(cv::Ptr<cv::FeatureEvaluator>&, cv::Point, double&)", "N2cv16FeatureEvaluatorE", "bool cv::CascadeClassifier::Data::read(const cv::FileNode&)", "N2cv17CascadeClassifierE", "N2cv12LBPEvaluatorE", "virtual void cv::HOGEvaluator::integralHistogram(const cv::Mat&, std::vector<cv::Mat>&, cv::Mat&, int) const", "N2cv12HOGEvaluatorE", "virtual void cv::CascadeClassifier::detectMultiScale(const cv::Mat&, std::vector<cv::Rect_<int> >&, std::vector<int>&, std::vector<double>&, double, int, int, cv::Size, cv::Size, bool)", "cv::Seq<_Tp>::Seq(const CvSeq*) [with _Tp = CvAvgComp, CvSeq = CvSeq]", "N2cv13HaarEvaluatorE", "rects", "tilted", "rect", "img.type() == CV_8U || img.type() == CV_8UC3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/objdetect/src/cascadedetect.cpp", "oldCascade.empty()", "!_seq || _seq->elem_size == sizeof(_Tp)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "vector::reserve", "vector::_M_insert_aux", "vector::_M_fill_insert", "vector::_M_range_insert", "stageType", "BOOST", "featureType", "HAAR", "width", "height", "origWinSize.height > 0 && origWinSize.width > 0", "stageParams", "maxDepth", "featureParams", "maxCatCount", "stages", "stageThreshold", "weakClassifiers", "internalNodes", "leafValues", "features", "scaleFactor > 1 && image.depth() == CV_8U", "N2cv38HaarDetectObjects_ScaleCascade_InvokerE", "N2cv36HaarDetectObjects_ScaleImage_InvokerE", "void* icvReadHaarClassifier(CvFileStorage*, CvFileNode*)", "CvHaarClassifierCascade* icvCreateHaarClassifierCascade(int)", "opencv-haar-classifier", "size", "stages", "stage %d", "trees", "tree %d", "node %d", "feature", "rects", "left_node", "left_val", "right_node", "right_val", "stage_threshold", "parent", "next", "tilted", "threshold", "Invalid classifier pointer", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/objdetect/src/haar.cpp", "hid_cascade has been already created", "Negative number of cascade stages", "header of the stage classifier #%d is invalid (has null pointers or non-positive classfier count)", "rectangle #%d of the classifier #%d of the stage classifier #%d is not inside the reference (original) cascade window", "Number of stages should be positive", "Invalid stages node", "size node is not a valid sequence.", "Invalid size node: width must be positive integer", "Invalid size node: height must be positive integer", "Invalid stage %d", "Trees node is not a valid sequence. (stage %d)", "Tree node is not a valid sequence. (stage %d, tree %d)", "Tree node %d is not a valid map. (stage %d, tree %d)", "Feature node is not a valid map. (stage %d, tree %d, node %d)", "Rects node is not a valid sequence. (stage %d, tree %d, node %d)", "Rect %d is not a valid sequence. (stage %d, tree %d, node %d)", "x coordinate must be non-negative integer. (stage %d, tree %d, node %d, rect %d)", "y coordinate must be non-negative integer. (stage %d, tree %d, node %d, rect %d)", "width must be positive integer and (x + width) must not exceed window width. (stage %d, tree %d, node %d, rect %d)", "height must be positive integer and (y + height) must not exceed window height. (stage %d, tree %d, node %d, rect %d)", "weight must be real number. (stage %d, tree %d, node %d, rect %d)", "tilted must be 0 or 1. (stage %d, tree %d, node %d)", "threshold must be real number. (stage %d, tree %d, node %d)", "left node must be valid node number. (stage %d, tree %d, node %d)", "left node or left value must be specified. (stage %d, tree %d, node %d)", "left value must be real number. (stage %d, tree %d, node %d)", "Tree structure is broken: too many values. (stage %d, tree %d, node %d)", "right node must be valid node number. (stage %d, tree %d, node %d)", "right node or right value must be specified. (stage %d, tree %d, node %d)", "right value must be real number. (stage %d, tree %d, node %d)", "Tree structure is broken: too few values. (stage %d, tree %d)", "stage threshold must be real number. (stage %d)", "parent must be integer number. (stage %d)", "next must be integer number. (stage %d)", "Scale must be positive", "COI is not supported", "All integral images must have the same size", "Only (32s, 64f, 32s) combination of (sum,sqsum,tilted_sum) formats is allowed", "Sum and tilted_sum must have the same stride (step, widthStep)", "Invalid cascade pointer", "Hidden cascade has not been created.\nUse cvSetImagesForHaarClassifierCascade", "Null path is passed", "%s%s%d/AdaBoostCARTHaarClassifier.txt", "Invalid path", "Could not allocate memory for input_cascade", "%s/%d/AdaBoostCARTHaarClassifier.txt", "elements_read == (size_t)(size)", "%d%n", "%d%d%d%d%d%f%n", "%s%n", "%f%d%d%n", "%f%n", "%d%d%n", "vector::_M_insert_aux", "vector::_M_fill_insert", "Invalid classifier cascade", "Null storage pointer", "Only 8-bit images are supported", "scale factor must be > 1", "CvHaarClassifierCascade* cvLoadHaarClassifierCascade(char const*, CvSize)", "int cvRunHaarClassifierCascadeSum(const CvHaarClassifierCascade*, CvPoint, double&, int)", "void cvSetImagesForHaarClassifierCascade(CvHaarClassifierCascade*, const CvArr*, const CvArr*, const CvArr*, double)", "CvSeq* cvHaarDetectObjectsForROC(const CvArr*, CvHaarClassifierCascade*, CvMemStorage*, std::vector<int>&, std::vector<double>&, double, int, int, CvSize, CvSize, bool)", "CvHidHaarClassifierCascade* icvCreateHidHaarClassifierCascade(CvHaarClassifierCascade*)", "N2cv10HOGInvokerE", "N2cv14HOGConfInvokerE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = bool]", "N2cv13HOGDescriptorE", "std::size_t cv::HOGDescriptor::getDescriptorSize() const", "float const* cv::HOGCache::getBlock(cv::Point, float*)", "N2cv8HOGCacheE", "readALTModel", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = cv::Size_<int>]", "virtual void cv::HOGDescriptor::compute(const cv::Mat&, std::vector<float>&, cv::Size, cv::Size, const std::vector<cv::Point_<int> >&) const", "virtual void cv::HOGDescriptor::setSVMDetector(cv::InputArray)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = double]", "virtual bool cv::HOGDescriptor::read(cv::FileNode&)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "virtual void cv::HOGDescriptor::computeGradient(const cv::Mat&, cv::Mat&, cv::Mat&, cv::Size, cv::Size) const", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = std::vector<float>]", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "blockSize.width % cellSize.width == 0 && blockSize.height % cellSize.height == 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/objdetect/src/hog.cpp", "(winSize.width - blockSize.width) % blockStride.width == 0 && (winSize.height - blockSize.height) % blockStride.height == 0", "checkDetectorSize()", "(unsigned)pt.x <= (unsigned)(grad.cols - blockSize.width) && (unsigned)pt.y <= (unsigned)(grad.rows - blockSize.height)", "pt.x % cacheStride.width == 0 && pt.y % cacheStride.height == 0", "blockHist != 0", "img.type() == CV_8U || img.type() == CV_8UC3", "{opencv-object-detector-hog", "winSize", "blockSize", "blockStride", "cellSize", "nbins", "derivAperture", "winSigma", "histogramNormType", "L2HysThreshold", "gammaCorrection", "nlevels", "SVMDetector", "vector::_M_fill_insert", "vector::_M_insert_aux", "pt0.x % cacheStride.width == 0 && pt0.y % cacheStride.height == 0", "rectList.size() == weights.size()", "file not exist", "version?", "V6.01", "version doesnot match", "opencv-object-detector-hog", "void (anonymous namespace)::parserRFilter(FILE*, int, CvLSVMFilterObject*, float*)", "void (anonymous namespace)::parserPFilter(FILE*, int, int, CvLSVMFilterObject*)", "<ScoreThreshold>", "</ScoreThreshold>", "</Component>", "<RootFilter>", "</RootFilter>", "<PartFilters>", "</PartFilters>", "<PartFilter>", "</PartFilter>", "</Weights>", "</Penalty>", "<LinearTerm>", "</LinearTerm>", "elements_read == (size_t)(p * sizeX * sizeY)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/objdetect/src/lsvmparser.cpp", "N2cv7linemod8ModalityE", "N2cv7linemod16QuantizedPyramidE", "void cv::linemod::Detector::writeClass(const string&, cv::FileStorage&) const", "virtual void cv::linemod::ColorGradient::read(const cv::FileNode&)", "DepthNormal", "const std::vector<cv::linemod::Template>& cv::linemod::Detector::getTemplates(const string&, int) const", "N2cv7linemod11DepthNormalE", "N2cv7linemod13ColorGradientE", "N2cv7linemod20ColorGradientPyramidE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = float]", "void cv::linemod::similarity(const std::vector<cv::Mat>&, const cv::linemod::Template&, cv::Mat&, cv::Size, int)", "int cv::linemod::getLabel(int)", "N2cv7linemod18DepthNormalPyramidE", "void cv::linemod::computeResponseMaps(const cv::Mat&, std::vector<cv::Mat>&)", "std::string cv::linemod::Detector::readClass(const cv::FileNode&, const string&)", "ColorGradient", "virtual void cv::linemod::DepthNormal::read(const cv::FileNode&)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "void cv::linemod::similarityLocal(const std::vector<cv::Mat>&, const cv::linemod::Template&, cv::Mat&, cv::Size, int, cv::Point)", "type", "type == DN_NAME", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/objdetect/src/linemod.cpp", "distance_threshold", "difference_threshold", "num_features", "extract_threshold", "type == CG_NAME", "weak_threshold", "strong_threshold", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "Invalid value of quantized parameter", "width", "height", "pyramid_level", "features", "ColorGradient", "DepthNormal", "pyramid_levels", "modalities", "it != class_templates.end()", "class_id", "template_pyramids", "template_id", "templates", "i != class_templates.end()", "i->second.size() > size_t(template_id)", "vector::_M_insert_aux", "vector::_M_fill_insert", "vector::_M_range_insert", "templ.features.size() <= 63", "mod_fn.size() == modalities.size()", "modalities[i]->name() == (std::string)(*mod_it)", "(int)fn[\"pyramid_levels\"] == pyramid_levels", "class_templates.find(class_id_tmp) == class_templates.end()", "template_id == expected_id", "(src.rows * src.cols) % 16 == 0", "response_map.rows % T == 0", "response_map.cols % T == 0", "N2cv11MOG2InvokerE", "N2cv24BackgroundSubtractorMOG2E", "virtual void cv::BackgroundSubtractorMOG2::operator()(cv::InputArray, cv::OutputArray, double)", "nchannels == 1 || nchannels == 3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/bgfg_gaussmix2.cpp", "learningRate >= 0", "virtual void cv::BackgroundSubtractorMOG2::getBackgroundImage(cv::OutputArray) const", "CvSeq* cvSegmentMotion(const CvArr*, CvArr*, CvMemStorage*, double, double)", "cv::Seq<_Tp>::Seq(const CvSeq*) [with _Tp = CvConnectedComp, CvSeq = CvSeq]", "void cvCalcMotionGradient(const CvArr*, CvArr*, CvArr*, double, double, int)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/motempl.cpp", "!_seq || _seq->elem_size == sizeof(_Tp)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "NULL memory storage", "Both MHI and the destination mask", "aperture_size must be 3, 5 or 7", "both delta's must be positive", "MHI and orientation must be single-channel floating-point images", "orientation image must be different from MHI", "MHI duration must be positive", "vector::_M_fill_insert", "double cvCalcGlobalOrientation(void const*, void const*, void const*, double, double)", "void cvUpdateMotionHistory(void const*, void*, double, double)", "N2cv23BackgroundSubtractorGMGE", "*N12_GLOBAL__N_112GMG_LoopBodyE", "func != 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/bgfg_gmg.cpp", "min < max", "maxFeatures > 0", "learningRate >= 0.0 && learningRate <= 1.0", "numInitializationFrames >= 1", "quantizationLevels >= 1 && quantizationLevels <= 255", "backgroundPrior >= 0.0 && backgroundPrior <= 1.0", "frame.depth() == CV_8U || frame.depth() == CV_16U || frame.depth() == CV_32F", "frame.channels() == 1 || frame.channels() == 3 || frame.channels() == 4", "newLearningRate >= 0.0 && newLearningRate <= 1.0", "void cv::BackgroundSubtractorGMG::initialize(cv::Size, double, double)", "virtual void (anonymous namespace)::GMG_LoopBody::operator()(const cv::Range&) const", "virtual void cv::BackgroundSubtractorGMG::operator()(cv::InputArray, cv::OutputArray, double)", "BackgroundSubtractor.MOG", "BackgroundSubtractor.MOG2", "BackgroundSubtractor.GMG", "history", "nmixtures", "backgroundRatio", "noiseSigma", "varThreshold", "detectShadows", "varThresholdGen", "fVarInit", "fVarMin", "fVarMax", "nShadowDetection", "fTau", "Maximum number of features to store in histogram. Harsh enforcement of sparsity constraint.", "maxFeatures", "Adaptation rate of histogram. Close to 1, slow adaptation. Close to 0, fast adaptation, features forgotten quickly.", "learningRate", "Number of frames to use to initialize histograms of pixels.", "initializationFrames", "Number of discrete colors to be used in histograms. Up-front quantization.", "quantizationLevels", "Prior probability that each individual pixel is a background pixel.", "backgroundPrior", "Radius of smoothing kernel to filter noise from FG mask image.", "smoothingRadius", "Threshold for FG decision rule. Pixel is FG if posterior probability exceeds threshold.", "decisionThreshold", "Perform background model update.", "updateBackgroundModel", "void cvCalcOpticalFlowFarneback(const CvArr*, const CvArr*, CvArr*, double, int, int, int, int, double, int)", "prev0.size() == next0.size() && prev0.channels() == next0.channels() && prev0.channels() == 1 && pyr_scale < 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/optflowgf.cpp", "flow.size() == prev.size() && flow.type() == CV_32FC2", "void cv::calcOpticalFlowFarneback(cv::InputArray, cv::InputArray, cv::OutputArray, double, int, int, int, int, double, int)", "CvKalman* cvCreateKalman(int, int, int)", "state and measurement vectors must have positive number of dimensions", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/kalman.cpp", "DP > 0 && MP > 0", "type == CV_32F || type == CV_64F", "const CvMat* cvKalmanPredict(CvKalman*, const CvMat*)", "void cvReleaseKalman(CvKalman**)", "const CvMat* cvKalmanCorrect(CvKalman*, const CvMat*)", "int cvMeanShift(void const*, CvRect, CvTermCriteria, CvConnectedComp*)", "Unsupported format", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/camshift.cpp", "Input window has non-positive sizes", "void cv::calcOpticalFlowSF(cv::Mat&, cv::Mat&, cv::Mat&, int, int, int, double, double, int, double, double, double, int, double, double, double)", "void cv::calcConfidence(const cv::Mat&, const cv::Mat&, const cv::Mat&, cv::Mat&, int)", "confidence.at<float>(r0, c0) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/simpleflow.cpp", "(int)pyr_from_images.size() == layers && (int)pyr_to_images.size() == layers", "int cvEstimateRigidTransform(const CvArr*, const CvArr*, CvMat*, int)", "int cv::buildOpticalFlowPyramid(cv::InputArray, cv::OutputArrayOfArrays, cv::Size, int, bool, int, int, bool)", "void (anonymous namespace)::calcSharrDeriv(const cv::Mat&, cv::Mat&)", "void cv::calcOpticalFlowPyrLK(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputOutputArray, cv::OutputArray, cv::OutputArray, cv::Size, int, cv::TermCriteria, int, double)", "void icvInitPyramidalAlgorithm(const CvMat*, const CvMat*, CvMat*, CvMat*, int, CvTermCriteria*, int, int, uchar***, uchar***, int**, CvSize**, double**, cv::AutoBuffer<unsigned char>*)", "N2cv6detail16LKTrackerInvokerE", "Some of the precomputed pyramids are missing", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/lkpyramid.cpp", "The number of pyramid levels is negative", "Invalid termination criteria", "depth == CV_8U", "img.depth() == CV_8U && winSize.width > 2 && winSize.height > 2", "imgA and imgB must have equal steps", "pyramid A has insufficient size", "pyramid B has insufficient size", "the search window is too small", "maxLevel >= 0 && winSize.width > 2 && winSize.height > 2", "(npoints = prevPtsMat.checkVector(2, CV_32F, true)) >= 0", "nextPtsMat.checkVector(2, CV_32F, true) == npoints", "statusMat.isContinuous()", "errMat.isContinuous()", "levels1 >= 0", "ofs.x >= winSize.width && ofs.y >= winSize.height && ofs.x + prevPyr[lvlStep1].cols + winSize.width <= fullSize.width && ofs.y + prevPyr[lvlStep1].rows + winSize.height <= fullSize.height", "levels2 >= 0", "ofs.x >= winSize.width && ofs.y >= winSize.height && ofs.x + nextPyr[lvlStep2].cols + winSize.width <= fullSize.width && ofs.y + nextPyr[lvlStep2].rows + winSize.height <= fullSize.height", "prevPyr[level * lvlStep1].size() == nextPyr[level * lvlStep2].size()", "prevPyr[level * lvlStep1].type() == nextPyr[level * lvlStep2].type()", "featuresA && featuresB", "Output parameter M is not a valid matrix", "Both input images must have the same size", "Both input images must have the same data type", "Both input images must have either 8uC1 or 8uC3 type", "void cvCalcAffineFlowPyrLK(void const*, void const*, void*, void*, const CvPoint2D32f*, CvPoint2D32f*, float*, int, CvSize, int, char*, float*, CvTermCriteria, int)", "void cvCalcOpticalFlowPyrLK(void const*, void const*, void*, void*, const CvPoint2D32f*, CvPoint2D32f*, int, CvSize, int, char*, float*, CvTermCriteria, int)", "virtual void cv::BackgroundSubtractorMOG::initialize(cv::Size, int)", "N2cv20BackgroundSubtractorE", "virtual void cv::BackgroundSubtractorMOG::operator()(cv::InputArray, cv::OutputArray, double)", "CV_MAT_DEPTH(frameType) == CV_8U", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/bgfg_gaussmix.cpp", "image.depth() == CV_8U", "learningRate >= 0", "Only 1- and 3-channel 8-bit images are supported in BackgroundSubtractorMOG", "N2cv23BackgroundSubtractorMOGE", "N2cv16DenseOpticalFlowE", "*N12_GLOBAL__N_120OpticalFlowDual_TVL1E", "*N12_GLOBAL__N_115CalcGradRhoBodyE", "*N12_GLOBAL__N_114DivergenceBodyE", "*N12_GLOBAL__N_116BuildFlowMapBodyE", "DenseOpticalFlow.DualTVL1", "Time step of the numerical scheme", "Weight parameter for the data term, attachment parameter", "lambda", "Weight parameter for (u - v)^2, tightness parameter", "theta", "Number of scales used to create the pyramid of images", "nscales", "Number of warpings per scale", "warps", "Stopping criterion threshold used in the numerical scheme, which is a trade-off between precision and running time", "epsilon", "Stopping criterion iterations number used in the numerical scheme", "iterations", "useInitialFlow", "vector::_M_fill_insert", "I0.type() == CV_8UC1 || I0.type() == CV_32FC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/video/src/tvl1flow.cpp", "I0.size() == I1.size()", "I0.type() == I1.type()", "!useInitialFlow || (_flow.size() == I0.size() && _flow.type() == CV_32FC2)", "nscales > 0", "*N12_GLOBAL__N_120CenteredGradientBodyE", "virtual void (anonymous namespace)::OpticalFlowDual_TVL1::calc(cv::InputArray, cv::InputArray, cv::InputOutputArray)", "*N12_GLOBAL__N_113EstimateVBodyE", "*N12_GLOBAL__N_125EstimateDualVariablesBodyE", "*N12_GLOBAL__N_119ForwardGradientBodyE", "void cv::generateColors(std::vector<cv::Scalar_<double> >&, std::size_t, std::size_t)", "vector::_M_fill_insert", "count >= 2", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/gencolors.cpp", "src.cols == 1 || src.rows == 1", "src.total() >= count", "src.type() == CV_8UC3", "Such big matrix cann't be created.", "bgr_subset.total() == count", "void downsamplePoints(const cv::Mat&, cv::Mat&, std::size_t)", "void cv::LDA::compute(cv::InputArrayOfArrays, cv::InputArray)", "cv::Mat cv::subspaceReconstruct(cv::InputArray, cv::InputArray, cv::InputArray)", "void cv::sortMatrixColumnsByIndices(cv::InputArray, cv::InputArray, cv::OutputArray)", "void cv::LDA::save(const string&) const", "void cv::LDA::load(const string&)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = cv::Mat]", "void cv::LDA::lda(cv::InputArrayOfArrays, cv::InputArray)", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "cv::sortColumnsByIndices only works on integer indices!", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/lda.cpp", "Wrong shapes for given matrices. Was size(src) = (%d,%d), size(W) = (%d,%d).", "Wrong mean shape for the given data matrix. Expected %d, but was %d.", "Wrong mean shape for the given eigenvector matrix. Expected %d, but was %d.", "num_components", "eigenvalues", "eigenvectors", "File can't be opened for writing!", "At least two classes are needed to perform a LDA. Reason: Only one class was given!", "The number of samples must equal the number of labels. Given %d labels, %d samples. ", "Warning: Less observations than feature dimension given!", "Computation will probably fail.", "Wrong shape of input matrix! Expected a matrix with one row or column.", "The data is expected as InputArray::STD_VECTOR_MAT (a std::vector<Mat>) or _InputArray::STD_VECTOR_VECTOR (a std::vector< vector<...> >).", "Wrong number of elements in matrix #%d! Expected %d was %d.", "InputArray Datatype %d is not supported.", "cv::Mat cv::asRowMatrix(cv::InputArrayOfArrays, int, double, double)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "cv::Mat cv::argsort(cv::InputArray, bool)", "cv::Mat cv::subspaceProject(cv::InputArray, cv::InputArray, cv::InputArray)", "N2cv8colormap6AutumnE", "N2cv8colormap8ColorMapE", "N2cv8colormap3JetE", "N2cv8colormap4BoneE", "N2cv8colormap4CoolE", "N2cv8colormap3HotE", "N2cv8colormap3HSVE", "N2cv8colormap5OceanE", "N2cv8colormap4PinkE", "N2cv8colormap7RainbowE", "N2cv8colormap6SpringE", "N2cv8colormap6SummerE", "N2cv8colormap6WinterE", "void cv::applyColorMap(cv::InputArray, cv::OutputArray, int)", "cv::Mat cv::argsort(cv::InputArray, bool)", "cv::argsort only sorts 1D matrices.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/colormap.cpp", "cv::LUT only supports tables of size 256.", "cv::sortRowsByIndices only works on integer indices!", "Unknown colormap id; use one of COLORMAP_*", "void cv::colormap::ColorMap::operator()(cv::InputArray, cv::OutputArray) const", "cv::Mat cv::interp1(cv::InputArray, cv::InputArray, cv::InputArray)", "N2cv9StereoVarE", "virtual void cv::StereoVar::operator()(const cv::Mat&, const cv::Mat&, cv::Mat&)", "left.size() == right.size() && left.type() == right.type()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/stereovar.cpp", "disp.size() == left.size() && disp.type() == CV_8UC1", "void cv::polyfit(const cv::Mat&, const cv::Mat&, cv::Mat&, int)", "(src_x.rows>0)&&(src_y.rows>0)&&(src_x.cols==1)&&(src_y.cols==1) &&(dst.cols==1)&&(dst.rows==(order+1))&&(order>=1)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/polyfit.cpp", "vector::_M_insert_aux", "vector::_M_range_insert", "N2cv14TemplateBufferIfEE", "St8valarrayIfE", "N2cv17BasicRetinaFilter24Parallel_localAdaptationE", "N2cv17BasicRetinaFilter40Parallel_horizontalCausalFilter_addInputE", "N2cv17BasicRetinaFilter35Parallel_horizontalAnticausalFilterE", "N2cv17BasicRetinaFilter29Parallel_verticalCausalFilterE", "N2cv17BasicRetinaFilter42Parallel_verticalAnticausalFilter_multGainE", "N2cv17BasicRetinaFilter45Parallel_horizontalAnticausalFilter_IrregularE", "N2cv17BasicRetinaFilter39Parallel_verticalCausalFilter_IrregularE", "BasicRetinaFilter::resize( ", "BasicRetinaFilter::spatial constant of the low pass filter must be superior to zero !!! correcting parameter setting to 0,001", "BasicRetinaFilter::spatial filtering coefficient must be superior to zero, correcting value to 0.01", "BasicRetinaFilter::setProgressiveFilterConstants_CustomAccuracy: error: input accuracy map does not match filter size, init skept", "BasicRetinaFilter::runProgressiveFilter: cannot perform filtering, no progressive filter settled up", "22CvAdaptiveSkinDetector", "N22CvAdaptiveSkinDetector9HistogramE", "N2cv17BasicRetinaFilterE", "ImageLogPolProjection::initLogRetinaSampling: could not initialize logPolar projection for a log projection system\n -> you probably chose the wrong init function, use initLogPolarCortexSampling() instead", "ImageLogPolProjection::initLogRetinaSampling: reduction factor must be superior to 0, skeeping initialisation...", "ImageLogPolProjection::could not initialize log projection for a logPolar projection system\n -> you probably chose the wrong init function, use initLogRetinaSampling() instead", "ImageLogPolProjection::reduction factor must be superior to 0, skeeping initialisation...", "ImageLogPolProjection::no projection setted up... performing default retina projection... take care", "N2cv21ImageLogPolProjectionE", "means", "bool cv::RGBDOdometry(cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, float, float, float, const std::vector<int>&, const std::vector<float>&, int)", "int computeCorresp(const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, float, cv::Mat&)", "vector::_M_fill_insert", "vector::reserve", "vector::_M_insert_aux", "Unsupported value of transformation type flag.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/rgbdodometry.cpp", "ksi.size() == Size(1,6) && ksi.type() == CV_64FC1", "!image0.empty()", "image0.type() == CV_8UC1", "depth0.type() == CV_32FC1 && depth0.size() == image0.size()", "image1.size() == image0.size()", "image1.type() == CV_8UC1", "depth1.type() == CV_32FC1 && depth1.size() == image0.size()", "validMask0.empty() || (validMask0.type() == CV_8UC1 && validMask0.size() == image0.size())", "validMask1.empty() || (validMask1.type() == CV_8UC1 && validMask1.size() == image0.size())", "cameraMatrix.type() == CV_32FC1 && cameraMatrix.size() == Size(3,3)", "iterCounts.empty() || minGradientMagnitudes.empty() || minGradientMagnitudes.size() == iterCounts.size()", "initRt.empty() || (initRt.type()==CV_64FC1 && initRt.size()==Size(4,4) )", "cameraMatrix.type() == CV_64FC1", "level_dI_dx1.type() == CV_16S", "level_dI_dy1.type() == CV_16S", "K.type() == CV_64FC1", "K_inv.type() == CV_64FC1", "Rt.type() == CV_64FC1", "bool computeKsi(int, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, int, double, double, double, double, cv::Mat&)", "void cvtDepth2Cloud(const cv::Mat&, cv::Mat&, const cv::Mat&)", "void computeProjectiveMatrix(const cv::Mat&, cv::Mat&)", "N2cv17MagnoRetinaFilter31Parallel_amacrineCellsComputingE", "N2cv17MagnoRetinaFilterE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = bool]", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "OPLandIPLparvo", "colorMode", "normaliseOutput", "photoreceptorsLocalAdaptationSensitivity", "photoreceptorsTemporalConstant", "photoreceptorsSpatialConstant", "horizontalCellsGain", "hcellsTemporalConstant", "hcellsSpatialConstant", "ganglionCellsSensitivity", "IPLmagno", "parasolCells_beta", "parasolCells_tau", "parasolCells_k", "amacrinCellsTemporalCutFrequency", "V0CompressionParameter", "localAdaptintegration_tau", "localAdaptintegration_k", "Current Retina instance setup :", "\nOPLandIPLparvo", "\n==> colorMode : ", "\n==> normalizeParvoOutput :", "\n==> photoreceptorsLocalAdaptationSensitivity : ", "\n==> photoreceptorsTemporalConstant : ", "\n==> photoreceptorsSpatialConstant : ", "\n==> horizontalCellsGain : ", "\n==> hcellsTemporalConstant : ", "\n==> hcellsSpatialConstant : ", "\n==> parvoGanglionCellsSensitivity : ", "\nIPLmagno", "\n==> normaliseOutput : ", "\n==> parasolCells_beta : ", "\n==> parasolCells_tau : ", "\n==> parasolCells_k : ", "\n==> amacrinCellsTemporalCutFrequency : ", "\n==> V0CompressionParameter : ", "\n==> localAdaptintegration_tau : ", "\n==> localAdaptintegration_k : ", "Retina::setup: provided parameters file could not be open... skeeping configuration", "Retina::setup: resetting retina with default parameters", "Retina::setup: wrong/unappropriate xml parameter file : error report :`n=>", "=> keeping current parameters", "Bad retina size setup : size height and with must be superior to zero", "Retina::setup", "Retina.h", "Retina cannot be applied, input buffer is empty", "Retina::run", "input image must be single channel (gray levels), bgr format (color) or bgra (color with transparency which won't be considered", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/retina.cpp", "Retina cannot be applied, wrong input buffer size", "bool cv::Retina::_convertCvMat2ValarrayBuffer(cv::Mat, std::valarray<float>&)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = float]", "N2cv6RetinaE", "virtual void cv::SelfSimDescriptor::compute(const cv::Mat&, std::vector<float>&, cv::Size, const std::vector<cv::Point_<int> >&) const", "N2cv17SelfSimDescriptorE", "vector::_M_fill_insert", "img.depth() == CV_8U", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/selfsimilarity.cpp", "vector::_M_fill_insert", "Feature2D.SIFT", "OpenCV has been compiled without SIFT support", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/featuretracker.cpp", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "Feature2D.SURF", "OpenCV has been compiled without SURF support", "hessianThreshold", "nOctaves", "Unknown feature type", "cv::CvFeatureTracker::CvFeatureTracker(cv::CvFeatureTrackerParams)", "void cv::of2::ChowLiuTree::add(const cv::Mat&)", "!imgDescriptors.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/chowliutree.cpp", "reduceEdgesToMinSpan(edges)", "!imgDescriptor.empty()", "imgDescriptors[0].cols == imgDescriptor.cols", "imgDescriptors[0].type() == imgDescriptor.type()", "N2cv3of211ChowLiuTreeE", "cv::Mat cv::of2::ChowLiuTree::make(double)", "N2cv15FaceRecognizer2E", "cv::Mat cv::asRowMatrix(cv::InputArrayOfArrays, int, double, double)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = cv::Mat]", "void cv::LBPH::train(cv::InputArrayOfArrays, cv::InputArray, bool)", "void cv::FaceRecognizer::setLabelsInfo(const std::map<int, std::basic_string<char> >&)", "N2cv14FaceRecognizerE", "N2cv4LBPHE", "cv::Mat cv::histc(cv::InputArray, int, int, bool)", "N2cv11FisherfacesE", "virtual void cv::FaceRecognizer::load(const string&)", "void cv::elbp(cv::InputArray, cv::OutputArray, int, int)", "virtual void cv::Fisherfaces::predict(cv::InputArray, int&, double&) const", "N2cv10EigenfacesE", "label", "value", "File can't be opened for writing!", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/facerec.cpp", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "num_components", "mean", "eigenvalues", "eigenvectors", "projections", "labels", "labelsInfo", "radius", "neighbors", "grid_x", "grid_y", "histograms", "FaceRecognizer.Eigenfaces", "FaceRecognizer.Fisherfaces", "FaceRecognizer.LBPH", "Using Original Local Binary Patterns for feature extraction only works on single-channel images (given %d). Please pass the image data as a grayscale image!", "The data is expected as InputArray::STD_VECTOR_MAT (a std::vector<Mat>) or _InputArray::STD_VECTOR_VECTOR (a std::vector< vector<...> >).", "Wrong number of elements in matrix #%d! Expected %d was %d.", "base != 0", "This Fisherfaces model is not computed yet. Did you call Fisherfaces::train?", "Wrong input image size. Reason: Training and Test images must be of equal size! Expected an image with %d elements, but got %d.", "This Eigenfaces model is not computed yet. Did you call Eigenfaces::train?", "(type()==0) || (DataType<_Tp>::type == type())", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/mat.hpp", "DataType<_Tp>::type == type() && cols == 1", "ncomponents", "threshold", "This type is not implemented yet.", "This LBPH model is not computed yet. Did you call the train method?", "Empty training data was given. You'll need more than one sample to learn a model.", "Labels must be given as integer (CV_32SC1). Expected %d, but was %d.", "In the Fisherfaces method all input samples (training images) must be of equal size! Expected %d pixels, but was %d pixels.", "The number of samples (src) must equal the number of labels (labels)! len(src)=%d, len(labels)=%d.", "Expected the labels in a matrix with one row or column! Given dimensions are rows=%s, cols=%d.", "The images are expected as InputArray::STD_VECTOR_MAT (a std::vector<Mat>) or _InputArray::STD_VECTOR_VECTOR (a std::vector< vector<...> >).", "The number of samples (src) must equal the number of labels (labels). Was len(samples)=%d, len(labels)=%d.", "This FaceRecognizer (%s) does not support updating, you have to use FaceRecognizer::train to update it.", "In the Eigenfaces method all input samples (training images) must be of equal size! Expected %d pixels, but was %d pixels.", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = cv::LabelInfo]", "virtual void cv::FaceRecognizer::save(const string&) const", "void cv::Mat::push_back(const _Tp&) [with _Tp = int]", "virtual void cv::LBPH::predict(cv::InputArray, int&, double&) const", "std::vector<int> cv::FaceRecognizer::getLabelsByString(const string&)", "virtual void cv::Fisherfaces::train(cv::InputArrayOfArrays, cv::InputArray)", "virtual void cv::Eigenfaces::predict(cv::InputArray, int&, double&) const", "void cv::FaceRecognizer::update(cv::InputArrayOfArrays, cv::InputArray)", "std::string cv::FaceRecognizer::getLabelInfo(int const&)", "virtual void cv::Eigenfaces::train(cv::InputArrayOfArrays, cv::InputArray)", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "DetectionBasedTracker::DetectionBasedTracker(const string&, const DetectionBasedTracker::Parameters&)", "void DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector()", "void* workcycleObjectDetectorFunction(void*)", "virtual void DetectionBasedTracker::process(const cv::Mat&)", "OBJECT_DETECTOR", "DetectionBasedTracker::SeparateDetectionWork::run() --- start", "DetectionBasedTracker::SeparateDetectionWork::run is called while the previous run is not stopped", "DetectionBasedTracker::SeparateDetectionWork::run --- end", "DetectionBasedTracker::SeparateDetectionWork::stop: before going to sleep to wait for the signal from the workthread", "DetectionBasedTracker::SeparateDetectionWork::stop: after receiving the signal from the workthread, stateThread=%d", "SimpleHighguiDemoCore::stop is called but the SimpleHighguiDemoCore pthread is not active", "DetectionBasedTracker::SeparateDetectionWork::resetTracking", "DetectionBasedTracker::SeparateDetectionWork::resetTracking: since workthread is detecting objects at the moment, we should make cascadeInThread stop detecting and forget the detecting results", "DetectionBasedTracker::SeparateDetectionWork::resetTracking: since workthread is NOT detecting objects at the moment, we should NOT make any additional actions", "DetectionBasedTracker::calcTrackedObjectPositionToShow: ERROR: wrong i=%d", "DetectionBasedTracker::calcTrackedObjectPositionToShow: trackedObjects[%d].numDetectedFrames=%d <= numStepsToWaitBeforeFirstShow=%d --- return empty Rect()", "DetectionBasedTracker::calcTrackedObjectPositionToShow: ERROR: no positions for i=%d", "DetectionBasedTracker::calcTrackedObjectPositionToShow: Result for i=%d: {%d, %d, %d x %d}", "DetectionBasedTracker::process: found a object with SIZE %d x %d, rect={%d, %d, %d x %d}", "DetectionBasedTracker::setParameters: ERROR: wrong parameters value", "\n\n\nATTENTION!!! dangerous algorithm error: destructor DetectionBasedTracker::DetectionBasedTracker::~SeparateDetectionWork is called before stopping the workthread", "DetectionBasedTracker::SeparateDetectionWork::SeparateDetectionWork: Cannot load a cascade from the file '", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/detection_based_tracker.cpp", "ERROR in DetectionBasedTracker::SeparateDetectionWork::SeparateDetectionWork in pthread_mutex_init(&mutex, NULL) is %d", "ERROR in DetectionBasedTracker::SeparateDetectionWork::SeparateDetectionWork in pthread_cond_init(&objectDetectorRun,, NULL) is %d", "ERROR in DetectionBasedTracker::SeparateDetectionWork::SeparateDetectionWork in pthread_cond_init(&objectDetectorThreadStartStop,, NULL) is %d", "DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingThread: shouldCommunicateWithDetectingThread=%d", "DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingThread: lastBigDetectionDuration=%f ms", "DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingThread: shouldSendNewDataToWorkThread was 1, now it is %d, since time_from_previous_launch_in_ms=%.2f, minDetectionPeriod=%d", "DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingThread: result: shouldHandleResult=%d", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- start", "stateThread==STATE_THREAD_WORKING_SLEEPING", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- before waiting", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- after waiting", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- imageSeparateDetecting is empty, continue", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- start handling imageSeparateDetecting, img.size=%dx%d, img.data=0x%p", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- end handling imageSeparateDetecting", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- objects num==%d, t_ms=%.4f", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- next step", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector: Returning", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- go out from the workcycle from inner part of lock just before waiting", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- go out from the workcycle just after waiting", "DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- go out from the workcycle just after detecting", "\n %s: ERROR: OpenCV Exception caught: \n'%s'\n\n", "\n %s: ERROR: Exception caught: \n'%s'\n\n", "\n %s: ERROR: UNKNOWN Exception caught\n\n", "DetectionBasedTracker::detectInRegion: Empty intersection", "DetectionBasedTracker::detectInRegion: img1.size()=%d x %d, d=%d", "(params.minObjectSize > 0) && (params.maxObjectSize >= 0) && (params.scaleFactor > 1.0) && (params.maxTrackLifetime >= 0)", "DetectionBasedTracker::DetectionBasedTracker: Cannot load a cascade from the file '", "DetectionBasedTracker::updateTrackedObjects: N1=%d, N2=%d", "vector::_M_fill_insert", "DetectionBasedTracker::updateTrackedObjects: i=%d", "numpositions > 0", "DetectionBasedTracker::updateTrackedObjects: prevRect[%d]={%d, %d, %d x %d}", "DetectionBasedTracker::updateTrackedObjects: j=%d", "DetectionBasedTracker::updateTrackedObjects: j=%d is rejected, because it has correspondence=%d", "DetectionBasedTracker::updateTrackedObjects: j=%d is rejected, because it is intersected with another rectangle", "DetectionBasedTracker::updateTrackedObjects: detectedObjects[%d]={%d, %d, %d x %d}", "DetectionBasedTracker::updateTrackedObjects: There is intersection between prevRect and detectedRect, r={%d, %d, %d x %d}", "DetectionBasedTracker::updateTrackedObjects: The area of intersection is %d, it is better than bestArea=%d", "DetectionBasedTracker::updateTrackedObjects: The best correspondence for i=%d is j=%d", "DetectionBasedTracker::updateTrackedObjects: Found intersection between rectangles j=%d and bestIndex=%d, rectangle j=%d is marked as intersected", "DetectionBasedTracker::updateTrackedObjects: There is no correspondence for i=%d ", "DetectionBasedTracker::updateTrackedObjects: start second cycle", "DetectionBasedTracker::updateTrackedObjects: add position", "DetectionBasedTracker::updateTrackedObjects: new object", "DetectionBasedTracker::updateTrackedObjects: was auxiliary intersection", "numpos > 0", "DetectionBasedTracker::updateTrackedObjects: deleted object {%d, %d, %d x %d}", "imageGray.type()==CV_8UC1", "DetectionBasedTracker::process: time from the previous call is %f ms", "DetectionBasedTracker::process: get _rectsWhereRegions were got from resultDetect", "DetectionBasedTracker::process: get _rectsWhereRegions from previous positions", "n > 0", "DetectionBasedTracker::process: ERROR: ATTENTION: strange algorithm's behavior: trackedObjects[i].rect() is empty", "DetectionBasedTracker::process: tracked objects num==%d", "DetectionBasedTracker::process: rectsWhereRegions.size()=%d", "DetectionBasedTracker::process: detectedObjectsInRegions.size()=%d", "21DetectionBasedTracker", "void DetectionBasedTracker::updateTrackedObjects(const std::vector<cv::Rect_<int> >&)", "N21DetectionBasedTracker21SeparateDetectionWorkE", "DetectionBasedTracker::SeparateDetectionWork::SeparateDetectionWork(DetectionBasedTracker&, const string&)", "RetinaFilter::Problem initializing photoreceptors log sampling, could not setup retina filter", "RetinaFilter::checkInput: input buffer does not match retina buffer size, conversion aborted", "RetinaFilter::checkInput: input size=", "retina size=", "not working, sorry", "N2cv6Mesh3D18EmptyMeshExceptionE", "float cv::Mesh3D::estimateResolution(float)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/spinimages.cpp", "#VRML V2.0 utf8", "Shape", "geometry PointSet", "coord Coordinate", "point[", "color Color", "color[", "vector::reserve", "vector::_M_fill_insert", "vector::_M_insert_aux", "Comparing scene spinimage ", " of ", "Spin correlation time  = ", "Matches number = ", "Matches number [filtered by similarity measure] = ", "Matches number [filtered by geometric consistency] = ", "grouping ...", "G = ", "void cv::of2::FabMap::compare(const cv::Mat&, std::vector<cv::of2::IMatch>&, bool, const cv::Mat&)", "N2cv3of29FabMapFBOE", "virtual double cv::of2::FabMap::getNewPlaceLikelihood(const cv::Mat&)", "virtual void cv::of2::FabMap::addTraining(const std::vector<cv::Mat>&)", "void cv::of2::FabMap::compare(const std::vector<cv::Mat>&, const std::vector<cv::Mat>&, std::vector<cv::of2::IMatch>&, const cv::Mat&)", "virtual void cv::of2::FabMap::add(const std::vector<cv::Mat>&)", "cv::of2::FabMap2::FabMap2(const cv::Mat&, double, double, int)", "N2cv3of29FabMapLUTE", "virtual void cv::of2::FabMap2::getLikelihoods(const cv::Mat&, const std::vector<cv::Mat>&, std::vector<cv::of2::IMatch>&)", "virtual void cv::of2::FabMap::add(const cv::Mat&)", "virtual void cv::of2::FabMap2::addTraining(const std::vector<cv::Mat>&)", "N2cv3of27FabMap1E", "virtual void cv::of2::FabMap::addTraining(const cv::Mat&)", "void cv::of2::FabMap::compare(const cv::Mat&, const std::vector<cv::Mat>&, std::vector<cv::of2::IMatch>&, const cv::Mat&)", "N2cv3of27FabMap2E", "void cv::of2::FabMap::normaliseDistribution(std::vector<cv::of2::IMatch>&)", "N2cv3of26FabMapE", "virtual void cv::of2::FabMap2::add(const std::vector<cv::Mat>&)", "cv::of2::FabMap::FabMap(const cv::Mat&, double, double, int, int)", "virtual double cv::of2::FabMap2::getNewPlaceLikelihood(const cv::Mat&)", "void cv::of2::FabMap::compare(const cv::Mat&, const cv::Mat&, std::vector<cv::of2::IMatch>&, const cv::Mat&)", "void cv::of2::FabMap::compare(const std::vector<cv::Mat>&, std::vector<cv::of2::IMatch>&, bool, const cv::Mat&)", "flags & MEAN_FIELD || flags & SAMPLED", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/openfabmap.cpp", "flags & NAIVE_BAYES || flags & CHOW_LIU", "clTree.type() == CV_64FC1", "!matches.empty()", "vector::_M_insert_aux", "!trainingImgDescriptors.empty()", "!(flags & MOTION_MODEL)", "vector::_M_range_insert", "!_testImgDescriptors[i].empty()", "_testImgDescriptors[i].rows == 1", "_testImgDescriptors[i].cols == clTree.cols", "_testImgDescriptors[i].type() == CV_32F", "!queryImgDescriptors[i].empty()", "queryImgDescriptors[i].rows == 1", "queryImgDescriptors[i].cols == clTree.cols", "queryImgDescriptors[i].type() == CV_32F", "numSamples > 0", "!queryImgDescriptor.empty()", "!testImgDescriptor.empty()", "flags & SAMPLED", "vector::_M_fill_insert", "N2cv17ParvoRetinaFilter31Parallel_OPL_OnOffWaysComputingE", "N2cv17ParvoRetinaFilterE", "25Parallel_clipBufferValuesIfE", "N2cv11RetinaColor48Parallel_adaptiveHorizontalCausalFilter_addInputE", "N2cv11RetinaColor50Parallel_adaptiveVerticalAnticausalFilter_multGainE", "N2cv11RetinaColorE", "TemplateBuffer::TemplateBuffer<type>::normalizeGrayOutputCentredSigmoide error: 2nd parameter (sensitivity) must not equal 0, copying original data...", "Color channels proportions: pR, pG, pB= ", "RetinaColor::No or wrong color sampling method, skeeping", "RetinaColor::applyKrauskopfLMS2Acr1cr2Transform: input buffer does not match retina buffer size, conversion aborted", "!descriptors.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/bowmsctrainer.cpp", "!_descriptors.empty()", "vector::_M_fill_insert", "virtual cv::Mat cv::of2::BOWMSCTrainer::cluster() const", "virtual cv::Mat cv::of2::BOWMSCTrainer::cluster(const cv::Mat&) const", "N2cv3of213BOWMSCTrainerE", "N2cv13LevMarqSparseE", "Iteration: ", ", normError: ", "] failed", "move failed: lambda = ", ", e2 = ", ") > ", "decreasing lambda to ", "imagePoints.size() == (size_t)num_cameras && visibility.size() == (size_t)num_cameras && R.size() == (size_t)num_cameras && T.size() == (size_t)num_cameras && (distCoeffs.size() == (size_t)num_cameras || distCoeffs.size() == 0)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/ba.cpp", "_points.size() == ptparams.size() && _points.type() == ptparams.type()", "static void cv::LevMarqSparse::bundleAdjust(std::vector<cv::Point3_<double> >&, const std::vector<std::vector<cv::Point_<double> > >&, const std::vector<std::vector<int> >&, std::vector<cv::Mat>&, std::vector<cv::Mat>&, std::vector<cv::Mat>&, std::vector<cv::Mat>&, const cv::TermCriteria&, cv::BundleAdjustCallback, void*)", "N2cv6OctreeE", "vector::_M_fill_insert", "N2cv14ChamferMatcher13ImageIteratorE", "N2cv14ChamferMatcher10ImageRangeE", "int cv::chamerMatching(cv::Mat&, cv::Mat&, std::vector<std::vector<cv::Point_<int> > >&, std::vector<float>&, double, int, double, int, int, int, double, double, double, double)", "N2cv14ChamferMatcher26LocationScaleImageIteratorE", "cv::ChamferMatcher::Matches* cv::ChamferMatcher::Matching::matchEdgeImage(cv::Mat&, const cv::ChamferMatcher::ImageRange&, float, int, float)", "N2cv14ChamferMatcher21LocationImageIteratorE", "N2cv14ChamferMatcher23SlidingWindowImageRangeE", "templ", "Index too big.\n", "vector::_M_insert_aux", "vector::_M_fill_insert", "vector::_M_range_insert", "edge_img.channels()==1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/contrib/src/chamfermatching.cpp", "vector::_M_range_check", "img.type() == CV_8UC1 && templ.type() == CV_8UC1", "N2cv14ChamferMatcher26SlidingWindowImageIteratorE", "void cvInpaint(const CvArr*, const CvArr*, CvArr*, double, int)", "All the input and output images must have the same size", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/photo/src/inpaint.cpp", "Only 8-bit 1-channel and 3-channel input/output images are supported", "The mask must be 8-bit 1-channel image", "The flags argument must be one of CV_INPAINT_TELEA or CV_INPAINT_NS", "27FastNlMeansDenoisingInvokerIhE", "27FastNlMeansDenoisingInvokerIN2cv3VecIhLi2EEEE", "27FastNlMeansDenoisingInvokerIN2cv3VecIhLi3EEEE", "32FastNlMeansMultiDenoisingInvokerIhE", "32FastNlMeansMultiDenoisingInvokerIN2cv3VecIhLi2EEEE", "32FastNlMeansMultiDenoisingInvokerIN2cv3VecIhLi3EEEE", "FastNlMeansMultiDenoisingInvoker<T>::FastNlMeansMultiDenoisingInvoker(const std::vector<cv::Mat>&, int, int, cv::Mat&, int, int, float) [with T = cv::Vec<unsigned char, 2>]", "void fastNlMeansDenoisingMultiCheckPreconditions(const std::vector<cv::Mat>&, int, int, int, int)", "FastNlMeansDenoisingInvoker<T>::FastNlMeansDenoisingInvoker(const cv::Mat&, cv::Mat&, int, int, float) [with T = unsigned char]", "void cv::fastNlMeansDenoising(cv::InputArray, cv::OutputArray, float, int, int)", "void cv::fastNlMeansDenoisingMulti(cv::InputArrayOfArrays, cv::OutputArray, int, int, float, int, int)", "Input images vector should not be empty!", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/photo/src/denoising.cpp", "All windows sizes should be odd!", "imgToDenoiseIndex and temporalWindowSize should be chosen corresponding srcImgs size!", "Input images should have the same size and type!", "vector::_M_fill_insert", "src.channels() == sizeof(T)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/photo/src/fast_nlmeans_denoising_invoker.hpp", "template_window_size_ <= 46340", "almost_dist2weight_[0] == fixed_point_mult_", "Unsupported image format! Only CV_8UC1, CV_8UC2 and CV_8UC3 are supported", "Type of input image should be CV_8UC3!", "srcImgs.size() > 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/photo/src/fast_nlmeans_multi_denoising_invoker.hpp", "srcImgs[0].channels() == sizeof(T)", "almost_dist2weight[0] == fixed_point_mult_", "Unsupported matrix format! Only uchar, Vec2b, Vec3b are supported", "Type of input images should be CV_8UC3!", "FastNlMeansDenoisingInvoker<T>::FastNlMeansDenoisingInvoker(const cv::Mat&, cv::Mat&, int, int, float) [with T = cv::Vec<unsigned char, 3>]", "void cv::fastNlMeansDenoisingColoredMulti(cv::InputArrayOfArrays, cv::OutputArray, int, int, float, float, int, int)", "void cv::fastNlMeansDenoisingColored(cv::InputArray, cv::OutputArray, float, float, int, int)", "FastNlMeansMultiDenoisingInvoker<T>::FastNlMeansMultiDenoisingInvoker(const std::vector<cv::Mat>&, int, int, cv::Mat&, int, int, float) [with T = cv::Vec<unsigned char, 3>]", "FastNlMeansDenoisingInvoker<T>::FastNlMeansDenoisingInvoker(const cv::Mat&, cv::Mat&, int, int, float) [with T = cv::Vec<unsigned char, 2>]", "FastNlMeansMultiDenoisingInvoker<T>::FastNlMeansMultiDenoisingInvoker(const std::vector<cv::Mat>&, int, int, cv::Mat&, int, int, float) [with T = unsigned char]", "void cv::PlanarObjectDetector::read(const cv::FileNode&)", "void cv::LDetector::operator()(const std::vector<cv::Mat>&, std::vector<cv::KeyPoint>&, int, bool) const", "N2cv14FernClassifierE", "virtual void cv::FernClassifier::prepare(int, int, int, int, int, int, int)", "bool cv::PlanarObjectDetector::operator()(const std::vector<cv::Mat>&, const std::vector<cv::KeyPoint>&, cv::Mat&, std::vector<cv::Point_<float> >&, std::vector<int>*) const", "N2cv21FernDescriptorMatcherE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = double]", "N2cv20PlanarObjectDetectorE", "virtual cv::Ptr<cv::GenericDescriptorMatcher> cv::FernDescriptorMatcher::clone(bool) const", "nclasses", "patchSize", "signatureSize", "nstructs", "structSize", "nviews", "compressionMethod", "struct-size", "signature-size", "compression-method", "patch-size", "features", "posteriors", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "points.size() == refimgs.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/planardetect.cpp", "labels.empty() || labels.size() == points.size()", "0 <= classId && classId < nclasses", "radius", "threshold", "noctaves", "base-feature-size", "clustering-distance", "model-roi", "detector", "model-points", "fern-classifier", "vector::_M_fill_insert", "vector::reserve", "_nclasses > 1 && _patchSize >= 5 && _nstructs > 0 && _nviews > 0 && _structSize > 0 && (_compressionMethod == COMPRESSION_NONE || _compressionMethod == COMPRESSION_RANDOM_PROJ || _compressionMethod == COMPRESSION_PCA)", "patchSize.width <= 256 && patchSize.height <= 256", "vector::_M_insert_aux", "n8 > 0", "fhcircle0.size() == (size_t)(radius+1) && circle0.size() % 2 == 0", "The descriptor has not been trained or the floating-point posteriors have been deleted", "patch.size() == patchSize", "modelPoints.size() == (size_t)fernClassifier.getClassCount()", "0 <= kpt.octave && kpt.octave < (int)pyr.size()", "matM.type() == CV_64F", "deep clone dunctionality is not implemented, because FernClassifier has not copy constructor or clone method ", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "virtual int cv::FernClassifier::operator()(const cv::Mat&, std::vector<float>&) const", "void cv::getDiscreteCircle(int, std::vector<cv::Point_<int> >&, std::vector<int>&)", "virtual void cv::FernClassifier::trainFromSingleView(const cv::Mat&, const std::vector<cv::KeyPoint>&, int, int, int, int, int, int, const cv::PatchGenerator&)", "virtual void cv::FernClassifier::train(const std::vector<std::vector<cv::Point_<float> > >&, const std::vector<cv::Mat>&, const std::vector<std::vector<int> >&, int, int, int, int, int, int, int, const cv::PatchGenerator&)", "4Face", "5RFace", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/hmmobs.cpp", "(icvImgToObs_DCT_8u32f_C1R( mat->data.ptr, mat->step, cvGetMatSize(mat), obs, dctSize, obsSize, delta )) >= 0", "(icvImgToObs_DCT_32f_C1R( mat->data.fl, mat->step, cvGetMatSize(mat), obs, dctSize, obsSize, delta )) >= 0", "void cvImgToObs_DCT(void const*, float*, CvSize, CvSize, CvSize)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/bgfg_acmmm2003.cpp", "Invalid or NULL first_frame parameter", "first_frame must have 3 color channels", "Inner function failed.", "27CvBlobTrackPostProcTimeAver", "22CvBlobTrackPostProcOne", "BlobTrackPostOne", "TimeAver", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/segment.cpp", "void cvUniformImgSegm(CvImgObsInfo*, CvEHMM*)", "float cvEViterbi(CvImgObsInfo*, CvEHMM*)", "(icvUniformImgSegm( obs_info, hmm )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/hmm.cpp", "(icvEstimateObsProb( obs_info, hmm )) >= 0", "Null pointer.", "void cvEstimateObsProb(CvImgObsInfo*, CvEHMM*)", "Video", "VideoObj", "noise_gaussian", "noise_normal", "noise_uniform", "noise_speckle", "noise_salt_and_pepper", "Size", "auto", "File", ".avi", "WARNING!!! Cannot open avi file %s\n", "WARNING!!! Can not open avi file %s\n", "Trans", "Shift", "Mask", "FrameBegin", "FrameNum", "LastFrame", "frame", "WARNING!!! - Video %s does not exist!\n", "Read node %s\n", "WARNING in parsing %s record!!! Cannot read array element\n", "NoiseAmp", "Voronoi Diagram is not defined", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/lcm.cpp", "Treshold parameter must be non negative", "Can't operate with multiconnected domains", "Can't operate with large domains", "input image has more than one channel", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/snakes.cpp", "Unsupported format", "(icvSnake8uC1R( data, step, size, points, length, alpha, beta, gamma, coeffUsage, win, criteria, calcGradient ? 2 : 1 )) >= 0", "void cvSnakeImage(const IplImage*, CvPoint*, int, float*, float*, float*, int, CvSize, CvTermCriteria, int)", "15CvSpillTreeWrap", "13CvFeatureTree", "Unsupported format", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/createhandmask.cpp", "output image have wrong number of channels", "(icvCreateHandMask8uC1R( numbers, img_mask_data, img_mask_step, img_mask_size, roi )) >= 0", "void cvCreateHandMask(CvSeq*, IplImage*, CvRect*)", "Contour sequence is empty", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/lee.cpp", "Storage is not initialized", "Unsupported parameter: type", "Unsupported parameter: orientation", "Contour sequence is not initialized", "Contour sequence is not empty", "Image is not initialized", "Unsupported image format", "Unsupported presision value", "Unsupported regularisation method", "void cvCalcOpticalFlowLK(void const*, void const*, CvSize, void*, void*)", "Source images have different formats", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/optflowlk.cpp", "Destination images have different formats", "Source images must have 8uC1 type and destination images must have 32fC1 type", "source and destination images have different step", "(icvCalcOpticalFlowLK_8u32fR( (uchar*)srcA->data.ptr, (uchar*)srcB->data.ptr, srcA->step, cvGetMatSize( srcA ), winSize, velx->data.fl, vely->data.fl, velx->step )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/texture.cpp", "Number of channels must be 1", "Depth must be equal IPL_DEPTH_8U", "Inner function failed.", "Histogram-based method is not implemented", "Matrices are not allocated", "descriptorOptimizationType different from CV_GLCMDESC_OPTIMIZATION_ALLOWDOUBLENEST\nis not supported", "step is not in 0 .. GLCM->numMatrices - 1", "descriptor is not in 0 .. GLCM->numDescriptors - 1", "Descriptors are not calculated", "Descriptor index is out of range", "The step index is out of range", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/prewarp.cpp", "void cvFindRuns(int, uchar*, uchar*, int*, int*, int*, int*, int*, int*)", "14CvBlobDetector", "9CvBlobSeq", "16CvBlobDetectorCC", "20CvBlobDetectorSimple", "ffffi", "BlobDetector", "Simple", "Latency", "HMin", "WMin", "MinDistToBorder", "Minimal allowed distance from blob center to image border in blob sizes", "Clastering", "ROIScale", "Determines the size of search window around a blob", "OnlyROI", "Shows the whole debug image (0) or only ROIs where the detector was applied (1)", "CvSeq* cvFindDominantPoints(CvSeq*, CvMemStorage*, int, double, double, double, double)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/dominants.cpp", "(icvFindDominantPointsIPAN( contour, storage, &corners, dmin*dmin, dmax*dmax, dneigh*dneigh, (float)amax )) >= 0", "Assertion: model && CV_MAT_TYPE(image->type) == CV_8UC3 && (!mask || (CV_IS_MASK_ARR(mask) && CV_ARE_SIZES_EQ(image, mask))) failed", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/bgfg_codebook.cpp", "Assertion: (unsigned)roi.x < (unsigned)image->cols && (unsigned)roi.y < (unsigned)image->rows && roi.width >= 0 && roi.height >= 0 && roi.x + roi.width <= image->cols && roi.y + roi.height <= image->rows failed", "Assertion: nblocks > 0 failed", "Assertion: model && CV_MAT_TYPE(image->type) == CV_8UC3 && image->cols == model->size.width && image->rows == model->size.height && CV_IS_MASK_ARR(mask) && CV_ARE_SIZES_EQ(image, mask) failed", "Assertion: model && (!mask || (CV_IS_MASK_ARR(mask) && mask->cols == model->size.width && mask->rows == model->size.height)) failed", "Assertion: (unsigned)roi.x < (unsigned)mask->cols && (unsigned)roi.y < (unsigned)mask->rows && roi.width >= 0 && roi.height >= 0 && roi.x + roi.width <= mask->cols && roi.y + roi.height <= mask->rows failed", "12CvKDTreeWrap", "virtual void CvKDTreeWrap::FindFeatures(const CvMat*, int, int, CvMat*, CvMat*)", "virtual int CvKDTreeWrap::FindOrthoRange(CvMat*, CvMat*, CvMat*)", "CvFeatureTree* cvCreateKDTree(CvMat*)", "vector::reserve", "vector::_M_insert_aux", "desc columns be equal feature dimensions", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/kdtree.cpp", "results and desc must be same height", "dist and desc must be same height", "results must be CV_32SC1", "dist must be CV_64FC1", "bounds_{min,max} must 1 x dims or dims x 1", "bounds_{min,max} must have same type", "descriptors must be either CV_32FC1 or CV_64FC1", "CvSubdiv2DPoint* cvSubdivDelaunay2DInsert(CvSubdiv2D*, CvPoint2D32f)", "CvSubdiv2DEdge cvSubdiv2DMakeEdge(CvSubdiv2D*)", "CvSubdiv2D* cvCreateSubdiv2D(int, int, int, int, CvMemStorage*)", "void cvClearSubdivVoronoi2D(CvSubdiv2D*)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/subdiv2.cpp", "edge != 0", "cvSubdiv2DLocate returned invalid location = %d", "CvSubdiv2DPoint* cvFindNearestPoint2D(CvSubdiv2D*, CvPoint2D32f)", "void cvCalcSubdivVoronoi2D(CvSubdiv2D*)", "void cvSubdiv2DSetEdgePoints(CvSubdiv2DEdge, CvSubdiv2DPoint*, CvSubdiv2DPoint*)", "CvSubdiv2DPointLocation cvSubdiv2DLocate(CvSubdiv2D*, CvPoint2D32f, CvSubdiv2DEdge*, CvSubdiv2DPoint**)", "void cvInitSubdivDelaunay2D(CvSubdiv2D*, CvRect)", "Unsupported format", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/eigenobjects.cpp", "Insufficient memory", "Different sizes of objects", "Different steps of objects", "Inner function failed.", "Unsupported i/o flag", "different sizes of images", "Different sizes of projects", "void cvConDensInitSampleSet(CvConDensation*, CvMat*, CvMat*)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/condens.cpp", "source  has not appropriate format", "source  has not appropriate size", "void cvConDensUpdateByTime(CvConDensation*)", "CvConDensation* cvCreateConDensation(int, int, int)", "21CvBlobTrackerOneMSFGS", "16CvBlobTrackerOne", "FGWeight", "Weight of FG mask using (0 - mask will not be used for tracking)", "Alpha", "Coefficient for model histogramm updating (0 - hist is not upated)", "MSFGS", "13CvCalibFilter", "%d\n\n", "%15.10f ", "%15.10lf ", "values_read == 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/calibfilter.cpp", "%lf ", "virtual bool CvCalibFilter::LoadCameraParams(char const*)", "17CvBlobTrackerList", "ffffi", "Collision", "if 1 then collision cases are processed in special way", "BGImageUsing", "Weight of using BG image in update hist model (0 - BG dies not use 1 - use)", "List", "17MouthFaceTemplate", "11FaceFeature", "12FaceTemplate", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/epilines.cpp", "void cv::extractPatches(IplImage*, std::vector<_IplImage*>&, CvSize)", "virtual void cv::OneWayDescriptorMatcher::knnMatchImpl(const cv::Mat&, std::vector<cv::KeyPoint>&, std::vector<std::vector<cv::DMatch> >&, int, const std::vector<cv::Mat>&, bool)", "virtual cv::Ptr<cv::GenericDescriptorMatcher> cv::OneWayDescriptorMatcher::clone(bool) const", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "%s/patch_%04d.png", "Image depth %d is not supported\n", "affine_poses", "affine poses", "pca_components_number", "pca components number", "descriptor_for_pca_component_%d", "descriptor for pca component %d", "File %s not found...\n", "Successfully read %d pca components\n", "avg_%s", "eigenvectors_%s", "The first component is the average Vector, so the total number of components is <pca components number> + 1", "patch_width", "patch_height", "poseCount", "patchWidth", "patchHeight", "minScale", "maxScale", "stepScale", "pyrLevels", "pcaDimHigh", "pcaDimLow", "Created descriptor for PCA component %d\n", "eigenvectors", "Cannot open file %s! Exiting!", "%s/%s", "Initializing the descriptors...", "pca_descriptors.yml", "Cannot open images list file %s\n", "SURF", "OpenCV was built without SURF support", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/oneway.cpp", "hessianThreshold", "pca.yml", "Calculating %d PCA descriptors (you can grab a coffee, this will take a while)...\n", "vector::_M_fill_insert", "deep clone functionality is not implemented, because OneWayDescriptorBase has not copy constructor or clone method ", "knn == 1", "N2cv23OneWayDescriptorMatcherE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = float]", "N2cv20OneWayDescriptorBaseE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "N2cv22OneWayDescriptorObjectE", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/levmarprojbandle.cpp", "Number of images must be more than zero", "Some of parameters is a NULL pointer", "Number of points4D must be more than zero", "Points must have 4 cordinates", "Number of images must be more than one", "Maximum number of iteration must be in [1..1000]", "Epsilon parameter must be >= 0", "resultPoints4D must be a matrix 4 x NumPnt", "resultPoints4D must have 4 cordinates", "each of initial projMatrs must be a matrix 3 x 4", "each of observProjPoints must be a matrix 2 x NumPnts", "each of pointsPres must be a matrix 1 x NumPnt", "each of resultProjMatrs must be a matrix 3 x 4", "d:\\test\\bundle.txt", "begin\n", "\n========================================\n", "Iter=0\n", "Error = %20.15lf\n", "Change = %20.15lf\n", "projection errors\n", "\nImage=%d\n", "%40.35lf, %40.35lf\n", "points4D must be a matrix 4xN", "Number of coordinates of points4D must be 4", "projMatr must be a matrix 3x4", "Size of projection matrix (projMatr) must be 3x4", "Status must be a matrix 1xN", "Size of status of points must be 1xN", "derivProj must be a matrix VisN x 12", "derivProj must be a matrix 2VisN x 12", "points4D must be a matrix N x 4", "Number of points must be more than zero", "Size of presPoints status must be 1xN", "derivPoint must be a matrix 2 x 4VisNum", "Number of points must more than zero", "matrW must be a matrix 12NumIm x 4NumPnt", "jacProjErr must be a matrix 12NumIm x 1", "jacPointErr must be a matrix 4NumPnt x 1", "\n----- test 13,01 currImage=%d currNorm=%lf -----\n", "numPoints=%d\n", "Iter=%d\n", "\nChange inside newVal change = %20.15lf\n", "   normAll1= %20.15lf\n", "   normAll2= %20.15lf\n", "\nBest error = %40.35lf\n", "The histogram header is invalid ", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/pgh.cpp", "Sparse histogram are not supported", "The histogram must be two-dimensional", "The contour is not valid or the point type is not supported", "(icvCalcPGH( contour, ((CvMatND*)(hist->bins))->data.fl, size[0], size[1] )) >= 0", "void cvCalcPGH(const CvSeq*, CvHistogram*)", "15CvBlobTrackerCC", "NearestBlob", "AverFG", "ConfidenceType", "WARNING!!! Invalid Predictor in CC tracker", "ffffi", "Collision", "If 1 then collision cases are processed in special way", "AlphaSize", "Size update speed (0..1)", "AlphaPos", "Position update speed (0..1)", "Alpha", "Coefficient for model histogram updating (0 - hist is not updated)", "Type of calculated Confidence (NearestBlob, AverFG, BC)", "void cvCalcOpticalFlowHS(void const*, void const*, int, void*, void*, double, CvTermCriteria)", "Source images have different formats", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/optflowhs.cpp", "Destination images have different formats", "Source images must have 8uC1 type and destination images must have 32fC1 type", "source and destination images have different step", "(icvCalcOpticalFlowHS_8u32fR( (uchar*)srcA->data.ptr, (uchar*)srcB->data.ptr, srcA->step, cvGetMatSize( srcA ), usePrevious, velx->data.fl, vely->data.fl, velx->step, (float)lambda, criteria )) >= 0", "Source image must have 3 channel.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/lines.cpp", "Channel depth of source image must be 8.", "Inner function failed.", "Channel depth of image must be 8.", "void cvExtractSURF(const CvArr*, const CvArr*, CvSeq**, CvSeq**, CvMemStorage*, CvSURFParams, int)", "Feature2D.SURF", "OpenCV was built without SURF support", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/features2d.cpp", "hessianThreshold", "nOctaves", "nOctaveLayers", "upright", "extended", "15CvBlobTrackGen1", "14CvBlobTrackGen", "Warning! Cannot open %s file for track output\n", ", %.1f, %.1f", ", %.2f", "ffffi", "BlobTrackGen", "Gen1", "17CvCamShiftTracker", "void cvMorphEpilinesMulti(int, uchar*, int*, uchar*, int*, uchar*, int*, float, int*, int*, int*, int*, int*, int*)", "(icvMorphEpilines8uC3Multi( lines, first_pix, first_num, second_pix, second_num, dst_pix, dst_num, alpha, first, first_runs, second, second_runs, first_corr, second_corr )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/morphing.cpp", "void cvMakeScanlines(const CvMatrix3*, CvSize, int*, int*, int*, int*, int*)", "(icvMakeScanlines( (CvMatrix3*)matrix, imgSize, scanlines_1, scanlines_2, lens_1, lens_2, numlines )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/scanlines.cpp", "cvRandSetRange", "Null pointer to RNG state", "cvcompat.h", "index is not in -1..3", "cvRandInit", "Unknown distribution type", "cvRand", "cvStartScanGraph", "Null scanner pointer", "cvEndScanGraph", "virtual bool CvEM::train(const cv::Mat&, const cv::Mat&, CvEMParams, cv::Mat*)", "4CvEM", "virtual bool CvEM::train(const CvMat*, const CvMat*, CvEMParams, CvMat*)", "prbs.size == prbs0.size", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/em.cpp", "_sample_idx == 0", "labels0.data == labels.data", "nclusters", "weights", "means", "vector::_M_fill_insert", "covs", "_sample_idx.empty()", "Bad start type of EM algorithm", "virtual float CvEM::predict(const CvMat*, CvMat*) const", "22CvBlobTrackAnalysisIOR", "19CvBlobTrackAnalysis", "BlobTrackAnalysis", "HIST", "Can not add track analyzer %s! (not more that %d analyzers)\n", "bool CvImage::load(char const*, char const*, int)", ".xml", ".Xml", ".XML", ".yml", ".Yml", ".YML", ".yaml", ".Yaml", ".YAML", "The object is neither an image, nor a matrix", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/image.cpp", "RGB<->Grayscale conversion is not implemented for images stored in XML/YAML", "RGB<->Grayscale conversion is not implemented for matrices stored in XML/YAML", "IplImage* icvRetrieveImage(void*)", "CvMat* icvRetrieveMatrix(void*)", "bool CvMatrix::load(char const*, char const*, int)", "=Unsupported format", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/pyrsegmentation.cpp", "src and dst have different formats", "src and dst have different ROIs", "(icvPyrSegmentation8uC1R( src_data, src_step, dst_data, dst_step, src_size, CV_GAUSSIAN_5x5, comp, storage, level, thresh1, thresh2 )) >= 0", "(icvPyrSegmentation8uC3R( src_data, src_step, dst_data, dst_step, src_size, CV_GAUSSIAN_5x5, comp, storage, level, thresh1, thresh2 )) >= 0", "void cvPyrSegmentation(IplImage*, IplImage*, CvMemStorage*, CvSeq**, int, double, double)", "CvBGStatModel* cvCreateGaussianBGModel(IplImage*, CvGaussBGStatModelParams*)", "int icvUpdateGaussianBGModel2(IplImage*, CvGaussBGModel2*)", "void icvReleaseGaussianBGModel(CvGaussBGModel**)", "int icvUpdateGaussianBGModel(IplImage*, CvGaussBGModel*, double)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/bgfg_gaussmix.cpp", "mog != 0", "CV_IS_IMAGE(first_frame)", "the image not the same size as the reserved GMM background model", "Invalid or NULL first_frame parameter", "Maxumum number of channels in the image is excedded (change CV_BGFG_MOG2_MAXBANDS constant)!", "Inner function failed.", "double cvMatchContourTrees(const CvContourTree*, const CvContourTree*, int, double)", "CvContourTree* cvCreateContourTree(const CvSeq*, CvMemStorage*, double)", "(icvCreateContourTree( contour, storage, &tree, threshold )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/contourtree.cpp", "Unknown/unsupported comparison method", "The first argument is not a valid contour tree", "The second argument is not a valid contour tree", "CvSeq* cvContourFromContourTree(const CvContourTree*, CvMemStorage*, CvTermCriteria)", "17CvBlobTrackGenYML", "ffffi", "WARNING!!! Cannot open %s file for trajectory output.", "%s_obj%d", "FrameBegin", "VideoObj", "Size", "BlobTrackGen", "20CvBlobTrackPredictor", "24CvBlobTrackPredictKalman", "BlobTrackPostOne", "ModelNoise", "DataNoisePos", "DataNoiseSize", "Kalman", "BlobTrackPredictor", "25CvBlobTrackPostProcKalman", "20BoostingFaceTemplate", "13FaceDetection", "21FaceDetectionListElem", "17FaceDetectionList", "12CvFGDetector", "13CvBlobTracker", "10CvVSModule", "ffffi", "DebugWnd", "unknown", "WARNING!!! Can't read structure %s\n", "WARNING!!! Structure %s is not sequence and can not be read\n", "FGDetector", "BlobTracker", "14CvBlobTrackSeq", "void cvCalcImageHomography(float*, CvPoint3D32f*, float*, float*)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/calcimagehomography.cpp", "17CvBlobTrackerAuto", "BlobList", "FrameCount", "NextBlobID", "- %sFrame: %d ALL_TIME - %f\n", "ForFrame Frame: %d %s %f on %f blobs\n", "FGDetector", "ForBlob  Frame: %d %s - %f\n", "BlobTracker", "PostProcessing", "BlobDeleter", "BlobTrackerUpdate", "BlobDetector", "TrajectoryGeneration", "TrackAnalysis", "BlobTrackerAuto", "ffffi", "TimesFile", "BlobTrackerReal", "Auto1", "18CvBlobTrackerAuto1", "15memory_hash_opsIfE", "15CvLSHOperations", "15memory_hash_opsIdE", "CvLSH* cvCreateLSH(CvLSHOperations*, int, int, int, int, double, int64)", "void cvLSHQuery(CvLSH*, const CvMat*, CvMat*, CvMat*, int, int)", "indices must be CV_32SC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/lsh.cpp", "data must be n x d, where d is what was used to construct LSH", "type of data and constructed LSH must agree", "indices must be n x 1 or 1 x n for n x d data", "k must be positive", "dist must be n x k for n x d data", "dist and indices must be same size", "dist must be CV_64FC1", "vector::_M_fill_insert", "vectors must be either CV_32FC1 or CV_64FC1", "vector::reserve", "vector::_M_insert_aux", "void cvLSHRemove(CvLSH*, const CvMat*)", "void cvLSHAdd(CvLSH*, const CvMat*, CvMat*)", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/video.cpp", "All the input images must have the same type", "Uncorrelated sizes of the input image and output fields", "Chess board size is invalid", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/3dtracker.cpp", "Null image", "Unsupported image format", "Null image data", "Invalid ROI", "Channel depth of source image must be 8", "Source image must have 1 or 3 channels", "Inner function failed.", "void cvCalcOpticalFlowBM(void const*, void const*, CvSize, CvSize, CvSize, int, void*, void*)", "Source images have different formats", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/optflowbm.cpp", "Destination images have different formats", "Source images must have 8uC1 type and destination images must have 32fC1 type", "two source or two destination images have different steps", "Inner function failed.", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/dpstereo.cpp", "COI is not supported by the function", "All images must be single-channel and have 8u", "parameter /maxDisparity/ is out of range", "Unsupported mode of function", "17CvBlobTrackerCCCR", "BlobNum", "BlobList", "Blob", "ffffi", "BlobPredict", "BlobPrev", "BlobHyp", "Collision", "Predictor", "Resolver", "DataNoisePos", "AlphaSize", "Size update speed (0..1)", "CCCR", "MSPF", "SizeVar", "17CvBlobTrackFVGenN", "16CvBlobTrackFVGen", "23CvBlobTrackAnalysisHist", "18CvBlobTrackFVGenSS", "abnormal", "BlobNum", "BlobList", "Blob", "ffffi", "LastFrame", "State", "Hist", "BlobTrackFVGen", ".yml", "WARNING!!! Can't load %s matrix\n", "BlobTrackAnalysis", "AbnormalThreshold", "If trajectory histogram value is lesst then <AbnormalThreshold*DataBaseTrackNum> then trajectory is abnormal", "SmoothRadius", "Radius (in bins) for histogram smoothing", "SmoothKernel", "L - Linear, G - Gaussian", "BinNum", "Number of bin for each dimention of feature vector", "(icvDynamicCorrespondMulti( lines, first, first_runs, second, second_runs, first_corr, second_corr )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/correspond.cpp", "void cvDynamicCorrespondMulti(int, int*, int*, int*, int*, int*, int*)", "void cvFindHandRegionA(CvPoint3D32f*, int, CvSeq*, float*, CvSize2D32f, int, CvPoint3D32f*, CvMemStorage*, CvSeq**)", "void cvFindHandRegion(CvPoint3D32f*, int, CvSeq*, float*, CvSize2D32f, int, CvPoint3D32f*, CvMemStorage*, CvSeq**)", "(icvFindHandRegion( points, count, indexs, line, size, -flag, center, storage, numbers )) >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/findhandregion.cpp", "(icvFindHandRegionA( points, count, indexs, line, size, flag, center, storage, numbers )) >= 0", "(icvFindHandRegionA( points, count, indexs, line, size, jc, center, storage, numbers )) >= 0", "state != 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/stereogc.cpp", "CV_ARE_SIZES_EQ(left, right) && CV_ARE_TYPES_EQ(left, right) && CV_MAT_TYPE(left->type) == CV_8UC1", "!dispLeft || (CV_ARE_SIZES_EQ(dispLeft, left) && CV_MAT_CN(dispLeft->type) == 1)", "!dispRight || (CV_ARE_SIZES_EQ(dispRight, left) && CV_MAT_CN(dispRight->type) == 1)", "dispLeft && dispRight", "void cvFindStereoCorrespondenceGC(const CvArr*, const CvArr*, CvArr*, CvArr*, CvStereoGCState*, int)", "20CvBlobTrackerOneMSFG", "18CvBlobTrackerOneMS", "20CvBlobTrackerOneMSPF", "Blob", "ffffi", "Collision", "HistVolume", "Hist", "ParticleNum", "ParticlesPredicted", "ffffiffd", "ParticlesResampled", "FGWeight", "Weight of FG mask using (0 - mask will not be used for tracking)", "Alpha", "Coefficient for model histogram updating (0 - hist is not upated)", "IterNum", "Maximal number of iteration in meanshift operation", "MSFG", "Number of particles", "UseVel", "Percent of particles which use velocity feature", "SizeVar", "Size variation (in object size)", "PosVar", "Position variation (in object size)", "MSPF", "sizeof(DefParticle) is %d\n", "Some of parameters is a NULL pointer", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/trifocal.cpp", "Input parameters must be a matrices", "Number of points must be the same", "Number of coordinates of projected points must be 2", "Number of coordinates of 4D points must be 4", "Size of projection matrix must be 3x4", "Inner function failed.", "srcMatr and dstMatr must be a matrices", "Number of rows of matrices must be the same", "points and resultT must be a matrices", "Number of points must be 4. And they must have 2 coordinates", "size of matrix resultT must be 3x3", "Number of points1 must be 3 and and have 3 coordinates", "Number of points2 must be 3 and and have 3 coordinates", "Size of fundReduceCoef1 must be 1x5", "Size of fundReduceCoef2 must be 1x5", "Size of resFundReduceCoef must be 1x5", "Size of fundReduceCoefs must be 1x5", "Size of projMatrCoefs must be 1x4", "Size of projMatr must be 3x4", "Number of points must be at least 6", "Number of points must be same", "Object points must have 4 coordinates", "Projected points must have 2 or 3 coordinates", "d:\\test\\recProjMatr.txt", "%d (%lf %lf %lf %lf) - (%lf %lf %lf)\n", "Number of points must be same and == 6", "Number of points coordinates must be 2", "Size of project matrix must be 3x4 or 9x4 (for 3 matrices)", "Number of points must be at least 5", "Size of transMatr must be 4x4", "Number of coordinates of points must be 4", "Number of proj points coordinates must be == 2", "Number of world points coordinates must be == 4", "Size of projection matrices must be 3x4", "Number points must be more than 6", "number of points must be the same", "Probability must be >=0 and <=1", "Threshold for good points must be at least >= 0", "Number of coordinates of points must be 2", "28CvBlobTrackAnalysisTrackDist", "abnormal", ".yml", "BlobTrackAnalysis", "ffffi", "DebugAVI", "Name of AVI file to save images from debug window", "TraceLen", "Length (in frames) of trajectory part that is used for comparison", "AbnormalThreshold", "If trajectory is equal with less then <AbnormalThreshold*DataBaseTrackNum> tracks then trajectory is abnormal", "PosThreshold", "Minimal allowd distance in blob width that is allowed", "VelThreshold", "Minimal allowed relative difference between blob speed", "TrackDist", "23CvBlobTrackAnalysisList", "BlobTrackAnalysis", "ffffi", "List", "23CvBlobTrackPostProcList", "19CvBlobTrackPostProc", "BlobTrackPostProc", "ffffi", "List", "void sum_50t_176c(uchar**, uchar*, short unsigned int*)", "[WARNING] %s:%i: square CS matrix (-> no reduction)\n", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/legacy/src/calonder.cpp", "PHI_DISTR_TYPE not implemented.", "Not supported without SSE2", "\n[OK] compressing leaves with phi %i x %i\n", "[WARNING] RandomizedTree::compressLeaves:  not compressing because reduced_dim == classes()", "clamp_mode == %i is not valid (%s:%i).\n", "WARNING: Cannot write float posteriors (posteriors_ = NULL).", "%.10e", "RTreeClassifier::write: num_quant_bits_=%i\n", "[DEBUG] writing all float posteriors to %s...\n", "[DEBUG] done", "[DEBUG] writing all byte posteriors to %s...\n", "[EXPERIMENTAL] read entire tree from '%s'\n", "[OK] RTC: overall %i/%i (%.3f%%) zeros in float leaves\n", "          overall %i/%i (%.3f%%) zeros in uint8 leaves\n", "[OK] RTC: discarded float posteriors of all trees", "vector::reserve", "vector::_M_insert_aux", "vector::_M_fill_insert", "[OK] signature quantization is now %i bits (before: %i)\n", "\n[OK] NO compression to leaves applied, dim=%i\n", "INVALID PARAMS in RTreeClassifier::train: reduced_num_dim{%i} > base_set.size(){%i}\n", "[OK] Training trees: base size=%i, reduced size=%i\n", "[OK] Trained 0 / %i trees", "\r[OK] Trained %i / %i trees", "[WARNING] RTC: suspicious value num_quant_bits_=%i found; setting to %i.\n", "[OK] Loaded RTC, quantization=%i bits\n", "16CvFGDetectorBase", "alpha1", "alpha2", "alpha3", "N1cc", "N2cc", "SaveName", "LoadName", "ObjWithoutHoles", "Morphology", "void cv::ocl::dft(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::Size, int)", "OpenCL DFT is not implemented", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/fft.cpp", "(anonymous namespace)::StereoBeliefPropagationImpl::StereoBeliefPropagationImpl(cv::ocl::StereoBeliefPropagation&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, std::vector<cv::ocl::oclMat>&, cv::ocl::oclMat&)", "void (anonymous namespace)::StereoBeliefPropagationImpl::operator()(const cv::ocl::oclMat&, cv::ocl::oclMat&)", "0 < rthis.ndisp && 0 < rthis.iters && 0 < rthis.levels", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/stereobp.cpp", "rthis.msg_type == CV_32F || rthis.msg_type == CV_16S", "rthis.msg_type == CV_32F || (1 << (rthis.levels - 1)) * scale * rthis.max_data_term < numeric_limits<short>::max()", "vector::_M_insert_aux", "-D T_SHORT", "-D T_FLOAT", "level_up_message", "T_SHORT", "T_FLOAT", "data_step_down", "one_iteration", "-D %s -D CNDISP=%d", "output", "vector::_M_fill_insert", "(data.type() == rthis.msg_type) && (data.rows % rthis.ndisp == 0)", "min(lowest_cols, lowest_rows) > min_image_dim_size", "left.size() == right.size() && left.type() == right.type()", "left.type() == CV_8UC1 || left.type() == CV_8UC3 || left.type() == CV_8UC4", "comp_data", "%s -D CN=%d", "void (anonymous namespace)::StereoBeliefPropagationImpl::operator()(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&)", "src.type() == CV_32FC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/columnsum.cpp", "columnSum", "void cv::ocl::columnSum(const cv::ocl::oclMat&, cv::ocl::oclMat&)", "N2cv3ocl16FilterEngine_GPUE", "N2cv3ocl14BaseFilter_GPUE", "N2cv3ocl17BaseRowFilter_GPUE", "N2cv3ocl20BaseColumnFilter_GPUE", "@void cv::ocl::morphologyEx(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, const cv::Mat&, cv::Point, int, int, const Scalar&)", "cv::Ptr<cv::ocl::FilterEngine_GPU> cv::ocl::createGaussianFilter_GPU(int, cv::Size, double, double, int, cv::Size)", "*N12_GLOBAL__N_135SingleStepSeparableFilterEngine_GPUE", "void linearRowFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = short unsigned int]", "void linearRowFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = unsigned char]", "void (anonymous namespace)::normalizeAnchor(int&, int)", "void sepFilter2D_SinglePass(const cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::Mat&, const cv::Mat&, int)", "ksize.height > 0 && ksize.width > 0 && ((ksize.height & 1) == 1) && ((ksize.width & 1) == 1)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/filtering.cpp", "roi.x >= 0 && roi.y >= 0 && roi.width <= src_size.width && roi.height <= src_size.height", "0 <= anchor && anchor < ksize", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "op == MORPH_ERODE || op == MORPH_DILATE", "type == CV_8UC1 || type == CV_8UC3 || type == CV_8UC4 || type == CV_32FC1 || type == CV_32FC3 || type == CV_32FC4", "delta == 0", "Selected device doesn't support double", "ksize == 1 || ksize == 3", "iterations > 0", "unsupported border type", "unknown morphological operation", "(ksize.width & 1) && (ksize.height & 1)", "src.type() == CV_8UC1 || src.type() == CV_8UC3", "adaptiveBilateralFilter", "BORDER_CONSTANT", "BORDER_REPLICATE", "BORDER_REFLECT", "BORDER_REFLECT_101", "This border type is not supported", "-D VAR_PER_CHANNEL=1 -D CALCVAR=1 -D FIXED_WEIGHT=0 -D EXTRA=%d -D MAX_VAR_VAL=%f -D ABF_GAUSSIAN=%d -D THREADS=%d -D anX=%d -D anY=%d -D ksX=%d -D ksY=%d -D %s", "-D BLK_X=%d -D BLK_Y=%d -D RADIUSX=%d -D RADIUSY=%d", " -D KERNEL_MATRIX_X=", "DIG(0x%x)", " -D KERNEL_MATRIX_Y=", " -D SRCTYPE=uchar -D CONVERT_SRCTYPE=convert_float -D WORKTYPE=float", " -D SRCTYPE=float -D CONVERT_SRCTYPE= -D WORKTYPE=float", " -D SRCTYPE=uchar2 -D CONVERT_SRCTYPE=convert_float2 -D WORKTYPE=float2", " -D SRCTYPE=float2 -D CONVERT_SRCTYPE= -D WORKTYPE=float2", " -D SRCTYPE=uchar3 -D CONVERT_SRCTYPE=convert_float3 -D WORKTYPE=float3", " -D SRCTYPE=float3 -D CONVERT_SRCTYPE= -D WORKTYPE=float3", " -D SRCTYPE=uchar4 -D CONVERT_SRCTYPE=convert_float4 -D WORKTYPE=float4", " -D SRCTYPE=float4 -D CONVERT_SRCTYPE= -D WORKTYPE=float4", "Image type is not supported!", " -D DSTTYPE=uchar -D CONVERT_DSTTYPE=convert_uchar_sat", " -D DSTTYPE=uchar2 -D CONVERT_DSTTYPE=convert_uchar2_sat", " -D DSTTYPE=uchar3 -D CONVERT_DSTTYPE=convert_uchar3_sat", " -D DSTTYPE=uchar4 -D CONVERT_DSTTYPE=convert_uchar4_sat", " -D DSTTYPE=float -D CONVERT_DSTTYPE=", " -D DSTTYPE=float2 -D CONVERT_DSTTYPE=", " -D DSTTYPE=float3 -D CONVERT_DSTTYPE=", " -D DSTTYPE=float4 -D CONVERT_DSTTYPE=", " -D BORDER_CONSTANT", " -D BORDER_REPLICATE", " -D BORDER_REFLECT", " -D BORDER_REFLECT_101", " -D BORDER_WRAP", "BORDER type is not supported!", "sep_filter_singlepass", "col_filter", "-D RADIUSY=%d -D LSIZE0=%d -D LSIZE1=%d -D CN=%d -D %s -D GENTYPE_SRC=%s -D GENTYPE_DST=%s -D convert_to_DST=%s", "float", "uchar", "convert_uchar_sat", "float2", "uchar2", "convert_uchar2_sat", "float4", "uchar4", "convert_uchar4_sat", "convert_int_sat", "int4", "convert_int4_sat", "clCxt == dst.clCxt", "src.cols == dst.cols", "src.oclchannels() == dst.oclchannels()", "ksize == (anchor << 1) + 1", "bordertype <= BORDER_REFLECT_101", "-D RADIUSX=%d -D LSIZE0=%d -D LSIZE1=%d -D CN=%d -D %s", "row_filter", "-D RECTKERNEL", "src.clCxt == dst.clCxt", "(src.cols == dst.cols) && (src.rows == dst.rows)", "(src.oclchannels() == dst.oclchannels())", "morph_C1_D0", "localThreads[0]*localThreads[1] * 8 >= (localThreads[0] * 4 + ksize.width - 1) * (localThreads[1] + ksize.height - 1)", "morph", "localThreads[0]*localThreads[1] * 2 >= (localThreads[0] + ksize.width - 1) * (localThreads[1] + ksize.height - 1)", "-D VAL=0 -D GENTYPE=uchar4", "-D VAL=-FLT_MAX -D GENTYPE=float", "-D VAL=-FLT_MAX -D GENTYPE=float4", "unsupported type", "-D RADIUSX=%d -D RADIUSY=%d -D LSIZE0=%d -D LSIZE1=%d -D DILATE %s %s", "-D VAL=255", "-D VAL=255 -D GENTYPE=uchar4", "-D VAL=FLT_MAX -D GENTYPE=float", "-D VAL=FLT_MAX -D GENTYPE=float4", "-D RADIUSX=%d -D RADIUSY=%d -D LSIZE0=%d -D LSIZE1=%d -D ERODE %s %s", "EXTRA_EXTRAPOLATION", "NO_EXTRA_EXTRAPOLATION", "BORDER_ISOLATED", "NO_BORDER_ISOLATED", "(size_t)ksize.width <= BLOCK_SIZE", "(int)(offsetX * src.elemSize()) == offsetXBytes", "(int)(_offsetX * dst.elemSize()) == _offsetXBytes", "BORDER_WRAP is not supported!", "w >= ksize.width && h >= ksize.height", "-D LOCAL_SIZE=%d -D BLOCK_SIZE_Y=%d -D DATA_DEPTH=%d -D DATA_CHAN=%d -D USE_DOUBLE=%d -D ANCHOR_X=%d -D ANCHOR_Y=%d -D KERNEL_SIZE_X=%d -D KERNEL_SIZE_Y=%d -D %s -D %s -D %s", "boxFilter", "BLOCK_SIZE > kernelWorkGroupSize", "ksize.width > 0 && ksize.width % 2 == 1 && ksize.height > 0 && ksize.height % 2 == 1", "vector::_M_fill_insert", "kernel.cols == ksize.width && kernel.rows == ksize.height", "kernel.channels() == 1", "anchor.x >= 0 && anchor.x < kernel.cols", "anchor.y >= 0 && anchor.y < kernel.rows", "-D LOCAL_SIZE=%d -D BLOCK_SIZE_Y=%d -D DATA_DEPTH=%d -D DATA_CHAN=%d -D USE_DOUBLE=%d -D ANCHOR_X=%d -D ANCHOR_Y=%d -D KERNEL_SIZE_X=%d -D KERNEL_SIZE_Y=%d -D KERNEL_SIZE_Y2_ALIGNED=%d -D %s -D %s -D %s", "filter2D", "BORDER_WRAP", "void GPUFilterBox(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::Size&, cv::Point, int)", "void linearColumnFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = float]", "void cv::ocl::filter2D(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, const cv::Mat&, cv::Point, double, int)", "void cv::ocl::GaussianBlur(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::Size, double, double, int)", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "void linearRowFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = short int]", "*N12_GLOBAL__N_126MorphologyFilterEngine_GPUE", "void cv::ocl::Laplacian(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, double, double, int)", "void linearRowFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = float]", "*N12_GLOBAL__N_121GpuLinearColumnFilterE", "void cv::ocl::adaptiveBilateralFilter(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::Size, double, double, cv::Point, int)", "void (anonymous namespace)::morphOp(int, const cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::Mat&, cv::Point, int, int, const Scalar&)", "*N12_GLOBAL__N_118GpuLinearRowFilterE", "void GPUFilter2D(const cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::Mat&, const Size&, const Point&, int)", "cv::Ptr<cv::ocl::BaseFilter_GPU> cv::ocl::getMorphologyFilter_GPU(int, int, const cv::Mat&, const Size&, cv::Point)", "void cv::ocl::sepFilter2D(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, const cv::Mat&, const cv::Mat&, cv::Point, double, int)", "void (anonymous namespace)::normalizeROI(cv::Rect&, const Size&, const Point&, const Size&)", "*N12_GLOBAL__N_115MorphFilter_GPUE", "void linearColumnFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = int]", "cv::Ptr<cv::ocl::FilterEngine_GPU> cv::ocl::createMorphologyFilter_GPU(int, int, const cv::Mat&, const Point&, int)", "void linearColumnFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = char]", "void linearColumnFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = short unsigned int]", "void linearColumnFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = unsigned char]", "void GPUDilate(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::Size&, cv::Point, bool)", "void GPUErode(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::Size&, cv::Point, bool)", "void linearRowFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = int]", "*N12_GLOBAL__N_125SeparableFilterEngine_GPUE", "void linearRowFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = char]", "*N12_GLOBAL__N_116LinearFilter_GPUE", "*N12_GLOBAL__N_112GPUBoxFilterE", "void linearColumnFilter_gpu(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int) [with T = short int]", "*N12_GLOBAL__N_118Filter2DEngine_GPUE", "src.type() == CV_8UC4", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/mssegmentation.cpp", "vector::reserve", "void cv::ocl::meanShiftSegmentation(const cv::ocl::oclMat&, cv::Mat&, int, int, int, cv::TermCriteria)", "  244", "void cv::ocl::oclMat::upload(const cv::Mat&)", "void cv::ocl::oclMat::convertTo(cv::ocl::oclMat&, int, double, double) const", "cv::ocl::oclMat& cv::ocl::oclMat::setTo(const Scalar&, const cv::ocl::oclMat&)", "uchar", "char", "ushort", "short", "float", "double", "uchar2", "char2", "ushort2", "short2", "int2", "float2", "double2", "uchar3", "char3", "ushort3", "short3", "int3", "float3", "double3", "uchar4", "char4", "ushort4", "short4", "int4", "float4", "double4", "-D GENTYPE=%s", "src.flags & cv::_InputArray::OCL_MAT", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/matrix_operations.cpp", "-D GENTYPE4=%s4", "convertC4C3", "copy_to_with_mask", "Selected device doesn't support double", "convertC3C4", "oclMat's number of rows can not be changed for current version", "The matrix is not continuous, thus its number of rows can not be changed", "Bad new number of rows", "The total number of matrix elements is not divisible by the new number of rows", "The total width is not divisible by the new number of channels", "convert_to", "convert_%s_sat_rte", "-D srcT=%s -D dstT=%s -D convertToDstType=%s", "set_to_without_mask_C1_D0", "set_to_without_mask", "mask.type() == CV_8UC1", "this->depth() >= 0 && this->depth() <= 6", "-D GENTYPE=%s%c", "set_to_with_mask", "cv::ocl::oclMat cv::ocl::oclMat::reshape(int, int) const", "cv::ocl::oclMat& cv::ocl::getOclMatRef(cv::OutputArray)", "cv::ocl::oclMat& cv::ocl::getOclMatRef(cv::InputArray)", "void cv::ocl::oclMat::download(cv::Mat&) const", "void cv::ocl::gemm(const cv::ocl::oclMat&, const cv::ocl::oclMat&, double, const cv::ocl::oclMat&, double, cv::ocl::oclMat&, int)", "void cv::ocl::clBlasSetup()", "OpenCL BLAS is not implemented", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/gemm.cpp", "void lkSparse_run(cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, bool, int, int, dim3, cv::Size, int)", "void cv::ocl::PyrLKOpticalFlow::dense(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat*)", "void cv::ocl::PyrLKOpticalFlow::sparse(const cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat*)", "vector::_M_fill_insert", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "derivLambda >= 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/pyrlk.cpp", "maxLevel >= 0 && winSize.width > 2 && winSize.height > 2", "prevImg.size() == nextImg.size() && prevImg.type() == nextImg.type()", "patch.x > 0 && patch.x < 6 && patch.y > 0 && patch.y < 6", "prevPts.rows == 1 && prevPts.type() == CV_32FC2", "nextPts.size() == prevPts.size() && nextPts.type() == CV_32FC2", "lkSparse", " -D CPU", "-D WAVE_SIZE=%d", "prevImg.type() == CV_8UC1", "maxLevel >= 0", "winSize.width > 2 && winSize.height > 2", "lkDense", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "CL_DEVICE_NOT_FOUND", "CL_DEVICE_NOT_AVAILABLE", "CL_COMPILER_NOT_AVAILABLE", "CL_MEM_OBJECT_ALLOCATION_FAILURE", "CL_OUT_OF_RESOURCES", "CL_OUT_OF_HOST_MEMORY", "CL_PROFILING_INFO_NOT_AVAILABLE", "CL_MEM_COPY_OVERLAP", "CL_IMAGE_FORMAT_MISMATCH", "CL_IMAGE_FORMAT_NOT_SUPPORTED", "CL_BUILD_PROGRAM_FAILURE", "CL_MAP_FAILURE", "CL_MISALIGNED_SUB_BUFFER_OFFSET", "CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST", "CL_INVALID_VALUE", "CL_INVALID_DEVICE_TYPE", "CL_INVALID_PLATFORM", "CL_INVALID_DEVICE", "CL_INVALID_CONTEXT", "CL_INVALID_QUEUE_PROPERTIES", "CL_INVALID_COMMAND_QUEUE", "CL_INVALID_HOST_PTR", "CL_INVALID_MEM_OBJECT", "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR", "CL_INVALID_IMAGE_SIZE", "CL_INVALID_SAMPLER", "CL_INVALID_BINARY", "CL_INVALID_BUILD_OPTIONS", "CL_INVALID_PROGRAM", "CL_INVALID_PROGRAM_EXECUTABLE", "CL_INVALID_KERNEL_NAME", "CL_INVALID_KERNEL_DEFINITION", "CL_INVALID_KERNEL", "CL_INVALID_ARG_INDEX", "CL_INVALID_ARG_VALUE", "CL_INVALID_ARG_SIZE", "CL_INVALID_KERNEL_ARGS", "CL_INVALID_WORK_DIMENSION", "CL_INVALID_WORK_GROUP_SIZE", "CL_INVALID_WORK_ITEM_SIZE", "CL_INVALID_GLOBAL_OFFSET", "CL_INVALID_EVENT_WAIT_LIST", "CL_INVALID_EVENT", "CL_INVALID_OPERATION", "CL_INVALID_GL_OBJECT", "CL_INVALID_BUFFER_SIZE", "CL_INVALID_MIP_LEVEL", "CL_INVALID_GLOBAL_WORK_SIZE", "unknown function", "OpenCV Error: ", ") in ", ", file ", ", line ", "convert_float4", "(float)", "depth == CV_8U || depth == CV_16U || depth == CV_16S || depth == CV_32F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/pyrup.cpp", "channels == 1 || channels == 3 || channels == 4", "convert_%s%s_sat_rte", "-D Type=%s%s -D floatType=float%s -D convertToType=%s -D convertToFloat=%s", "pyrUp", "uchar", "char", "ushort", "short", "float", "void cv::ocl::pyrUp(const cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::FarnebackOpticalFlow::operator()(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::FarnebackOpticalFlow::gaussianBlurOcl(const cv::ocl::oclMat&, int, cv::ocl::oclMat&)", "updateFlow", "updateMatrices", "vector::_M_fill_insert", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "gaussianBlur", "dst.size() == src.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/optical_flow_farneback.cpp", "polynomialExpansion", "-D polyN=%d", "gaussianBlur5", "boxFilter5", "frame0.channels() == 1 && frame1.channels() == 1", "frame0.size() == frame1.size()", "polyN == 5 || polyN == 7", "!fastPyramids || std::abs(pyrScale - 0.5) < 1e-6", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "  244", "void arithmetic_minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&) [with T = int, WT = int]", "void cv::ocl::compare(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "cv::Scalar cv::ocl::sqrSum(const cv::ocl::oclMat&)", "void arithmetic_minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&) [with T = short int, WT = int]", "void cv::ocl::LUT(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&)", "cv::Scalar cv::ocl::absSum(const cv::ocl::oclMat&)", "void cv::ocl::cartToPolar(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, bool)", "std::vector<unsigned char> scalarToVector(const Scalar&, int, int, int)", "void cv::ocl::magnitude(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::phase(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, bool)", "void arithmetic_exp_log_run(const cv::ocl::oclMat&, cv::ocl::oclMat&, std::string, const cv::ocl::ProgramEntry*)", "double cv::ocl::norm(const cv::ocl::oclMat&, int)", "cv::Scalar arithmetic_sum(const cv::ocl::oclMat&, int, int) [with T = float, cv::Scalar = cv::Scalar_<double>]", "void cv::ocl::transpose(const cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::minMaxLoc(const cv::ocl::oclMat&, double*, double*, cv::Point*, cv::Point*, const cv::ocl::oclMat&)", "void cv::ocl::repeat(const cv::ocl::oclMat&, int, int, cv::ocl::oclMat&)", "void arithmetic_minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&) [with T = double, WT = double]", "cv::Scalar cv::ocl::sum(const cv::ocl::oclMat&)", "void arithmetic_run_generic(const cv::ocl::oclMat&, const cv::ocl::oclMat&, const Scalar&, const cv::ocl::oclMat&, cv::ocl::oclMat&, int, bool)", "void cv::ocl::flip(const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void cv::ocl::pow(const cv::ocl::oclMat&, double, cv::ocl::oclMat&)", "int cv::ocl::countNonZero(const cv::ocl::oclMat&)", "void bitwise_run(const cv::ocl::oclMat&, const cv::ocl::oclMat&, const Scalar&, const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void cv::ocl::addWeighted(const cv::ocl::oclMat&, double, const cv::ocl::oclMat&, double, double, cv::ocl::oclMat&)", "void cv::ocl::polarToCart(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, bool)", "double cv::ocl::norm(const cv::ocl::oclMat&, const cv::ocl::oclMat&, int)", "void cv::ocl::minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&)", "void cv::ocl::setIdentity(cv::ocl::oclMat&, const Scalar&)", "void cv::ocl::meanStdDev(const cv::ocl::oclMat&, cv::Scalar&, cv::Scalar&)", "void arithmetic_minMaxLoc(const cv::ocl::oclMat&, double*, double*, cv::Point*, cv::Point*, const cv::ocl::oclMat&) [with T = double, cv::Point = cv::Point_<int>]", "void arithmetic_minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&) [with T = float, WT = float]", "void arithmetic_minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&) [with T = char, WT = int]", "void arithmetic_minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&) [with T = short unsigned int, WT = int]", "void arithmetic_minMax(const cv::ocl::oclMat&, double*, double*, const cv::ocl::oclMat&) [with T = unsigned char, WT = int]", "cv::Scalar arithmetic_sum(const cv::ocl::oclMat&, int, int) [with T = int, cv::Scalar = cv::Scalar_<double>]", "void arithmetic_minMaxLoc(const cv::ocl::oclMat&, double*, double*, cv::Point*, cv::Point*, const cv::ocl::oclMat&) [with T = float, cv::Point = cv::Point_<int>]", "float", "double", "Selected device doesn't support double", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/arithm.cpp", "src.depth() == CV_32F || src.depth() == CV_64F", "-D srcT=%s", "-D DEPTH_%d -D REPEAT_E%d", "arithm_op_minMaxLoc_mask", "operationType >= AND && operationType <= NOT", "src2.empty() || (src1.type() == src2.type() && src1.size() == src2.size())", "mask.empty() || (mask.type() == CV_8UC1 && mask.size() == src1.size())", "-D Operation=%c -D T=%s%s", " -D HAVE_SCALAR", " -D OP_BINARY", " -D HAVE_MASK", "arithm_bitwise", "-D DEPTH_%d -D REPEAT_S%d -D REPEAT_E%d", "arithm_op_minMaxLoc", "-D DEGREE", "-D RADIAN", "src.oclchannels() == 1", "groupnum != 0", "FUNC_SUM", "FUNC_ABS_SUM", "FUNC_SQR_SUM", "-D srcT=%s%s -D dstT=%s%s -D convertToDstT=convert_%s%s -D %s", "arithm_op_sum", "src.step % src.elemSize() == 0", "_sat_rte", "_rte", "src2.empty() || (!src2.empty() && src1.type() == src2.type() && src1.size() == src2.size())", "mask.empty() || (!mask.empty() && mask.type() == CV_8UC1 && mask.size() == src1.size())", "op_type >= ADD && op_type <= MAX", "arithm_binary_op", "-D T=%s%s -D WT=%s%s -D convertToT=convert_%s%s%s -D %s -D convertToWT=convert_%s%s", "_mat", "ocn == cn || (ocn == 4 && cn == 3)", "_scalar", "_mask", "-D T=%s%s", "-D T=%s%c", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "-D T=", " -D MAX_VAL=", " -D MIN_VAL=", " -D vlen=", " -D WITH_MASK", "arithm_op_minMax", " -D DEPTH_", "src1.type() == src2.type() && src1.channels() == 1", "cmpOp >= CMP_EQ && cmpOp <= CMP_NE", "arithm_compare", "-D T=%s -D Operation=%s", "src.channels() == 1", "src.size() == mask.size() || mask.empty()", "src.step % src.elemSize1() == 0", "func != 0", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2", "src1.step % src1.elemSize() == 0 && (src2.empty() || src2.step % src2.elemSize() == 0)", "diff.step % diff.elemSize() == 0", "arithm_absdiff_nonsaturate", "-D srcT=%s%s -D dstT=%s%s -D convertToDstT=convert_%s%s", "_binary", " -D BINARY", "(normType & NORM_RELATIVE) == 0", "arithm_flip_rows", "arithm_flip_cols", "arithm_flip_rows_cols", "depth == CV_8U || depth == CV_8S", "lut.channels() == 1 || lut.channels() == src.channels()", "lut.rows == 1 && lut.cols == 256", "-D srcT=%s -D dstT=%s", "arithm_exp", "arithm_log", "src1.type() == src2.type() && src1.size() == src2.size() && (src1.depth() == CV_32F || src1.depth() == CV_64F)", "arithm_magnitude", "arithm_phase_indegrees", "arithm_phase_inradians", "x.type() == y.type() && x.size() == y.size() && (x.depth() == CV_32F || x.depth() == CV_64F)", "x.step % x.elemSize() == 0 && y.step % y.elemSize() == 0", "arithm_cartToPolar", "angle.depth() == CV_32F || angle.depth() == CV_64F", "magnitude.size() == angle.size() && magnitude.type() == angle.type()", "arithm_polarToCart_mag", "arithm_polarToCart", "selected device doesn't support double", "-D srcT=%s%s -D dstT=int%s -D convertToDstT=convert_int%s", "arithm_op_nonzero", "transpose_inplace", "transpose", "src1.size() == src2.size() && src1.type() == src2.type()", "-D T=%s -D WT=%s -D convertToT=convert_%s%s", "addWeighted", "x.depth() == CV_32F || x.depth() == CV_64F", "arithm_pow", "-D VT=%s%s -D T=%s", "setIdentity", "nx > 0 && ny > 0", "uchar", "char", "ushort", "short", "FUNC_ADD", "FUNC_SUB", "FUNC_MUL", "FUNC_DIV", "FUNC_ABS", "FUNC_ABS_DIFF", "FUNC_MIN", "FUNC_MAX", "ulong", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "cv::Scalar arithmetic_sum(const cv::ocl::oclMat&, int, int) [with T = double, cv::Scalar = cv::Scalar_<double>]", "void arithm_absdiff_nonsaturate_run(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "const cv::ocl::oclMat& cv::ocl::KalmanFilter::correct(const cv::ocl::oclMat&)", "DP > 0 && MP > 0", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/kalman.cpp", "type == CV_32F || type == CV_64F", "measurement.empty() == false", "void cv::ocl::KalmanFilter::init(int, int, int, int)", "depth == CV_8U || depth == CV_16U || depth == CV_16S || depth == CV_32F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/pyrdown.cpp", "channels == 1 || channels == 3 || channels == 4", "src.type() == dst.type()", "src.depth() != CV_8S", "pyrDown", "void cv::ocl::pyrDown(const cv::ocl::oclMat&, cv::ocl::oclMat&)", "void pyrdown_run(const cv::ocl::oclMat&, const cv::ocl::oclMat&)", "void cv::ocl::(anonymous namespace)::warpAffine_gpu(const cv::ocl::oclMat&, cv::ocl::oclMat&, double (*)[3], int)", "void cv::ocl::warpPerspective(const cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::Mat&, cv::Size, int)", "*N2cv3ocl12_GLOBAL__N_110CLAHE_ImplE", "void cv::ocl::oclbilateralFilter_8u(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, double, double, int)", "void cv::ocl::meanShiftFiltering(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, cv::TermCriteria)", "void cv::ocl::corner_ocl(const cv::ocl::ProgramEntry*, std::string, int, float, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void cv::ocl::calcHist(const cv::ocl::oclMat&, cv::ocl::oclMat&)", "std::vector<unsigned char> cv::ocl::scalarToVector(const Scalar&, int, int, int)", "void cv::ocl::(anonymous namespace)::warpPerspective_gpu(const cv::ocl::oclMat&, cv::ocl::oclMat&, double (*)[3], int)", "void cv::ocl::extractCovData(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, int)", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "void cv::ocl::meanShiftFiltering_gpu(const cv::ocl::oclMat&, cv::ocl::oclMat, int, int, int, float)", "void cv::ocl::copyMakeBorder(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, int, int, int, const Scalar&)", "void cv::ocl::resize(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::Size, double, double, int)", "CLAHE_OCL", "ocn == cn || (ocn == 4 && cn == 3)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/imgproc.cpp", "clipLimit", "tilesX", "tilesY", "src.type() == CV_8UC1", "integral_sum_cols", "integral_sum_rows", "(src.depth() == CV_8U || src.depth() == CV_32F) && src.oclchannels() != 2 && src.oclchannels() != 3", "interpolation == INTER_NEAREST || interpolation == INTER_LINEAR || interpolation == INTER_CUBIC", "M.rows == 3 && M.cols == 3", "(src.oclchannels() == dst.oclchannels())", "Linear", "Cubic", "warpPerspective", "M.rows == 2 && M.cols == 3", "warpAffine", "m % 2 == 1 && m > 1", "(src.depth() == CV_8U || src.depth() == CV_32F) && (src.channels() == 1 || src.channels() == 4)", "medianFilter3", "medianFilter5", "Non-supported filter length", "thresholdType == THRESH_BINARY || thresholdType == THRESH_BINARY_INV || thresholdType == THRESH_TRUNC || thresholdType == THRESH_TOZERO || thresholdType == THRESH_TOZERO_INV", "-D T=%s%s -D %s", " -D VECTORIZED -D VT=%s%d -D VLOADN=vload%d -D VECSIZE=%d -D VSTOREN=vstore%d", " -D DST_ALIGNED", " -D SRC_ALIGNED", "threshold", "BORDER_CONSTANT", "BORDER_REFLECT101", "BORDER_REFLECT", "BORDER_REPLICATE", "BORDER type is not supported!", "-D anX=%d -D anY=%d -D ksX=%d -D ksY=%d -D %s", "x.depth() == CV_32F && t.depth() == CV_32F", "t.cols <= 17 && t.rows <= 17", "convolve", "The input image is empty", "Only 8-bit, 4-channel images are supported", "(src.cols == dstr.cols) && (src.rows == dstr.rows) && (src.rows == dstsp.rows) && (src.cols == dstsp.cols)", "!(dstsp.step & 0x3)", "meanshiftproc_kernel", "(src.cols == dst.cols) && (src.rows == dst.rows)", "!(dst.step & 0x3)", "meanshift_kernel", "Select device doesn't support double", "integral_cols", "integral_rows", "_sat_rte", "Selected device does not support double", "interpolation == INTER_LINEAR || interpolation == INTER_NEAREST", "(map1.type() == CV_16SC2 && (map2.empty() || (map2.type() == CV_16UC1 || map2.type() == CV_16SC1)) ) || (map1.type() == CV_32FC2 && !map2.data) || (map1.type() == CV_32FC1 && map2.type() == CV_32FC1)", "!map2.data || map2.size() == map1.size()", "borderType == BORDER_CONSTANT || borderType == BORDER_REPLICATE || borderType == BORDER_WRAP || borderType == BORDER_REFLECT_101 || borderType == BORDER_REFLECT", "remap", "_32FC2", "_16SC2", "_16UC1", "_2_32FC1", "Unsupported map types", "-D %s -D %s -D T=%s%s", " -D WT=%s%s -D convertToT=convert_%s%s%s -D convertToWT=convert_%s%s -D convertToWT2=convert_%s2 -D WT2=%s2", "src.type() == CV_8UC1 || src.type() == CV_32FC1", "Dx.rows == Dy.rows && Dx.cols == Dy.cols", "-D BLK_X=%d -D BLK_Y=%d", " -D SRCTYPE=uchar", " -D SRCTYPE=float", " -D BORDER_CONSTANT", " -D BORDER_REPLICATE", " -D BORDER_REFLECT", " -D BORDER_REFLECT_101", " -D BORDER_WRAP", " -D SCHARR", "sobel3", "sobel5", "sobel7", "Kernel size is not supported!", "Dx.offset == 0 && Dy.offset == 0", "Selected device doesn't support double", "borderType == cv::BORDER_CONSTANT || borderType == cv::BORDER_REFLECT101 || borderType == cv::BORDER_REPLICATE || borderType == cv::BORDER_REFLECT", "calcMinEigenVal", "calcHarris", "top >= 0 && bottom >= 0 && left >= 0 && right >= 0", "Unsupported border type", "-D GENTYPE=%s%s -D %s", "copymakeborder", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "calcLut", "-D CPU", "-D WAVE_SIZE=%d", "transform", "(src.channels() == 1 || src.channels() == 3) && src.type() == dst.type() && src.size() == dst.size() && src.data != dst.data", "bilateral", "bilateral2", "Bilateral filtering is only implemented for CV_8U images", "mat_src.type() == CV_8UC1", "calc_sub_hist", "calc_sub_hist_border", "merge_hist", "calLUT", "resize", "-D %s -D T=%s%s", " -D WT=%s -D WTV=%s%s -D convertToWTV=convert_%s%s -D convertToT=convert_%s%s%s", "_FAST", " -D WT2V=%s%s -D convertToWT2V=convert_%s%s -D AREA_FAST -D XSCALE=%d -D YSCALE=%d -D SCALE=%f", "src.type() == CV_8UC1 || src.type() == CV_8UC3 || src.type() == CV_8UC4 || src.type() == CV_32FC1 || src.type() == CV_32FC3 || src.type() == CV_32FC4", "dsize.area() > 0 || (fx > 0 && fy > 0)", "dsize.area() > 0", "interpolation == INTER_LINEAR || interpolation == INTER_NEAREST || (interpolation == INTER_AREA && inv_fx >= 1 && inv_fy >= 1)", "THRESH_BINARY", "THRESH_BINARY_INV", "THRESH_TRUNC", "THRESH_TOZERO", "THRESH_TOZERO_INV", "uchar", "char", "ushort", "short", "float", "double", "INTER_NEAREST", "INTER_LINEAR", "INTER_CUBIC", "INTER_LANCZOS", "BORDER_WRAP", "BORDER_REFLECT_101", "BORDER_TRANSPARENT", "CUBIC", "AREA", "LAN4", "void cv::ocl::convolve(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&)", "virtual void cv::ocl::(anonymous namespace)::CLAHE_Impl::apply(cv::InputArray, cv::OutputArray)", "void cv::ocl::integral(const cv::ocl::oclMat&, cv::ocl::oclMat&)", "double cv::ocl::threshold(const cv::ocl::oclMat&, cv::ocl::oclMat&, double, double, int)", "void cv::ocl::clahe::calcLut(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, cv::Size, int, float)", "void cv::ocl::meanShiftProc(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, cv::TermCriteria)", "void cv::ocl::integral(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::warpAffine(const cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::Mat&, cv::Size, int)", "void cv::ocl::medianFilter(const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void cv::ocl::cornerMinEigenVal_dxdy(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, int)", "void cv::ocl::remap(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, const Scalar&)", "void cv::ocl::bilateralFilter(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, double, double, int)", "void cv::ocl::cornerHarris_dxdy(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int, int, double, int)", "void cv::ocl::meanShiftProc_gpu(const cv::ocl::oclMat&, cv::ocl::oclMat, cv::ocl::oclMat, int, int, int, float)", "void cv::ocl::BruteForceMatcher_OCL_base::matchCollection(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::ocl::oclMat&)", "static void cv::ocl::BruteForceMatcher_OCL_base::matchConvert(const cv::Mat&, const cv::Mat&, std::vector<cv::DMatch>&)", "void cv::ocl::BruteForceMatcher_OCL_base::matchSingle(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::ocl::oclMat&)", "static void cv::ocl::BruteForceMatcher_OCL_base::knnMatch2Convert(const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, bool)", "static void cv::ocl::BruteForceMatcher_OCL_base::radiusMatchConvert(const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, bool)", "void cv::ocl::BruteForceMatcher_OCL_base::knnMatch2Collection(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::ocl::oclMat&)", "static void cv::ocl::BruteForceMatcher_OCL_base::matchConvert(const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<cv::DMatch>&)", "static void cv::ocl::BruteForceMatcher_OCL_base::knnMatchConvert(const cv::Mat&, const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, bool)", "vector::reserve", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "masks.size() == trainDescCollection.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/brute_force_matcher.cpp", "mask.empty() || (mask.type() == CV_8UC1 && mask.cols == train.rows)", "query.channels() == 1 && query.depth() < CV_64F", "trainIdx.empty() || (trainIdx.rows == nQuery && trainIdx.size() == distance.size() && trainIdx.size() == imgIdx.size())", "vector::_M_range_insert", "vector::_M_insert_aux", "trainIdx.type() == CV_32SC1", "distance.type() == CV_32FC1 && distance.cols == trainIdx.cols", "imgIdx.type() == CV_32SC1 && imgIdx.cols == trainIdx.cols", "BruteForceMatch_findBestMatch", "-D T=%s -D DIST_TYPE=%d -D BLOCK_SIZE=%d", "BruteForceMatch_Match", "-D T=%s -D DIST_TYPE=%d -D BLOCK_SIZE=%d -D MAX_DESC_LEN=%d", "BruteForceMatch_UnrollMatch", "train.cols == query.cols && train.type() == query.type()", "BruteForceMatch_calcDistance", "BruteForceMatch_calcDistanceUnrolled", "BruteForceMatch_knnMatch", "BruteForceMatch_knnUnrollMatch", "train.type() == query.type() && train.cols == query.cols", "BruteForceMatch_RadiusMatch", "BruteForceMatch_RadiusUnrollMatch", "trainIdx.empty() || (trainIdx.rows == query.rows && trainIdx.size() == distance.size())", "trainIdx.type() == CV_32SC2", "imgIdx.type() == CV_32SC2 && imgIdx.cols == trainIdx.cols", "distance.type() == CV_32FC2 && distance.cols == trainIdx.cols", "trainIdx.type() == CV_32SC2 || trainIdx.type() == CV_32SC1", "distance.type() == CV_32FC2 || distance.type() == CV_32FC1", "distance.size() == trainIdx.size()", "trainIdx.isContinuous() && distance.isContinuous()", "vector::_M_fill_insert", "imgIdx.type() == CV_32SC1 && imgIdx.size() == trainIdx.size()", "distance.type() == CV_32FC1 && distance.size() == trainIdx.size()", "nMatches.type() == CV_32SC1 && nMatches.cols == trainIdx.rows", "uchar", "char", "ushort", "short", "float -D T_FLOAT", "double", "void cv::ocl::BruteForceMatcher_OCL_base::radiusMatchSingle(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, float, const cv::ocl::oclMat&)", "static void cv::ocl::BruteForceMatcher_OCL_base::radiusMatchConvert(const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, std::vector<std::vector<cv::DMatch> >&, bool)", "void cv::ocl::BruteForceMatcher_OCL_base::radiusMatchCollection(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, float, const std::vector<cv::ocl::oclMat>&)", "void cv::ocl::BruteForceMatcher_OCL_base::makeGpuCollection(cv::ocl::oclMat&, cv::ocl::oclMat&, const std::vector<cv::ocl::oclMat>&)", "void cv::ocl::BruteForceMatcher_OCL_base::knnMatchSingle(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int, const cv::ocl::oclMat&)", "void cv::ocl::buildWarpCylindricalMaps(cv::Size, cv::Rect, const cv::Mat&, const cv::Mat&, float, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::buildWarpAffineMaps(const cv::Mat&, bool, cv::Size, cv::ocl::oclMat&, cv::ocl::oclMat&)", "M.rows == 3 && M.cols == 3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/build_warps.cpp", "dsize.area() > 0", "buildWarpPerspectiveMaps", "M.rows == 2 && M.cols == 3", "dsize.area()", "buildWarpAffineMaps", "K.size() == Size(3, 3) && K.type() == CV_32F", "R.size() == Size(3, 3) && R.type() == CV_32F", "K_Rinv.isContinuous()", "buildWarpSphericalMaps", "buildWarpCylindricalMaps", "(T.size() == Size(3, 1) || T.size() == Size(1, 3)) && T.type() == CV_32F && T.isContinuous()", "buildWarpPlaneMaps", "void cv::ocl::buildWarpSphericalMaps(cv::Size, cv::Rect, const cv::Mat&, const cv::Mat&, float, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::buildWarpPlaneMaps(cv::Size, cv::Rect, const cv::Mat&, const cv::Mat&, const cv::Mat&, float, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::buildWarpPerspectiveMaps(const cv::Mat&, bool, cv::Size, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::stereoCSBP::compute_data_cost_reduce_caller(uchar*, uchar*, cv::ocl::StereoConstantSpaceBP&, int, int, const cv::ocl::oclMat&, const cv::ocl::oclMat&, int, int, int, int, int)", "void csbp_operator(cv::ocl::StereoConstantSpaceBP&, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&) [with T = float]", "void csbp_operator(cv::ocl::StereoConstantSpaceBP&, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat*, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&) [with T = short int]", "void cv::ocl::stereoCSBP::get_first_initial_local_caller(uchar*, uchar*, cv::ocl::oclMat&, cv::ocl::StereoConstantSpaceBP&, int, int, int, int)", "void cv::ocl::stereoCSBP::init_message(uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, cv::ocl::oclMat&, cv::ocl::StereoConstantSpaceBP, std::size_t, std::size_t, int, int, int, int, int, int)", "void cv::ocl::StereoConstantSpaceBP::operator()(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::stereoCSBP::get_first_initial_global_caller(uchar*, uchar*, cv::ocl::oclMat&, cv::ocl::StereoConstantSpaceBP&, int, int, int, int)", "void cv::ocl::stereoCSBP::compute_data_cost_caller(uchar*, uchar*, cv::ocl::StereoConstantSpaceBP&, int, int, const cv::ocl::oclMat&, const cv::ocl::oclMat&, int, int, int, int, int)", "init_message_", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/stereo_csbp.cpp", "compute_data_cost_", "compute_data_cost_reduce_", "init_data_cost_", "init_data_cost_reduce_", "get_first_k_initial_local_", "get_first_k_initial_global_", "compute_disp_", "compute_message_", "rthis.levels <= 8 && (left.type() == CV_8UC1 || left.type() == CV_8UC3)", "msg_type_ == CV_32F || msg_type_ == CV_16S", "msg_type == CV_32F || msg_type == CV_16S", "void cv::ocl::stereoCSBP::init_data_cost_reduce_caller(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::StereoConstantSpaceBP&, int, int, int, int)", "void cv::ocl::stereoCSBP::init_data_cost_caller(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::StereoConstantSpaceBP&, int, int, int, int)", "cv::ocl::StereoConstantSpaceBP::StereoConstantSpaceBP(int, int, int, int, float, float, float, float, int, int)", "void cv::ocl::stereoCSBP::calc_all_iterations_caller(uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, cv::ocl::oclMat&, cv::ocl::StereoConstantSpaceBP, int, int, int, int, int)", "cv::ocl::StereoConstantSpaceBP::StereoConstantSpaceBP(int, int, int, int, int)", "void cv::ocl::stereoCSBP::compute_disp(uchar*, uchar*, uchar*, uchar*, uchar*, uchar*, cv::ocl::StereoConstantSpaceBP&, std::size_t, cv::ocl::oclMat&, int)", "void cv::ocl::ProgramCache::releaseProgram()", "bool cv::ocl::ProgramFileCache::readConfigurationFromFile(const string&, std::vector<char>&)", "bool cv::ocl::ProgramFileCache::writeConfigurationToFile(const string&, std::vector<char>&)", "f.is_open()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/cl_programcache.cpp", "hashLength > 0", "numberOfEntries > 0", "Invalid file: ", "memcmp(&foptions, options.c_str(), entry.optionsLength) != 0", "vector::_M_fill_insert", "Invalid file (empty): ", "NULL", "dynamic program", ".clb", "Can't write data to file: ", "BUILD LOG: ", "_cl_program* cv::ocl::ProgramFileCache::getOrBuildProgram(const cv::ocl::Context*, const cv::ocl::ProgramEntry*, const string&)", "virtual void cv::ocl::MOG::operator()(const cv::ocl::oclMat&, cv::ocl::oclMat&, float)", "void cv::ocl::MOG::initialize(cv::Size, int)", "N2cv3ocl4MOG2E", "N2cv3ocl20BackgroundSubtractorE", "-D CN1 -D NMIXTURES=%d", "-D NMIXTURES=%d", "mog_withLearning_kernel", "mog_withoutLearning_kernel", "frameType == CV_8UC1 || frameType == CV_8UC3 || frameType == CV_8UC4", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/bgfg_mog.cpp", "frame.depth() == CV_8U", "learningRate >= 0.0f", "getBackgroundImage_kernel", "mog2_kernel", "getBackgroundImage2_kernel", "void cv::ocl::MOG2::initialize(cv::Size, int)", "N2cv3ocl3MOGE", "virtual void cv::ocl::MOG2::operator()(const cv::ocl::oclMat&, cv::ocl::oclMat&, float)", "CvSeq* cv::ocl::OclCascadeClassifier::oclHaarDetectObjects(cv::ocl::oclMat&, CvMemStorage*, double, int, int, CvSize, CvSize)", "GpuHidHaarClassifierCascade* gpuCreateHidHaarClassifierCascade(CvHaarClassifierCascade*, int*, int*)", "void cv::ocl::OclCascadeClassifierBuf::detectMultiScale(cv::ocl::oclMat&, std::vector<cv::Rect_<int> >&, double, int, int, cv::Size, cv::Size)", "void cv::ocl::OclCascadeClassifierBuf::release()", "void gpuSetImagesForHaarClassifierCascade(CvHaarClassifierCascade*, double, int)", "Invalid classifier pointer", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/haar.cpp", "hid_cascade has been already created", "Negative number of cascade stages", "header of the stage classifier #%d is invalid (has null pointers or non-positive classfier count)", "rectangle #%d of the classifier #%d of the stage classifier #%d is not inside the reference (original) cascade window", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "!_seq || _seq->elem_size == sizeof(_Tp)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "Invalid classifier cascade", "scale factor must be > 1", "Image too small", "gpuscaleclassifier", "vector::_M_fill_insert", "vector::_M_insert_aux", "-D STUMP_BASED=1", "-D STUMP_BASED=0", "Only 8-bit images are supported", "gpuRunHaarClassifierCascade", "gpuRunHaarClassifierCascade_scaled2", "Null storage pointer", "-D PACKED_CLASSIFIER", " -D NODE_SIZE=%d", " -D WND_SIZE_X=%d", " -D WND_SIZE_Y=%d", " -D STUMP_BASED=%d", " -D SPLITNODE=%d", " -D SPLITSTAGE=%d", " -D OUTPUTSZ=%d", " -D PIXEL_STEP=%d", " -D WGSTART=%d", " -D LSx=%d", " -D LSy=%d", "gpuRunHaarClassifierCascadePacked", "void cv::ocl::OclCascadeClassifierBuf::CreateFactorRelatedBufs(int, int, int, double, const size_t*, CvSize, CvSize)", "void cv::ocl::OclCascadeClassifierBuf::CreateBaseBufs(int, int, int, int)", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "void cv::ocl::OclCascadeClassifierBuf::Init(int, int, double, int, int, const size_t*, CvSize, CvSize)", "void gpuSetHaarClassifierCascade(CvHaarClassifierCascade*)", "prefilter_xsobel", "stereoKernel", "-D radius=%d", "textureness_kernel", "0 < ndisp && ndisp <= max_supported_ndisp", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/stereobm.cpp", "ndisp % 8 == 0", "winSize % 2 == 1", "cv::ocl::StereoBM_OCL::StereoBM_OCL(int, int, int)", "void cv::ocl::split_merge::merge(const cv::ocl::oclMat*, std::size_t, cv::ocl::oclMat&)", "void cv::ocl::split_merge::merge_vector_run(const cv::ocl::oclMat*, std::size_t, cv::ocl::oclMat&)", "void cv::ocl::split_merge::split_vector_run(const cv::ocl::oclMat&, cv::ocl::oclMat*)", "mat_dst", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/split_merge.cpp", "Selected device doesn't support double", "split_vector", "-D VEC_SIZE=%d -D DATA_DEPTH=%d -D DATA_CHAN=%d", " -D DST0_ALIGNED", " -D DST1_ALIGNED", " -D DST2_ALIGNED", " -D DST3_ALIGNED", "Intel", "Build 56860", "Build 76921", "Build 78712", " -D BYPASS_VSTORE=true", "mat_src", "n > 0", "depth == mat_src[i].depth()", "size == mat_src[i].size()", "total_channels <= 4", "merge_vector", "vector::_M_fill_insert", "void cv::ocl::split_merge::split(const cv::ocl::oclMat&, cv::ocl::oclMat*)", "void cv::ocl::HOGDescriptor::computeGradient(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::HOGDescriptor::getDescriptors(const cv::ocl::oclMat&, cv::Size, cv::ocl::oclMat&, int)", "void cv::ocl::HOGDescriptor::setSVMDetector(const std::vector<float>&)", "void cv::ocl::HOGDescriptor::detect(const cv::ocl::oclMat&, std::vector<cv::Point_<int> >&, double, cv::Size, cv::Size)", "checkDetectorSize()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/hog.cpp", "(win_size.width - block_size.width ) % block_stride.width == 0 && (win_size.height - block_size.height) % block_stride.height == 0", "block_size.width % cell_size.width == 0 && block_size.height % cell_size.height == 0", "block_stride == cell_size", "cell_size == Size(8, 8)", "cells_per_block == Size(2, 2)", "compute_hists_lut_kernel", "-D CPU", "-D WAVE_SIZE=%d", "normalize_hists_36_kernel", "normalize_hists_kernel", "normalize_hists: histogram's size is too small or too big", "normalize_hists", "classify_hists_180_kernel", "classify_hists_252_kernel", "classify_hists_kernel", "extract_descrs_by_rows_kernel", "extract_descrs_by_cols_kernel", "compute_gradients_8UC1_kernel", "compute_gradients_8UC4_kernel", "img.type() == CV_8UC1 || img.type() == CV_8UC4", "padding == Size(0, 0)", "win_stride.width % block_stride.width == 0 && win_stride.height % block_stride.height == 0", "Unknown descriptor format", "vector::_M_insert_aux", "vector::_M_fill_insert", "scale0 > 1", "void cv::ocl::HOGDescriptor::detectMultiScale(const cv::ocl::oclMat&, std::vector<cv::Rect_<int> >&, double, cv::Size, cv::Size, double, int)", "libOpenCL.so", "OPENCV_OPENCL_BINARY", "OpenCL function is not available: [", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/cl_runtime/cl_runtime.cpp", "clGetPlatformIDs", "clGetPlatformInfo", "clGetDeviceIDs", "clGetDeviceInfo", "clCreateSubDevices", "clRetainDevice", "clReleaseDevice", "clCreateContext", "clCreateContextFromType", "clRetainContext", "clReleaseContext", "clGetContextInfo", "clCreateCommandQueue", "clRetainCommandQueue", "clReleaseCommandQueue", "clGetCommandQueueInfo", "clCreateBuffer", "clCreateSubBuffer", "clCreateImage", "clRetainMemObject", "clReleaseMemObject", "clGetSupportedImageFormats", "clGetMemObjectInfo", "clGetImageInfo", "clSetMemObjectDestructorCallback", "clCreateSampler", "clRetainSampler", "clReleaseSampler", "clGetSamplerInfo", "clCreateProgramWithSource", "clCreateProgramWithBinary", "clCreateProgramWithBuiltInKernels", "clRetainProgram", "clReleaseProgram", "clBuildProgram", "clCompileProgram", "clLinkProgram", "clUnloadPlatformCompiler", "clGetProgramInfo", "clGetProgramBuildInfo", "clCreateKernel", "clCreateKernelsInProgram", "clRetainKernel", "clReleaseKernel", "clSetKernelArg", "clGetKernelInfo", "clGetKernelArgInfo", "clGetKernelWorkGroupInfo", "clWaitForEvents", "clGetEventInfo", "clCreateUserEvent", "clRetainEvent", "clReleaseEvent", "clSetUserEventStatus", "clSetEventCallback", "clGetEventProfilingInfo", "clFlush", "clFinish", "clEnqueueReadBuffer", "clEnqueueReadBufferRect", "clEnqueueWriteBuffer", "clEnqueueWriteBufferRect", "clEnqueueFillBuffer", "clEnqueueCopyBuffer", "clEnqueueCopyBufferRect", "clEnqueueReadImage", "clEnqueueWriteImage", "clEnqueueFillImage", "clEnqueueCopyImage", "clEnqueueCopyImageToBuffer", "clEnqueueCopyBufferToImage", "clEnqueueMapBuffer", "clEnqueueMapImage", "clEnqueueUnmapMemObject", "clEnqueueMigrateMemObjects", "clEnqueueNDRangeKernel", "clEnqueueTask", "clEnqueueNativeKernel", "clEnqueueMarkerWithWaitList", "clEnqueueBarrierWithWaitList", "clGetExtensionFunctionAddressForPlatform", "clCreateImage2D", "clCreateImage3D", "clEnqueueMarker", "clEnqueueWaitForEvents", "clEnqueueBarrier", "clUnloadCompiler", "clGetExtensionFunctionAddress", "void cv::ocl::sortByKey(cv::ocl::oclMat&, cv::ocl::oclMat&, int, bool)", "void cv::ocl::selection_sort::sortByKey(cv::ocl::oclMat&, cv::ocl::oclMat&, std::size_t, bool)", "vector::_M_insert_aux", "-D IS_GT=%d -D K_T=%s -D V_T=%s", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "keys.depth() == CV_32S || keys.depth() == CV_32F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/sort_by_key.cpp", " -D K_%s", "histogramRadixN", "permuteRadixN", "keys.rows == 1", "keys.channels() == 1", "vecSize <= static_cast<size_t>(keys.cols)", "isSizePowerOf2(vecSize)", "bitonicSort", "This function is incorrect at the moment.", "selectionSortLocal", "selectionSortFinal", "blockInsertionSort", "merge", "vector::_M_fill_insert", "keys.size() == vals.size()", "uchar", "char", "ushort", "short", "float", "double", "void cv::ocl::bitonic_sort::sortByKey(cv::ocl::oclMat&, cv::ocl::oclMat&, std::size_t, bool)", "void cv::ocl::sortByKey(cv::ocl::oclMat&, cv::ocl::oclMat&, std::size_t, int, bool)", "void cv::ocl::radix_sort::sortByKey(cv::ocl::oclMat&, cv::ocl::oclMat&, std::size_t, bool)", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "memsetKernel", "normalizeKernel", "forwardWarpKernel", "blendFramesKernel", "frame0.type() == CV_32FC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/interpolate_frames.cpp", "frame1.size() == frame0.size() && frame1.type() == frame0.type()", "fu.size() == frame0.size() && fu.type() == frame0.type()", "fv.size() == frame0.size() && fv.type() == frame0.type()", "bu.size() == frame0.size() && bu.type() == frame0.type()", "bv.size() == frame0.size() && bv.type() == frame0.type()", "frame1.step == step && fu.step == step && fv.step == step && bu.step == step && bv.step == step && newFrame.step == step && buf.step == step", "void cv::ocl::interpolateFrames(const cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, float, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::OpticalFlowDual_TVL1_OCL::operator()(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&)", "vector::_M_fill_insert", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "centeredGradientKernel", "estimateDualVariablesKernel", "estimateUKernel", "warpBackwardKernel", "I0.type() == CV_8UC1 || I0.type() == CV_32FC1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/tvl1flow.cpp", "I0.size() == I1.size()", "I0.type() == I1.type()", "!useInitialFlow || (flowx.size() == I0.size() && flowx.type() == CV_32FC1 && flowy.size() == flowx.size() && flowy.type() == flowx.type())", "nscales > 0", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "N2cv3ocl15CvSVMKernel_oclE", "float cv::ocl::CvSVM_OCL::predict(int, int, cv::Mat&, bool) const", "svm_linear", "svm_sigmod", "svm_poly", "svm_rbf", "The sample is not a valid vector", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/svm.cpp", "Input sample must have 32fC1 type", "Inner function failed.", "Input sample must be 1-dimensional vector", "The sample size is different from what has been used for training", "INTERNAL ERROR: The row_sample pointer is NULL", "INTERNAL ERROR: invalid comp_idx", "The output matrix of probabilities is invalid", "The matrix of probabilities must be 1-dimensional vector of 32fC1 type", "The vector of probabilities must contain as many elements as the number of classes in the training set", "INTERNAL ERROR: Unknown SVM type, the SVM structure is probably corrupted", "The SVM should be trained first", "my_svm", "N2cv3ocl9CvSVM_OCLE", "N2cv3ocl15CvSVMSolver_oclE", "void cv::ocl::matchTemplateNaive_SQDIFF(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void cv::ocl::matchTemplate_CCOFF(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::MatchTemplateBuf&)", "void cv::ocl::matchTemplateNaive_CCORR(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void cv::ocl::matchTemplate_CCOFF_NORMED(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::MatchTemplateBuf&)", "void cv::ocl::matchTemplate(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, int, cv::ocl::MatchTemplateBuf&)", "vector::_M_fill_insert", "(image.depth() == CV_8U && templ.depth() == CV_8U ) || ((image.depth() == CV_32F && templ.depth() == CV_32F) && result.depth() == CV_32F)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/match_template.cpp", "image.oclchannels() == templ.oclchannels() && (image.oclchannels() == 1 || image.oclchannels() == 4) && result.oclchannels() == 1", "result.rows == image.rows - templ.rows + 1 && result.cols == image.cols - templ.cols + 1", "matchTemplate_Naive_SQDIFF", "convolve is not fully implemented yet", "matchTemplate_Naive_CCORR", "image.depth() == CV_8U && templ.depth() == CV_8U", "matchTemplate_Prepared_CCOFF", "matchTemplate: unsupported number of channels", "normalizeKernel", "matchTemplate_Prepared_SQDIFF_NORMED", "extractFirstChannel", "image.type() == templ.type()", "image.cols >= templ.cols && image.rows >= templ.rows", "caller", "matchTemplate_Prepared_CCOFF_NORMED", "void cv::ocl::convolve_32F(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::MatchTemplateBuf&)", "void cv::ocl::openCLReadBuffer(cv::ocl::Context*, cl_mem, void*, std::size_t)", "void cv::ocl::openCLFree(void*)", "_cl_mem* cv::ocl::openCLCreateBuffer(cv::ocl::Context*, std::size_t, std::size_t)", "_cl_mem* cv::ocl::load_constant(cl_context, cl_command_queue, void const*, std::size_t)", "void cv::ocl::openCLMemcpy2D(cv::ocl::Context*, void*, std::size_t, void const*, std::size_t, std::size_t, std::size_t, cv::ocl::openCLMemcpyKind, int)", "kernel != NULL", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/cl_operations.cpp", "ProgramCache::getProgramCache() != NULL", "program != NULL", "localThreads[0] <= ctx->getDeviceInfo().maxWorkItemSizes[0]", "localThreads[1] <= ctx->getDeviceInfo().maxWorkItemSizes[1]", "localThreads[2] <= ctx->getDeviceInfo().maxWorkItemSizes[2]", "localThreads[0] * localThreads[1] * localThreads[2] <= kernelWorkGroupSize", "localThreads[0] * localThreads[1] * localThreads[2] <= ctx->getDeviceInfo().maxWorkGroupSize", "custom_", "globalThreads != NULL", "_cl_kernel* cv::ocl::openCLGetKernelFromSource(const cv::ocl::Context*, const cv::ocl::ProgramEntry*, std::string, char const*)", "void cv::ocl::openCLCopyBuffer2D(cv::ocl::Context*, void*, std::size_t, int, void const*, std::size_t, std::size_t, std::size_t, int)", "void cv::ocl::openCLVerifyKernel(const cv::ocl::Context*, cl_kernel, std::size_t*)", "void cv::ocl::openCLExecuteKernelInterop(cv::ocl::Context*, const cv::ocl::ProgramSource&, std::string, std::size_t*, std::size_t*, std::vector<std::pair<unsigned int, void const*> >&, int, int, char const*)", "void cv::ocl::openCLMallocPitchEx(cv::ocl::Context*, void**, std::size_t*, std::size_t, std::size_t, cv::ocl::DevMemRW, cv::ocl::DevMemType)", "void cv::ocl::openCLExecuteKernel(cv::ocl::Context*, cl_kernel, std::size_t*, std::size_t*, std::vector<std::pair<unsigned int, void const*> >&)", "std::size_t cv::ocl::queryWaveFrontSize(cl_kernel)", "-D DEPTH_%d -D dcn=%d -D bidx=%d -D pixels_per_work_item=%d", "-D DEPTH_%d -D scn=%d -D bidx=%d -D pixels_per_work_item=%d", "-D DEPTH_%d -D greenbits=%d -D scn=%d -D bidx=%d", "-D DEPTH_%d -D scn=%d -D bidx=%d", "-D DEPTH_%d -D greenbits=%d -D dcn=%d -D bidx=%d", "REVERSE", "ORDER", "RGBA2mRGBA", "mRGBA2RGBA", "depth == CV_8U || depth == CV_16U || depth == CV_32F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/color.cpp", "scn == 3 || scn == 4", "-D DEPTH_%d -D dcn=%d -D scn=%d -D %s", "(scn == 3 || scn == 4) && depth == CV_8U", "RGB2RGB5x5", "(dcn == 3 || dcn == 4) && scn == 2 && depth == CV_8U", "RGB5x52RGB", "scn == 2 && depth == CV_8U", "BGR5x52Gray", "scn == 1 && depth == CV_8U", "Gray2BGR5x5", "RGB2Gray", "scn == 1", "Gray2RGB", "-D DEPTH_%d -D dcn=%d -D bidx=%d", "RGB2YUV", "scn == 3 && (dcn == 3 || dcn == 4)", "YUV2RGB", "sz.width % 2 == 0 && sz.height % 3 == 0 && depth == CV_8U", "YUV2RGBA_NV12", "RGB2YCrCb", "YCrCb2RGB", "RGB2XYZ", "XYZ2RGB", "(scn == 3 || scn == 4) && (depth == CV_8U || depth == CV_32F)", "RGB2", " -D hrange=%d", " -D hscale=%f", "scn == 3 && (dcn == 3 || dcn == 4) && (depth == CV_8U || depth == CV_32F)", "2RGB", " -D hrange=%d -D hscale=%f", "scn == 4 && depth == CV_8U", "Unknown/unsupported color conversion code", "void cvtColor_caller(const cv::ocl::oclMat&, cv::ocl::oclMat&, int, int)", "void cv::ocl::blendLinear(const cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::oclMat&)", "_sat_rte", "src1.depth() <= CV_32F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/blend.cpp", "src1.size() == src2.size() && src1.type() == src2.type()", "weights1.size() == weights2.size() && weights1.size() == src1.size() && weights1.type() == CV_32FC1 && weights2.type() == CV_32FC1", "-D T=%s%s -D convertToT=convert_%s%s%s -D FT=float%s -D convertToFT=convert_float%s", "blendLinear", "uchar", "char", "ushort", "short", "float", "double", "void cv::ocl::Canny(const cv::ocl::oclMat&, cv::ocl::CannyBuf&, cv::ocl::oclMat&, double, double, int, bool)", "cv::ocl::CannyBuf::CannyBuf(const cv::ocl::oclMat&, const cv::ocl::oclMat&)", "void cv::ocl::canny::edgesHysteresisGlobal_gpu(cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&, int, int)", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "dx_.type() == CV_32SC1 && dy_.type() == CV_32SC1 && dx_.size() == dy_.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/canny.cpp", "count >= 0", "edgesHysteresisGlobal", "getEdges", "edgesHysteresisLocal", "calcMap", "-D L2GRAD", "calcMagnitude", "dx.type() == CV_32SC1 && dy.type() == CV_32SC1 && dx.size() == dy.size()", "calcMagnitude_buf", "calcSobelRowPass", "src.type() == CV_8UC1", "void cv::ocl::Canny(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::ocl::CannyBuf&, cv::ocl::oclMat&, double, double, bool)", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "24KMeansPPDistanceComputer", "void cv::ocl::distanceToCenters(const cv::ocl::oclMat&, const cv::ocl::oclMat&, cv::Mat&, cv::Mat&, int)", "double cv::ocl::kmeans(const cv::ocl::oclMat&, int, cv::ocl::oclMat&, cv::TermCriteria, int, int, cv::ocl::oclMat&)", "-D L1_DIST", "-D L2SQR_DIST", "src.cols * src.channels() == centers.cols * centers.channels()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/kmeans.cpp", "src.depth() == CV_32F && centers.depth() == CV_32F", "distType == NORM_L1 || distType == NORM_L2SQR", "distanceToCenters", "type == CV_32F && K > 0", "N >= K", "(_bestLabels.cols == 1 || _bestLabels.rows == 1) && _bestLabels.cols * _bestLabels.rows == N && _bestLabels.type() == CV_32S", "(unsigned)labels[i] < (unsigned)K", "counters[k] != 0", "void cv::ocl::KNearestNeighbour::find_nearest(const cv::ocl::oclMat&, int, cv::ocl::oclMat&)", "N2cv3ocl17KNearestNeighbourE", "!samples_ocl.empty()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/knearest.cpp", "samples.cols == CvKNearest::var_count", "samples.type() == CV_32FC1", "k >= 1 && k <= max_k", "knn_find_nearest", "-D DOUBLE_SUPPORT", "N2cv7TLSDataINS_3ocl12CommandQueueEEE", "bool cv::ocl::selectOpenCLDevice()", "static void cv::ocl::ContextImpl::initializeContext(void*, void*, void*)", "static void cv::ocl::ContextImpl::setContext(const cv::ocl::DeviceInfo*)", "int cv::ocl::initializeOpenCLDevices()", "static cv::ocl::ContextImpl* cv::ocl::ContextImpl::getContext()", "void cv::ocl::DeviceInfoImpl::init(int, cv::ocl::PlatformInfoImpl&, cl_device_id)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/cl_context.cpp", "basic_string::substr", "Invalid feature type", "this != currentContext", "deviceInfo->_id >= 0", "deviceInfo->_id < (int)global_devices.size()", "deviceInfo == &infoImpl", "platform_id == NULL", "device_id == NULL", "cl_khr_fp64", "-D DOUBLE_SUPPORT", "Intel", " -D INTEL_DEVICE", "pClPlatform != NULL", "pClContext != NULL", "pClDevice != NULL", "vector::_M_fill_insert", "vector::_M_insert_aux", "OpenCL not available", "OPENCV_OPENCL_DEVICE", "ERROR: Invalid configuration string for OpenCL device", "deviceID >= 0", "ERROR: Can't find OpenCL platform by name: ", "ACCELERATOR", "ERROR: Unsupported device type for OpenCL device (GPU, CPU, ACCELERATOR): ", "Skip unsupported version of OpenCL device: ", "ERROR: Required OpenCL device not found, check configuration: ", "    Platform: ", "    Device types: ", "    Device name: ", "ERROR: Can't select OpenCL device: ", "Can't select OpenCL device", "currentContext != NULL", "void cv::ocl::CommandQueue::release()", "void cv::ocl::CommandQueue::create(cv::ocl::ContextImpl*)", "cv::ocl::ContextImpl::~ContextImpl()", "void cv::ocl::PlatformInfoImpl::init(int, cl_platform_id)", "bool cv::ocl::ContextImpl::supportsFeature(cv::ocl::FEATURE_TYPE) const", "cv::ocl::ContextImpl::ContextImpl(const cv::ocl::DeviceInfoImpl&, cl_context)", "void cv::ocl::GoodFeaturesToTrackDetector_OCL::operator()(const cv::ocl::oclMat&, cv::ocl::oclMat&, const cv::ocl::oclMat&)", "void cv::ocl::GoodFeaturesToTrackDetector_OCL::downloadPoints(const cv::ocl::oclMat&, std::vector<cv::Point_<float> >&)", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "vector::_M_insert_aux", "vector::_M_fill_insert", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/gftt.cpp", "qualityLevel > 0 && minDistance >= 0 && maxCorners >= 0", "mask.empty() || (mask.type() == CV_8UC1 && mask.size() == image.size())", "groupnum != 0", "arithm_op_minMax", "-D T=float -D DEPTH_5 -D vlen=1", "arithm_op_minMax_final", " -D WITH_MASK=1", "findCorners", "vector::reserve", "void minMaxEig_caller(const cv::ocl::oclMat&, cv::ocl::oclMat&, cv::ocl::oclMat&)", "void cv::ocl::openCLExecuteKernel_2(cv::ocl::Context*, const cv::ocl::ProgramEntry*, std::string, std::size_t*, std::size_t*, std::vector<std::pair<unsigned int, void const*> >&, int, int, char*, cv::ocl::FLUSH_MODE)", "_cl_mem* cv::ocl::bindTexture(const cv::ocl::oclMat&)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/mcwutil.cpp", "Image forma is not supported", "Image format is not supported", "cv::Moments cv::ocl::ocl_moments(cv::ocl::oclMat&, bool)", "cv::Moments cv::ocl::ocl_moments(cv::InputArray)", "src.oclchannels() == 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/src/moments.cpp", "Moments - double is not supported by your GPU!", "-D CV_8UC1", "-D CV_16UC1", "-D CV_16SC1", "-D CV_32FC1", "-D CV_64FC1", "CvMoments", "contour", "icvContourMoments", "void cv::ocl::icvContourMoments(CvSeq*, CvMoments*)", "tvl1flow", "__kernel void centeredGradientKernel(__global const float* src, int src_col, int src_row, int src_step,\n__global float* dx, __global float* dy, int dx_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif((x < src_col)&&(y < src_row))\n{\nint src_x1 = (x + 1) < (src_col -1)? (x + 1) : (src_col - 1);\nint src_x2 = (x - 1) > 0 ? (x -1) : 0;\ndx[y * dx_step+ x] = 0.5f * (src[y * src_step + src_x1] - src[y * src_step+ src_x2]);\nint src_y1 = (y+1) < (src_row - 1) ? (y + 1) : (src_row - 1);\nint src_y2 = (y - 1) > 0 ? (y - 1) : 0;\ndy[y * dx_step+ x] = 0.5f * (src[src_y1 * src_step + x] - src[src_y2 * src_step+ x]);\n}\n}\nfloat bicubicCoeff(float x_)\n{\nfloat x = fabs(x_);\nif (x <= 1.0f)\nreturn x * x * (1.5f * x - 2.5f) + 1.0f;\nelse if (x < 2.0f)\nreturn x * (x * (-0.5f * x + 2.5f) - 4.0f) + 2.0f;\nelse\nreturn 0.0f;\n}\n__kernel void warpBackwardKernel(__global const float* I0, int I0_step, int I0_col, int I0_row,\nimage2d_t tex_I1, image2d_t tex_I1x, image2d_t tex_I1y,\n__global const float* u1, int u1_step,\n__global const float* u2,\n__global float* I1w,\n__global float* I1wx, \n__global float* I1wy, \n__global float* grad, \n__global float* rho,\nint I1w_step,\nint u2_step,\nint u1_offset_x,\nint u1_offset_y,\nint u2_offset_x,\nint u2_offset_y)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < I0_col&&y < I0_row)\n{\nfloat u1Val = u1[(y + u1_offset_y) * u1_step + x + u1_offset_x];\nfloat u2Val = u2[(y + u2_offset_y) * u2_step + x + u2_offset_x];\nfloat wx = x + u1Val;\nfloat wy = y + u2Val;\nint xmin = ceil(wx - 2.0f);\nint xmax = floor(wx + 2.0f);\nint ymin = ceil(wy - 2.0f);\nint ymax = floor(wy + 2.0f);\nfloat sum  = 0.0f;\nfloat sumx = 0.0f;\nfloat sumy = 0.0f;\nfloat wsum = 0.0f;\nsampler_t sampleri = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\nfor (int cy = ymin; cy <= ymax; ++cy)\n{\nfor (int cx = xmin; cx <= xmax; ++cx)\n{\nfloat w = bicubicCoeff(wx - cx) * bicubicCoeff(wy - cy);\nint2 cood = (int2)(cx, cy);\nsum += w * read_imagef(tex_I1, sampleri, cood).x;\nsumx += w * read_imagef(tex_I1x, sampleri, cood).x;\nsumy += w * read_imagef(tex_I1y, sampleri, cood).x;\nwsum += w;\n}\n}\nfloat coeff = 1.0f / wsum;\nfloat I1wVal  = sum  * coeff;\nfloat I1wxVal = sumx * coeff;\nfloat I1wyVal = sumy * coeff;\nI1w[y * I1w_step + x]  = I1wVal;\nI1wx[y * I1w_step + x] = I1wxVal;\nI1wy[y * I1w_step + x] = I1wyVal;\nfloat Ix2 = I1wxVal * I1wxVal;\nfloat Iy2 = I1wyVal * I1wyVal;\ngrad[y * I1w_step + x] = Ix2 + Iy2;\nfloat I0Val = I0[y * I0_step + x];\nrho[y * I1w_step + x] = I1wVal - I1wxVal * u1Val - I1wyVal * u2Val - I0Val;\n}\n}\nfloat readImage(__global float *image,  int x,  int y,  int rows,  int cols, int elemCntPerRow)\n{\nint i0 = clamp(x, 0, cols - 1);\nint j0 = clamp(y, 0, rows - 1);\nreturn image[j0 * elemCntPerRow + i0];\n}\n__kernel void warpBackwardKernelNoImage2d(__global const float* I0, int I0_step, int I0_col, int I0_row,\n__global const float* tex_I1, __global const float* tex_I1x, __global const float* tex_I1y,\n__global const float* u1, int u1_step,\n__global const float* u2,\n__global float* I1w,\n__global float* I1wx, \n__global float* I1wy, \n__global float* grad, \n__global float* rho,\nint I1w_step,\nint u2_step,\nint I1_step,\nint I1x_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < I0_col&&y < I0_row)\n{\nfloat u1Val = u1[y * u1_step + x];\nfloat u2Val = u2[y * u2_step + x];\nfloat wx = x + u1Val;\nfloat wy = y + u2Val;\nint xmin = ceil(wx - 2.0f);\nint xmax = floor(wx + 2.0f);\nint ymin = ceil(wy - 2.0f);\nint ymax = floor(wy + 2.0f);\nfloat sum  = 0.0f;\nfloat sumx = 0.0f;\nfloat sumy = 0.0f;\nfloat wsum = 0.0f;\nfor (int cy = ymin; cy <= ymax; ++cy)\n{\nfor (int cx = xmin; cx <= xmax; ++cx)\n{\nfloat w = bicubicCoeff(wx - cx) * bicubicCoeff(wy - cy);\nint2 cood = (int2)(cx, cy);\nsum += w * readImage(tex_I1, cood.x, cood.y, I0_col, I0_row, I1_step);\nsumx += w * readImage(tex_I1x, cood.x, cood.y, I0_col, I0_row, I1x_step);\nsumy += w * readImage(tex_I1y, cood.x, cood.y, I0_col, I0_row, I1x_step);\nwsum += w;\n}\n}\nfloat coeff = 1.0f / wsum;\nfloat I1wVal  = sum  * coeff;\nfloat I1wxVal = sumx * coeff;\nfloat I1wyVal = sumy * coeff;\nI1w[y * I1w_step + x]  = I1wVal;\nI1wx[y * I1w_step + x] = I1wxVal;\nI1wy[y * I1w_step + x] = I1wyVal;\nfloat Ix2 = I1wxVal * I1wxVal;\nfloat Iy2 = I1wyVal * I1wyVal;\ngrad[y * I1w_step + x] = Ix2 + Iy2;\nfloat I0Val = I0[y * I0_step + x];\nrho[y * I1w_step + x] = I1wVal - I1wxVal * u1Val - I1wyVal * u2Val - I0Val;\n}\n}\n__kernel void estimateDualVariablesKernel(__global const float* u1, int u1_col, int u1_row, int u1_step,\n__global const float* u2,\n__global float* p11, int p11_step,\n__global float* p12,\n__global float* p21,\n__global float* p22,\nfloat taut,\nint u2_step,\nint u1_offset_x,\nint u1_offset_y,\nint u2_offset_x,\nint u2_offset_y)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < u1_col && y < u1_row)\n{\nint src_x1 = (x + 1) < (u1_col - 1) ? (x + 1) : (u1_col - 1);\nfloat u1x = u1[(y + u1_offset_y) * u1_step + src_x1 + u1_offset_x] - u1[(y + u1_offset_y) * u1_step + x + u1_offset_x];\nint src_y1 = (y + 1) < (u1_row - 1) ? (y + 1) : (u1_row - 1);\nfloat u1y = u1[(src_y1 + u1_offset_y) * u1_step + x + u1_offset_x] - u1[(y + u1_offset_y) * u1_step + x + u1_offset_x];\nint src_x2 = (x + 1) < (u1_col - 1) ? (x + 1) : (u1_col - 1);\nfloat u2x = u2[(y + u2_offset_y) * u2_step + src_x2 + u2_offset_x] - u2[(y + u2_offset_y) * u2_step + x + u2_offset_x];\nint src_y2 = (y + 1) <  (u1_row - 1) ? (y + 1) : (u1_row - 1);\nfloat u2y = u2[(src_y2 + u2_offset_y) * u2_step + x + u2_offset_x] - u2[(y + u2_offset_y) * u2_step + x + u2_offset_x];\nfloat g1 = hypot(u1x, u1y);\nfloat g2 = hypot(u2x, u2y);\nfloat ng1 = 1.0f + taut * g1;\nfloat ng2 = 1.0f + taut * g2;\np11[y * p11_step + x] = (p11[y * p11_step + x] + taut * u1x) / ng1;\np12[y * p11_step + x] = (p12[y * p11_step + x] + taut * u1y) / ng1;\np21[y * p11_step + x] = (p21[y * p11_step + x] + taut * u2x) / ng2;\np22[y * p11_step + x] = (p22[y * p11_step + x] + taut * u2y) / ng2;\n}\n}\nfloat divergence(__global const float* v1, __global const float* v2, int y, int x, int v1_step, int v2_step)\n{\nif (x > 0 && y > 0)\n{\nfloat v1x = v1[y * v1_step + x] - v1[y * v1_step + x - 1];\nfloat v2y = v2[y * v2_step + x] - v2[(y - 1) * v2_step + x];\nreturn v1x + v2y;\n}\nelse\n{\nif (y > 0)\nreturn v1[y * v1_step + 0] + v2[y * v2_step + 0] - v2[(y - 1) * v2_step + 0];\nelse\n{\nif (x > 0)\nreturn v1[0 * v1_step + x] - v1[0 * v1_step + x - 1] + v2[0 * v2_step + x];\nelse\nreturn v1[0 * v1_step + 0] + v2[0 * v2_step + 0];\n}\n}\n}\n__kernel void estimateUKernel(__global const float* I1wx, int I1wx_col, int I1wx_row, int I1wx_step,\n__global const float* I1wy, \n__global const float* grad, \n__global const float* rho_c, \n__global const float* p11, \n__global const float* p12, \n__global const float* p21, \n__global const float* p22, \n__global float* u1, int u1_step,\n__global float* u2,\n__global float* error, float l_t, float theta, int u2_step,\nint u1_offset_x,\nint u1_offset_y,\nint u2_offset_x,\nint u2_offset_y,\nchar calc_error)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < I1wx_col && y < I1wx_row)\n{\nfloat I1wxVal = I1wx[y * I1wx_step + x];\nfloat I1wyVal = I1wy[y * I1wx_step + x];\nfloat gradVal = grad[y * I1wx_step + x];\nfloat u1OldVal = u1[(y + u1_offset_y) * u1_step + x + u1_offset_x];\nfloat u2OldVal = u2[(y + u2_offset_y) * u2_step + x + u2_offset_x];\nfloat rho = rho_c[y * I1wx_step + x] + (I1wxVal * u1OldVal + I1wyVal * u2OldVal);\nfloat d1 = 0.0f;\nfloat d2 = 0.0f;\nif (rho < -l_t * gradVal)\n{\nd1 = l_t * I1wxVal;\nd2 = l_t * I1wyVal;\n}\nelse if (rho > l_t * gradVal)\n{\nd1 = -l_t * I1wxVal;\nd2 = -l_t * I1wyVal;\n}\nelse if (gradVal > 1.192092896e-07f)\n{\nfloat fi = -rho / gradVal;\nd1 = fi * I1wxVal;\nd2 = fi * I1wyVal;\n}\nfloat v1 = u1OldVal + d1;\nfloat v2 = u2OldVal + d2;\nfloat div_p1 = divergence(p11, p12, y, x, I1wx_step, I1wx_step);\nfloat div_p2 = divergence(p21, p22, y, x, I1wx_step, I1wx_step);\nfloat u1NewVal = v1 + theta * div_p1;\nfloat u2NewVal = v2 + theta * div_p2;\nu1[(y + u1_offset_y) * u1_step + x + u1_offset_x] = u1NewVal;\nu2[(y + u2_offset_y) * u2_step + x + u2_offset_x] = u2NewVal;\nif(calc_error)\n{\nfloat n1 = (u1OldVal - u1NewVal) * (u1OldVal - u1NewVal);\nfloat n2 = (u2OldVal - u2NewVal) * (u2OldVal - u2NewVal);\nerror[y * I1wx_step + x] = n1 + n2;\n}\n}\n}\n", "15d604b56daef7cecff8d9ada2970732", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define TYPE double\n#else\n#define TYPE float\n#endif\n#if defined ADDEXP\n#define EXP(X) exp(X)\n#else\n#define EXP(X) X\n#endif\n#if defined ADDPOW\n#define POW(X,Y) pow(fabs(X),(Y))\n#else\n#define POW(X,Y) X\n#endif\n#define MAX_VAL   (FLT_MAX*1e-3)\n#define BLOCK_SIZE 16\n__kernel void svm_linear(__global float* src, int src_step, __global float* src2, int src2_step, __global TYPE* dst, int dst_step, int src_rows, int src2_cols,\nint width, TYPE alpha, TYPE beta)\n{\nconst int  col = get_global_id(0);\nconst int  row = get_global_id(1);\nif(row < src_rows && col < src2_cols)\n{\nint t = 0;\nTYPE temp = 0.0;\nfor(t = 0; t < width - BLOCK_SIZE; t += BLOCK_SIZE)\n{\nfloat16 t0 = vload16(0, src + row * src_step + t);\nfloat16 t1 = vload16(0, src2 + col * src2_step + t);\nt0 *= t1;\ntemp += t0.s0 + t0.s1 + t0.s2 + t0.s3 + t0.s4 + t0.s5 + t0.s6 + t0.s7 +\nt0.s8 + t0.s9 + t0.sa + t0.sb + t0.sc + t0.sd + t0.se + t0.sf;\n}\nfor(; t < width; t++)\n{\ntemp += src[row * src_step + t] * src2[col * src2_step + t];\n}\nTYPE temp1 = (TYPE) (temp * alpha + beta);\nif( temp1 > MAX_VAL )\n{\ndst[row * dst_step + col] = MAX_VAL;\n}\nelse\n{\ndst[row * dst_step + col] = temp1;\n}\n}\n}\n__kernel void svm_sigmod(__global float* src, int src_step, __global float* src2, int src2_step, __global TYPE* dst, int dst_step, int src_rows, int src2_cols,\nint width, TYPE alpha, TYPE beta)\n{\nconst int  col = get_global_id(0);\nconst int  row = get_global_id(1);\nif(row < src_rows && col < src2_cols)\n{\nint t = 0;\nTYPE temp = 0.0;\nfor(t = 0; t < width - BLOCK_SIZE; t += BLOCK_SIZE)\n{\nfloat16 t0 = vload16(0, src + row * src_step + t);\nfloat16 t1 = vload16(0, src2 + col * src2_step + t);\nt0 *= t1;\ntemp += t0.s0 + t0.s1 + t0.s2 + t0.s3 + t0.s4 + t0.s5 + t0.s6 + t0.s7 +\nt0.s8 + t0.s9 + t0.sa + t0.sb + t0.sc + t0.sd + t0.se + t0.sf;\n}\nfor(; t < width; t++)\n{\ntemp += src[row * src_step + t] * src2[col * src2_step + t];\n}\nTYPE tp = (TYPE) (temp * alpha + beta);\nTYPE e = exp(-fabs(tp));\nTYPE temp1;\nif(tp > 0)\n{\ntemp1 = (TYPE)((1. - e) / (1. + e));\n}\nelse\n{\ntemp1 = (TYPE)((e - 1.) / (e + 1.));\n}\nif( temp1 > MAX_VAL )\n{\ndst[row * dst_step + col] = MAX_VAL;\n}\nelse\n{\ndst[row * dst_step + col] = temp1;\n}\n}\n}\n__kernel void svm_poly(__global float* src, int src_step, __global float* src2, int src2_step, __global TYPE* dst, int dst_step, int src_rows, int src2_cols,\nint width, TYPE alpha, TYPE beta, TYPE degree)\n{\nconst int  col = get_global_id(0);\nconst int  row = get_global_id(1);\nif(row < src_rows && col < src2_cols)\n{\nint t = 0;\nTYPE temp = 0.0;\nfor(t = 0; t < width - BLOCK_SIZE; t += BLOCK_SIZE)\n{\nfloat16 t0 = vload16(0, src + row * src_step + t);\nfloat16 t1 = vload16(0, src2 + col * src2_step + t);\nt0 *= t1;\ntemp += t0.s0 + t0.s1 + t0.s2 + t0.s3 + t0.s4 + t0.s5 + t0.s6 + t0.s7 +\nt0.s8 + t0.s9 + t0.sa + t0.sb + t0.sc + t0.sd + t0.se + t0.sf;\n}\nfor(; t < width; t++)\n{\ntemp += src[row * src_step + t] * src2[col * src2_step + t];\n}\nTYPE temp1 = (TYPE)(POW((temp * alpha + beta), degree));\nif( temp1 > MAX_VAL )\n{\ndst[row * dst_step + col] = MAX_VAL;\n}\nelse\n{\ndst[row * dst_step + col] = temp1;\n}\n}\n}\n__kernel void svm_rbf(__global float* src, int src_step, __global float* src2, int src2_step, __global TYPE* dst, int dst_step, int src_rows, int src2_cols,\nint width, TYPE gamma)\n{\nconst int  col = get_global_id(0);\nconst int  row = get_global_id(1);\nif(row < src_rows && col < src2_cols)\n{\nint t = 0;\nTYPE temp = 0.0;\nfor(t = 0; t < width - BLOCK_SIZE; t += BLOCK_SIZE)\n{\nfloat16 t0 = vload16(0, src + row * src_step + t);\nfloat16 t1 = vload16(0, src2 + col * src2_step + t);\nt0 = (t0 - t1) * (t0 - t1);\ntemp += t0.s0 + t0.s1 + t0.s2 + t0.s3 + t0.s4 + t0.s5 + t0.s6 + t0.s7 +\nt0.s8 + t0.s9 + t0.sa + t0.sb + t0.sc + t0.sd + t0.se + t0.sf;\n}\nfor(; t < width; t++)\n{\ntemp += (src[row * src_step + t] - src2[col * src2_step + t]) * (src[row * src_step + t] - src2[col * src2_step + t]);\n}\nTYPE temp1 = EXP((TYPE)(temp * gamma));\nif( temp1 > MAX_VAL )\n{\ndst[row * dst_step + col] = MAX_VAL;\n}\nelse\n{\ndst[row * dst_step + col] = temp1;\n}\n}\n}\n", "366022531756acf8bbab0f837ce1849a", "stereocsbp", "__kernel void get_first_k_initial_global_0(__global short *data_cost_selected_, __global short *selected_disp_pyr,\n__global short *ctemp, int h, int w, int nr_plane,\nint cmsg_step1, int cdisp_step1, int cndisp)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\n__global short *selected_disparity = selected_disp_pyr      + y * cmsg_step1 + x;\n__global short *data_cost_selected = data_cost_selected_    + y * cmsg_step1 + x;\n__global short *data_cost          = ctemp + y * cmsg_step1 + x;\nfor(int i = 0; i < nr_plane; i++)\n{\nshort minimum = SHRT_MAX;\nint id = 0;\nfor(int d = 0; d < cndisp; d++)\n{\nshort cur = data_cost[d * cdisp_step1];\nif(cur < minimum)\n{\nminimum = cur;\nid = d;\n}\n}\ndata_cost_selected[i  * cdisp_step1] = minimum;\nselected_disparity[i  * cdisp_step1] = id;\ndata_cost         [id * cdisp_step1] = SHRT_MAX;\n}\n}\n}\n__kernel void get_first_k_initial_global_1(__global  float *data_cost_selected_, __global float *selected_disp_pyr,\n__global  float *ctemp, int h, int w, int nr_plane,\nint cmsg_step1, int cdisp_step1, int cndisp)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\n__global   float *selected_disparity = selected_disp_pyr      + y * cmsg_step1 + x;\n__global   float *data_cost_selected = data_cost_selected_    + y * cmsg_step1 + x;\n__global   float *data_cost          = ctemp + y * cmsg_step1 + x;\nfor(int i = 0; i < nr_plane; i++)\n{\nfloat minimum = FLT_MAX;\nint id = 0;\nfor(int d = 0; d < cndisp; d++)\n{\nfloat cur = data_cost[d * cdisp_step1];\nif(cur < minimum)\n{\nminimum = cur;\nid = d;\n}\n}\ndata_cost_selected[i  * cdisp_step1] = minimum;\nselected_disparity[i  * cdisp_step1] = id;\ndata_cost         [id * cdisp_step1] = FLT_MAX;\n}\n}\n}\n__kernel void get_first_k_initial_local_0(__global  short *data_cost_selected_, __global short *selected_disp_pyr,\n__global  short *ctemp,int h, int w, int nr_plane,\nint cmsg_step1, int cdisp_step1, int cndisp)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\n__global short *selected_disparity = selected_disp_pyr   + y * cmsg_step1 + x;\n__global short *data_cost_selected = data_cost_selected_ + y * cmsg_step1 + x;\n__global short *data_cost = ctemp + y * cmsg_step1 + x;\nint nr_local_minimum = 0;\nshort prev = data_cost[0 * cdisp_step1];\nshort cur  = data_cost[1 * cdisp_step1];\nshort next = data_cost[2 * cdisp_step1];\nfor (int d = 1; d < cndisp - 1 && nr_local_minimum < nr_plane; d++)\n{\nif (cur < prev && cur < next)\n{\ndata_cost_selected[nr_local_minimum * cdisp_step1] = cur;\nselected_disparity[nr_local_minimum * cdisp_step1] = d;\ndata_cost[d * cdisp_step1] = SHRT_MAX;\nnr_local_minimum++;\n}\nprev = cur;\ncur = next;\nnext = data_cost[(d + 1) * cdisp_step1];\n}\nfor (int i = nr_local_minimum; i < nr_plane; i++)\n{\nshort minimum = SHRT_MAX;\nint id = 0;\nfor (int d = 0; d < cndisp; d++)\n{\ncur = data_cost[d * cdisp_step1];\nif (cur < minimum)\n{\nminimum = cur;\nid = d;\n}\n}\ndata_cost_selected[i * cdisp_step1] = minimum;\nselected_disparity[i * cdisp_step1] = id;\ndata_cost[id * cdisp_step1] = SHRT_MAX;\n}\n}\n}\n__kernel void get_first_k_initial_local_1(__global float *data_cost_selected_, __global float *selected_disp_pyr,\n__global float *ctemp,int h, int w, int nr_plane,\nint cmsg_step1,  int cdisp_step1, int cndisp)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\n__global float *selected_disparity = selected_disp_pyr   + y * cmsg_step1 + x;\n__global float *data_cost_selected = data_cost_selected_ + y * cmsg_step1 + x;\n__global float *data_cost = ctemp + y * cmsg_step1 + x;\nint nr_local_minimum = 0;\nfloat prev = data_cost[0 * cdisp_step1];\nfloat cur  = data_cost[1 * cdisp_step1];\nfloat next = data_cost[2 * cdisp_step1];\nfor (int d = 1; d < cndisp - 1 && nr_local_minimum < nr_plane; d++)\n{\nif (cur < prev && cur < next)\n{\ndata_cost_selected[nr_local_minimum * cdisp_step1] = cur;\nselected_disparity[nr_local_minimum * cdisp_step1] = d;\ndata_cost[d * cdisp_step1] = FLT_MAX ;\nnr_local_minimum++;\n}\nprev = cur;\ncur = next;\nnext = data_cost[(d + 1) * cdisp_step1];\n}\nfor (int i = nr_local_minimum; i < nr_plane; i++)\n{\nfloat minimum = FLT_MAX;\nint id = 0;\nfor (int d = 0; d < cndisp; d++)\n{\ncur = data_cost[d * cdisp_step1];\nif (cur < minimum)\n{\nminimum = cur;\nid = d;\n}\n}\ndata_cost_selected[i * cdisp_step1] = minimum;\nselected_disparity[i * cdisp_step1] = id;\ndata_cost[id * cdisp_step1] = FLT_MAX;\n}\n}\n}\nfloat compute_3(__global uchar* left, __global uchar* right,\nfloat cdata_weight,  float cmax_data_term)\n{\nfloat tb = 0.114f * abs((int)left[0] - right[0]);\nfloat tg = 0.587f * abs((int)left[1] - right[1]);\nfloat tr = 0.299f * abs((int)left[2] - right[2]);\nreturn fmin(cdata_weight * (tr + tg + tb), cdata_weight * cmax_data_term);\n}\nfloat compute_1(__global uchar* left, __global uchar* right,\nfloat cdata_weight,  float cmax_data_term)\n{\nreturn fmin(cdata_weight * abs((int)*left - (int)*right), cdata_weight * cmax_data_term);\n}\nshort round_short(float v)\n{\nreturn convert_short_sat_rte(v);\n}\n__kernel void init_data_cost_0(__global short *ctemp, __global uchar *cleft, __global uchar *cright,\nint h, int w, int level, int channels,\nint cmsg_step1, float cdata_weight, float cmax_data_term, int cdisp_step1,\nint cth, int cimg_step, int cndisp)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\nint y0 = y << level;\nint yt = (y + 1) << level;\nint x0 = x << level;\nint xt = (x + 1) << level;\n__global short *data_cost = ctemp + y * cmsg_step1 + x;\nfor(int d = 0; d < cndisp; ++d)\n{\nfloat val = 0.0f;\nfor(int yi = y0; yi < yt; yi++)\n{\nfor(int xi = x0; xi < xt; xi++)\n{\nint xr = xi - d;\nif(d < cth || xr < 0)\nval += cdata_weight * cmax_data_term;\nelse\n{\n__global uchar *lle = cleft  + yi * cimg_step + xi * channels;\n__global uchar *lri = cright + yi * cimg_step + xr * channels;\nif(channels == 1)\nval += compute_1(lle, lri, cdata_weight, cmax_data_term);\nelse\nval += compute_3(lle, lri, cdata_weight, cmax_data_term);\n}\n}\n}\ndata_cost[cdisp_step1 * d] = round_short(val);\n}\n}\n}\n__kernel void init_data_cost_1(__global float *ctemp, __global uchar *cleft, __global uchar *cright,\nint h, int w, int level, int channels,\nint cmsg_step1, float cdata_weight, float cmax_data_term, int cdisp_step1,\nint cth, int cimg_step, int cndisp)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\nint y0 = y << level;\nint yt = (y + 1) << level;\nint x0 = x << level;\nint xt = (x + 1) << level;\n__global float *data_cost = ctemp + y * cmsg_step1 + x;\nfor(int d = 0; d < cndisp; ++d)\n{\nfloat val = 0.0f;\nfor(int yi = y0; yi < yt; yi++)\n{\nfor(int xi = x0; xi < xt; xi++)\n{\nint xr = xi - d;\nif(d < cth || xr < 0)\nval += cdata_weight * cmax_data_term;\nelse\n{\n__global uchar* lle = cleft  + yi * cimg_step + xi * channels;\n__global uchar* lri = cright + yi * cimg_step + xr * channels;\nif(channels == 1)\nval += compute_1(lle, lri, cdata_weight, cmax_data_term);\nelse\nval += compute_3(lle, lri, cdata_weight, cmax_data_term);\n}\n}\n}\ndata_cost[cdisp_step1 * d] = val;\n}\n}\n}\n__kernel void init_data_cost_reduce_0(__global short *ctemp, __global uchar *cleft, __global uchar *cright,\n__local float *smem, int level, int rows, int cols, int h, int winsz, int channels,\nint cndisp,int cimg_step, float cdata_weight, float cmax_data_term, int cth,\nint cdisp_step1, int cmsg_step1)\n{\nint x_out = get_group_id(0);\nint y_out = get_group_id(1) % h;\nint d = (get_group_id(1) / h ) * get_local_size(2) + get_local_id(2);\nint tid = get_local_id(0);\nif (d < cndisp)\n{\nint x0 = x_out << level;\nint y0 = y_out << level;\nint len = min(y0 + winsz, rows) - y0;\nfloat val = 0.0f;\nif (x0 + tid < cols)\n{\nif (x0 + tid - d < 0 || d < cth)\nval = cdata_weight * cmax_data_term * len;\nelse\n{\n__global uchar* lle =  cleft + y0 * cimg_step + channels * (x0 + tid    );\n__global uchar* lri = cright + y0 * cimg_step + channels * (x0 + tid - d);\nfor(int y = 0; y < len; ++y)\n{\nif(channels == 1)\nval += compute_1(lle, lri, cdata_weight, cmax_data_term);\nelse\nval += compute_3(lle, lri, cdata_weight, cmax_data_term);\nlle += cimg_step;\nlri += cimg_step;\n}\n}\n}\n__local float* dline = smem + winsz * get_local_id(2);\ndline[tid] = val;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local float* dline = smem + winsz * get_local_id(2);\nif (winsz >= 256)\n{\nif (tid < 128)\ndline[tid] += dline[tid + 128];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local float* dline = smem + winsz * get_local_id(2);\nif (winsz >= 128)\n{\nif (tid <  64)\ndline[tid] += dline[tid + 64];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 64)\nif (tid < 32)\nvdline[tid] += vdline[tid + 32];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 32)\nif (tid < 16)\nvdline[tid] += vdline[tid + 16];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d<cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 16)\nif (tid <  8)\nvdline[tid] += vdline[tid + 8];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d<cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 8)\nif (tid <  4)\nvdline[tid] += vdline[tid + 4];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d<cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 4)\nif (tid <  2)\nvdline[tid] += vdline[tid + 2];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d<cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 2)\nif (tid <  1)\nvdline[tid] += vdline[tid + 1];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local float* dline = smem + winsz * get_local_id(2);\n__global short* data_cost = ctemp + y_out * cmsg_step1 + x_out;\nif (tid == 0)\ndata_cost[cdisp_step1 * d] = convert_short_sat_rte(dline[0]);\n}\n}\n__kernel void init_data_cost_reduce_1(__global float *ctemp, __global uchar *cleft, __global uchar *cright,\n__local float *smem, int level, int rows, int cols, int h, int winsz, int channels,\nint cndisp,int cimg_step, float cdata_weight, float cmax_data_term, int cth,\nint cdisp_step1, int cmsg_step1)\n{\nint x_out = get_group_id(0);\nint y_out = get_group_id(1) % h;\nint d = (get_group_id(1) / h ) * get_local_size(2) + get_local_id(2);\nint tid = get_local_id(0);\nif (d < cndisp)\n{\nint x0 = x_out << level;\nint y0 = y_out << level;\nint len = min(y0 + winsz, rows) - y0;\nfloat val = 0.0f;\nif (x0 + tid < cols)\n{\nif (x0 + tid - d < 0 || d < cth)\nval = cdata_weight * cmax_data_term * len;\nelse\n{\n__global uchar* lle =  cleft + y0 * cimg_step + channels * (x0 + tid    );\n__global uchar* lri = cright + y0 * cimg_step + channels * (x0 + tid - d);\nfor(int y = 0; y < len; ++y)\n{\nif(channels == 1)\nval += compute_1(lle, lri, cdata_weight, cmax_data_term);\nelse\nval += compute_3(lle, lri, cdata_weight, cmax_data_term);\nlle += cimg_step;\nlri += cimg_step;\n}\n}\n}\n__local float* dline = smem + winsz * get_local_id(2);\ndline[tid] = val;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local float* dline = smem + winsz * get_local_id(2);\nif (winsz >= 256)\nif (tid < 128)\ndline[tid] += dline[tid + 128];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local float* dline = smem + winsz * get_local_id(2);\nif (winsz >= 128)\nif (tid < 64)\ndline[tid] += dline[tid + 64];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 64)\nif (tid < 32)\nvdline[tid] += vdline[tid + 32];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 32)\nif (tid < 16)\nvdline[tid] += vdline[tid + 16];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 16)\nif (tid < 8)\nvdline[tid] += vdline[tid + 8];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 8)\nif (tid < 4)\nvdline[tid] += vdline[tid + 4];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 4)\nif (tid < 2)\nvdline[tid] += vdline[tid + 2];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 2)\nif (tid < 1)\nvdline[tid] += vdline[tid + 1];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < cndisp)\n{\n__global float *data_cost = ctemp + y_out * cmsg_step1 + x_out;\n__local float* dline = smem + winsz * get_local_id(2);\nif (tid == 0)\ndata_cost[cdisp_step1 * d] =  dline[0];\n}\n}\n__kernel void compute_data_cost_0(__global const short *selected_disp_pyr, __global short *data_cost_,\n__global uchar *cleft, __global uchar *cright,\nint h, int w, int level, int nr_plane, int channels,\nint cmsg_step1, int cmsg_step2, int cdisp_step1, int cdisp_step2, float cdata_weight,\nfloat cmax_data_term, int cimg_step, int cth)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\nint y0 = y << level;\nint yt = (y + 1) << level;\nint x0 = x << level;\nint xt = (x + 1) << level;\n__global const short *selected_disparity = selected_disp_pyr + y/2 * cmsg_step2 + x/2;\n__global       short *data_cost          = data_cost_ + y * cmsg_step1 + x;\nfor(int d = 0; d < nr_plane; d++)\n{\nfloat val = 0.0f;\nfor(int yi = y0; yi < yt; yi++)\n{\nfor(int xi = x0; xi < xt; xi++)\n{\nint sel_disp = selected_disparity[d * cdisp_step2];\nint xr = xi - sel_disp;\nif (xr < 0 || sel_disp < cth)\nval += cdata_weight * cmax_data_term;\nelse\n{\n__global uchar* left_x  = cleft + yi * cimg_step + xi * channels;\n__global uchar* right_x = cright + yi * cimg_step + xr * channels;\nif(channels == 1)\nval += compute_1(left_x, right_x, cdata_weight, cmax_data_term);\nelse\nval += compute_3(left_x, right_x, cdata_weight, cmax_data_term);\n}\n}\n}\ndata_cost[cdisp_step1 * d] = convert_short_sat_rte(val);\n}\n}\n}\n__kernel void compute_data_cost_1(__global const float *selected_disp_pyr, __global float *data_cost_,\n__global uchar *cleft, __global uchar *cright,\nint h, int w, int level, int nr_plane, int channels,\nint cmsg_step1, int cmsg_step2, int cdisp_step1, int cdisp_step2, float cdata_weight,\nfloat cmax_data_term, int cimg_step, int cth)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\nint y0 = y << level;\nint yt = (y + 1) << level;\nint x0 = x << level;\nint xt = (x + 1) << level;\n__global const float *selected_disparity = selected_disp_pyr + y/2 * cmsg_step2 + x/2;\n__global       float *data_cost          = data_cost_ + y * cmsg_step1 + x;\nfor(int d = 0; d < nr_plane; d++)\n{\nfloat val = 0.0f;\nfor(int yi = y0; yi < yt; yi++)\n{\nfor(int xi = x0; xi < xt; xi++)\n{\nint sel_disp = selected_disparity[d * cdisp_step2];\nint xr = xi - sel_disp;\nif (xr < 0 || sel_disp < cth)\nval += cdata_weight * cmax_data_term;\nelse\n{\n__global uchar* left_x  = cleft + yi * cimg_step + xi * channels;\n__global uchar* right_x = cright + yi * cimg_step + xr * channels;\nif(channels == 1)\nval += compute_1(left_x, right_x, cdata_weight, cmax_data_term);\nelse\nval += compute_3(left_x, right_x, cdata_weight, cmax_data_term);\n}\n}\n}\ndata_cost[cdisp_step1 * d] = val;\n}\n}\n}\n__kernel void compute_data_cost_reduce_0(__global const short* selected_disp_pyr, __global short* data_cost_,\n__global uchar *cleft, __global uchar *cright,__local float *smem,\nint level, int rows, int cols, int h, int nr_plane,\nint channels, int winsz,\nint cmsg_step1, int cmsg_step2, int cdisp_step1, int cdisp_step2,\nfloat cdata_weight,  float cmax_data_term, int cimg_step,int cth)\n{\nint x_out = get_group_id(0);\nint y_out = get_group_id(1) % h;\nint d = (get_group_id(1)/ h) * get_local_size(2) + get_local_id(2);\nint tid = get_local_id(0);\n__global const short* selected_disparity = selected_disp_pyr + y_out/2 * cmsg_step2 + x_out/2;\n__global short* data_cost = data_cost_ + y_out * cmsg_step1 + x_out;\nif (d < nr_plane)\n{\nint sel_disp = selected_disparity[d * cdisp_step2];\nint x0 = x_out << level;\nint y0 = y_out << level;\nint len = min(y0 + winsz, rows) - y0;\nfloat val = 0.0f;\nif (x0 + tid < cols)\n{\nif (x0 + tid - sel_disp < 0 || sel_disp < cth)\nval = cdata_weight * cmax_data_term * len;\nelse\n{\n__global uchar* lle =  cleft + y0 * cimg_step + channels * (x0 + tid    );\n__global uchar* lri = cright + y0 * cimg_step + channels * (x0 + tid - sel_disp);\nfor(int y = 0; y < len; ++y)\n{\nif(channels == 1)\nval += compute_1(lle, lri, cdata_weight, cmax_data_term);\nelse\nval += compute_3(lle, lri, cdata_weight, cmax_data_term);\nlle += cimg_step;\nlri += cimg_step;\n}\n}\n}\n__local float* dline = smem + winsz * get_local_id(2);\ndline[tid] = val;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 64)\n{\nif (tid < 32)\nvdline[tid] += vdline[tid + 32];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 32)\n{\nif (tid < 16)\nvdline[tid] += vdline[tid + 16];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 16)\n{\nif (tid < 8)\nvdline[tid] += vdline[tid + 8];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 8)\n{\nif (tid < 4)\nvdline[tid] += vdline[tid + 4];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 4)\n{\nif (tid < 2)\nvdline[tid] += vdline[tid + 2];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 2)\n{\nif (tid < 1)\nvdline[tid] += vdline[tid + 1];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (tid == 0)\ndata_cost[cdisp_step1 * d] = convert_short_sat_rte(vdline[0]);\n}\n}\n__kernel void compute_data_cost_reduce_1(__global const float *selected_disp_pyr, __global float *data_cost_,\n__global uchar *cleft, __global uchar *cright, __local float *smem,\nint level, int rows, int cols, int h, int nr_plane,\nint channels, int winsz,\nint cmsg_step1, int cmsg_step2, int cdisp_step1,int cdisp_step2, float cdata_weight,\nfloat cmax_data_term, int cimg_step, int cth)\n{\nint x_out = get_group_id(0);\nint y_out = get_group_id(1) % h;\nint d = (get_group_id(1)/ h) * get_local_size(2) + get_local_id(2);\nint tid = get_local_id(0);\n__global const float *selected_disparity = selected_disp_pyr + y_out/2 * cmsg_step2 + x_out/2;\n__global float *data_cost = data_cost_ + y_out * cmsg_step1 + x_out;\nif (d < nr_plane)\n{\nint sel_disp = selected_disparity[d * cdisp_step2];\nint x0 = x_out << level;\nint y0 = y_out << level;\nint len = min(y0 + winsz, rows) - y0;\nfloat val = 0.0f;\nif (x0 + tid < cols)\n{\nif (x0 + tid - sel_disp < 0 || sel_disp < cth)\nval = cdata_weight * cmax_data_term * len;\nelse\n{\n__global uchar* lle =  cleft + y0 * cimg_step + channels * (x0 + tid    );\n__global uchar* lri = cright + y0 * cimg_step + channels * (x0 + tid - sel_disp);\nfor(int y = 0; y < len; ++y)\n{\nif(channels == 1)\nval += compute_1(lle, lri, cdata_weight, cmax_data_term);\nelse\nval += compute_3(lle, lri, cdata_weight, cmax_data_term);\nlle += cimg_step;\nlri += cimg_step;\n}\n}\n}\n__local float* dline = smem + winsz * get_local_id(2);\ndline[tid] = val;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 64)\n{\nif (tid < 32)\nvdline[tid] += vdline[tid + 32];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 32)\n{\nif (tid < 16)\nvdline[tid] += vdline[tid + 16];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >= 16)\n{\nif (tid <  8)\nvdline[tid] += vdline[tid + 8];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >=  8)\n{\nif (tid <  4)\nvdline[tid] += vdline[tid + 4];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >=  4)\n{\nif (tid <  2)\nvdline[tid] += vdline[tid + 2];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (winsz >=  2)\n{\nif (tid <  1)\nvdline[tid] += vdline[tid + 1];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(d < nr_plane)\n{\n__local volatile float* vdline = smem + winsz * get_local_id(2);\nif (tid == 0)\ndata_cost[cdisp_step1 * d] = vdline[0];\n}\n}\nvoid get_first_k_element_increase_0(__global short* u_new, __global short *d_new, __global short *l_new,\n__global short *r_new, __global const short *u_cur, __global const short *d_cur,\n__global const short *l_cur, __global const short *r_cur,\n__global short *data_cost_selected, __global short *disparity_selected_new,\n__global short *data_cost_new, __global const short* data_cost_cur,\n__global const short *disparity_selected_cur,\nint nr_plane, int nr_plane2,\nint cdisp_step1, int cdisp_step2)\n{\nfor(int i = 0; i < nr_plane; i++)\n{\nshort minimum = SHRT_MAX;\nint id = 0;\nfor(int j = 0; j < nr_plane2; j++)\n{\nshort cur = data_cost_new[j * cdisp_step1];\nif(cur < minimum)\n{\nminimum = cur;\nid = j;\n}\n}\ndata_cost_selected[i * cdisp_step1] = data_cost_cur[id * cdisp_step1];\ndisparity_selected_new[i * cdisp_step1] = disparity_selected_cur[id * cdisp_step2];\nu_new[i * cdisp_step1] = u_cur[id * cdisp_step2];\nd_new[i * cdisp_step1] = d_cur[id * cdisp_step2];\nl_new[i * cdisp_step1] = l_cur[id * cdisp_step2];\nr_new[i * cdisp_step1] = r_cur[id * cdisp_step2];\ndata_cost_new[id * cdisp_step1] = SHRT_MAX;\n}\n}\n__kernel void init_message_0(__global short *u_new_, __global short *d_new_, __global short *l_new_,\n__global short *r_new_, __global  short *u_cur_, __global const short *d_cur_,\n__global const short *l_cur_, __global const short *r_cur_, __global short *ctemp,\n__global short *selected_disp_pyr_new, __global const short *selected_disp_pyr_cur,\n__global short *data_cost_selected_, __global const short *data_cost_,\nint h, int w, int nr_plane, int h2, int w2, int nr_plane2,\nint cdisp_step1, int cdisp_step2, int cmsg_step1, int cmsg_step2)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < h && x < w)\n{\n__global const short *u_cur = u_cur_ + min(h2-1, y/2 + 1) * cmsg_step2 + x/2;\n__global const short *d_cur = d_cur_ + max(0, y/2 - 1)    * cmsg_step2 + x/2;\n__global const short *l_cur = l_cur_ + y/2                * cmsg_step2 + min(w2-1, x/2 + 1);\n__global const short *r_cur = r_cur_ + y/2                * cmsg_step2 + max(0, x/2 - 1);\n__global short *data_cost_new = ctemp + y * cmsg_step1 + x;\n__global const short *disparity_selected_cur = selected_disp_pyr_cur + y/2 * cmsg_step2 + x/2;\n__global const short *data_cost = data_cost_ + y * cmsg_step1 + x;\nfor(int d = 0; d < nr_plane2; d++)\n{\nint idx2 = d * cdisp_step2;\nshort val  = data_cost[d * cdisp_step1] + u_cur[idx2] + d_cur[idx2] + l_cur[idx2] + r_cur[idx2];\ndata_cost_new[d * cdisp_step1] = val;\n}\n__global short *data_cost_selected = data_cost_selected_ + y * cmsg_step1 + x;\n__global short *disparity_selected_new = selected_disp_pyr_new + y * cmsg_step1 + x;\n__global short *u_new = u_new_ + y * cmsg_step1 + x;\n__global short *d_new = d_new_ + y * cmsg_step1 + x;\n__global short *l_new = l_new_ + y * cmsg_step1 + x;\n__global short *r_new = r_new_ + y * cmsg_step1 + x;\nu_cur = u_cur_ + y/2 * cmsg_step2 + x/2;\nd_cur = d_cur_ + y/2 * cmsg_step2 + x/2;\nl_cur = l_cur_ + y/2 * cmsg_step2 + x/2;\nr_cur = r_cur_ + y/2 * cmsg_step2 + x/2;\nget_first_k_element_increase_0(u_new, d_new, l_new, r_new, u_cur, d_cur, l_cur, r_cur,\ndata_cost_selected, disparity_selected_new, data_cost_new,\ndata_cost, disparity_selected_cur, nr_plane, nr_plane2,\ncdisp_step1, cdisp_step2);\n}\n}\n__kernel void init_message_1(__global float *u_new_, __global float *d_new_, __global float *l_new_,\n__global float *r_new_, __global const float *u_cur_, __global const float *d_cur_,\n__global const float *l_cur_, __global const float *r_cur_, __global float *ctemp,\n__global float *selected_disp_pyr_new, __global const float *selected_disp_pyr_cur,\n__global float *data_cost_selected_, __global const float *data_cost_,\nint h, int w, int nr_plane, int h2, int w2, int nr_plane2,\nint cdisp_step1, int cdisp_step2, int cmsg_step1, int cmsg_step2)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\n__global const float *u_cur = u_cur_ + min(h2-1, y/2 + 1) * cmsg_step2 + x/2;\n__global const float *d_cur = d_cur_ + max(0, y/2 - 1)    * cmsg_step2 + x/2;\n__global const float *l_cur = l_cur_ + y/2                * cmsg_step2 + min(w2-1, x/2 + 1);\n__global const float *r_cur = r_cur_ + y/2                * cmsg_step2 + max(0, x/2 - 1);\n__global float *data_cost_new = ctemp + y * cmsg_step1 + x;\n__global const float *disparity_selected_cur = selected_disp_pyr_cur + y/2 * cmsg_step2 + x/2;\n__global const float *data_cost = data_cost_ + y * cmsg_step1 + x;\nif (y < h && x < w)\n{\nfor(int d = 0; d < nr_plane2; d++)\n{\nint idx2 = d * cdisp_step2;\nfloat val  = data_cost[d * cdisp_step1] + u_cur[idx2] + d_cur[idx2] + l_cur[idx2] + r_cur[idx2];\ndata_cost_new[d * cdisp_step1] = val;\n}\n}\n__global float *data_cost_selected = data_cost_selected_ + y * cmsg_step1 + x;\n__global float *disparity_selected_new = selected_disp_pyr_new + y * cmsg_step1 + x;\n__global float *u_new = u_new_ + y * cmsg_step1 + x;\n__global float *d_new = d_new_ + y * cmsg_step1 + x;\n__global float *l_new = l_new_ + y * cmsg_step1 + x;\n__global float *r_new = r_new_ + y * cmsg_step1 + x;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(y < h && x < w)\n{\nu_cur = u_cur_ + y/2 * cmsg_step2 + x/2;\nd_cur = d_cur_ + y/2 * cmsg_step2 + x/2;\nl_cur = l_cur_ + y/2 * cmsg_step2 + x/2;\nr_cur = r_cur_ + y/2 * cmsg_step2 + x/2;\nfor(int i = 0; i < nr_plane; i++)\n{\nfloat minimum = FLT_MAX;\nint id = 0;\nfor(int j = 0; j < nr_plane2; j++)\n{\nfloat cur = data_cost_new[j * cdisp_step1];\nif(cur < minimum)\n{\nminimum = cur;\nid = j;\n}\n}\ndata_cost_selected[i * cdisp_step1] = data_cost[id * cdisp_step1];\ndisparity_selected_new[i * cdisp_step1] = disparity_selected_cur[id * cdisp_step2];\nu_new[i * cdisp_step1] = u_cur[id * cdisp_step2];\nd_new[i * cdisp_step1] = d_cur[id * cdisp_step2];\nl_new[i * cdisp_step1] = l_cur[id * cdisp_step2];\nr_new[i * cdisp_step1] = r_cur[id * cdisp_step2];\ndata_cost_new[id * cdisp_step1] = FLT_MAX;\n}\n}\n}\nvoid message_per_pixel_0(__global const short *data, __global short *msg_dst, __global const short *msg1,\n__global const short *msg2, __global const short *msg3,\n__global const short *dst_disp, __global const short *src_disp,\nint nr_plane, __global short *temp,\nfloat cmax_disc_term, int cdisp_step1, float cdisc_single_jump)\n{\nshort minimum = SHRT_MAX;\nfor(int d = 0; d < nr_plane; d++)\n{\nint idx = d * cdisp_step1;\nshort val  = data[idx] + msg1[idx] + msg2[idx] + msg3[idx];\nif(val < minimum)\nminimum = val;\nmsg_dst[idx] = val;\n}\nfloat sum = 0;\nfor(int d = 0; d < nr_plane; d++)\n{\nfloat cost_min = minimum + cmax_disc_term;\nshort src_disp_reg = src_disp[d * cdisp_step1];\nfor(int d2 = 0; d2 < nr_plane; d2++)\ncost_min = fmin(cost_min, (msg_dst[d2 * cdisp_step1] +\ncdisc_single_jump * abs(dst_disp[d2 * cdisp_step1] - src_disp_reg)));\ntemp[d * cdisp_step1] = convert_short_sat_rte(cost_min);\nsum += cost_min;\n}\nsum /= nr_plane;\nfor(int d = 0; d < nr_plane; d++)\nmsg_dst[d * cdisp_step1] = convert_short_sat_rte(temp[d * cdisp_step1] - sum);\n}\nvoid message_per_pixel_1(__global const float *data, __global float *msg_dst, __global const float *msg1,\n__global const float *msg2, __global const float *msg3,\n__global const float *dst_disp, __global const float *src_disp,\nint nr_plane, __global float *temp,\nfloat cmax_disc_term, int cdisp_step1, float cdisc_single_jump)\n{\nfloat minimum = FLT_MAX;\nfor(int d = 0; d < nr_plane; d++)\n{\nint idx = d * cdisp_step1;\nfloat val  = data[idx] + msg1[idx] + msg2[idx] + msg3[idx];\nif(val < minimum)\nminimum = val;\nmsg_dst[idx] = val;\n}\nfloat sum = 0;\nfor(int d = 0; d < nr_plane; d++)\n{\nfloat cost_min = minimum + cmax_disc_term;\nfloat src_disp_reg = src_disp[d * cdisp_step1];\nfor(int d2 = 0; d2 < nr_plane; d2++)\ncost_min = fmin(cost_min, (msg_dst[d2 * cdisp_step1] +\ncdisc_single_jump * fabs(dst_disp[d2 * cdisp_step1] - src_disp_reg)));\ntemp[d * cdisp_step1] = cost_min;\nsum += cost_min;\n}\nsum /= nr_plane;\nfor(int d = 0; d < nr_plane; d++)\nmsg_dst[d * cdisp_step1] = temp[d * cdisp_step1] - sum;\n}\n__kernel void compute_message_0(__global short *u_, __global short *d_, __global short *l_, __global short *r_,\n__global const short *data_cost_selected, __global const short *selected_disp_pyr_cur,\n__global short *ctemp, int h, int w, int nr_plane, int i,\nfloat cmax_disc_term, int cdisp_step1, int cmsg_step1, float cdisc_single_jump)\n{\nint y = get_global_id(1);\nint x = ((get_global_id(0)) << 1) + ((y + i) & 1);\nif (y > 0 && y < h - 1 && x > 0 && x < w - 1)\n{\n__global const short *data = data_cost_selected + y * cmsg_step1 + x;\n__global short *u = u_ + y * cmsg_step1 + x;\n__global short *d = d_ + y * cmsg_step1 + x;\n__global short *l = l_ + y * cmsg_step1 + x;\n__global short *r = r_ + y * cmsg_step1 + x;\n__global const short *disp = selected_disp_pyr_cur + y * cmsg_step1 + x;\n__global short *temp = ctemp + y * cmsg_step1 + x;\nmessage_per_pixel_0(data, u, r - 1, u + cmsg_step1, l + 1, disp, disp - cmsg_step1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\nmessage_per_pixel_0(data, d, d - cmsg_step1, r - 1, l + 1, disp, disp + cmsg_step1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\nmessage_per_pixel_0(data, l, u + cmsg_step1, d - cmsg_step1, l + 1, disp, disp - 1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\nmessage_per_pixel_0(data, r, u + cmsg_step1, d - cmsg_step1, r - 1, disp, disp + 1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\n}\n}\n__kernel void compute_message_1(__global float *u_, __global float *d_, __global float *l_, __global float *r_,\n__global const float *data_cost_selected, __global const float *selected_disp_pyr_cur,\n__global float *ctemp, int h, int w, int nr_plane, int i,\nfloat cmax_disc_term, int cdisp_step1, int cmsg_step1, float cdisc_single_jump)\n{\nint y = get_global_id(1);\nint x = ((get_global_id(0)) << 1) + ((y + i) & 1);\nif (y > 0 && y < h - 1 && x > 0 && x < w - 1)\n{\n__global const float *data = data_cost_selected + y * cmsg_step1 + x;\n__global float *u = u_ + y * cmsg_step1 + x;\n__global float *d = d_ + y * cmsg_step1 + x;\n__global float *l = l_ + y * cmsg_step1 + x;\n__global float *r = r_ + y * cmsg_step1 + x;\n__global const float *disp = selected_disp_pyr_cur + y * cmsg_step1 + x;\n__global float *temp = ctemp + y * cmsg_step1 + x;\nmessage_per_pixel_1(data, u, r - 1, u + cmsg_step1, l + 1, disp, disp - cmsg_step1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\nmessage_per_pixel_1(data, d, d - cmsg_step1, r - 1, l + 1, disp, disp + cmsg_step1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\nmessage_per_pixel_1(data, l, u + cmsg_step1, d - cmsg_step1, l + 1, disp, disp - 1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\nmessage_per_pixel_1(data, r, u + cmsg_step1, d - cmsg_step1, r - 1, disp, disp + 1, nr_plane, temp,\ncmax_disc_term, cdisp_step1, cdisc_single_jump);\n}\n}\n__kernel void compute_disp_0(__global const short *u_, __global const short *d_, __global const short *l_,\n__global const short *r_, __global const short * data_cost_selected,\n__global const short *disp_selected_pyr,\n__global short* disp,\nint res_step, int cols, int rows, int nr_plane,\nint cmsg_step1, int cdisp_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y > 0 && y < rows - 1 && x > 0 && x < cols - 1)\n{\n__global const short *data = data_cost_selected + y * cmsg_step1 + x;\n__global const short *disp_selected = disp_selected_pyr + y * cmsg_step1 + x;\n__global const short *u = u_ + (y+1) * cmsg_step1 + (x+0);\n__global const short *d = d_ + (y-1) * cmsg_step1 + (x+0);\n__global const short *l = l_ + (y+0) * cmsg_step1 + (x+1);\n__global const short *r = r_ + (y+0) * cmsg_step1 + (x-1);\nshort best = 0;\nshort best_val = SHRT_MAX;\nfor (int i = 0; i < nr_plane; ++i)\n{\nint idx = i * cdisp_step1;\nshort val = data[idx]+ u[idx] + d[idx] + l[idx] + r[idx];\nif (val < best_val)\n{\nbest_val = val;\nbest = disp_selected[idx];\n}\n}\ndisp[res_step * y + x] = best;\n}\n}\n__kernel void compute_disp_1(__global const float *u_, __global const float *d_, __global const float *l_,\n__global const float *r_, __global const float *data_cost_selected,\n__global const float *disp_selected_pyr,\n__global short *disp,\nint res_step, int cols, int rows, int nr_plane,\nint cmsg_step1, int cdisp_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y > 0 && y < rows - 1 && x > 0 && x < cols - 1)\n{\n__global const float *data = data_cost_selected + y * cmsg_step1 + x;\n__global const float *disp_selected = disp_selected_pyr + y * cmsg_step1 + x;\n__global const float *u = u_ + (y+1) * cmsg_step1 + (x+0);\n__global const float *d = d_ + (y-1) * cmsg_step1 + (x+0);\n__global const float *l = l_ + (y+0) * cmsg_step1 + (x+1);\n__global const float *r = r_ + (y+0) * cmsg_step1 + (x-1);\nshort best = 0;\nshort best_val = SHRT_MAX;\nfor (int i = 0; i < nr_plane; ++i)\n{\nint idx = i * cdisp_step1;\nfloat val = data[idx]+ u[idx] + d[idx] + l[idx] + r[idx];\nif (val < best_val)\n{\nbest_val = val;\nbest = convert_short_sat_rte(disp_selected[idx]);\n}\n}\ndisp[res_step * y + x] = best;\n}\n}\n", "d203bd312e7d4f9915cdec480d0c54e1", "stereobp", "#if defined (DOUBLE_SUPPORT)\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#ifdef T_FLOAT\n#define T float\n#define T4 float4\n#else\n#define T short\n#define T4 short4\n#endif\nT saturate_cast(float v){\n#ifdef T_SHORT\nreturn convert_short_sat_rte(v);\n#else\nreturn v;\n#endif\n}\nT4 saturate_cast4(float4 v){\n#ifdef T_SHORT\nreturn convert_short4_sat_rte(v);\n#else\nreturn v;\n#endif\n}\n#define FLOAT_MAX 3.402823466e+38f\ntypedef struct\n{\nint   cndisp;\nfloat cmax_data_term;\nfloat cdata_weight;\nfloat cmax_disc_term;\nfloat cdisc_single_jump;\n}con_srtuct_t;\nfloat pix_diff_1(const uchar4 l, __global const uchar *rs)\n{\nreturn abs((int)(l.x) - *rs);\n}\nfloat pix_diff_4(const uchar4 l, __global const uchar *rs)\n{\nuchar4 r;\nr = *((__global uchar4 *)rs);\nconst float tr = 0.299f;\nconst float tg = 0.587f;\nconst float tb = 0.114f;\nfloat val;\nval  = tb * abs((int)l.x - r.x);\nval += tg * abs((int)l.y - r.y);\nval += tr * abs((int)l.z - r.z);\nreturn val;\n}\nfloat pix_diff_3(const uchar4 l, __global const uchar *rs)\n{\nreturn pix_diff_4(l, rs);\n}\n#ifndef CN\n#define CN 4\n#endif\n#ifndef CNDISP\n#define CNDISP 64\n#endif\n#define CAT(X,Y) X##Y\n#define CAT2(X,Y) CAT(X,Y)\n#define PIX_DIFF CAT2(pix_diff_, CN)\n__kernel void comp_data(__global uchar *left,  int left_rows,  int left_cols,  int left_step,\n__global uchar *right, int right_step,\n__global T *data, int data_step,\n__constant con_srtuct_t *con_st)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y > 0 && y < (left_rows - 1) && x > 0 && x < (left_cols - 1))\n{\ndata_step /= sizeof(T);\nconst __global uchar* ls = left  + y * left_step  + x * CN;\nconst __global uchar* rs = right + y * right_step + x * CN;\n__global T *ds = data + y * data_step + x;\nconst unsigned int disp_step = data_step * left_rows;\nconst float weightXterm = con_st -> cdata_weight * con_st -> cmax_data_term;\nconst uchar4 ls_data = vload4(0, ls);\nfor (int disp = 0; disp < con_st -> cndisp; disp++)\n{\nif (x - disp >= 1)\n{\nfloat val = 0;\nval = PIX_DIFF(ls_data, rs - disp * CN);\nds[disp * disp_step] =  saturate_cast(fmin(con_st -> cdata_weight * val, weightXterm));\n}\nelse\n{\nds[disp * disp_step] =  saturate_cast(weightXterm);\n}\n}\n}\n}\n__kernel void data_step_down(__global T *src, int src_rows,\n__global T *dst, int dst_rows, int dst_cols,\nint src_step, int dst_step,\nint cndisp)\n{\nconst int x = get_global_id(0);\nconst int y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nsrc_step /= sizeof(T);\ndst_step /= sizeof(T);\nint4 coor_step = (int4)(src_rows * src_step);\nint4 coor = (int4)(min(2*y+0, src_rows-1) * src_step + 2*x+0,\nmin(2*y+1, src_rows-1) * src_step + 2*x+0,\nmin(2*y+0, src_rows-1) * src_step + 2*x+1,\nmin(2*y+1, src_rows-1) * src_step + 2*x+1);\nfor (int d = 0; d < cndisp; ++d)\n{\nfloat dst_reg;\ndst_reg  = src[coor.x];\ndst_reg += src[coor.y];\ndst_reg += src[coor.z];\ndst_reg += src[coor.w];\ncoor += coor_step;\ndst[(d * dst_rows + y) * dst_step + x] = saturate_cast(dst_reg);\n}\n}\n}\n__kernel void level_up_message(__global T *src, int src_rows, int src_step,\n__global T *dst, int dst_rows, int dst_cols, int dst_step,\nint cndisp)\n{\nconst int x = get_global_id(0);\nconst int y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nsrc_step /= sizeof(T);\ndst_step /= sizeof(T);\nconst int dst_disp_step = dst_step * dst_rows;\nconst int src_disp_step = src_step * src_rows;\n__global T       *dstr = dst + y * dst_step + x;\n__global const T *srcr = src + (y / 2 * src_step) + (x / 2);\nfor (int d = 0; d < cndisp; ++d)\ndstr[d * dst_disp_step] = srcr[d * src_disp_step];\n}\n}\nvoid message(__global T *us_, __global T *ds_, __global T *ls_, __global T *rs_,\nconst __global T *dt,\nint u_step, int msg_disp_step, int data_disp_step,\nfloat4 cmax_disc_term, float4 cdisc_single_jump)\n{\n__global T *us = us_ + u_step;\n__global T *ds = ds_ - u_step;\n__global T *ls = ls_ + 1;\n__global T *rs = rs_ - 1;\nfloat4 minimum = (float4)(FLOAT_MAX);\nT4 t_dst[CNDISP];\nfloat4 dst_reg;\nfloat4 prev;\nfloat4 cur;\nT t_us = us[0];\nT t_ds = ds[0];\nT t_ls = ls[0];\nT t_rs = rs[0];\nT t_dt = dt[0];\nprev = (float4)(t_us + t_ls + t_rs + t_dt,\nt_ds + t_ls + t_rs + t_dt,\nt_us + t_ds + t_rs + t_dt,\nt_us + t_ds + t_ls + t_dt);\nminimum = min(prev, minimum);\nt_dst[0] = saturate_cast4(prev);\nfor(int i = 1, idx = msg_disp_step; i < CNDISP; ++i, idx+=msg_disp_step)\n{\nt_us = us[idx];\nt_ds = ds[idx];\nt_ls = ls[idx];\nt_rs = rs[idx];\nt_dt = dt[data_disp_step * i];\ndst_reg = (float4)(t_us + t_ls + t_rs + t_dt,\nt_ds + t_ls + t_rs + t_dt,\nt_us + t_ds + t_rs + t_dt,\nt_us + t_ds + t_ls + t_dt);\nminimum = min(dst_reg, minimum);\nprev += cdisc_single_jump;\nprev = min(prev, dst_reg);\nt_dst[i] = saturate_cast4(prev);\n}\nminimum += cmax_disc_term;\nfloat4 sum = (float4)(0);\nprev = convert_float4(t_dst[CNDISP - 1]);\nfor (int disp = CNDISP - 2; disp >= 0; disp--)\n{\nprev += cdisc_single_jump;\ncur = convert_float4(t_dst[disp]);\nprev = min(prev, cur);\ncur = min(prev, minimum);\nsum += cur;\nt_dst[disp] = saturate_cast4(cur);\n}\ndst_reg = convert_float4(t_dst[CNDISP - 1]);\ndst_reg = min(dst_reg, minimum);\nt_dst[CNDISP - 1] = saturate_cast4(dst_reg);\nsum += dst_reg;\nsum /= (float4)(CNDISP);\n#pragma unroll\nfor(int i = 0, idx = 0; i < CNDISP; ++i, idx+=msg_disp_step)\n{\nT4 dst = t_dst[i];\nus_[idx] = dst.x - sum.x;\nds_[idx] = dst.y - sum.y;\nrs_[idx] = dst.z - sum.z;\nls_[idx] = dst.w - sum.w;\n}\n}\n__kernel void one_iteration(__global T *u,    int u_step,\n__global T *data, int data_step,\n__global T *d,    __global T *l, __global T *r,\nint t, int cols, int rows,\nfloat cmax_disc_term, float cdisc_single_jump)\n{\nconst int y = get_global_id(1);\nconst int x = ((get_global_id(0)) << 1) + ((y + t) & 1);\nif ((y > 0) && (y < rows - 1) && (x > 0) && (x < cols - 1))\n{\nu_step    /= sizeof(T);\ndata_step /= sizeof(T);\n__global T *us = u + y * u_step + x;\n__global T *ds = d + y * u_step + x;\n__global T *ls = l + y * u_step + x;\n__global T *rs = r + y * u_step + x;\nconst __global  T *dt = data + y * data_step + x;\nint msg_disp_step = u_step * rows;\nint data_disp_step = data_step * rows;\nmessage(us, ds, ls, rs, dt,\nu_step, msg_disp_step, data_disp_step,\n(float4)(cmax_disc_term), (float4)(cdisc_single_jump));\n}\n}\n__kernel void output(const __global T *u, int u_step,\nconst __global T *d, const __global T *l,\nconst __global T *r, const __global T *data,\n__global T *disp, int disp_rows, int disp_cols, int disp_step,\nint cndisp)\n{\nconst int x = get_global_id(0);\nconst int y = get_global_id(1);\nif (y > 0 && y < disp_rows - 1 && x > 0 && x < disp_cols - 1)\n{\nu_step    /= sizeof(T);\ndisp_step /= sizeof(T);\nconst __global T *us = u + (y + 1) * u_step + x;\nconst __global T *ds = d + (y - 1) * u_step + x;\nconst __global T *ls = l + y * u_step + (x + 1);\nconst __global T *rs = r + y * u_step + (x - 1);\nconst __global T *dt = data + y * u_step + x;\nint disp_steps = disp_rows * u_step;\nint best = 0;\nfloat best_val = FLOAT_MAX;\nfor (int d = 0; d < cndisp; ++d)\n{\nfloat val;\nval  = us[d * disp_steps];\nval += ds[d * disp_steps];\nval += ls[d * disp_steps];\nval += rs[d * disp_steps];\nval += dt[d * disp_steps];\nif (val < best_val)\n{\nbest_val = val;\nbest = d;\n}\n}\n(disp + y * disp_step)[x] = convert_short_sat(best);\n}\n}\n", "c1f26bdbf3637f3bf83d2d9b7adc3c2b", "stereobm", "#define ROWSperTHREAD 21\n#define BLOCK_W       128\n#define N_DISPARITIES 8\n#define STEREO_MIND 0\n#define STEREO_DISP_STEP N_DISPARITIES\n#ifndef radius\n#define radius 64\n#endif\nunsigned int CalcSSD(__local unsigned int *col_ssd)\n{\nunsigned int cache = col_ssd[0];\n#pragma unroll\nfor(int i = 1; i <= (radius << 1); i++)\ncache += col_ssd[i];\nreturn cache;\n}\nuint2 MinSSD(__local unsigned int *col_ssd)\n{\nunsigned int ssd[N_DISPARITIES];\nconst int win_size = (radius << 1);\nssd[0] = CalcSSD(col_ssd + 0 * (BLOCK_W + win_size));\nssd[1] = CalcSSD(col_ssd + 1 * (BLOCK_W + win_size));\nssd[2] = CalcSSD(col_ssd + 2 * (BLOCK_W + win_size));\nssd[3] = CalcSSD(col_ssd + 3 * (BLOCK_W + win_size));\nssd[4] = CalcSSD(col_ssd + 4 * (BLOCK_W + win_size));\nssd[5] = CalcSSD(col_ssd + 5 * (BLOCK_W + win_size));\nssd[6] = CalcSSD(col_ssd + 6 * (BLOCK_W + win_size));\nssd[7] = CalcSSD(col_ssd + 7 * (BLOCK_W + win_size));\nunsigned int mssd = min(min(min(ssd[0], ssd[1]), min(ssd[4], ssd[5])), min(min(ssd[2], ssd[3]), min(ssd[6], ssd[7])));\nint bestIdx = 0;\nfor (int i = 0; i < N_DISPARITIES; i++)\n{\nif (mssd == ssd[i])\nbestIdx = i;\n}\nreturn (uint2)(mssd, bestIdx);\n}\nvoid StepDown(int idx1, int idx2, __global unsigned char* imageL,\n__global unsigned char* imageR, int d,   __local unsigned int *col_ssd)\n{\nuint8 imgR1 = convert_uint8(vload8(0, imageR + (idx1 - d - 7)));\nuint8 imgR2 = convert_uint8(vload8(0, imageR + (idx2 - d - 7)));\nuint8 diff1 = (uint8)(imageL[idx1]) - imgR1;\nuint8 diff2 = (uint8)(imageL[idx2]) - imgR2;\nuint8 res = diff2 * diff2 - diff1 * diff1;\nconst int win_size = (radius << 1);\ncol_ssd[0 * (BLOCK_W + win_size)] += res.s7;\ncol_ssd[1 * (BLOCK_W + win_size)] += res.s6;\ncol_ssd[2 * (BLOCK_W + win_size)] += res.s5;\ncol_ssd[3 * (BLOCK_W + win_size)] += res.s4;\ncol_ssd[4 * (BLOCK_W + win_size)] += res.s3;\ncol_ssd[5 * (BLOCK_W + win_size)] += res.s2;\ncol_ssd[6 * (BLOCK_W + win_size)] += res.s1;\ncol_ssd[7 * (BLOCK_W + win_size)] += res.s0;\n}\nvoid InitColSSD(int x_tex, int y_tex, int im_pitch, __global unsigned char* imageL,\n__global unsigned char* imageR, int d,\n__local unsigned int *col_ssd)\n{\nuint8 leftPixel1;\nuint8 diffa = 0;\nint idx = y_tex * im_pitch + x_tex;\nconst int win_size = (radius << 1);\nfor(int i = 0; i < (win_size + 1); i++)\n{\nleftPixel1 = (uint8)(imageL[idx]);\nuint8 imgR = convert_uint8(vload8(0, imageR + (idx - d - 7)));\nuint8 res = leftPixel1 - imgR;\ndiffa += res * res;\nidx += im_pitch;\n}\ncol_ssd[0 * (BLOCK_W + win_size)] = diffa.s7;\ncol_ssd[1 * (BLOCK_W + win_size)] = diffa.s6;\ncol_ssd[2 * (BLOCK_W + win_size)] = diffa.s5;\ncol_ssd[3 * (BLOCK_W + win_size)] = diffa.s4;\ncol_ssd[4 * (BLOCK_W + win_size)] = diffa.s3;\ncol_ssd[5 * (BLOCK_W + win_size)] = diffa.s2;\ncol_ssd[6 * (BLOCK_W + win_size)] = diffa.s1;\ncol_ssd[7 * (BLOCK_W + win_size)] = diffa.s0;\n}\n__kernel void stereoKernel(__global unsigned char *left, __global unsigned char *right,\n__global unsigned int *cminSSDImage, int cminSSD_step,\n__global unsigned char *disp, int disp_step,int cwidth, int cheight,\nint img_step, int maxdisp,\n__local unsigned int *col_ssd_cache)\n{\n__local unsigned int *col_ssd = col_ssd_cache + get_local_id(0);\n__local unsigned int *col_ssd_extra = get_local_id(0) < (radius << 1) ? col_ssd + BLOCK_W : 0;\nint X = get_group_id(0) * BLOCK_W + get_local_id(0) + maxdisp + radius;\n#define Y (int)(get_group_id(1) * ROWSperTHREAD + radius)\n__global unsigned int* minSSDImage = cminSSDImage + X + Y * cminSSD_step;\n__global unsigned char* disparImage = disp + X + Y * disp_step;\nint end_row = ROWSperTHREAD < (cheight - Y) ? ROWSperTHREAD:(cheight - Y);\nint y_tex;\nint x_tex = X - radius;\nfor(int d = STEREO_MIND; d < maxdisp; d += STEREO_DISP_STEP)\n{\ny_tex = Y - radius;\nInitColSSD(x_tex, y_tex, img_step, left, right, d, col_ssd);\nif (col_ssd_extra > 0)\nif (x_tex + BLOCK_W < cwidth)\nInitColSSD(x_tex + BLOCK_W, y_tex, img_step, left, right, d, col_ssd_extra);\nbarrier(CLK_LOCAL_MEM_FENCE);\nuint2 minSSD = MinSSD(col_ssd);\nif (X < cwidth - radius && Y < cheight - radius)\n{\nif (minSSD.x < minSSDImage[0])\n{\ndisparImage[0] = (unsigned char)(d + minSSD.y);\nminSSDImage[0] = minSSD.x;\n}\n}\nfor(int row = 1; row < end_row; row++)\n{\nint idx1 = y_tex * img_step + x_tex;\nint idx2 = min(y_tex + ((radius << 1) + 1), cheight - 1) * img_step + x_tex;\nbarrier(CLK_LOCAL_MEM_FENCE);\nStepDown(idx1, idx2, left, right, d, col_ssd);\nif (col_ssd_extra > 0)\nif (x_tex + BLOCK_W < cwidth)\nStepDown(idx1, idx2, left + BLOCK_W, right + BLOCK_W, d, col_ssd_extra);\nbarrier(CLK_LOCAL_MEM_FENCE);\nuint2 minSSD = MinSSD(col_ssd);\nif (X < cwidth - radius && row < cheight - radius - Y)\n{\nint idx = row * cminSSD_step;\nif (minSSD.x < minSSDImage[idx])\n{\ndisparImage[disp_step * row] = (unsigned char)(d + minSSD.y);\nminSSDImage[idx] = minSSD.x;\n}\n}\ny_tex++;\n}\n}\n}\n__kernel void prefilter_xsobel(__global unsigned char *input, __global unsigned char *output,\nint rows, int cols, int prefilterCap)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < cols && y < rows)\n{\nint cov = input[(y-1) * cols + (x-1)] * (-1) + input[(y-1) * cols + (x+1)] * (1) +\ninput[(y)   * cols + (x-1)] * (-2) + input[(y)   * cols + (x+1)] * (2) +\ninput[(y+1) * cols + (x-1)] * (-1) + input[(y+1) * cols + (x+1)] * (1);\ncov = min(min(max(-prefilterCap, cov), prefilterCap) + prefilterCap, 255);\noutput[y * cols + x] = cov & 0xFF;\n}\n}\nfloat sobel(__global unsigned char *input, int x, int y, int rows, int cols)\n{\nfloat conv = 0;\nint y1 = y==0? 0 : y-1;\nint x1 = x==0? 0 : x-1;\nif(x < cols && y < rows && x > 0 && y > 0)\n{\nconv = (float)input[(y1)  * cols + (x1)] * (-1) + (float)input[(y1)  * cols + (x+1)] * (1) +\n(float)input[(y)   * cols + (x1)] * (-2) + (float)input[(y)   * cols + (x+1)] * (2) +\n(float)input[(y+1) * cols + (x1)] * (-1) + (float)input[(y+1) * cols + (x+1)] * (1);\n}\nreturn fabs(conv);\n}\nfloat CalcSums(__local float *cols, __local float *cols_cache, int winsz)\n{\nunsigned int cache = cols[0];\nfor(int i = 1; i <= winsz; i++)\ncache += cols[i];\nreturn cache;\n}\n#define RpT (2 * ROWSperTHREAD)\n__kernel void textureness_kernel(__global unsigned char *disp, int disp_rows, int disp_cols,\nint disp_step, __global unsigned char *input, int input_rows,\nint input_cols,int winsz, float threshold,\n__local float *cols_cache)\n{\nint winsz2 = winsz/2;\nint n_dirty_pixels = (winsz2) * 2;\nint local_id_x = get_local_id(0);\nint group_size_x = get_local_size(0);\nint group_id_y = get_group_id(1);\n__local float *cols = cols_cache + group_size_x + local_id_x;\n__local float *cols_extra = local_id_x < n_dirty_pixels ? cols + group_size_x : 0;\nint x = get_global_id(0);\nint beg_row = group_id_y * RpT;\nint end_row = min(beg_row + RpT, disp_rows);\nint y = beg_row;\nfloat sum = 0;\nfloat sum_extra = 0;\nfor(int i = y - winsz2; i <= y + winsz2; ++i)\n{\nsum += sobel(input, x - winsz2, i, input_rows, input_cols);\nif (cols_extra)\nsum_extra += sobel(input, x + group_size_x - winsz2, i, input_rows, input_cols);\n}\n*cols = sum;\nif (cols_extra)\n*cols_extra = sum_extra;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat sum_win = CalcSums(cols, cols_cache + local_id_x, winsz) * 255;\nif (sum_win < threshold)\ndisp[y * disp_step + x] = 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor(int y = beg_row + 1; y < end_row; ++y)\n{\nsum = sum - sobel(input, x - winsz2, y - winsz2 - 1, input_rows, input_cols) +\nsobel(input, x - winsz2, y + winsz2, input_rows, input_cols);\n*cols = sum;\nif (cols_extra)\n{\nsum_extra = sum_extra - sobel(input, x + group_size_x - winsz2, y - winsz2 - 1,input_rows, input_cols)\n+ sobel(input, x + group_size_x - winsz2, y + winsz2, input_rows, input_cols);\n*cols_extra = sum_extra;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (x < disp_cols)\n{\nfloat sum_win = CalcSums(cols, cols_cache + local_id_x, winsz) * 255;\nif (sum_win < threshold)\ndisp[y * disp_step + x] = 0;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\n", "5dcc7a3ab0f93796613f382a3c29d5fc", "split_mat", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#if DATA_DEPTH == 0\n#define BASE_TYPE uchar\n#elif DATA_DEPTH == 1\n#error data_depth char, use uchar datatype instead\n#elif DATA_DEPTH == 2\n#define BASE_TYPE ushort\n#elif DATA_DEPTH == 3\n#error data_depth short, use ushort datatype instead\n#elif DATA_DEPTH == 4\n#define BASE_TYPE int\n#elif DATA_DEPTH == 5\n#define BASE_TYPE float\n#elif DATA_DEPTH == 6\n#define BASE_TYPE double\n#else\n#error data_depth\n#endif\n#if DATA_CHAN == 2\n#define SRC_VEC_SIZE 2\n#elif DATA_CHAN == 3\n#define SRC_VEC_SIZE 4\n#elif DATA_CHAN == 4\n#define SRC_VEC_SIZE 4\n#else\n#error data_chan\n#endif\n#define __CAT(x, y) x##y\n#define CAT(x, y) __CAT(x, y)\n#define uchar1 uchar\n#define char1 char\n#define ushort1 ushort\n#define short1 short\n#define int1 int\n#define float1 float\n#define double1 double\n#define TYPE BASE_TYPE\n#define SRC_TYPE CAT(BASE_TYPE, SRC_VEC_SIZE)\n#define DST_VEC_TYPE CAT(BASE_TYPE, VEC_SIZE)\n#define vstore1 vstore\n#define VSTORE CAT(vstore, VEC_SIZE)\n#define VSTORE_ALIGNED(ptr, v) *((__global DST_VEC_TYPE*)(ptr)) = (v)\n#define VSTORE_UNALIGNED(ptr, v) VSTORE((v), 0, (__global TYPE*)(ptr))\n#ifdef DST0_ALIGNED\n#define VSTORE_dst0 VSTORE_ALIGNED\n#else\n#define VSTORE_dst0 VSTORE_UNALIGNED\n#endif\n#ifdef DST1_ALIGNED\n#define VSTORE_dst1 VSTORE_ALIGNED\n#else\n#define VSTORE_dst1 VSTORE_UNALIGNED\n#endif\n#ifdef DST2_ALIGNED\n#define VSTORE_dst2 VSTORE_ALIGNED\n#else\n#define VSTORE_dst2 VSTORE_UNALIGNED\n#endif\n#ifdef DST3_ALIGNED\n#define VSTORE_dst3 VSTORE_ALIGNED\n#else\n#define VSTORE_dst3 VSTORE_UNALIGNED\n#endif\n__kernel void split_vector(\n__global SRC_TYPE* src, int srcStepBytes, int2 srcOffset,\n__global TYPE* dst0, int dst0StepBytes, int2 dst0Offset,\n__global TYPE* dst1, int dst1StepBytes, int2 dst1Offset,\n#if DATA_CHAN > 2\n__global TYPE* dst2, int dst2StepBytes, int2 dst2Offset,\n#endif\n#if DATA_CHAN > 3\n__global TYPE* dst3, int dst3StepBytes, int2 dst3Offset,\n#endif\nint2 size)\n{\nint x = get_global_id(0) * VEC_SIZE;\nint y = get_global_id(1);\nif (x < size.x && y < size.y)\n{\nSRC_TYPE srcData[VEC_SIZE];\nint xOffsetLimitBytes = srcOffset.x + size.x * sizeof(SRC_TYPE);\nint xOffsetBytes = srcOffset.x + x * sizeof(SRC_TYPE);\nint yOffsetBytes = (srcOffset.y + y) * srcStepBytes;\n#pragma unroll\nfor (int i = 0; i < VEC_SIZE; i++, xOffsetBytes += sizeof(SRC_TYPE))\n{\nsrcData[i] = (xOffsetBytes >= xOffsetLimitBytes) ? (SRC_TYPE)0 :\n*(__global SRC_TYPE*)((__global char*)src + yOffsetBytes + xOffsetBytes);\n}\n#if VEC_SIZE == 1\nTYPE dstC0 = srcData[0].s0;\nTYPE dstC1 = srcData[0].s1;\n#if DATA_CHAN > 2\nTYPE dstC2 = srcData[0].s2;\n#endif\n#if DATA_CHAN > 3\nTYPE dstC3 = srcData[0].s3;\n#endif\n# define VEC_TO_ARRAY(v, a) TYPE a[1] = {v};\n#elif VEC_SIZE == 2\nDST_VEC_TYPE dstC0 = (DST_VEC_TYPE)(srcData[0].s0, srcData[1].s0);\nDST_VEC_TYPE dstC1 = (DST_VEC_TYPE)(srcData[0].s1, srcData[1].s1);\n#if DATA_CHAN > 2\nDST_VEC_TYPE dstC2 = (DST_VEC_TYPE)(srcData[0].s2, srcData[1].s2);\n#endif\n#if DATA_CHAN > 3\nDST_VEC_TYPE dstC3 = (DST_VEC_TYPE)(srcData[0].s3, srcData[1].s3);\n#endif\n# define VEC_TO_ARRAY(v, a) TYPE a[2] = {v.s0, v.s1};\n#elif VEC_SIZE == 4\nDST_VEC_TYPE dstC0 = (DST_VEC_TYPE)(srcData[0].s0, srcData[1].s0, srcData[2].s0, srcData[3].s0);\nDST_VEC_TYPE dstC1 = (DST_VEC_TYPE)(srcData[0].s1, srcData[1].s1, srcData[2].s1, srcData[3].s1);\n#if DATA_CHAN > 2\nDST_VEC_TYPE dstC2 = (DST_VEC_TYPE)(srcData[0].s2, srcData[1].s2, srcData[2].s2, srcData[3].s2);\n#endif\n#if DATA_CHAN > 3\nDST_VEC_TYPE dstC3 = (DST_VEC_TYPE)(srcData[0].s3, srcData[1].s3, srcData[2].s3, srcData[3].s3);\n#endif\n# define VEC_TO_ARRAY(v, a) TYPE a[4] = {v.s0, v.s1, v.s2, v.s3};\n#endif\n#ifndef BYPASS_VSTORE\n#define BYPASS_VSTORE false\n#endif\n#define WRITE_VEC_DST(dst, vecValue) \\\n{ \\\nint dst ## xOffsetLimitBytes = dst ## Offset.x + size.x * sizeof(TYPE); \\\nint dst ## xOffsetBytes = dst ## Offset.x + x * sizeof(TYPE); \\\nint dst ## yOffsetBytes = (dst ## Offset.y + y) * dst ## StepBytes; \\\nif (!BYPASS_VSTORE && dst ## xOffsetBytes + (int)sizeof(DST_VEC_TYPE) <= dst ## xOffsetLimitBytes) \\\n{ \\\nVSTORE_ ## dst(((__global char*)dst + dst ## yOffsetBytes + dst ## xOffsetBytes), vecValue); \\\n} \\\nelse \\\n{ \\\nVEC_TO_ARRAY(vecValue, vecValue##Array); \\\nfor (int i = 0; i < VEC_SIZE; i++, dst ## xOffsetBytes += sizeof(TYPE)) \\\n{ \\\nif (dst ## xOffsetBytes + (int)sizeof(TYPE) <= dst ## xOffsetLimitBytes) \\\n*(__global TYPE*)((__global char*)dst + dst ## yOffsetBytes + dst ## xOffsetBytes) = vecValue##Array[i]; \\\nelse \\\nbreak; \\\n} \\\n} \\\n}\nWRITE_VEC_DST(dst0, dstC0);\nWRITE_VEC_DST(dst1, dstC1);\n#if DATA_CHAN > 2\nWRITE_VEC_DST(dst2, dstC2);\n#endif\n#if DATA_CHAN > 3\nWRITE_VEC_DST(dst3, dstC3);\n#endif\n}\n}\n", "8689026266644305bc75b3f61ac6d027", "pyrlk", "#define  BUFFER  64\n#define  BUFFER2  BUFFER>>1\n#ifndef WAVE_SIZE\n#define WAVE_SIZE 1\n#endif\n#ifdef CPU\nvoid reduce3(float val1, float val2, float val3,  __local float* smem1,  __local float* smem2,  __local float* smem3, int tid)\n{\nsmem1[tid] = val1;\nsmem2[tid] = val2;\nsmem3[tid] = val3;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor(int i = BUFFER2; i > 0; i >>= 1)\n{\nif(tid < i)\n{\nsmem1[tid] += smem1[tid + i];\nsmem2[tid] += smem2[tid + i];\nsmem3[tid] += smem3[tid + i];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nvoid reduce2(float val1, float val2, volatile __local float* smem1, volatile __local float* smem2, int tid)\n{\nsmem1[tid] = val1;\nsmem2[tid] = val2;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor(int i = BUFFER2; i > 0; i >>= 1)\n{\nif(tid < i)\n{\nsmem1[tid] += smem1[tid + i];\nsmem2[tid] += smem2[tid + i];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nvoid reduce1(float val1, volatile __local float* smem1, int tid)\n{\nsmem1[tid] = val1;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor(int i = BUFFER2; i > 0; i >>= 1)\n{\nif(tid < i)\n{\nsmem1[tid] += smem1[tid + i];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\n#else\nvoid reduce3(float val1, float val2, float val3,\n__local volatile float* smem1, __local volatile float* smem2, __local volatile float* smem3, int tid)\n{\nsmem1[tid] = val1;\nsmem2[tid] = val2;\nsmem3[tid] = val3;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 32)\n{\nsmem1[tid] += smem1[tid + 32];\nsmem2[tid] += smem2[tid + 32];\nsmem3[tid] += smem3[tid + 32];\n#if WAVE_SIZE < 32\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16)\n{\n#endif\nsmem1[tid] += smem1[tid + 16];\nsmem2[tid] += smem2[tid + 16];\nsmem3[tid] += smem3[tid + 16];\n#if WAVE_SIZE <16\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 8)\n{\n#endif\nsmem1[tid] += smem1[tid + 8];\nsmem2[tid] += smem2[tid + 8];\nsmem3[tid] += smem3[tid + 8];\nsmem1[tid] += smem1[tid + 4];\nsmem2[tid] += smem2[tid + 4];\nsmem3[tid] += smem3[tid + 4];\nsmem1[tid] += smem1[tid + 2];\nsmem2[tid] += smem2[tid + 2];\nsmem3[tid] += smem3[tid + 2];\nsmem1[tid] += smem1[tid + 1];\nsmem2[tid] += smem2[tid + 1];\nsmem3[tid] += smem3[tid + 1];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nvoid reduce2(float val1, float val2, __local volatile float* smem1, __local volatile float* smem2, int tid)\n{\nsmem1[tid] = val1;\nsmem2[tid] = val2;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 32)\n{\nsmem1[tid] += smem1[tid + 32];\nsmem2[tid] += smem2[tid + 32];\n#if WAVE_SIZE < 32\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16)\n{\n#endif\nsmem1[tid] += smem1[tid + 16];\nsmem2[tid] += smem2[tid + 16];\n#if WAVE_SIZE <16\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 8)\n{\n#endif\nsmem1[tid] += smem1[tid + 8];\nsmem2[tid] += smem2[tid + 8];\nsmem1[tid] += smem1[tid + 4];\nsmem2[tid] += smem2[tid + 4];\nsmem1[tid] += smem1[tid + 2];\nsmem2[tid] += smem2[tid + 2];\nsmem1[tid] += smem1[tid + 1];\nsmem2[tid] += smem2[tid + 1];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nvoid reduce1(float val1, __local volatile float* smem1, int tid)\n{\nsmem1[tid] = val1;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 32)\n{\nsmem1[tid] += smem1[tid + 32];\n#if WAVE_SIZE < 32\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16)\n{\n#endif\nsmem1[tid] += smem1[tid + 16];\n#if WAVE_SIZE <16\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 8)\n{\n#endif\nsmem1[tid] += smem1[tid + 8];\nsmem1[tid] += smem1[tid + 4];\nsmem1[tid] += smem1[tid + 2];\nsmem1[tid] += smem1[tid + 1];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n#endif\n#define SCALE (1.0f / (1 << 20))\n#define  THRESHOLD  0.01f\n__constant sampler_t sampler    = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\nvoid SetPatch(image2d_t I, float x, float y,\nfloat* Pch, float* Dx, float* Dy,\nfloat* A11, float* A12, float* A22)\n{\n*Pch = read_imagef(I, sampler, (float2)(x, y)).x;\nfloat dIdx = 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x + 1, y)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)).x -\n(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x - 1, y)).x + 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)).x);\nfloat dIdy = 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x, y + 1)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)).x -\n(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x, y - 1)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)).x);\n*Dx = dIdx;\n*Dy = dIdy;\n*A11 += dIdx * dIdx;\n*A12 += dIdx * dIdy;\n*A22 += dIdy * dIdy;\n}\nvoid GetPatch(image2d_t J, float x, float y,\nfloat* Pch, float* Dx, float* Dy,\nfloat* b1, float* b2)\n{\nfloat J_val = read_imagef(J, sampler, (float2)(x, y)).x;\nfloat diff = (J_val - *Pch) * 32.0f;\n*b1 += diff**Dx;\n*b2 += diff**Dy;\n}\nvoid GetError(image2d_t J, const float x, const float y, const float* Pch, float* errval)\n{\nfloat diff = read_imagef(J, sampler, (float2)(x,y)).x-*Pch;\n*errval += fabs(diff);\n}\nvoid SetPatch4(image2d_t I, const float x, const float y,\nfloat4* Pch, float4* Dx, float4* Dy,\nfloat* A11, float* A12, float* A22)\n{\n*Pch = read_imagef(I, sampler, (float2)(x, y));\nfloat4 dIdx = 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x + 1, y)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)) -\n(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x - 1, y)) + 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)));\nfloat4 dIdy = 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)) + 10.0f * read_imagef(I, sampler, (float2)(x, y + 1)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)) -\n(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x, y - 1)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)));\n*Dx = dIdx;\n*Dy = dIdy;\nfloat4 sqIdx = dIdx * dIdx;\n*A11 += sqIdx.x + sqIdx.y + sqIdx.z;\nsqIdx = dIdx * dIdy;\n*A12 += sqIdx.x + sqIdx.y + sqIdx.z;\nsqIdx = dIdy * dIdy;\n*A22 += sqIdx.x + sqIdx.y + sqIdx.z;\n}\nvoid GetPatch4(image2d_t J, const float x, const float y,\nconst float4* Pch, const float4* Dx, const float4* Dy,\nfloat* b1, float* b2)\n{\nfloat4 J_val = read_imagef(J, sampler, (float2)(x, y));\nfloat4 diff = (J_val - *Pch) * 32.0f;\nfloat4 xdiff = diff* *Dx;\n*b1 += xdiff.x + xdiff.y + xdiff.z;\nxdiff = diff* *Dy;\n*b2 += xdiff.x + xdiff.y + xdiff.z;\n}\nvoid GetError4(image2d_t J, const float x, const float y, const float4* Pch, float* errval)\n{\nfloat4 diff = read_imagef(J, sampler, (float2)(x,y))-*Pch;\n*errval += fabs(diff.x) + fabs(diff.y) + fabs(diff.z);\n}\n#define  GRIDSIZE  3\n__kernel void lkSparse_C1_D5(image2d_t I, image2d_t J,\n__global const float2* prevPts, int prevPtsStep, __global float2* nextPts, int nextPtsStep, __global uchar* status, __global float* err,\nconst int level, const int rows, const int cols, int PATCH_X, int PATCH_Y, int cn, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n{\n__local float smem1[BUFFER];\n__local float smem2[BUFFER];\n__local float smem3[BUFFER];\nunsigned int xid=get_local_id(0);\nunsigned int yid=get_local_id(1);\nunsigned int gid=get_group_id(0);\nunsigned int xsize=get_local_size(0);\nunsigned int ysize=get_local_size(1);\nint xBase, yBase, k;\nfloat2 c_halfWin = (float2)((c_winSize_x - 1)>>1, (c_winSize_y - 1)>>1);\nconst int tid = mad24(yid, xsize, xid);\nfloat2 prevPt = prevPts[gid] / (float2)(1 << level);\nif (prevPt.x < 0 || prevPt.x >= cols || prevPt.y < 0 || prevPt.y >= rows)\n{\nif (tid == 0 && level == 0)\n{\nstatus[gid] = 0;\n}\nreturn;\n}\nprevPt -= c_halfWin;\nfloat A11 = 0;\nfloat A12 = 0;\nfloat A22 = 0;\nfloat I_patch[GRIDSIZE][GRIDSIZE];\nfloat dIdx_patch[GRIDSIZE][GRIDSIZE];\nfloat dIdy_patch[GRIDSIZE][GRIDSIZE];\nyBase=yid;\n{\nxBase=xid;\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][0], &dIdx_patch[0][0], &dIdy_patch[0][0],\n&A11, &A12, &A22);\nxBase+=xsize;\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][1], &dIdx_patch[0][1], &dIdy_patch[0][1],\n&A11, &A12, &A22);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][2], &dIdx_patch[0][2], &dIdy_patch[0][2],\n&A11, &A12, &A22);\n}\nyBase+=ysize;\n{\nxBase=xid;\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][0], &dIdx_patch[1][0], &dIdy_patch[1][0],\n&A11, &A12, &A22);\nxBase+=xsize;\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][1], &dIdx_patch[1][1], &dIdy_patch[1][1],\n&A11, &A12, &A22);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][2], &dIdx_patch[1][2], &dIdy_patch[1][2],\n&A11, &A12, &A22);\n}\nyBase+=ysize;\nif(yBase<c_winSize_y)\n{\nxBase=xid;\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][0], &dIdx_patch[2][0], &dIdy_patch[2][0],\n&A11, &A12, &A22);\nxBase+=xsize;\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][1], &dIdx_patch[2][1], &dIdy_patch[2][1],\n&A11, &A12, &A22);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nSetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][2], &dIdx_patch[2][2], &dIdy_patch[2][2],\n&A11, &A12, &A22);\n}\nreduce3(A11, A12, A22, smem1, smem2, smem3, tid);\nA11 = smem1[0];\nA12 = smem2[0];\nA22 = smem3[0];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat D = A11 * A22 - A12 * A12;\nif (D < 1.192092896e-07f)\n{\nif (tid == 0 && level == 0)\nstatus[gid] = 0;\nreturn;\n}\nA11 /= D;\nA12 /= D;\nA22 /= D;\nprevPt = nextPts[gid] * 2.0f - c_halfWin;\nfor (k = 0; k < c_iters; ++k)\n{\nif (prevPt.x < -c_halfWin.x || prevPt.x >= cols || prevPt.y < -c_halfWin.y || prevPt.y >= rows)\n{\nif (tid == 0 && level == 0)\nstatus[gid] = 0;\nreturn;\n}\nfloat b1 = 0;\nfloat b2 = 0;\nyBase=yid;\n{\nxBase=xid;\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][0], &dIdx_patch[0][0], &dIdy_patch[0][0],\n&b1, &b2);\nxBase+=xsize;\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][1], &dIdx_patch[0][1], &dIdy_patch[0][1],\n&b1, &b2);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][2], &dIdx_patch[0][2], &dIdy_patch[0][2],\n&b1, &b2);\n}\nyBase+=ysize;\n{\nxBase=xid;\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][0], &dIdx_patch[1][0], &dIdy_patch[1][0],\n&b1, &b2);\nxBase+=xsize;\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][1], &dIdx_patch[1][1], &dIdy_patch[1][1],\n&b1, &b2);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][2], &dIdx_patch[1][2], &dIdy_patch[1][2],\n&b1, &b2);\n}\nyBase+=ysize;\nif(yBase<c_winSize_y)\n{\nxBase=xid;\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][0], &dIdx_patch[2][0], &dIdy_patch[2][0],\n&b1, &b2);\nxBase+=xsize;\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][1], &dIdx_patch[2][1], &dIdy_patch[2][1],\n&b1, &b2);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][2], &dIdx_patch[2][2], &dIdy_patch[2][2],\n&b1, &b2);\n}\nreduce2(b1, b2, smem1, smem2, tid);\nb1 = smem1[0];\nb2 = smem2[0];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat2 delta;\ndelta.x = A12 * b2 - A22 * b1;\ndelta.y = A12 * b1 - A11 * b2;\nprevPt += delta;\nif (fabs(delta.x) < THRESHOLD && fabs(delta.y) < THRESHOLD)\nbreak;\n}\nD = 0.0f;\nif (calcErr)\n{\nyBase=yid;\n{\nxBase=xid;\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][0], &D);\nxBase+=xsize;\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][1], &D);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[0][2], &D);\n}\nyBase+=ysize;\n{\nxBase=xid;\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][0], &D);\nxBase+=xsize;\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][1], &D);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[1][2], &D);\n}\nyBase+=ysize;\nif(yBase<c_winSize_y)\n{\nxBase=xid;\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][0], &D);\nxBase+=xsize;\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][1], &D);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n&I_patch[2][2], &D);\n}\nreduce1(D, smem1, tid);\n}\nif (tid == 0)\n{\nprevPt += c_halfWin;\nnextPts[gid] = prevPt;\nif (calcErr)\nerr[gid] = smem1[0] / (float)(c_winSize_x * c_winSize_y);\n}\n}\n__kernel void lkSparse_C4_D5(image2d_t I, image2d_t J,\n__global const float2* prevPts, int prevPtsStep, __global float2* nextPts, int nextPtsStep, __global uchar* status, __global float* err,\nconst int level, const int rows, const int cols, int PATCH_X, int PATCH_Y, int cn, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n{\n__local float smem1[BUFFER];\n__local float smem2[BUFFER];\n__local float smem3[BUFFER];\nunsigned int xid=get_local_id(0);\nunsigned int yid=get_local_id(1);\nunsigned int gid=get_group_id(0);\nunsigned int xsize=get_local_size(0);\nunsigned int ysize=get_local_size(1);\nint xBase, yBase, k;\nfloat2 c_halfWin = (float2)((c_winSize_x - 1)>>1, (c_winSize_y - 1)>>1);\nconst int tid = mad24(yid, xsize, xid);\nfloat2 nextPt = prevPts[gid]/(float2)(1<<level);\nif (nextPt.x < 0 || nextPt.x >= cols || nextPt.y < 0 || nextPt.y >= rows)\n{\nif (tid == 0 && level == 0)\n{\nstatus[gid] = 0;\n}\nreturn;\n}\nnextPt -= c_halfWin;\nfloat A11 = 0.0f;\nfloat A12 = 0.0f;\nfloat A22 = 0.0f;\nfloat4 I_patch[8];\nfloat4 dIdx_patch[8];\nfloat4 dIdy_patch[8];\nfloat4 I_add,Dx_add,Dy_add;\nyBase=yid;\n{\nxBase=xid;\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[0], &dIdx_patch[0], &dIdy_patch[0],\n&A11, &A12, &A22);\nxBase+=xsize;\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[1], &dIdx_patch[1], &dIdy_patch[1],\n&A11, &A12, &A22);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[2], &dIdx_patch[2], &dIdy_patch[2],\n&A11, &A12, &A22);\n}\nyBase+=ysize;\n{\nxBase=xid;\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[3], &dIdx_patch[3], &dIdy_patch[3],\n&A11, &A12, &A22);\nxBase+=xsize;\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[4], &dIdx_patch[4], &dIdy_patch[4],\n&A11, &A12, &A22);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[5], &dIdx_patch[5], &dIdy_patch[5],\n&A11, &A12, &A22);\n}\nyBase+=ysize;\nif(yBase<c_winSize_y)\n{\nxBase=xid;\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[6], &dIdx_patch[6], &dIdy_patch[6],\n&A11, &A12, &A22);\nxBase+=xsize;\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[7], &dIdx_patch[7], &dIdy_patch[7],\n&A11, &A12, &A22);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nSetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_add, &Dx_add, &Dy_add,\n&A11, &A12, &A22);\n}\nreduce3(A11, A12, A22, smem1, smem2, smem3, tid);\nA11 = smem1[0];\nA12 = smem2[0];\nA22 = smem3[0];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat D = A11 * A22 - A12 * A12;\nif (D < 1.192092896e-07f)\n{\nif (tid == 0 && level == 0)\nstatus[gid] = 0;\nreturn;\n}\nA11 /= D;\nA12 /= D;\nA22 /= D;\nnextPt = nextPts[gid] * 2.0f - c_halfWin;\nfor (k = 0; k < c_iters; ++k)\n{\nif (nextPt.x < -c_halfWin.x || nextPt.x >= cols || nextPt.y < -c_halfWin.y || nextPt.y >= rows)\n{\nif (tid == 0 && level == 0)\nstatus[gid] = 0;\nreturn;\n}\nfloat b1 = 0;\nfloat b2 = 0;\nyBase=yid;\n{\nxBase=xid;\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[0], &dIdx_patch[0], &dIdy_patch[0],\n&b1, &b2);\nxBase+=xsize;\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[1], &dIdx_patch[1], &dIdy_patch[1],\n&b1, &b2);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[2], &dIdx_patch[2], &dIdy_patch[2],\n&b1, &b2);\n}\nyBase+=ysize;\n{\nxBase=xid;\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[3], &dIdx_patch[3], &dIdy_patch[3],\n&b1, &b2);\nxBase+=xsize;\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[4], &dIdx_patch[4], &dIdy_patch[4],\n&b1, &b2);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[5], &dIdx_patch[5], &dIdy_patch[5],\n&b1, &b2);\n}\nyBase+=ysize;\nif(yBase<c_winSize_y)\n{\nxBase=xid;\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[6], &dIdx_patch[6], &dIdy_patch[6],\n&b1, &b2);\nxBase+=xsize;\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[7], &dIdx_patch[7], &dIdy_patch[7],\n&b1, &b2);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_add, &Dx_add, &Dy_add,\n&b1, &b2);\n}\nreduce2(b1, b2, smem1, smem2, tid);\nb1 = smem1[0];\nb2 = smem2[0];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat2 delta;\ndelta.x = A12 * b2 - A22 * b1;\ndelta.y = A12 * b1 - A11 * b2;\nnextPt +=delta;\nif (fabs(delta.x) < THRESHOLD && fabs(delta.y) < THRESHOLD)\nbreak;\n}\nD = 0.0f;\nif (calcErr)\n{\nyBase=yid;\n{\nxBase=xid;\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[0], &D);\nxBase+=xsize;\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[1], &D);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[2], &D);\n}\nyBase+=ysize;\n{\nxBase=xid;\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[3], &D);\nxBase+=xsize;\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[4], &D);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[5], &D);\n}\nyBase+=ysize;\nif(yBase<c_winSize_y)\n{\nxBase=xid;\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[6], &D);\nxBase+=xsize;\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_patch[7], &D);\nxBase+=xsize;\nif(xBase<c_winSize_x)\nGetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n&I_add, &D);\n}\nreduce1(D, smem1, tid);\n}\nif (tid == 0)\n{\nnextPt += c_halfWin;\nnextPts[gid] = nextPt;\nif (calcErr)\nerr[gid] = smem1[0] / (float)(3 * c_winSize_x * c_winSize_y);\n}\n}\n__kernel void lkDense_C1_D0(image2d_t I, image2d_t J, __global float* u, int uStep, __global float* v, int vStep, __global const float* prevU, int prevUStep, __global const float* prevV, int prevVStep,\nconst int rows, const int cols,  int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n{\nint c_halfWin_x = (c_winSize_x - 1) / 2;\nint c_halfWin_y = (c_winSize_y - 1) / 2;\nconst int patchWidth  = get_local_size(0) + 2 * c_halfWin_x;\nconst int patchHeight = get_local_size(1) + 2 * c_halfWin_y;\n__local int smem[8192];\n__local int* I_patch = smem;\n__local int* dIdx_patch = I_patch + patchWidth * patchHeight;\n__local int* dIdy_patch = dIdx_patch + patchWidth * patchHeight;\nconst int xBase = get_group_id(0) * get_local_size(0);\nconst int yBase = get_group_id(1) * get_local_size(1);\nsampler_t sampleri    = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\nfor (int i = get_local_id(1); i < patchHeight; i += get_local_size(1))\n{\nfor (int j = get_local_id(0); j < patchWidth; j += get_local_size(0))\n{\nfloat x = xBase - c_halfWin_x + j + 0.5f;\nfloat y = yBase - c_halfWin_y + i + 0.5f;\nI_patch[i * patchWidth + j] = read_imagei(I, sampleri, (float2)(x, y)).x;\ndIdx_patch[i * patchWidth + j] = 3 * read_imagei(I, sampleri, (float2)(x+1, y-1)).x + 10 * read_imagei(I, sampleri, (float2)(x+1, y)).x + 3 * read_imagei(I, sampleri, (float2)(x+1, y+1)).x -\n(3 * read_imagei(I, sampleri, (float2)(x-1, y-1)).x + 10 * read_imagei(I, sampleri, (float2)(x-1, y)).x + 3 * read_imagei(I, sampleri, (float2)(x-1, y+1)).x);\ndIdy_patch[i * patchWidth + j] = 3 * read_imagei(I, sampleri, (float2)(x-1, y+1)).x + 10 * read_imagei(I, sampleri, (float2)(x, y+1)).x + 3 * read_imagei(I, sampleri, (float2)(x+1, y+1)).x -\n(3 * read_imagei(I, sampleri, (float2)(x-1, y-1)).x + 10 * read_imagei(I, sampleri, (float2)(x, y-1)).x + 3 * read_imagei(I, sampleri, (float2)(x+1, y-1)).x);\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nconst int x = get_global_id(0);\nconst int y = get_global_id(1);\nif (x >= cols || y >= rows)\nreturn;\nint A11i = 0;\nint A12i = 0;\nint A22i = 0;\nfor (int i = 0; i < c_winSize_y; ++i)\n{\nfor (int j = 0; j < c_winSize_x; ++j)\n{\nint dIdx = dIdx_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\nint dIdy = dIdy_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\nA11i += dIdx * dIdx;\nA12i += dIdx * dIdy;\nA22i += dIdy * dIdy;\n}\n}\nfloat A11 = A11i;\nfloat A12 = A12i;\nfloat A22 = A22i;\nfloat D = A11 * A22 - A12 * A12;\nif (D < 1.192092896e-07f)\n{\nreturn;\n}\nD = 1.f / D;\nA11 *= D;\nA12 *= D;\nA22 *= D;\nfloat2 nextPt;\nnextPt.x = x + prevU[y/2 * prevUStep / 4 + x/2] * 2.0f;\nnextPt.y = y + prevV[y/2 * prevVStep / 4 + x/2] * 2.0f;\nfor (int k = 0; k < c_iters; ++k)\n{\nif (nextPt.x < 0 || nextPt.x >= cols || nextPt.y < 0 || nextPt.y >= rows)\n{\nreturn;\n}\nint b1 = 0;\nint b2 = 0;\nfor (int i = 0; i < c_winSize_y; ++i)\n{\nfor (int j = 0; j < c_winSize_x; ++j)\n{\nint iI = I_patch[(get_local_id(1) + i) * patchWidth + get_local_id(0) + j];\nint iJ = read_imagei(J, sampler, (float2)(nextPt.x - c_halfWin_x + j + 0.5f, nextPt.y - c_halfWin_y + i + 0.5f)).x;\nint diff = (iJ - iI) * 32;\nint dIdx = dIdx_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\nint dIdy = dIdy_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\nb1 += diff * dIdx;\nb2 += diff * dIdy;\n}\n}\nfloat2 delta;\ndelta.x = A12 * b2 - A22 * b1;\ndelta.y = A12 * b1 - A11 * b2;\nnextPt.x += delta.x;\nnextPt.y += delta.y;\nif (fabs(delta.x) < 0.01f && fabs(delta.y) < 0.01f)\nbreak;\n}\nu[y * uStep / 4 + x] = nextPt.x - x;\nv[y * vStep / 4 + x] = nextPt.y - y;\nif (calcErr)\n{\nint errval = 0;\nfor (int i = 0; i < c_winSize_y; ++i)\n{\nfor (int j = 0; j < c_winSize_x; ++j)\n{\nint iI = I_patch[(get_local_id(1) + i) * patchWidth + get_local_id(0) + j];\nint iJ = read_imagei(J, sampler, (float2)(nextPt.x - c_halfWin_x + j + 0.5f, nextPt.y - c_halfWin_y + i + 0.5f)).x;\nerrval += abs(iJ - iI);\n}\n}\n}\n}\n", "516e74880f1fd439f623e7b83bfb3b37", "pyr_up", "__kernel void pyrUp(__global Type* src, __global Type* dst,\nint srcRows, int dstRows, int srcCols, int dstCols,\nint srcOffset, int dstOffset, int srcStep, int dstStep)\n{\nconst int x = get_global_id(0);\nconst int y = get_global_id(1);\nconst int lsizex = get_local_size(0);\nconst int lsizey = get_local_size(1);\nconst int tidx = get_local_id(0);\nconst int tidy = get_local_id(1);\n__local floatType s_srcPatch[10][10];\n__local floatType s_dstPatch[20][16];\nif( tidx < 10 && tidy < 10 )\n{\nint srcx = mad24((int)get_group_id(0), lsizex>>1, tidx) - 1;\nint srcy = mad24((int)get_group_id(1), lsizey>>1, tidy) - 1;\nsrcx = abs(srcx);\nsrcx = min(srcCols - 1,srcx);\nsrcy = abs(srcy);\nsrcy = min(srcRows -1 ,srcy);\ns_srcPatch[tidy][tidx] = convertToFloat(src[srcx + srcy * srcStep]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloatType sum = (floatType)0;\nconst floatType evenFlag = (floatType)((tidx & 1) == 0);\nconst floatType oddFlag = (floatType)((tidx & 1) != 0);\nconst bool  eveny = ((tidy & 1) == 0);\nconst floatType co1 = (floatType)0.375f;\nconst floatType co2 = (floatType)0.25f;\nconst floatType co3 = (floatType)0.0625f;\nif(eveny)\n{\nsum =       ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 2) >> 1)];\nsum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 1) >> 1)];\nsum = sum + ( evenFlag* co1 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx    ) >> 1)];\nsum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 1) >> 1)];\nsum = sum + ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 2) >> 1)];\n}\ns_dstPatch[2 + tidy][tidx] = sum;\nif (tidy < 2)\n{\nsum = 0;\nif (eveny)\n{\nsum =       (evenFlag * co3 ) * s_srcPatch[lsizey-16][1 + ((tidx - 2) >> 1)];\nsum = sum + ( oddFlag * co2 ) * s_srcPatch[lsizey-16][1 + ((tidx - 1) >> 1)];\nsum = sum + (evenFlag * co1 ) * s_srcPatch[lsizey-16][1 + ((tidx    ) >> 1)];\nsum = sum + ( oddFlag * co2 ) * s_srcPatch[lsizey-16][1 + ((tidx + 1) >> 1)];\nsum = sum + (evenFlag * co3 ) * s_srcPatch[lsizey-16][1 + ((tidx + 2) >> 1)];\n}\ns_dstPatch[tidy][tidx] = sum;\n}\nif (tidy > 13)\n{\nsum = 0;\nif (eveny)\n{\nsum =       (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx - 2) >> 1)];\nsum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx - 1) >> 1)];\nsum = sum + (evenFlag * co1) * s_srcPatch[lsizey-7][1 + ((tidx    ) >> 1)];\nsum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx + 1) >> 1)];\nsum = sum + (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx + 2) >> 1)];\n}\ns_dstPatch[4 + tidy][tidx] = sum;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum =       co3 * s_dstPatch[2 + tidy - 2][tidx];\nsum = sum + co2 * s_dstPatch[2 + tidy - 1][tidx];\nsum = sum + co1 * s_dstPatch[2 + tidy    ][tidx];\nsum = sum + co2 * s_dstPatch[2 + tidy + 1][tidx];\nsum = sum + co3 * s_dstPatch[2 + tidy + 2][tidx];\nif ((x < dstCols) && (y < dstRows))\ndst[x + y * dstStep] = convertToType(4.0f * sum);\n}\n", "66198bcfcc6a241a5e4d6cadf0cd3dc0", "pyr_down", "int idx_row_low(int y, int last_row)\n{\nreturn abs(y) % (last_row + 1);\n}\nint idx_row_high(int y, int last_row)\n{\nreturn abs(last_row - (int)abs(last_row - y)) % (last_row + 1);\n}\nint idx_row(int y, int last_row)\n{\nreturn idx_row_low(idx_row_high(y, last_row), last_row);\n}\nint idx_col_low(int x, int last_col)\n{\nreturn abs(x) % (last_col + 1);\n}\nint idx_col_high(int x, int last_col)\n{\nreturn abs(last_col - (int)abs(last_col - x)) % (last_col + 1);\n}\nint idx_col(int x, int last_col)\n{\nreturn idx_col_low(idx_col_high(x, last_col), last_col);\n}\n__kernel void pyrDown_C1_D0(__global uchar * srcData, int srcStep, int srcRows, int srcCols, __global uchar *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float smem[256 + 4];\nfloat sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       0.0625f * (((srcData + (src_y - 2) * srcStep))[x]);\nsum = sum + 0.25f   * (((srcData + (src_y - 1) * srcStep))[x]);\nsum = sum + 0.375f  * (((srcData + (src_y    ) * srcStep))[x]);\nsum = sum + 0.25f   * (((srcData + (src_y + 1) * srcStep))[x]);\nsum = sum + 0.0625f * (((srcData + (src_y + 2) * srcStep))[x]);\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       0.0625f * (((srcData + (src_y - 2) * srcStep))[left_x]);\nsum = sum + 0.25f   * (((srcData + (src_y - 1) * srcStep))[left_x]);\nsum = sum + 0.375f  * (((srcData + (src_y    ) * srcStep))[left_x]);\nsum = sum + 0.25f   * (((srcData + (src_y + 1) * srcStep))[left_x]);\nsum = sum + 0.0625f * (((srcData + (src_y + 2) * srcStep))[left_x]);\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       0.0625f * (((srcData + (src_y - 2) * srcStep))[right_x]);\nsum = sum + 0.25f   * (((srcData + (src_y - 1) * srcStep))[right_x]);\nsum = sum + 0.375f  * (((srcData + (src_y    ) * srcStep))[right_x]);\nsum = sum + 0.25f   * (((srcData + (src_y + 1) * srcStep))[right_x]);\nsum = sum + 0.0625f * (((srcData + (src_y + 2) * srcStep))[right_x]);\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       0.0625f * (((srcData + idx_row(src_y - 2, last_row) * srcStep))[col]);\nsum = sum + 0.25f   * (((srcData + idx_row(src_y - 1, last_row) * srcStep))[col]);\nsum = sum + 0.375f  * (((srcData + idx_row(src_y    , last_row) * srcStep))[col]);\nsum = sum + 0.25f   * (((srcData + idx_row(src_y + 1, last_row) * srcStep))[col]);\nsum = sum + 0.0625f * (((srcData + idx_row(src_y + 2, last_row) * srcStep))[col]);\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       0.0625f * (((srcData + idx_row(src_y - 2, last_row) * srcStep))[col]);\nsum = sum + 0.25f   * (((srcData + idx_row(src_y - 1, last_row) * srcStep))[col]);\nsum = sum + 0.375f  * (((srcData + idx_row(src_y    , last_row) * srcStep))[col]);\nsum = sum + 0.25f   * (((srcData + idx_row(src_y + 1, last_row) * srcStep))[col]);\nsum = sum + 0.0625f * (((srcData + idx_row(src_y + 2, last_row) * srcStep))[col]);\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       0.0625f * (((srcData + idx_row(src_y - 2, last_row) * srcStep))[col]);\nsum = sum + 0.25f   * (((srcData + idx_row(src_y - 1, last_row) * srcStep))[col]);\nsum = sum + 0.375f  * (((srcData + idx_row(src_y    , last_row) * srcStep))[col]);\nsum = sum + 0.25f   * (((srcData + idx_row(src_y + 1, last_row) * srcStep))[col]);\nsum = sum + 0.0625f * (((srcData + idx_row(src_y + 2, last_row) * srcStep))[col]);\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       0.0625f * smem[2 + tid2 - 2];\nsum = sum + 0.25f   * smem[2 + tid2 - 1];\nsum = sum + 0.375f  * smem[2 + tid2    ];\nsum = sum + 0.25f   * smem[2 + tid2 + 1];\nsum = sum + 0.0625f * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep + dst_x] = convert_uchar_sat_rte(sum);\n}\n}\n__kernel void pyrDown_C4_D0(__global uchar4 * srcData, int srcStep, int srcRows, int srcCols, __global uchar4 *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float4 smem[256 + 4];\nfloat4 sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nfloat4 co1 = 0.375f;\nfloat4 co2 = 0.25f;\nfloat4 co3 = 0.0625f;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       co3 * convert_float4((((srcData + (src_y - 2) * srcStep / 4))[x]));\nsum = sum + co2 * convert_float4((((srcData + (src_y - 1) * srcStep / 4))[x]));\nsum = sum + co1 * convert_float4((((srcData + (src_y    ) * srcStep / 4))[x]));\nsum = sum + co2 * convert_float4((((srcData + (src_y + 1) * srcStep / 4))[x]));\nsum = sum + co3 * convert_float4((((srcData + (src_y + 2) * srcStep / 4))[x]));\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       co3 * convert_float4((((srcData + (src_y - 2) * srcStep / 4))[left_x]));\nsum = sum + co2 * convert_float4((((srcData + (src_y - 1) * srcStep / 4))[left_x]));\nsum = sum + co1 * convert_float4((((srcData + (src_y    ) * srcStep / 4))[left_x]));\nsum = sum + co2 * convert_float4((((srcData + (src_y + 1) * srcStep / 4))[left_x]));\nsum = sum + co3 * convert_float4((((srcData + (src_y + 2) * srcStep / 4))[left_x]));\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       co3 * convert_float4((((srcData + (src_y - 2) * srcStep / 4))[right_x]));\nsum = sum + co2 * convert_float4((((srcData + (src_y - 1) * srcStep / 4))[right_x]));\nsum = sum + co1 * convert_float4((((srcData + (src_y    ) * srcStep / 4))[right_x]));\nsum = sum + co2 * convert_float4((((srcData + (src_y + 1) * srcStep / 4))[right_x]));\nsum = sum + co3 * convert_float4((((srcData + (src_y + 2) * srcStep / 4))[right_x]));\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       co3 * convert_float4((((srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]));\nsum = sum + co2 * convert_float4((((srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]));\nsum = sum + co1 * convert_float4((((srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]));\nsum = sum + co2 * convert_float4((((srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]));\nsum = sum + co3 * convert_float4((((srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]));\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       co3 * convert_float4((((srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]));\nsum = sum + co2 * convert_float4((((srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]));\nsum = sum + co1 * convert_float4((((srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]));\nsum = sum + co2 * convert_float4((((srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]));\nsum = sum + co3 * convert_float4((((srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]));\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       co3 * convert_float4((((srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]));\nsum = sum + co2 * convert_float4((((srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]));\nsum = sum + co1 * convert_float4((((srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]));\nsum = sum + co2 * convert_float4((((srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]));\nsum = sum + co3 * convert_float4((((srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]));\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       co3 * smem[2 + tid2 - 2];\nsum = sum + co2 * smem[2 + tid2 - 1];\nsum = sum + co1 * smem[2 + tid2    ];\nsum = sum + co2 * smem[2 + tid2 + 1];\nsum = sum + co3 * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep / 4 + dst_x] = convert_uchar4_sat_rte(sum);\n}\n}\n__kernel void pyrDown_C1_D2(__global ushort * srcData, int srcStep, int srcRows, int srcCols, __global ushort *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float smem[256 + 4];\nfloat sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       0.0625f * ((__global ushort*)((__global char*)srcData + (src_y - 2) * srcStep))[x];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + (src_y - 1) * srcStep))[x];\nsum = sum + 0.375f  * ((__global ushort*)((__global char*)srcData + (src_y    ) * srcStep))[x];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + (src_y + 1) * srcStep))[x];\nsum = sum + 0.0625f * ((__global ushort*)((__global char*)srcData + (src_y + 2) * srcStep))[x];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       0.0625f * ((__global ushort*)((__global char*)srcData + (src_y - 2) * srcStep))[left_x];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + (src_y - 1) * srcStep))[left_x];\nsum = sum + 0.375f  * ((__global ushort*)((__global char*)srcData + (src_y    ) * srcStep))[left_x];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + (src_y + 1) * srcStep))[left_x];\nsum = sum + 0.0625f * ((__global ushort*)((__global char*)srcData + (src_y + 2) * srcStep))[left_x];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       0.0625f * ((__global ushort*)((__global char*)srcData + (src_y - 2) * srcStep))[right_x];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + (src_y - 1) * srcStep))[right_x];\nsum = sum + 0.375f  * ((__global ushort*)((__global char*)srcData + (src_y    ) * srcStep))[right_x];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + (src_y + 1) * srcStep))[right_x];\nsum = sum + 0.0625f * ((__global ushort*)((__global char*)srcData + (src_y + 2) * srcStep))[right_x];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       0.0625f * ((__global ushort*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global ushort*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global ushort*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       0.0625f * ((__global ushort*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global ushort*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global ushort*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       0.0625f * ((__global ushort*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global ushort*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global ushort*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global ushort*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       0.0625f * smem[2 + tid2 - 2];\nsum = sum + 0.25f   * smem[2 + tid2 - 1];\nsum = sum + 0.375f  * smem[2 + tid2    ];\nsum = sum + 0.25f   * smem[2 + tid2 + 1];\nsum = sum + 0.0625f * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep / 2 + dst_x] = convert_ushort_sat_rte(sum);\n}\n}\n__kernel void pyrDown_C4_D2(__global ushort4 * srcData, int srcStep, int srcRows, int srcCols, __global ushort4 *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float4 smem[256 + 4];\nfloat4 sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nfloat4 co1 = 0.375f;\nfloat4 co2 = 0.25f;\nfloat4 co3 = 0.0625f;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[x]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[x]);\nsum = sum + co1 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[x]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[x]);\nsum = sum + co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[x]);\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[left_x]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[left_x]);\nsum = sum + co1 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[left_x]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[left_x]);\nsum = sum + co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[left_x]);\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[right_x]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[right_x]);\nsum = sum + co1 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[right_x]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[right_x]);\nsum = sum + co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[right_x]);\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]);\nsum = sum + co1 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]);\nsum = sum + co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]);\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]);\nsum = sum + co1 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]);\nsum = sum + co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]);\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]);\nsum = sum + co1 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]);\nsum = sum + co3 * convert_float4(((__global ushort4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]);\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       co3 * smem[2 + tid2 - 2];\nsum = sum + co2 * smem[2 + tid2 - 1];\nsum = sum + co1 * smem[2 + tid2    ];\nsum = sum + co2 * smem[2 + tid2 + 1];\nsum = sum + co3 * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep / 8 + dst_x] = convert_ushort4_sat_rte(sum);\n}\n}\n__kernel void pyrDown_C1_D3(__global short * srcData, int srcStep, int srcRows, int srcCols, __global short *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float smem[256 + 4];\nfloat sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       0.0625f * ((__global short*)((__global char*)srcData + (src_y - 2) * srcStep))[x];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + (src_y - 1) * srcStep))[x];\nsum = sum + 0.375f  * ((__global short*)((__global char*)srcData + (src_y    ) * srcStep))[x];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + (src_y + 1) * srcStep))[x];\nsum = sum + 0.0625f * ((__global short*)((__global char*)srcData + (src_y + 2) * srcStep))[x];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       0.0625f * ((__global short*)((__global char*)srcData + (src_y - 2) * srcStep))[left_x];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + (src_y - 1) * srcStep))[left_x];\nsum = sum + 0.375f  * ((__global short*)((__global char*)srcData + (src_y    ) * srcStep))[left_x];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + (src_y + 1) * srcStep))[left_x];\nsum = sum + 0.0625f * ((__global short*)((__global char*)srcData + (src_y + 2) * srcStep))[left_x];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       0.0625f * ((__global short*)((__global char*)srcData + (src_y - 2) * srcStep))[right_x];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + (src_y - 1) * srcStep))[right_x];\nsum = sum + 0.375f  * ((__global short*)((__global char*)srcData + (src_y    ) * srcStep))[right_x];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + (src_y + 1) * srcStep))[right_x];\nsum = sum + 0.0625f * ((__global short*)((__global char*)srcData + (src_y + 2) * srcStep))[right_x];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       0.0625f * ((__global short*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global short*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global short*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       0.0625f * ((__global short*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global short*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global short*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       0.0625f * ((__global short*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global short*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global short*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global short*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       0.0625f * smem[2 + tid2 - 2];\nsum = sum + 0.25f   * smem[2 + tid2 - 1];\nsum = sum + 0.375f  * smem[2 + tid2    ];\nsum = sum + 0.25f   * smem[2 + tid2 + 1];\nsum = sum + 0.0625f * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep / 2 + dst_x] = convert_short_sat_rte(sum);\n}\n}\n__kernel void pyrDown_C4_D3(__global short4 * srcData, int srcStep, int srcRows, int srcCols, __global short4 *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float4 smem[256 + 4];\nfloat4 sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nfloat4 co1 = 0.375f;\nfloat4 co2 = 0.25f;\nfloat4 co3 = 0.0625f;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       co3 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[x]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[x]);\nsum = sum + co1 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[x]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[x]);\nsum = sum + co3 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[x]);\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       co3 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[left_x]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[left_x]);\nsum = sum + co1 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[left_x]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[left_x]);\nsum = sum + co3 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[left_x]);\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       co3 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[right_x]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[right_x]);\nsum = sum + co1 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[right_x]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[right_x]);\nsum = sum + co3 * convert_float4(((__global short4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[right_x]);\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       co3 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]);\nsum = sum + co1 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]);\nsum = sum + co3 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]);\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       co3 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]);\nsum = sum + co1 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]);\nsum = sum + co3 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]);\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       co3 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]);\nsum = sum + co1 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]);\nsum = sum + co2 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]);\nsum = sum + co3 * convert_float4(((__global short4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]);\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       co3 * smem[2 + tid2 - 2];\nsum = sum + co2 * smem[2 + tid2 - 1];\nsum = sum + co1 * smem[2 + tid2    ];\nsum = sum + co2 * smem[2 + tid2 + 1];\nsum = sum + co3 * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep / 8 + dst_x] = convert_short4_sat_rte(sum);\n}\n}\n__kernel void pyrDown_C1_D5(__global float * srcData, int srcStep, int srcRows, int srcCols, __global float *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float smem[256 + 4];\nfloat sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       0.0625f * ((__global float*)((__global char*)srcData + (src_y - 2) * srcStep))[x];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y - 1) * srcStep))[x];\nsum = sum + 0.375f  * ((__global float*)((__global char*)srcData + (src_y    ) * srcStep))[x];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y + 1) * srcStep))[x];\nsum = sum + 0.0625f * ((__global float*)((__global char*)srcData + (src_y + 2) * srcStep))[x];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       0.0625f * ((__global float*)((__global char*)srcData + (src_y - 2) * srcStep))[left_x];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y - 1) * srcStep))[left_x];\nsum = sum + 0.375f  * ((__global float*)((__global char*)srcData + (src_y    ) * srcStep))[left_x];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y + 1) * srcStep))[left_x];\nsum = sum + 0.0625f * ((__global float*)((__global char*)srcData + (src_y + 2) * srcStep))[left_x];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       0.0625f * ((__global float*)((__global char*)srcData + (src_y - 2) * srcStep))[right_x];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y - 1) * srcStep))[right_x];\nsum = sum + 0.375f  * ((__global float*)((__global char*)srcData + (src_y    ) * srcStep))[right_x];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y + 1) * srcStep))[right_x];\nsum = sum + 0.0625f * ((__global float*)((__global char*)srcData + (src_y + 2) * srcStep))[right_x];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global float*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global float*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\nsum = sum + 0.375f  * ((__global float*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\nsum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\nsum = sum + 0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       0.0625f * smem[2 + tid2 - 2];\nsum = sum + 0.25f   * smem[2 + tid2 - 1];\nsum = sum + 0.375f  * smem[2 + tid2    ];\nsum = sum + 0.25f   * smem[2 + tid2 + 1];\nsum = sum + 0.0625f * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep / 4 + dst_x] = sum;\n}\n}\n__kernel void pyrDown_C4_D5(__global float4 * srcData, int srcStep, int srcRows, int srcCols, __global float4 *dst, int dstStep, int dstCols)\n{\nconst int x = get_global_id(0);\nconst int y = get_group_id(1);\n__local float4 smem[256 + 4];\nfloat4 sum;\nconst int src_y = 2*y;\nconst int last_row = srcRows - 1;\nconst int last_col = srcCols - 1;\nfloat4 co1 = 0.375f;\nfloat4 co2 = 0.25f;\nfloat4 co3 = 0.0625f;\nif (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n{\nsum =       co3 * ((__global float4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[x];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[x];\nsum = sum + co1 * ((__global float4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[x];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[x];\nsum = sum + co3 * ((__global float4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[x];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\nsum =       co3 * ((__global float4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[left_x];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[left_x];\nsum = sum + co1 * ((__global float4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[left_x];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[left_x];\nsum = sum + co3 * ((__global float4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[left_x];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\nsum =       co3 * ((__global float4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[right_x];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[right_x];\nsum = sum + co1 * ((__global float4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[right_x];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[right_x];\nsum = sum + co3 * ((__global float4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[right_x];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nelse\n{\nint col = idx_col(x, last_col);\nsum =       co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col];\nsum = sum + co1 * ((__global float4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col];\nsum = sum + co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col];\nsmem[2 + get_local_id(0)] = sum;\nif (get_local_id(0) < 2)\n{\nconst int left_x = x - 2;\ncol = idx_col(left_x, last_col);\nsum =       co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col];\nsum = sum + co1 * ((__global float4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col];\nsum = sum + co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col];\nsmem[get_local_id(0)] = sum;\n}\nif (get_local_id(0) > 253)\n{\nconst int right_x = x + 2;\ncol = idx_col(right_x, last_col);\nsum =       co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col];\nsum = sum + co1 * ((__global float4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col];\nsum = sum + co2 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col];\nsum = sum + co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col];\nsmem[4 + get_local_id(0)] = sum;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (get_local_id(0) < 128)\n{\nconst int tid2 = get_local_id(0) * 2;\nsum =       co3 * smem[2 + tid2 - 2];\nsum = sum + co2 * smem[2 + tid2 - 1];\nsum = sum + co1 * smem[2 + tid2    ];\nsum = sum + co2 * smem[2 + tid2 + 1];\nsum = sum + co3 * smem[2 + tid2 + 2];\nconst int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\nif (dst_x < dstCols)\ndst[y * dstStep / 16 + dst_x] = sum;\n}\n}\n", "a852332a866d8849b7d1bfdd7017b87f", "optical_flow_farneback", "#define tx  (int)get_local_id(0)\n#define ty  get_local_id(1)\n#define bx  get_group_id(0)\n#define bdx (int)get_local_size(0)\n#define BORDER_SIZE 5\n#define MAX_KSIZE_HALF 100\n#ifndef polyN\n#define polyN 5\n#endif\n__kernel void polynomialExpansion(__global float * dst,\n__global __const float * src,\n__global __const float * c_g,\n__global __const float * c_xg,\n__global __const float * c_xxg,\n__local float * smem,\nconst float4 ig,\nconst int height, const int width,\nint dstStep, int srcStep)\n{\nconst int y = get_global_id(1);\nconst int x = bx * (bdx - 2*polyN) + tx - polyN;\ndstStep /= sizeof(*dst);\nsrcStep /= sizeof(*src);\nint xWarped;\n__local float *row = smem + tx;\nif (y < height && y >= 0)\n{\nxWarped = min(max(x, 0), width - 1);\nrow[0] = src[mad24(y, srcStep, xWarped)] * c_g[0];\nrow[bdx] = 0.f;\nrow[2*bdx] = 0.f;\n#pragma unroll\nfor (int k = 1; k <= polyN; ++k)\n{\nfloat t0 = src[mad24(max(y - k, 0), srcStep, xWarped)];\nfloat t1 = src[mad24(min(y + k, height - 1), srcStep, xWarped)];\nrow[0] += c_g[k] * (t0 + t1);\nrow[bdx] += c_xg[k] * (t1 - t0);\nrow[2*bdx] += c_xxg[k] * (t0 + t1);\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (y < height && y >= 0 && tx >= polyN && tx + polyN < bdx && x < width)\n{\nfloat b1 = c_g[0] * row[0];\nfloat b3 = c_g[0] * row[bdx];\nfloat b5 = c_g[0] * row[2*bdx];\nfloat b2 = 0, b4 = 0, b6 = 0;\n#pragma unroll\nfor (int k = 1; k <= polyN; ++k)\n{\nb1 += (row[k] + row[-k]) * c_g[k];\nb4 += (row[k] + row[-k]) * c_xxg[k];\nb2 += (row[k] - row[-k]) * c_xg[k];\nb3 += (row[k + bdx] + row[-k + bdx]) * c_g[k];\nb6 += (row[k + bdx] - row[-k + bdx]) * c_xg[k];\nb5 += (row[k + 2*bdx] + row[-k + 2*bdx]) * c_g[k];\n}\ndst[mad24(y, dstStep, xWarped)] = b3*ig.s0;\ndst[mad24(height + y, dstStep, xWarped)] = b2*ig.s0;\ndst[mad24(2*height + y, dstStep, xWarped)] = b1*ig.s1 + b5*ig.s2;\ndst[mad24(3*height + y, dstStep, xWarped)] = b1*ig.s1 + b4*ig.s2;\ndst[mad24(4*height + y, dstStep, xWarped)] = b6*ig.s3;\n}\n}\nint idx_row_low(const int y, const int last_row)\n{\nreturn abs(y) % (last_row + 1);\n}\nint idx_row_high(const int y, const int last_row)\n{\nreturn abs(last_row - abs(last_row - y)) % (last_row + 1);\n}\nint idx_row(const int y, const int last_row)\n{\nreturn idx_row_low(idx_row_high(y, last_row), last_row);\n}\nint idx_col_low(const int x, const int last_col)\n{\nreturn abs(x) % (last_col + 1);\n}\nint idx_col_high(const int x, const int last_col)\n{\nreturn abs(last_col - abs(last_col - x)) % (last_col + 1);\n}\nint idx_col(const int x, const int last_col)\n{\nreturn idx_col_low(idx_col_high(x, last_col), last_col);\n}\n__kernel void gaussianBlur(__global float * dst,\n__global const float * src,\n__global const float * c_gKer,\n__local float * smem,\nconst int height,  const int width,\nint dstStep, int srcStep,\nconst int ksizeHalf)\n{\nconst int y = get_global_id(1);\nconst int x = get_global_id(0);\ndstStep /= sizeof(*dst);\nsrcStep /= sizeof(*src);\n__local float *row = smem + ty * (bdx + 2*ksizeHalf);\nif (y < height)\n{\nfor (int i = tx; i < bdx + 2*ksizeHalf; i += bdx)\n{\nint xExt = (int)(bx * bdx) + i - ksizeHalf;\nxExt = idx_col(xExt, width - 1);\nrow[i] = src[mad24(y, srcStep, xExt)] * c_gKer[0];\nfor (int j = 1; j <= ksizeHalf; ++j)\nrow[i] += (src[mad24(idx_row_low(y - j, height - 1), srcStep, xExt)]\n+ src[mad24(idx_row_high(y + j, height - 1), srcStep, xExt)]) * c_gKer[j];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (y < height && y >= 0 && x < width && x >= 0)\n{\nrow += tx + ksizeHalf;\nfloat res = row[0] * c_gKer[0];\nfor (int i = 1; i <= ksizeHalf; ++i)\nres += (row[-i] + row[i]) * c_gKer[i];\ndst[mad24(y, dstStep, x)] = res;\n}\n}\n__constant float c_border[BORDER_SIZE + 1] = { 0.14f, 0.14f, 0.4472f, 0.4472f, 0.4472f, 1.f };\n__kernel void updateMatrices(__global float * M,\n__global const float * flowx, __global const float * flowy,\n__global const float * R0, __global const float * R1,\nconst int height, const int width,\nint mStep, int xStep,  int yStep, int R0Step, int R1Step)\n{\nconst int y = get_global_id(1);\nconst int x = get_global_id(0);\nmStep /= sizeof(*M);\nxStep /= sizeof(*flowx);\nyStep /= sizeof(*flowy);\nR0Step /= sizeof(*R0);\nR1Step /= sizeof(*R1);\nif (y < height && y >= 0 && x < width && x >= 0)\n{\nfloat dx = flowx[mad24(y, xStep, x)];\nfloat dy = flowy[mad24(y, yStep, x)];\nfloat fx = x + dx;\nfloat fy = y + dy;\nint x1 = convert_int(floor(fx));\nint y1 = convert_int(floor(fy));\nfx -= x1;\nfy -= y1;\nfloat r2, r3, r4, r5, r6;\nif (x1 >= 0 && y1 >= 0 && x1 < width - 1 && y1 < height - 1)\n{\nfloat a00 = (1.f - fx) * (1.f - fy);\nfloat a01 = fx * (1.f - fy);\nfloat a10 = (1.f - fx) * fy;\nfloat a11 = fx * fy;\nr2 = a00 * R1[mad24(y1, R1Step, x1)] +\na01 * R1[mad24(y1, R1Step, x1 + 1)] +\na10 * R1[mad24(y1 + 1, R1Step, x1)] +\na11 * R1[mad24(y1 + 1, R1Step, x1 + 1)];\nr3 = a00 * R1[mad24(height + y1, R1Step, x1)] +\na01 * R1[mad24(height + y1, R1Step, x1 + 1)] +\na10 * R1[mad24(height + y1 + 1, R1Step, x1)] +\na11 * R1[mad24(height + y1 + 1, R1Step, x1 + 1)];\nr4 = a00 * R1[mad24(2*height + y1, R1Step, x1)] +\na01 * R1[mad24(2*height + y1, R1Step, x1 + 1)] +\na10 * R1[mad24(2*height + y1 + 1, R1Step, x1)] +\na11 * R1[mad24(2*height + y1 + 1, R1Step, x1 + 1)];\nr5 = a00 * R1[mad24(3*height + y1, R1Step, x1)] +\na01 * R1[mad24(3*height + y1, R1Step, x1 + 1)] +\na10 * R1[mad24(3*height + y1 + 1, R1Step, x1)] +\na11 * R1[mad24(3*height + y1 + 1, R1Step, x1 + 1)];\nr6 = a00 * R1[mad24(4*height + y1, R1Step, x1)] +\na01 * R1[mad24(4*height + y1, R1Step, x1 + 1)] +\na10 * R1[mad24(4*height + y1 + 1, R1Step, x1)] +\na11 * R1[mad24(4*height + y1 + 1, R1Step, x1 + 1)];\nr4 = (R0[mad24(2*height + y, R0Step, x)] + r4) * 0.5f;\nr5 = (R0[mad24(3*height + y, R0Step, x)] + r5) * 0.5f;\nr6 = (R0[mad24(4*height + y, R0Step, x)] + r6) * 0.25f;\n}\nelse\n{\nr2 = r3 = 0.f;\nr4 = R0[mad24(2*height + y, R0Step, x)];\nr5 = R0[mad24(3*height + y, R0Step, x)];\nr6 = R0[mad24(4*height + y, R0Step, x)] * 0.5f;\n}\nr2 = (R0[mad24(y, R0Step, x)] - r2) * 0.5f;\nr3 = (R0[mad24(height + y, R0Step, x)] - r3) * 0.5f;\nr2 += r4*dy + r6*dx;\nr3 += r6*dy + r5*dx;\nfloat scale =\nc_border[min(x, BORDER_SIZE)] *\nc_border[min(y, BORDER_SIZE)] *\nc_border[min(width - x - 1, BORDER_SIZE)] *\nc_border[min(height - y - 1, BORDER_SIZE)];\nr2 *= scale;\nr3 *= scale;\nr4 *= scale;\nr5 *= scale;\nr6 *= scale;\nM[mad24(y, mStep, x)] = r4*r4 + r6*r6;\nM[mad24(height + y, mStep, x)] = (r4 + r5)*r6;\nM[mad24(2*height + y, mStep, x)] = r5*r5 + r6*r6;\nM[mad24(3*height + y, mStep, x)] = r4*r2 + r6*r3;\nM[mad24(4*height + y, mStep, x)] = r6*r2 + r5*r3;\n}\n}\n__kernel void boxFilter5(__global float * dst,\n__global const float * src,\n__local float * smem,\nconst int height,  const int width,\nint dstStep, int srcStep,\nconst int ksizeHalf)\n{\nconst int y = get_global_id(1);\nconst int x = get_global_id(0);\nconst float boxAreaInv = 1.f / ((1 + 2*ksizeHalf) * (1 + 2*ksizeHalf));\nconst int smw = bdx + 2*ksizeHalf;\n__local float *row = smem + 5 * ty * smw;\ndstStep /= sizeof(*dst);\nsrcStep /= sizeof(*src);\nif (y < height)\n{\nfor (int i = tx; i < bdx + 2*ksizeHalf; i += bdx)\n{\nint xExt = (int)(bx * bdx) + i - ksizeHalf;\nxExt = min(max(xExt, 0), width - 1);\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nrow[k*smw + i] = src[mad24(k*height + y, srcStep, xExt)];\nfor (int j = 1; j <= ksizeHalf; ++j)\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nrow[k*smw + i] +=\nsrc[mad24(k*height + max(y - j, 0), srcStep, xExt)] +\nsrc[mad24(k*height + min(y + j, height - 1), srcStep, xExt)];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (y < height && y >= 0 && x < width && x >= 0)\n{\nrow += tx + ksizeHalf;\nfloat res[5];\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nres[k] = row[k*smw];\nfor (int i = 1; i <= ksizeHalf; ++i)\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nres[k] += row[k*smw - i] + row[k*smw + i];\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\ndst[mad24(k*height + y, dstStep, x)] = res[k] * boxAreaInv;\n}\n}\n__kernel void updateFlow(__global float4 * flowx, __global float4 * flowy,\n__global const float4 * M,\nconst int height, const int width,\nint xStep, int yStep, int mStep)\n{\nconst int y = get_global_id(1);\nconst int x = get_global_id(0);\nxStep /= sizeof(*flowx);\nyStep /= sizeof(*flowy);\nmStep /= sizeof(*M);\nif (y < height && y >= 0 && x < width && x >= 0)\n{\nfloat4 g11 = M[mad24(y, mStep, x)];\nfloat4 g12 = M[mad24(height + y, mStep, x)];\nfloat4 g22 = M[mad24(2*height + y, mStep, x)];\nfloat4 h1 =  M[mad24(3*height + y, mStep, x)];\nfloat4 h2 =  M[mad24(4*height + y, mStep, x)];\nfloat4 detInv = (float4)(1.f) / (g11*g22 - g12*g12 + (float4)(1e-3f));\nflowx[mad24(y, xStep, x)] = (g11*h2 - g12*h1) * detInv;\nflowy[mad24(y, yStep, x)] = (g22*h1 - g12*h2) * detInv;\n}\n}\n__kernel void gaussianBlur5(__global float * dst,\n__global const float * src,\n__global const float * c_gKer,\n__local float * smem,\nconst int height,  const int width,\nint dstStep, int srcStep,\nconst int ksizeHalf)\n{\nconst int y = get_global_id(1);\nconst int x = get_global_id(0);\nconst int smw = bdx + 2*ksizeHalf;\n__local volatile float *row = smem + 5 * ty * smw;\ndstStep /= sizeof(*dst);\nsrcStep /= sizeof(*src);\nif (y < height)\n{\nfor (int i = tx; i < bdx + 2*ksizeHalf; i += bdx)\n{\nint xExt = (int)(bx * bdx) + i - ksizeHalf;\nxExt = idx_col(xExt, width - 1);\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nrow[k*smw + i] = src[mad24(k*height + y, srcStep, xExt)] * c_gKer[0];\nfor (int j = 1; j <= ksizeHalf; ++j)\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nrow[k*smw + i] +=\n(src[mad24(k*height + idx_row_low(y - j, height - 1), srcStep, xExt)] +\nsrc[mad24(k*height + idx_row_high(y + j, height - 1), srcStep, xExt)]) * c_gKer[j];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (y < height && y >= 0 && x < width && x >= 0)\n{\nrow += tx + ksizeHalf;\nfloat res[5];\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nres[k] = row[k*smw] * c_gKer[0];\nfor (int i = 1; i <= ksizeHalf; ++i)\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\nres[k] += (row[k*smw - i] + row[k*smw + i]) * c_gKer[i];\n#pragma unroll\nfor (int k = 0; k < 5; ++k)\ndst[mad24(k*height + y, dstStep, x)] = res[k];\n}\n}\n", "4ea04a3f4d11332d5b2176a64df4ffac", "operator_setToM", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void set_to_with_mask(\n__global GENTYPE * scalar,\n__global GENTYPE * dstMat,\nint cols,\nint rows,\nint dstStep_in_pixel,\nint dstoffset_in_pixel,\n__global const uchar * restrict maskMat,\nint maskStep,\nint maskoffset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint maskidx = mad24(y,maskStep,x+ maskoffset);\nif (maskMat[maskidx])\n{\nint dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\ndstMat[dstidx] = scalar[0];\n}\n}\n}\n", "9a888db2d6921485d70785f94e5a9393", "operator_setTo", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void set_to_without_mask_C1_D0(__global uchar * scalar,__global uchar * dstMat,\nint cols,int rows,int dstStep_in_pixel,int offset_in_pixel)\n{\nint x=get_global_id(0)<<2;\nint y=get_global_id(1);\nint idx = mad24(y,dstStep_in_pixel,x+ offset_in_pixel);\nuchar4 out;\nout.x = out.y = out.z = out.w = scalar[0];\nif ( (x+3 < cols) && (y < rows)&& ((offset_in_pixel&3) == 0))\n{\n*(__global uchar4*)(dstMat+idx) = out;\n}\nelse\n{\nif((x+3 < cols) && (y < rows))\n{\ndstMat[idx] = out.x;\ndstMat[idx+1] = out.y;\ndstMat[idx+2] = out.z;\ndstMat[idx+3] = out.w;\n}\nif((x+2 < cols) && (y < rows))\n{\ndstMat[idx] = out.x;\ndstMat[idx+1] = out.y;\ndstMat[idx+2] = out.z;\n}\nelse if((x+1 < cols) && (y < rows))\n{\ndstMat[idx] = out.x;\ndstMat[idx+1] = out.y;\n}\nelse if((x < cols) && (y < rows))\n{\ndstMat[idx] = out.x;\n}\n}\n}\n__kernel void set_to_without_mask(__global GENTYPE * scalar,__global GENTYPE * dstMat,\nint cols, int rows, int dstStep_in_pixel, int offset_in_pixel)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ( (x < cols) & (y < rows))\n{\nint idx = mad24(y, dstStep_in_pixel, x + offset_in_pixel);\ndstMat[idx] = scalar[0];\n}\n}\n", "a19d7ffed8829cb4d606327c9d41db89", "operator_copyToM", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void copy_to_with_mask(\n__global const GENTYPE* restrict srcMat,\n__global GENTYPE* dstMat,\n__global const uchar* restrict maskMat,\nint cols,\nint rows,\nint srcStep_in_pixel,\nint srcoffset_in_pixel,\nint dstStep_in_pixel,\nint dstoffset_in_pixel,\nint maskStep,\nint maskoffset)\n{\nint x=get_global_id(0);\nint y=get_global_id(1);\nif (x < cols && y < rows)\n{\nint maskidx = mad24(y,maskStep,x+ maskoffset);\nif ( maskMat[maskidx])\n{\nint srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\nint dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\ndstMat[dstidx] = srcMat[srcidx];\n}\n}\n}\n", "c6b06af957485640edb1940b4f8853fc", "operator_convertTo", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void convert_to(\n__global const srcT* restrict srcMat,\n__global dstT* dstMat,\nint cols1, int rows,\nint sstep1, int soffset1,\nint dstep1, int doffset1,\nfloat alpha, float beta)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nint srcidx = mad24(y, sstep1, x + soffset1);\nint dstidx = mad24(y, dstep1, x + doffset1);\nif ( (x < cols1) && (y < rows) )\n{\nfloat temp_src = convert_float(srcMat[srcidx]);\ndstMat[dstidx] = convertToDstType(temp_src*alpha+beta);\n}\n}\n", "3200cfd5ac5217f6e3d92e8af4e31487", "objdetect_hog", "#define CELL_WIDTH 8\n#define CELL_HEIGHT 8\n#define CELLS_PER_BLOCK_X 2\n#define CELLS_PER_BLOCK_Y 2\n#define NTHREADS 256\n#define CV_PI_F 3.1415926535897932384626433832795f\n#ifdef INTEL_DEVICE\n#define QANGLE_TYPE    int\n#define QANGLE_TYPE2  int2\n#else\n#define QANGLE_TYPE    uchar\n#define QANGLE_TYPE2  uchar2\n#endif\n__kernel void compute_hists_lut_kernel(\nconst int cblock_stride_x, const int cblock_stride_y,\nconst int cnbins, const int cblock_hist_size, const int img_block_width,\nconst int blocks_in_group, const int blocks_total,\nconst int grad_quadstep, const int qangle_step,\n__global const float* grad, __global const QANGLE_TYPE* qangle,\n__global const float* gauss_w_lut,\n__global float* block_hists, __local float* smem)\n{\nconst int lx = get_local_id(0);\nconst int lp = lx / 24; \nconst int gid = get_group_id(0) * blocks_in_group + lp;\nconst int gidY = gid / img_block_width;\nconst int gidX = gid - gidY * img_block_width;\nconst int lidX = lx - lp * 24;\nconst int lidY = get_local_id(1);\nconst int cell_x = lidX / 12;\nconst int cell_y = lidY;\nconst int cell_thread_x = lidX - cell_x * 12;\n__local float* hists = smem + lp * cnbins * (CELLS_PER_BLOCK_X *\nCELLS_PER_BLOCK_Y * 12 + CELLS_PER_BLOCK_X * CELLS_PER_BLOCK_Y);\n__local float* final_hist = hists + cnbins *\n(CELLS_PER_BLOCK_X * CELLS_PER_BLOCK_Y * 12);\nconst int offset_x = gidX * cblock_stride_x + (cell_x << 2) + cell_thread_x;\nconst int offset_y = gidY * cblock_stride_y + (cell_y << 2);\n__global const float* grad_ptr = (gid < blocks_total) ?\ngrad + offset_y * grad_quadstep + (offset_x << 1) : grad;\n__global const QANGLE_TYPE* qangle_ptr = (gid < blocks_total) ?\nqangle + offset_y * qangle_step + (offset_x << 1) : qangle;\n__local float* hist = hists + 12 * (cell_y * CELLS_PER_BLOCK_Y + cell_x) +\ncell_thread_x;\nfor (int bin_id = 0; bin_id < cnbins; ++bin_id)\nhist[bin_id * 48] = 0.f;\nconst int dist_x = -4 + cell_thread_x - 4 * cell_x;\nconst int dist_center_x = dist_x - 4 * (1 - 2 * cell_x);\nconst int dist_y_begin = -4 - 4 * lidY;\nfor (int dist_y = dist_y_begin; dist_y < dist_y_begin + 12; ++dist_y)\n{\nfloat2 vote = (float2) (grad_ptr[0], grad_ptr[1]);\nQANGLE_TYPE2 bin = (QANGLE_TYPE2) (qangle_ptr[0], qangle_ptr[1]);\ngrad_ptr += grad_quadstep;\nqangle_ptr += qangle_step;\nint dist_center_y = dist_y - 4 * (1 - 2 * cell_y);\nint idx = (dist_center_y + 8) * 16 + (dist_center_x + 8);\nfloat gaussian = gauss_w_lut[idx];\nidx = (dist_y + 8) * 16 + (dist_x + 8);\nfloat interp_weight = gauss_w_lut[256+idx];\nhist[bin.x * 48] += gaussian * interp_weight * vote.x;\nhist[bin.y * 48] += gaussian * interp_weight * vote.y;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nvolatile __local float* hist_ = hist;\nfor (int bin_id = 0; bin_id < cnbins; ++bin_id, hist_ += 48)\n{\nif (cell_thread_x < 6)\nhist_[0] += hist_[6];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (cell_thread_x < 3)\nhist_[0] += hist_[3];\n#ifdef CPU\nbarrier(CLK_LOCAL_MEM_FENCE);\n#endif\nif (cell_thread_x == 0)\nfinal_hist[(cell_x * 2 + cell_y) * cnbins + bin_id] =\nhist_[0] + hist_[1] + hist_[2];\n}\n#ifdef CPU\nbarrier(CLK_LOCAL_MEM_FENCE);\n#endif\nint tid = (cell_y * CELLS_PER_BLOCK_Y + cell_x) * 12 + cell_thread_x;\nif ((tid < cblock_hist_size) && (gid < blocks_total))\n{\n__global float* block_hist = block_hists +\n(gidY * img_block_width + gidX) * cblock_hist_size;\nblock_hist[tid] = final_hist[tid];\n}\n}\n__kernel void normalize_hists_36_kernel(__global float* block_hists,\nconst float threshold, __local float *squares)\n{\nconst int tid = get_local_id(0);\nconst int gid = get_global_id(0);\nconst int bid = tid / 36;      \nconst int boffset = bid * 36;  \nconst int hid = tid - boffset; \nfloat elem = block_hists[gid];\nsquares[tid] = elem * elem;\nbarrier(CLK_LOCAL_MEM_FENCE);\n__local float* smem = squares + boffset;\nfloat sum = smem[hid];\nif (hid < 18)\nsmem[hid] = sum = sum + smem[hid + 18];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (hid < 9)\nsmem[hid] = sum = sum + smem[hid + 9];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (hid < 4)\nsmem[hid] = sum + smem[hid + 4];\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum = smem[0] + smem[1] + smem[2] + smem[3] + smem[8];\nelem = elem / (sqrt(sum) + 3.6f);\nelem = min(elem, threshold);\nbarrier(CLK_LOCAL_MEM_FENCE);\nsquares[tid] = elem * elem;\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum = smem[hid];\nif (hid < 18)\nsmem[hid] = sum = sum + smem[hid + 18];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (hid < 9)\nsmem[hid] = sum = sum + smem[hid + 9];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (hid < 4)\nsmem[hid] = sum + smem[hid + 4];\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum = smem[0] + smem[1] + smem[2] + smem[3] + smem[8];\nblock_hists[gid] = elem / (sqrt(sum) + 1e-3f);\n}\nfloat reduce_smem(volatile __local float* smem, int size)\n{\nunsigned int tid = get_local_id(0);\nfloat sum = smem[tid];\nif (size >= 512) { if (tid < 256) smem[tid] = sum = sum + smem[tid + 256];\nbarrier(CLK_LOCAL_MEM_FENCE); }\nif (size >= 256) { if (tid < 128) smem[tid] = sum = sum + smem[tid + 128];\nbarrier(CLK_LOCAL_MEM_FENCE); }\nif (size >= 128) { if (tid < 64) smem[tid] = sum = sum + smem[tid + 64];\nbarrier(CLK_LOCAL_MEM_FENCE); }\n#ifdef CPU\nif (size >= 64) { if (tid < 32) smem[tid] = sum = sum + smem[tid + 32];\nbarrier(CLK_LOCAL_MEM_FENCE); }\nif (size >= 32) { if (tid < 16) smem[tid] = sum = sum + smem[tid + 16];\nbarrier(CLK_LOCAL_MEM_FENCE); }\nif (size >= 16) { if (tid < 8) smem[tid] = sum = sum + smem[tid + 8];\nbarrier(CLK_LOCAL_MEM_FENCE); }\nif (size >= 8) { if (tid < 4) smem[tid] = sum = sum + smem[tid + 4];\nbarrier(CLK_LOCAL_MEM_FENCE); }\nif (size >= 4) { if (tid < 2) smem[tid] = sum = sum + smem[tid + 2];\nbarrier(CLK_LOCAL_MEM_FENCE); }\nif (size >= 2) { if (tid < 1) smem[tid] = sum = sum + smem[tid + 1];\nbarrier(CLK_LOCAL_MEM_FENCE); }\n#else\nif (tid < 32)\n{\nif (size >= 64) smem[tid] = sum = sum + smem[tid + 32];\n#if WAVE_SIZE < 32\n} barrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16) {\n#endif\nif (size >= 32) smem[tid] = sum = sum + smem[tid + 16];\nif (size >= 16) smem[tid] = sum = sum + smem[tid + 8];\nif (size >= 8) smem[tid] = sum = sum + smem[tid + 4];\nif (size >= 4) smem[tid] = sum = sum + smem[tid + 2];\nif (size >= 2) smem[tid] = sum = sum + smem[tid + 1];\n}\n#endif\nreturn sum;\n}\n__kernel void normalize_hists_kernel(\nconst int nthreads, const int block_hist_size, const int img_block_width,\n__global float* block_hists, const float threshold, __local float *squares)\n{\nconst int tid = get_local_id(0);\nconst int gidX = get_group_id(0);\nconst int gidY = get_group_id(1);\n__global float* hist = block_hists + (gidY * img_block_width + gidX) *\nblock_hist_size + tid;\nfloat elem = 0.f;\nif (tid < block_hist_size)\nelem = hist[0];\nsquares[tid] = elem * elem;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat sum = reduce_smem(squares, nthreads);\nfloat scale = 1.0f / (sqrt(sum) + 0.1f * block_hist_size);\nelem = min(elem * scale, threshold);\nbarrier(CLK_LOCAL_MEM_FENCE);\nsquares[tid] = elem * elem;\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum = reduce_smem(squares, nthreads);\nscale = 1.0f / (sqrt(sum) + 1e-3f);\nif (tid < block_hist_size)\nhist[0] = elem * scale;\n}\n__kernel void classify_hists_180_kernel(\nconst int cdescr_width, const int cdescr_height, const int cblock_hist_size,\nconst int img_win_width, const int img_block_width,\nconst int win_block_stride_x, const int win_block_stride_y,\n__global const float * block_hists, __global const float* coefs,\nfloat free_coef, float threshold, __global uchar* labels)\n{\nconst int tid = get_local_id(0);\nconst int gidX = get_group_id(0);\nconst int gidY = get_group_id(1);\n__global const float* hist = block_hists + (gidY * win_block_stride_y *\nimg_block_width + gidX * win_block_stride_x) * cblock_hist_size;\nfloat product = 0.f;\nfor (int i = 0; i < cdescr_height; i++)\n{\nproduct += coefs[i * cdescr_width + tid] *\nhist[i * img_block_width * cblock_hist_size + tid];\n}\n__local float products[180];\nproducts[tid] = product;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 90) products[tid] = product = product + products[tid + 90];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 45) products[tid] = product = product + products[tid + 45];\nbarrier(CLK_LOCAL_MEM_FENCE);\nvolatile __local float* smem = products;\n#ifdef CPU\nif (tid < 13) smem[tid] = product = product + smem[tid + 32];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16) smem[tid] = product = product + smem[tid + 16];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<8) smem[tid] = product = product + smem[tid + 8];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<4) smem[tid] = product = product + smem[tid + 4];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<2) smem[tid] = product = product + smem[tid + 2];\nbarrier(CLK_LOCAL_MEM_FENCE);\n#else\nif (tid < 13)\n{\nsmem[tid] = product = product + smem[tid + 32];\n}\n#if WAVE_SIZE < 32\nbarrier(CLK_LOCAL_MEM_FENCE);\n#endif\nif (tid < 16)\n{\nsmem[tid] = product = product + smem[tid + 16];\nsmem[tid] = product = product + smem[tid + 8];\nsmem[tid] = product = product + smem[tid + 4];\nsmem[tid] = product = product + smem[tid + 2];\n}\n#endif\nif (tid == 0){\nproduct = product + smem[tid + 1];\nlabels[gidY * img_win_width + gidX] = (product + free_coef >= threshold);\n}\n}\n__kernel void classify_hists_252_kernel(\nconst int cdescr_width, const int cdescr_height, const int cblock_hist_size,\nconst int img_win_width, const int img_block_width,\nconst int win_block_stride_x, const int win_block_stride_y,\n__global const float * block_hists, __global const float* coefs,\nfloat free_coef, float threshold, __global uchar* labels)\n{\nconst int tid = get_local_id(0);\nconst int gidX = get_group_id(0);\nconst int gidY = get_group_id(1);\n__global const float* hist = block_hists + (gidY * win_block_stride_y *\nimg_block_width + gidX * win_block_stride_x) * cblock_hist_size;\nfloat product = 0.f;\nif (tid < cdescr_width)\n{\nfor (int i = 0; i < cdescr_height; i++)\nproduct += coefs[i * cdescr_width + tid] *\nhist[i * img_block_width * cblock_hist_size + tid];\n}\n__local float products[NTHREADS];\nproducts[tid] = product;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 128) products[tid] = product = product + products[tid + 128];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 64) products[tid] = product = product + products[tid + 64];\nbarrier(CLK_LOCAL_MEM_FENCE);\nvolatile __local float* smem = products;\n#ifdef CPU\nif(tid<32) smem[tid] = product = product + smem[tid + 32];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<16) smem[tid] = product = product + smem[tid + 16];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<8) smem[tid] = product = product + smem[tid + 8];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<4) smem[tid] = product = product + smem[tid + 4];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<2) smem[tid] = product = product + smem[tid + 2];\nbarrier(CLK_LOCAL_MEM_FENCE);\n#else\nif (tid < 32)\n{\nsmem[tid] = product = product + smem[tid + 32];\n#if WAVE_SIZE < 32\n} barrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16) {\n#endif\nsmem[tid] = product = product + smem[tid + 16];\nsmem[tid] = product = product + smem[tid + 8];\nsmem[tid] = product = product + smem[tid + 4];\nsmem[tid] = product = product + smem[tid + 2];\n}\n#endif\nif (tid == 0){\nproduct = product + smem[tid + 1];\nlabels[gidY * img_win_width + gidX] = (product + free_coef >= threshold);\n}\n}\n__kernel void classify_hists_kernel(\nconst int cdescr_size, const int cdescr_width, const int cblock_hist_size,\nconst int img_win_width, const int img_block_width,\nconst int win_block_stride_x, const int win_block_stride_y,\n__global const float * block_hists, __global const float* coefs,\nfloat free_coef, float threshold, __global uchar* labels)\n{\nconst int tid = get_local_id(0);\nconst int gidX = get_group_id(0);\nconst int gidY = get_group_id(1);\n__global const float* hist = block_hists + (gidY * win_block_stride_y *\nimg_block_width + gidX * win_block_stride_x) * cblock_hist_size;\nfloat product = 0.f;\nfor (int i = tid; i < cdescr_size; i += NTHREADS)\n{\nint offset_y = i / cdescr_width;\nint offset_x = i - offset_y * cdescr_width;\nproduct += coefs[i] *\nhist[offset_y * img_block_width * cblock_hist_size + offset_x];\n}\n__local float products[NTHREADS];\nproducts[tid] = product;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 128) products[tid] = product = product + products[tid + 128];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 64) products[tid] = product = product + products[tid + 64];\nbarrier(CLK_LOCAL_MEM_FENCE);\nvolatile __local float* smem = products;\n#ifdef CPU\nif(tid<32) smem[tid] = product = product + smem[tid + 32];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<16) smem[tid] = product = product + smem[tid + 16];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<8) smem[tid] = product = product + smem[tid + 8];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<4) smem[tid] = product = product + smem[tid + 4];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(tid<2) smem[tid] = product = product + smem[tid + 2];\nbarrier(CLK_LOCAL_MEM_FENCE);\n#else\nif (tid < 32)\n{\nsmem[tid] = product = product + smem[tid + 32];\n#if WAVE_SIZE < 32\n} barrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16) {\n#endif\nsmem[tid] = product = product + smem[tid + 16];\nsmem[tid] = product = product + smem[tid + 8];\nsmem[tid] = product = product + smem[tid + 4];\nsmem[tid] = product = product + smem[tid + 2];\n}\n#endif\nif (tid == 0){\nsmem[tid] = product = product + smem[tid + 1];\nlabels[gidY * img_win_width + gidX] = (product + free_coef >= threshold);\n}\n}\n__kernel void extract_descrs_by_rows_kernel(\nconst int cblock_hist_size, const int descriptors_quadstep,\nconst int cdescr_size, const int cdescr_width, const int img_block_width,\nconst int win_block_stride_x, const int win_block_stride_y,\n__global const float* block_hists, __global float* descriptors)\n{\nint tid = get_local_id(0);\nint gidX = get_group_id(0);\nint gidY = get_group_id(1);\n__global const float* hist = block_hists + (gidY * win_block_stride_y *\nimg_block_width + gidX * win_block_stride_x) * cblock_hist_size;\n__global float* descriptor = descriptors +\n(gidY * get_num_groups(0) + gidX) * descriptors_quadstep;\nfor (int i = tid; i < cdescr_size; i += NTHREADS)\n{\nint offset_y = i / cdescr_width;\nint offset_x = i - offset_y * cdescr_width;\ndescriptor[i] = hist[offset_y * img_block_width * cblock_hist_size + offset_x];\n}\n}\n__kernel void extract_descrs_by_cols_kernel(\nconst int cblock_hist_size, const int descriptors_quadstep, const int cdescr_size,\nconst int cnblocks_win_x, const int cnblocks_win_y, const int img_block_width,\nconst int win_block_stride_x, const int win_block_stride_y,\n__global const float* block_hists, __global float* descriptors)\n{\nint tid = get_local_id(0);\nint gidX = get_group_id(0);\nint gidY = get_group_id(1);\n__global const float* hist = block_hists +  (gidY * win_block_stride_y *\nimg_block_width + gidX * win_block_stride_x) * cblock_hist_size;\n__global float* descriptor = descriptors +\n(gidY * get_num_groups(0) + gidX) * descriptors_quadstep;\nfor (int i = tid; i < cdescr_size; i += NTHREADS)\n{\nint block_idx = i / cblock_hist_size;\nint idx_in_block = i - block_idx * cblock_hist_size;\nint y = block_idx / cnblocks_win_x;\nint x = block_idx - y * cnblocks_win_x;\ndescriptor[(x * cnblocks_win_y + y) * cblock_hist_size + idx_in_block] =\nhist[(y * img_block_width  + x) * cblock_hist_size + idx_in_block];\n}\n}\n__kernel void compute_gradients_8UC4_kernel(\nconst int height, const int width,\nconst int img_step, const int grad_quadstep, const int qangle_step,\nconst __global uchar4 * img, __global float * grad, __global QANGLE_TYPE * qangle,\nconst float angle_scale, const char correct_gamma, const int cnbins)\n{\nconst int x = get_global_id(0);\nconst int tid = get_local_id(0);\nconst int gSizeX = get_local_size(0);\nconst int gidY = get_group_id(1);\n__global const uchar4* row = img + gidY * img_step;\n__local float sh_row[(NTHREADS + 2) * 3];\nuchar4 val;\nif (x < width)\nval = row[x];\nelse\nval = row[width - 2];\nsh_row[tid + 1] = val.x;\nsh_row[tid + 1 + (NTHREADS + 2)] = val.y;\nsh_row[tid + 1 + 2 * (NTHREADS + 2)] = val.z;\nif (tid == 0)\n{\nval = row[max(x - 1, 1)];\nsh_row[0] = val.x;\nsh_row[(NTHREADS + 2)] = val.y;\nsh_row[2 * (NTHREADS + 2)] = val.z;\n}\nif (tid == gSizeX - 1)\n{\nval = row[min(x + 1, width - 2)];\nsh_row[gSizeX + 1] = val.x;\nsh_row[gSizeX + 1 + (NTHREADS + 2)] = val.y;\nsh_row[gSizeX + 1 + 2 * (NTHREADS + 2)] = val.z;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (x < width)\n{\nfloat3 a = (float3) (sh_row[tid], sh_row[tid + (NTHREADS + 2)],\nsh_row[tid + 2 * (NTHREADS + 2)]);\nfloat3 b = (float3) (sh_row[tid + 2], sh_row[tid + 2 + (NTHREADS + 2)],\nsh_row[tid + 2 + 2 * (NTHREADS + 2)]);\nfloat3 dx;\nif (correct_gamma == 1)\ndx = sqrt(b) - sqrt(a);\nelse\ndx = b - a;\nfloat3 dy = (float3) 0.f;\nif (gidY > 0 && gidY < height - 1)\n{\na = convert_float3(img[(gidY - 1) * img_step + x].xyz);\nb = convert_float3(img[(gidY + 1) * img_step + x].xyz);\nif (correct_gamma == 1)\ndy = sqrt(b) - sqrt(a);\nelse\ndy = b - a;\n}\nfloat best_dx = dx.x;\nfloat best_dy = dy.x;\nfloat mag0 = dx.x * dx.x + dy.x * dy.x;\nfloat mag1 = dx.y * dx.y + dy.y * dy.y;\nif (mag0 < mag1)\n{\nbest_dx = dx.y;\nbest_dy = dy.y;\nmag0 = mag1;\n}\nmag1 = dx.z * dx.z + dy.z * dy.z;\nif (mag0 < mag1)\n{\nbest_dx = dx.z;\nbest_dy = dy.z;\nmag0 = mag1;\n}\nmag0 = sqrt(mag0);\nfloat ang = (atan2(best_dy, best_dx) + CV_PI_F) * angle_scale - 0.5f;\nint hidx = (int)floor(ang);\nang -= hidx;\nhidx = (hidx + cnbins) % cnbins;\nqangle[(gidY * qangle_step + x) << 1] = hidx;\nqangle[((gidY * qangle_step + x) << 1) + 1] = (hidx + 1) % cnbins;\ngrad[(gidY * grad_quadstep + x) << 1] = mag0 * (1.f - ang);\ngrad[((gidY * grad_quadstep + x) << 1) + 1] = mag0 * ang;\n}\n}\n__kernel void compute_gradients_8UC1_kernel(\nconst int height, const int width,\nconst int img_step, const int grad_quadstep, const int qangle_step,\n__global const uchar * img, __global float * grad, __global QANGLE_TYPE * qangle,\nconst float angle_scale, const char correct_gamma, const int cnbins)\n{\nconst int x = get_global_id(0);\nconst int tid = get_local_id(0);\nconst int gSizeX = get_local_size(0);\nconst int gidY = get_group_id(1);\n__global const uchar* row = img + gidY * img_step;\n__local float sh_row[NTHREADS + 2];\nif (x < width)\nsh_row[tid + 1] = row[x];\nelse\nsh_row[tid + 1] = row[width - 2];\nif (tid == 0)\nsh_row[0] = row[max(x - 1, 1)];\nif (tid == gSizeX - 1)\nsh_row[gSizeX + 1] = row[min(x + 1, width - 2)];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (x < width)\n{\nfloat dx;\nif (correct_gamma == 1)\ndx = sqrt(sh_row[tid + 2]) - sqrt(sh_row[tid]);\nelse\ndx = sh_row[tid + 2] - sh_row[tid];\nfloat dy = 0.f;\nif (gidY > 0 && gidY < height - 1)\n{\nfloat a = (float) img[ (gidY + 1) * img_step + x ];\nfloat b = (float) img[ (gidY - 1) * img_step + x ];\nif (correct_gamma == 1)\ndy = sqrt(a) - sqrt(b);\nelse\ndy = a - b;\n}\nfloat mag = sqrt(dx * dx + dy * dy);\nfloat ang = (atan2(dy, dx) + CV_PI_F) * angle_scale - 0.5f;\nint hidx = (int)floor(ang);\nang -= hidx;\nhidx = (hidx + cnbins) % cnbins;\nqangle[ (gidY * qangle_step + x) << 1 ]     = hidx;\nqangle[ ((gidY * qangle_step + x) << 1) + 1 ] = (hidx + 1) % cnbins;\ngrad[ (gidY * grad_quadstep + x) << 1 ]       = mag * (1.f - ang);\ngrad[ ((gidY * grad_quadstep + x) << 1) + 1 ]   = mag * ang;\n}\n}\n", "9fce6b301b44c107c666aacfb0b0eaf2", "moments", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\ntypedef double T;\n#else\ntypedef long T;\n#endif\n#define DST_ROW_00     0\n#define DST_ROW_10     1\n#define DST_ROW_01     2\n#define DST_ROW_20     3\n#define DST_ROW_11     4\n#define DST_ROW_02     5\n#define DST_ROW_30     6\n#define DST_ROW_21     7\n#define DST_ROW_12     8\n#define DST_ROW_03     9\n__kernel void icvContourMoments(int contour_total,\n__global float* reader_oclmat_data,\n__global T* dst_a,\nint dst_step)\n{\nT xi_1, yi_1, xi_12, yi_12, xi, yi, xi2, yi2, dxy, xii_1, yii_1;\nint idx = get_global_id(0);\nif (idx < 0 || idx >= contour_total)\nreturn;\nxi_1 = (T)(*(reader_oclmat_data + (get_global_id(0) << 1)));\nyi_1 = (T)(*(reader_oclmat_data + (get_global_id(0) << 1) + 1));\nxi_12 = xi_1 * xi_1;\nyi_12 = yi_1 * yi_1;\nif(idx == contour_total - 1)\n{\nxi = (T)(*(reader_oclmat_data));\nyi = (T)(*(reader_oclmat_data + 1));\n}\nelse\n{\nxi = (T)(*(reader_oclmat_data + (idx + 1) * 2));\nyi = (T)(*(reader_oclmat_data + (idx + 1) * 2 + 1));\n}\nxi2 = xi * xi;\nyi2 = yi * yi;\ndxy = xi_1 * yi - xi * yi_1;\nxii_1 = xi_1 + xi;\nyii_1 = yi_1 + yi;\ndst_step /= sizeof(T);\n*( dst_a + DST_ROW_00 * dst_step + idx) = dxy;\n*( dst_a + DST_ROW_10 * dst_step + idx) = dxy * xii_1;\n*( dst_a + DST_ROW_01 * dst_step + idx) = dxy * yii_1;\n*( dst_a + DST_ROW_20 * dst_step + idx) = dxy * (xi_1 * xii_1 + xi2);\n*( dst_a + DST_ROW_11 * dst_step + idx) = dxy * (xi_1 * (yii_1 + yi_1) + xi * (yii_1 + yi));\n*( dst_a + DST_ROW_02 * dst_step + idx) = dxy * (yi_1 * yii_1 + yi2);\n*( dst_a + DST_ROW_30 * dst_step + idx) = dxy * xii_1 * (xi_12 + xi2);\n*( dst_a + DST_ROW_03 * dst_step + idx) = dxy * yii_1 * (yi_12 + yi2);\n*( dst_a + DST_ROW_21 * dst_step + idx) =\ndxy * (xi_12 * (3 * yi_1 + yi) + 2 * xi * xi_1 * yii_1 +\nxi2 * (yi_1 + 3 * yi));\n*( dst_a + DST_ROW_12 * dst_step + idx) =\ndxy * (yi_12 * (3 * xi_1 + xi) + 2 * yi * yi_1 * xii_1 +\nyi2 * (xi_1 + 3 * xi));\n}\n#if defined (DOUBLE_SUPPORT)\n#define WT double\n#define WT4 double4\n#define convert_T4 convert_double4\n#define convert_T convert_double\n#else\n#define WT float\n#define WT4 float4\n#define convert_T4 convert_float4\n#define convert_T convert_float\n#endif\n#ifdef CV_8UC1\n#define TT uchar\n#elif defined CV_16UC1\n#define TT ushort\n#elif defined CV_16SC1\n#define TT short\n#elif defined CV_32FC1\n#define TT float\n#elif defined CV_64FC1\n#ifdef DOUBLE_SUPPORT\n#define TT double\n#else\n#define TT float\n#endif\n#endif\n__kernel void CvMoments(__global TT* src_data, int src_rows, int src_cols, int src_step,\n__global WT* dst_m,\nint dst_cols, int dst_step, int binary)\n{\nint dy = get_global_id(1);\nint ly = get_local_id(1);\nint gidx = get_group_id(0);\nint gidy = get_group_id(1);\nint x_rest = src_cols % 256;\nint y_rest = src_rows % 256;\n__local int codxy[256];\ncodxy[ly] = ly;\nbarrier(CLK_LOCAL_MEM_FENCE);\nWT4 x0 = (WT4)(0.f);\nWT4 x1 = (WT4)(0.f);\nWT4 x2 = (WT4)(0.f);\nWT4 x3 = (WT4)(0.f);\n__global TT* row = src_data + gidy * src_step + ly * src_step + gidx * 256;\nWT4 p;\nWT4 x;\nWT4 xp;\nWT4 xxp;\nWT py = 0.f, sy = 0.f;\nif(dy < src_rows)\n{\nif((x_rest > 0) && (gidx == ((int)get_num_groups(0) - 1)))\n{\nint i;\nfor(i = 0; i < x_rest - 4; i += 4)\n{\np = convert_T4(vload4(0, row + i));\nx = convert_T4(vload4(0, codxy + i));\nxp = x * p;\nxxp = xp * x;\nx0 += p;\nx1 += xp;\nx2 += xxp;\nx3 += convert_T4(xxp * x);\n}\nx0.s0 = x0.s0 + x0.s1 + x0.s2 + x0.s3;\nx1.s0 = x1.s0 + x1.s1 + x1.s2 + x1.s3;\nx2.s0 = x2.s0 + x2.s1 + x2.s2 + x2.s3;\nx3.s0 = x3.s0 + x3.s1 + x3.s2 + x3.s3;\nWT x0_ = 0;\nWT x1_ = 0;\nWT x2_ = 0;\nWT x3_ = 0;\nfor(; i < x_rest; i++)\n{\nWT p_ = 0;\np_ = row[i];\nWT x_ = convert_T(codxy[i]);\nWT xp_ = x_ * p_;\nWT xxp_ = xp_ * x_;\nx0_ += p_;\nx1_ += xp_;\nx2_ += xxp_;\nx3_ += xxp_ * x_;\n}\nx0.s0 += x0_;\nx1.s0 += x1_;\nx2.s0 += x2_;\nx3.s0 += x3_;\n}else\n{\nfor(int i = 0; i < 256; i += 4)\n{\np = convert_T4(vload4(0, row + i));\nx = convert_T4(vload4(0, codxy + i));\nxp = x * p;\nxxp = xp * x;\nx0 += p;\nx1 += xp;\nx2 += xxp;\nx3 += convert_T4(xxp * x);\n}\nx0.s0 = x0.s0 + x0.s1 + x0.s2 + x0.s3;\nx1.s0 = x1.s0 + x1.s1 + x1.s2 + x1.s3;\nx2.s0 = x2.s0 + x2.s1 + x2.s2 + x2.s3;\nx3.s0 = x3.s0 + x3.s1 + x3.s2 + x3.s3;\n}\npy = ly * x0.s0;\nsy = ly * ly;\n}\n__local WT mom[10][256];\nif((y_rest > 0) && (gidy == ((int)get_num_groups(1) - 1)))\n{\nif(ly < y_rest)\n{\nmom[9][ly] = py * sy;\nmom[8][ly] = x1.s0 * sy;\nmom[7][ly] = x2.s0 * ly;\nmom[6][ly] = x3.s0;\nmom[5][ly] = x0.s0 * sy;\nmom[4][ly] = x1.s0 * ly;\nmom[3][ly] = x2.s0;\nmom[2][ly] = py;\nmom[1][ly] = x1.s0;\nmom[0][ly] = x0.s0;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 10)\nfor(int i = 1; i < y_rest; i++)\nmom[ly][0] = mom[ly][i] + mom[ly][0];\n}\nelse\n{\nmom[9][ly] = py * sy;\nmom[8][ly] = x1.s0 * sy;\nmom[7][ly] = x2.s0 * ly;\nmom[6][ly] = x3.s0;\nmom[5][ly] = x0.s0 * sy;\nmom[4][ly] = x1.s0 * ly;\nmom[3][ly] = x2.s0;\nmom[2][ly] = py;\nmom[1][ly] = x1.s0;\nmom[0][ly] = x0.s0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 128)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 128];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 128];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 128];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 128];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 128];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 128];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 128];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 128];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 128];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 128];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 64)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 64];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 64];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 64];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 64];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 64];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 64];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 64];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 64];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 64];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 64];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 32)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 32];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 32];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 32];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 32];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 32];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 32];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 32];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 32];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 32];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 32];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 16)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 16];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 16];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 16];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 16];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 16];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 16];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 16];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 16];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 16];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 16];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 8)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 8];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 8];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 8];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 8];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 8];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 8];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 8];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 8];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 8];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 8];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 4)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 4];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 4];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 4];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 4];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 4];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 4];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 4];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 4];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 4];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 4];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 2)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 2];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 2];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 2];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 2];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 2];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 2];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 2];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 2];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 2];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 2];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 1)\n{\nmom[0][ly] = mom[0][ly] + mom[0][ly + 1];\nmom[1][ly] = mom[1][ly] + mom[1][ly + 1];\nmom[2][ly] = mom[2][ly] + mom[2][ly + 1];\nmom[3][ly] = mom[3][ly] + mom[3][ly + 1];\nmom[4][ly] = mom[4][ly] + mom[4][ly + 1];\nmom[5][ly] = mom[5][ly] + mom[5][ly + 1];\nmom[6][ly] = mom[6][ly] + mom[6][ly + 1];\nmom[7][ly] = mom[7][ly] + mom[7][ly + 1];\nmom[8][ly] = mom[8][ly] + mom[8][ly + 1];\nmom[9][ly] = mom[9][ly] + mom[9][ly + 1];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(binary)\n{\nWT s = 1.0f/255;\nif(ly < 10)\nmom[ly][0] *= s;\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nWT xm = (gidx * 256) * mom[0][0];\nWT ym = (gidy * 256) * mom[0][0];\nif(ly == 0)\n{\nmom[0][1] = mom[0][0];\nmom[1][1] = mom[1][0] + xm;\nmom[2][1] = mom[2][0] + ym;\nmom[3][1] = mom[3][0] + gidx * 256 * (mom[1][0] * 2 + xm);\nmom[4][1] = mom[4][0] + gidx * 256 * (mom[2][0] + ym) + gidy * 256 * mom[1][0];\nmom[5][1] = mom[5][0] + gidy * 256 * (mom[2][0] * 2 + ym);\nmom[6][1] = mom[6][0] + gidx * 256 * (3 * mom[3][0] + 256 * gidx * (3 * mom[1][0] + xm));\nmom[7][1] = mom[7][0] + gidx * 256 * (2 * (mom[4][0] + 256 * gidy * mom[1][0]) + 256 * gidx * (mom[2][0] + ym)) + 256 * gidy * mom[3][0];\nmom[8][1] = mom[8][0] + gidy * 256 * (2 * (mom[4][0] + 256 * gidx * mom[2][0]) + 256 * gidy * (mom[1][0] + xm)) + 256 * gidx * mom[5][0];\nmom[9][1] = mom[9][0] + gidy * 256 * (3 * mom[5][0] + 256 * gidy * (3 * mom[2][0] + ym));\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(ly < 10)\ndst_m[10 * gidy * dst_step + ly * dst_step + gidx] = mom[ly][1];\n}\n", "9145a57effb2e86f802a70722027b627", "merge_mat", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void merge_vector_C2_D0(__global uchar *mat_dst,  int dst_step,  int dst_offset,\n__global uchar *mat_src0, int src0_step, int src0_offset,\n__global uchar *mat_src1, int src1_step, int src1_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nx = x << 1;\n#define dst_align  ((dst_offset & 3) >> 1)\nint src0_index = mad24(y, src0_step, src0_offset + x - dst_align);\nint src1_index = mad24(y, src1_step, src1_offset + x - dst_align);\nint dst_start  = mad24(y, dst_step, dst_offset);\nint dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\nint dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n__global uchar4 * dst  = (__global uchar4 *)(mat_dst + dst_index);\n__global uchar  * src0 = mat_src0 + src0_index;\n__global uchar  * src1 = src0     + 1;\n__global uchar  * src2 = mat_src1 + src1_index;\n__global uchar  * src3 = src2     + 1;\nuchar4 dst_data = *dst;\nuchar  data_0   = *(src0);\nuchar  data_1   = *(src1);\nuchar  data_2   = *(src2);\nuchar  data_3   = *(src3);\nuchar4 tmp_data = (uchar4)(data_0, data_2, data_1, data_3);\ntmp_data.xy = dst_index + 0 >= dst_start ? tmp_data.xy : dst_data.xy;\ntmp_data.zw = dst_index + 2 <  dst_end   ? tmp_data.zw : dst_data.zw;\n*dst = tmp_data;\n}\n}\n__kernel void merge_vector_C2_D1(__global char *mat_dst,  int dst_step,  int dst_offset,\n__global char *mat_src0, int src0_step, int src0_offset,\n__global char *mat_src1, int src1_step, int src1_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nx = x << 1;\n#define dst_align  ((dst_offset & 3) >> 1)\nint src0_index = mad24(y, src0_step, src0_offset + x - dst_align);\nint src1_index = mad24(y, src1_step, src1_offset + x - dst_align);\nint dst_start  = mad24(y, dst_step, dst_offset);\nint dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\nint dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n__global char4 * dst  = (__global char4 *)(mat_dst + dst_index);\n__global char  * src0 = mat_src0 + src0_index;\n__global char  * src1 = src0     + 1;\n__global char  * src2 = mat_src1 + src1_index;\n__global char  * src3 = src2     + 1;\nchar4 dst_data = *dst;\nchar  data_0   = *(src0);\nchar  data_1   = *(src1);\nchar  data_2   = *(src2);\nchar  data_3   = *(src3);\nchar4 tmp_data = (char4)(data_0, data_2, data_1, data_3);\ntmp_data.xy = dst_index + 0 >= dst_start ? tmp_data.xy : dst_data.xy;\ntmp_data.zw = dst_index + 2 <  dst_end   ? tmp_data.zw : dst_data.zw;\n*dst = tmp_data;\n}\n}\n__kernel void merge_vector_C2_D2(__global ushort *mat_dst,  int dst_step,  int dst_offset,\n__global ushort *mat_src0, int src0_step, int src0_offset,\n__global ushort *mat_src1, int src1_step, int src1_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\n__global ushort*  src0 = (__global ushort * )((__global uchar *)mat_src0 + src0_index + (x << 1));\n__global ushort*  src1 = (__global ushort * )((__global uchar *)mat_src1 + src1_index + (x << 1));\n__global ushort2* dist = (__global ushort2 *)((__global uchar *)mat_dst  + dst_index  + (x << 2));\nushort  src0_data = *src0;\nushort  src1_data = *src1;\n*dist = (ushort2)(src0_data, src1_data);\n}\n}\n__kernel void merge_vector_C2_D3(__global short *mat_dst,  int dst_step,  int dst_offset,\n__global short *mat_src0, int src0_step, int src0_offset,\n__global short *mat_src1, int src1_step, int src1_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\n__global short*  src0 = (__global short * )((__global uchar *)mat_src0 + src0_index + (x << 1));\n__global short*  src1 = (__global short * )((__global uchar *)mat_src1 + src1_index + (x << 1));\n__global short2* dist = (__global short2 *)((__global uchar *)mat_dst  + dst_index   + (x << 2));\nshort  src0_data = *src0;\nshort  src1_data = *src1;\n*dist = (short2)(src0_data, src1_data);\n}\n}\n__kernel void merge_vector_C2_D4(__global int *mat_dst,  int dst_step,  int dst_offset,\n__global int *mat_src0, int src0_step, int src0_offset,\n__global int *mat_src1, int src1_step, int src1_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nint src0 = *((__global int *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\nint src1 = *((__global int *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\n*((__global int2 *)((__global uchar *)mat_dst  + dst_index + (x << 3))) = (int2)(src0, src1);\n}\n}\n__kernel void merge_vector_C2_D5(__global float *mat_dst,  int dst_step,  int dst_offset,\n__global float *mat_src0, int src0_step, int src0_offset,\n__global float *mat_src1, int src1_step, int src1_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nfloat src0 = *((__global float *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\nfloat src1 = *((__global float *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\n*((__global float2 *)((__global uchar *)mat_dst  + dst_index + (x << 3))) = (float2)(src0, src1);\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void merge_vector_C2_D6(__global double *mat_dst,  int dst_step,  int dst_offset,\n__global double *mat_src0, int src0_step, int src0_offset,\n__global double *mat_src1, int src1_step, int src1_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\ndouble src0 = *((__global double *)((__global uchar *)mat_src0 + src0_index + (x << 3)));\ndouble src1 = *((__global double *)((__global uchar *)mat_src1 + src1_index + (x << 3)));\n*((__global double2 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (double2)(src0, src1);\n}\n}\n#endif\n__kernel void merge_vector_C3_D0(__global uchar *mat_dst,  int dst_step,  int dst_offset,\n__global uchar *mat_src0, int src0_step, int src0_offset,\n__global uchar *mat_src1, int src1_step, int src1_offset,\n__global uchar *mat_src2, int src2_step, int src2_offset, int offset_cols,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nx = x << 2;\nint src0_index = mad24(y, src0_step, x + src0_offset - offset_cols);\nint src1_index = mad24(y, src1_step, x + src1_offset - offset_cols);\nint src2_index = mad24(y, src2_step, x + src2_offset - offset_cols);\nint dst_start = mad24(y, dst_step, dst_offset);\nint dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\nint dst_index = mad24(y, dst_step, dst_offset + 3 * x - offset_cols * 3);\nuchar data0_0 = *(mat_src0 + src0_index + 0);\nuchar data0_1 = *(mat_src0 + src0_index + 1);\nuchar data0_2 = *(mat_src0 + src0_index + 2);\nuchar data0_3 = *(mat_src0 + src0_index + 3);\nuchar data1_0 = *(mat_src1 + src1_index + 0);\nuchar data1_1 = *(mat_src1 + src1_index + 1);\nuchar data1_2 = *(mat_src1 + src1_index + 2);\nuchar data1_3 = *(mat_src1 + src1_index + 3);\nuchar data2_0 = *(mat_src2 + src2_index + 0);\nuchar data2_1 = *(mat_src2 + src2_index + 1);\nuchar data2_2 = *(mat_src2 + src2_index + 2);\nuchar data2_3 = *(mat_src2 + src2_index + 3);\nuchar4 tmp_data0 = (uchar4)(data0_0, data1_0, data2_0, data0_1);\nuchar4 tmp_data1 = (uchar4)(data1_1, data2_1, data0_2, data1_2);\nuchar4 tmp_data2 = (uchar4)(data2_2, data0_3, data1_3, data2_3);\nuchar4 dst_data0 = *((__global uchar4*)(mat_dst + dst_index + 0));\nuchar4 dst_data1 = *((__global uchar4*)(mat_dst + dst_index + 4));\nuchar4 dst_data2 = *((__global uchar4*)(mat_dst + dst_index + 8));\ntmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\ntmp_data0.y = ((dst_index + 1  >= dst_start) && (dst_index + 1  < dst_end)) ? tmp_data0.y : dst_data0.y;\ntmp_data0.z = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.z : dst_data0.z;\ntmp_data0.w = ((dst_index + 3  >= dst_start) && (dst_index + 3  < dst_end)) ? tmp_data0.w : dst_data0.w;\ntmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\ntmp_data1.y = ((dst_index + 5  >= dst_start) && (dst_index + 5  < dst_end)) ? tmp_data1.y : dst_data1.y;\ntmp_data1.z = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.z : dst_data1.z;\ntmp_data1.w = ((dst_index + 7  >= dst_start) && (dst_index + 7  < dst_end)) ? tmp_data1.w : dst_data1.w;\ntmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\ntmp_data2.y = ((dst_index + 9  >= dst_start) && (dst_index + 9  < dst_end)) ? tmp_data2.y : dst_data2.y;\ntmp_data2.z = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.z : dst_data2.z;\ntmp_data2.w = ((dst_index + 11 >= dst_start) && (dst_index + 11 < dst_end)) ? tmp_data2.w : dst_data2.w;\n*((__global uchar4*)(mat_dst + dst_index + 0)) = tmp_data0;\n*((__global uchar4*)(mat_dst + dst_index + 4)) = tmp_data1;\n*((__global uchar4*)(mat_dst + dst_index + 8)) = tmp_data2;\n}\n}\n__kernel void merge_vector_C3_D1(__global char *mat_dst,  int dst_step,  int dst_offset,\n__global char *mat_src0, int src0_step, int src0_offset,\n__global char *mat_src1, int src1_step, int src1_offset,\n__global char *mat_src2, int src2_step, int src2_offset, int offset_cols,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nx = x << 2;\nint src0_index = mad24(y, src0_step, x + src0_offset - offset_cols);\nint src1_index = mad24(y, src1_step, x + src1_offset - offset_cols);\nint src2_index = mad24(y, src2_step, x + src2_offset - offset_cols);\nint dst_start = mad24(y, dst_step, dst_offset);\nint dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\nint dst_index = mad24(y, dst_step, dst_offset + 3 * x - offset_cols * 3);\nchar data0_0 = *(mat_src0 + src0_index + 0);\nchar data0_1 = *(mat_src0 + src0_index + 1);\nchar data0_2 = *(mat_src0 + src0_index + 2);\nchar data0_3 = *(mat_src0 + src0_index + 3);\nchar data1_0 = *(mat_src1 + src1_index + 0);\nchar data1_1 = *(mat_src1 + src1_index + 1);\nchar data1_2 = *(mat_src1 + src1_index + 2);\nchar data1_3 = *(mat_src1 + src1_index + 3);\nchar data2_0 = *(mat_src2 + src2_index + 0);\nchar data2_1 = *(mat_src2 + src2_index + 1);\nchar data2_2 = *(mat_src2 + src2_index + 2);\nchar data2_3 = *(mat_src2 + src2_index + 3);\nchar4 tmp_data0 = (char4)(data0_0, data1_0, data2_0, data0_1);\nchar4 tmp_data1 = (char4)(data1_1, data2_1, data0_2, data1_2);\nchar4 tmp_data2 = (char4)(data2_2, data0_3, data1_3, data2_3);\nchar4 dst_data0 = *((__global char4*)(mat_dst + dst_index + 0));\nchar4 dst_data1 = *((__global char4*)(mat_dst + dst_index + 4));\nchar4 dst_data2 = *((__global char4*)(mat_dst + dst_index + 8));\ntmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\ntmp_data0.y = ((dst_index + 1  >= dst_start) && (dst_index + 1  < dst_end)) ? tmp_data0.y : dst_data0.y;\ntmp_data0.z = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.z : dst_data0.z;\ntmp_data0.w = ((dst_index + 3  >= dst_start) && (dst_index + 3  < dst_end)) ? tmp_data0.w : dst_data0.w;\ntmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\ntmp_data1.y = ((dst_index + 5  >= dst_start) && (dst_index + 5  < dst_end)) ? tmp_data1.y : dst_data1.y;\ntmp_data1.z = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.z : dst_data1.z;\ntmp_data1.w = ((dst_index + 7  >= dst_start) && (dst_index + 7  < dst_end)) ? tmp_data1.w : dst_data1.w;\ntmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\ntmp_data2.y = ((dst_index + 9  >= dst_start) && (dst_index + 9  < dst_end)) ? tmp_data2.y : dst_data2.y;\ntmp_data2.z = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.z : dst_data2.z;\ntmp_data2.w = ((dst_index + 11 >= dst_start) && (dst_index + 11 < dst_end)) ? tmp_data2.w : dst_data2.w;\n*((__global char4*)(mat_dst + dst_index + 0)) = tmp_data0;\n*((__global char4*)(mat_dst + dst_index + 4)) = tmp_data1;\n*((__global char4*)(mat_dst + dst_index + 8)) = tmp_data2;\n}\n}\n__kernel void merge_vector_C3_D2(__global ushort *mat_dst,  int dst_step,  int dst_offset,\n__global ushort *mat_src0, int src0_step, int src0_offset,\n__global ushort *mat_src1, int src1_step, int src1_offset,\n__global ushort *mat_src2, int src2_step, int src2_offset, int offset_cols,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nx = x << 1;\nint src0_index = mad24(y, src0_step, (x << 1) + src0_offset - offset_cols);\nint src1_index = mad24(y, src1_step, (x << 1) + src1_offset - offset_cols);\nint src2_index = mad24(y, src2_step, (x << 1) + src2_offset - offset_cols);\nint dst_start = mad24(y, dst_step, dst_offset);\nint dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\nint dst_index = mad24(y, dst_step, dst_offset + 6 * x - offset_cols * 6);\nushort data0_0 = *((__global ushort *)((__global char *)mat_src0 + src0_index + 0));\nushort data0_1 = *((__global ushort *)((__global char *)mat_src0 + src0_index + 2));\nushort data1_0 = *((__global ushort *)((__global char *)mat_src1 + src1_index + 0));\nushort data1_1 = *((__global ushort *)((__global char *)mat_src1 + src1_index + 2));\nushort data2_0 = *((__global ushort *)((__global char *)mat_src2 + src2_index + 0));\nushort data2_1 = *((__global ushort *)((__global char *)mat_src2 + src2_index + 2));\nushort2 tmp_data0 = (ushort2)(data0_0, data1_0);\nushort2 tmp_data1 = (ushort2)(data2_0, data0_1);\nushort2 tmp_data2 = (ushort2)(data1_1, data2_1);\nushort2 dst_data0 = *((__global ushort2*)((__global char *)mat_dst + dst_index + 0));\nushort2 dst_data1 = *((__global ushort2*)((__global char *)mat_dst + dst_index + 4));\nushort2 dst_data2 = *((__global ushort2*)((__global char *)mat_dst + dst_index + 8));\ntmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\ntmp_data0.y = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.y : dst_data0.y;\ntmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\ntmp_data1.y = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.y : dst_data1.y;\ntmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\ntmp_data2.y = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.y : dst_data2.y;\n*((__global ushort2*)((__global char *)mat_dst + dst_index + 0)) = tmp_data0;\n*((__global ushort2*)((__global char *)mat_dst + dst_index + 4)) = tmp_data1;\n*((__global ushort2*)((__global char *)mat_dst + dst_index + 8)) = tmp_data2;\n}\n}\n__kernel void merge_vector_C3_D3(__global short *mat_dst,  int dst_step,  int dst_offset,\n__global short *mat_src0, int src0_step, int src0_offset,\n__global short *mat_src1, int src1_step, int src1_offset,\n__global short *mat_src2, int src2_step, int src2_offset, int offset_cols,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nx = x << 1;\nint src0_index = mad24(y, src0_step, (x << 1) + src0_offset - offset_cols);\nint src1_index = mad24(y, src1_step, (x << 1) + src1_offset - offset_cols);\nint src2_index = mad24(y, src2_step, (x << 1) + src2_offset - offset_cols);\nint dst_start = mad24(y, dst_step, dst_offset);\nint dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\nint dst_index = mad24(y, dst_step, dst_offset + 6 * x - offset_cols * 6);\nshort data0_0 = *((__global short *)((__global char *)mat_src0 + src0_index + 0));\nshort data0_1 = *((__global short *)((__global char *)mat_src0 + src0_index + 2));\nshort data1_0 = *((__global short *)((__global char *)mat_src1 + src1_index + 0));\nshort data1_1 = *((__global short *)((__global char *)mat_src1 + src1_index + 2));\nshort data2_0 = *((__global short *)((__global char *)mat_src2 + src2_index + 0));\nshort data2_1 = *((__global short *)((__global char *)mat_src2 + src2_index + 2));\nshort2 tmp_data0 = (short2)(data0_0, data1_0);\nshort2 tmp_data1 = (short2)(data2_0, data0_1);\nshort2 tmp_data2 = (short2)(data1_1, data2_1);\nshort2 dst_data0 = *((__global short2*)((__global char *)mat_dst + dst_index + 0));\nshort2 dst_data1 = *((__global short2*)((__global char *)mat_dst + dst_index + 4));\nshort2 dst_data2 = *((__global short2*)((__global char *)mat_dst + dst_index + 8));\ntmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\ntmp_data0.y = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.y : dst_data0.y;\ntmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\ntmp_data1.y = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.y : dst_data1.y;\ntmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\ntmp_data2.y = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.y : dst_data2.y;\n*((__global short2*)((__global char *)mat_dst + dst_index + 0)) = tmp_data0;\n*((__global short2*)((__global char *)mat_dst + dst_index + 4)) = tmp_data1;\n*((__global short2*)((__global char *)mat_dst + dst_index + 8)) = tmp_data2;\n}\n}\n__kernel void merge_vector_C3_D4(__global int *mat_dst,  int dst_step,  int dst_offset,\n__global int *mat_src0, int src0_step, int src0_offset,\n__global int *mat_src1, int src1_step, int src1_offset,\n__global int *mat_src2, int src2_step, int src2_offset, int offset_cols,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\n__global int* src0 = (__global int * )((__global uchar *)mat_src0 + src0_index + (x << 2));\n__global int* src1 = (__global int * )((__global uchar *)mat_src1 + src1_index + (x << 2));\n__global int* src2 = (__global int * )((__global uchar *)mat_src2 + src2_index + (x << 2));\n__global int* dist0 = (__global int *)((__global uchar *)mat_dst  + dst_index  + 3 * (x << 2));\n__global int* dist1 = dist0 + 1;\n__global int* dist2 = dist0 + 2;\nint  src0_data = *src0;\nint  src1_data = *src1;\nint  src2_data = *src2;\n*dist0 = src0_data;\n*dist1 = src1_data;\n*dist2 = src2_data;\n}\n}\n__kernel void merge_vector_C3_D5(__global float *mat_dst,  int dst_step,  int dst_offset,\n__global float *mat_src0, int src0_step, int src0_offset,\n__global float *mat_src1, int src1_step, int src1_offset,\n__global float *mat_src2, int src2_step, int src2_offset, int offset_cols,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\n__global float* src0 = (__global float * )((__global uchar *)mat_src0 + src0_index + (x << 2));\n__global float* src1 = (__global float * )((__global uchar *)mat_src1 + src1_index + (x << 2));\n__global float* src2 = (__global float * )((__global uchar *)mat_src2 + src2_index + (x << 2));\n__global float* dist0 = (__global float *)((__global uchar *)mat_dst  + dst_index  + 3 * (x << 2));\n__global float* dist1 = dist0 + 1;\n__global float* dist2 = dist0 + 2;\nfloat  src0_data = *src0;\nfloat  src1_data = *src1;\nfloat  src2_data = *src2;\n*dist0 = src0_data;\n*dist1 = src1_data;\n*dist2 = src2_data;\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void merge_vector_C3_D6(__global double *mat_dst,  int dst_step,  int dst_offset,\n__global double *mat_src0, int src0_step, int src0_offset,\n__global double *mat_src1, int src1_step, int src1_offset,\n__global double *mat_src2, int src2_step, int src2_offset, int offset_cols,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\n__global double* src0 = (__global double * )((__global uchar *)mat_src0 + src0_index + (x << 3));\n__global double* src1 = (__global double * )((__global uchar *)mat_src1 + src1_index + (x << 3));\n__global double* src2 = (__global double * )((__global uchar *)mat_src2 + src2_index + (x << 3));\n__global double* dist0 = (__global double *)((__global uchar *)mat_dst  + dst_index  + 3 * (x << 3));\n__global double* dist1 = dist0 + 1;\n__global double* dist2 = dist0 + 2;\ndouble  src0_data = *src0;\ndouble  src1_data = *src1;\ndouble  src2_data = *src2;\n*dist0 = src0_data;\n*dist1 = src1_data;\n*dist2 = src2_data;\n}\n}\n#endif\n__kernel void merge_vector_C4_D0(__global uchar *mat_dst,  int dst_step,  int dst_offset,\n__global uchar *mat_src0, int src0_step, int src0_offset,\n__global uchar *mat_src1, int src1_step, int src1_offset,\n__global uchar *mat_src2, int src2_step, int src2_offset,\n__global uchar *mat_src3, int src3_step, int src3_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint src3_index = mad24(y, src3_step, src3_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nuchar src0 = *(mat_src0 + src0_index + x );\nuchar src1 = *(mat_src1 + src1_index + x);\nuchar src2 = *(mat_src2 + src2_index + x);\nuchar src3 = *(mat_src3 + src3_index + x);\n*((__global uchar4 *)(mat_dst  + dst_index + (x << 2))) = (uchar4)(src0, src1, src2, src3);\n}\n}\n__kernel void merge_vector_C4_D1(__global char *mat_dst,  int dst_step,  int dst_offset,\n__global char *mat_src0, int src0_step, int src0_offset,\n__global char *mat_src1, int src1_step, int src1_offset,\n__global char *mat_src2, int src2_step, int src2_offset,\n__global char *mat_src3, int src3_step, int src3_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint src3_index = mad24(y, src3_step, src3_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nchar src0 = *(mat_src0 + src0_index + x );\nchar src1 = *(mat_src1 + src1_index + x);\nchar src2 = *(mat_src2 + src2_index + x);\nchar src3 = *(mat_src3 + src3_index + x);\n*((__global char4 *)(mat_dst  + dst_index + (x << 2))) = (char4)(src0, src1, src2, src3);\n}\n}\n__kernel void merge_vector_C4_D2(__global ushort *mat_dst,  int dst_step,  int dst_offset,\n__global ushort *mat_src0, int src0_step, int src0_offset,\n__global ushort *mat_src1, int src1_step, int src1_offset,\n__global ushort *mat_src2, int src2_step, int src2_offset,\n__global ushort *mat_src3, int src3_step, int src3_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint src3_index = mad24(y, src3_step, src3_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nushort src0 = *((__global ushort *)((__global uchar *)mat_src0 + src0_index + (x << 1)));\nushort src1 = *((__global ushort *)((__global uchar *)mat_src1 + src1_index + (x << 1)));\nushort src2 = *((__global ushort *)((__global uchar *)mat_src2 + src2_index + (x << 1)));\nushort src3 = *((__global ushort *)((__global uchar *)mat_src3 + src3_index + (x << 1)));\n*((__global ushort4 *)((__global uchar *)mat_dst  + dst_index + (x << 3))) = (ushort4)(src0, src1, src2, src3);\n}\n}\n__kernel void merge_vector_C4_D3(__global short *mat_dst,  int dst_step,  int dst_offset,\n__global short *mat_src0, int src0_step, int src0_offset,\n__global short *mat_src1, int src1_step, int src1_offset,\n__global short *mat_src2, int src2_step, int src2_offset,\n__global short *mat_src3, int src3_step, int src3_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint src3_index = mad24(y, src3_step, src3_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nshort src0 = *((__global short *)((__global uchar *)mat_src0 + src0_index + (x << 1)));\nshort src1 = *((__global short *)((__global uchar *)mat_src1 + src1_index + (x << 1)));\nshort src2 = *((__global short *)((__global uchar *)mat_src2 + src2_index + (x << 1)));\nshort src3 = *((__global short *)((__global uchar *)mat_src3 + src3_index + (x << 1)));\n*((__global short4 *)((__global uchar *)mat_dst  + dst_index + (x << 3))) = (short4)(src0, src1, src2, src3);\n}\n}\n__kernel void merge_vector_C4_D4(__global int *mat_dst,  int dst_step,  int dst_offset,\n__global int *mat_src0, int src0_step, int src0_offset,\n__global int *mat_src1, int src1_step, int src1_offset,\n__global int *mat_src2, int src2_step, int src2_offset,\n__global int *mat_src3, int src3_step, int src3_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint src3_index = mad24(y, src3_step, src3_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nint src0 = *((__global int *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\nint src1 = *((__global int *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\nint src2 = *((__global int *)((__global uchar *)mat_src2 + src2_index + (x << 2)));\nint src3 = *((__global int *)((__global uchar *)mat_src3 + src3_index + (x << 2)));\n*((__global int4 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (int4)(src0, src1, src2, src3);\n}\n}\n__kernel void merge_vector_C4_D5(__global float *mat_dst,  int dst_step,  int dst_offset,\n__global float *mat_src0, int src0_step, int src0_offset,\n__global float *mat_src1, int src1_step, int src1_offset,\n__global float *mat_src2, int src2_step, int src2_offset,\n__global float *mat_src3, int src3_step, int src3_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint src3_index = mad24(y, src3_step, src3_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\nfloat src0 = *((__global float *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\nfloat src1 = *((__global float *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\nfloat src2 = *((__global float *)((__global uchar *)mat_src2 + src2_index + (x << 2)));\nfloat src3 = *((__global float *)((__global uchar *)mat_src3 + src3_index + (x << 2)));\n*((__global float4 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (float4)(src0, src1, src2, src3);\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void merge_vector_C4_D6(__global double *mat_dst,  int dst_step,  int dst_offset,\n__global double *mat_src0, int src0_step, int src0_offset,\n__global double *mat_src1, int src1_step, int src1_offset,\n__global double *mat_src2, int src2_step, int src2_offset,\n__global double *mat_src3, int src3_step, int src3_offset,\nint rows, int cols, int dst_step1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\nint src0_index = mad24(y, src0_step, src0_offset);\nint src1_index = mad24(y, src1_step, src1_offset);\nint src2_index = mad24(y, src2_step, src2_offset);\nint src3_index = mad24(y, src3_step, src3_offset);\nint dst_index  = mad24(y, dst_step , dst_offset);\ndouble src0 = *((__global double *)((__global uchar *)mat_src0 + src0_index + (x << 3)));\ndouble src1 = *((__global double *)((__global uchar *)mat_src1 + src1_index + (x << 3)));\ndouble src2 = *((__global double *)((__global uchar *)mat_src2 + src2_index + (x << 3)));\ndouble src3 = *((__global double *)((__global uchar *)mat_src3 + src3_index + (x << 3)));\n*((__global double4 *)((__global uchar *)mat_dst  + dst_index + (x << 5))) = (double4)(src0, src1, src2, src3);\n}\n}\n#endif\n__kernel void merge_vector_C2_D0_1(int rows, int cols,\n__global uchar *mat_dst,  int dst_step,\n__global uchar *mat_src0, int src0_step,\n__global uchar *mat_src1, int src1_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global uchar4  *src0_y = (__global uchar4 * )(mat_src0 + y * src0_step);\n__global uchar4  *src1_y = (__global uchar4 * )(mat_src1 + y * src1_step);\n__global uchar8 *dst_y  = (__global uchar8 *)(mat_dst  + y * dst_step);\nuchar4 value1 = src0_y[x];\nuchar4 value2 = src1_y[x];\nuchar8 value;\nvalue.even = value1;\nvalue.odd = value2;\ndst_y[x] = value;\n}\n}\n__kernel void merge_vector_C2_D1_1(int rows, int cols,\n__global char *mat_dst,  int dst_step,\n__global char *mat_src0, int src0_step,\n__global char *mat_src1, int src1_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global char4  *src0_y = (__global char4 * )(mat_src0 + y * src0_step);\n__global char4  *src1_y = (__global char4 * )(mat_src1 + y * src1_step);\n__global char8 *dst_y  = (__global char8 *)(mat_dst  + y * dst_step);\nchar4 value1 = src0_y[x];\nchar4 value2 = src1_y[x];\nchar8 value;\nvalue.even = value1;\nvalue.odd = value2;\ndst_y[x] = value;\n}\n}\n__kernel void merge_vector_C2_D2_1(int rows, int cols,\n__global ushort *mat_dst,  int dst_step,\n__global ushort *mat_src0, int src0_step,\n__global ushort *mat_src1, int src1_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global ushort2  *src0_y = (__global ushort2 *)((__global uchar *)mat_src0 + y * src0_step);\n__global ushort2  *src1_y = (__global ushort2 *)((__global uchar *)mat_src1 + y * src1_step);\n__global ushort4  *dst_y  = (__global ushort4 *)((__global uchar *)mat_dst  + y * dst_step);\nushort2 value1 = src0_y[x];\nushort2 value2 = src1_y[x];\nushort4 value;\nvalue.even = value1;\nvalue.odd = value2;\ndst_y[x] = value;\n}\n}\n__kernel void merge_vector_C2_D3_1(int rows, int cols,\n__global short *mat_dst,  int dst_step,\n__global short *mat_src0, int src0_step,\n__global short *mat_src1, int src1_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global short2  *src0_y = (__global short2 *)((__global uchar *)mat_src0 + y * src0_step);\n__global short2  *src1_y = (__global short2 *)((__global uchar *)mat_src1 + y * src1_step);\n__global short4 *dst_y   = (__global short4 *)((__global uchar *)mat_dst  + y * dst_step);\nshort2 value1 = src0_y[x];\nshort2 value2 = src1_y[x];\nshort4 value;\nvalue.even = value1;\nvalue.odd = value2;\ndst_y[x] = value;\n}\n}\n__kernel void merge_vector_C2_D4_1(int rows, int cols,\n__global int *mat_dst,  int dst_step,\n__global int *mat_src0, int src0_step,\n__global int *mat_src1, int src1_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global int  *src0_y = (__global int *)((__global uchar *)mat_src0 + y * src0_step);\n__global int  *src1_y = (__global int *)((__global uchar *)mat_src1 + y * src1_step);\n__global int2  *dst_y  = (__global int2 *)((__global uchar *)mat_dst  + y * dst_step);\nint value1 = src0_y[x];\nint value2 = src1_y[x];\nint2 value;\nvalue.even = value1;\nvalue.odd = value2;\ndst_y[x] = value;\n}\n}\n__kernel void merge_vector_C2_D5_1(int rows, int cols,\n__global float *mat_dst,  int dst_step,\n__global float *mat_src0, int src0_step,\n__global float *mat_src1, int src1_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global float  *src0_y = (__global float *)((__global uchar *)mat_src0 + y * src0_step);\n__global float  *src1_y = (__global float *)((__global uchar *)mat_src1 + y * src1_step);\n__global float2  *dst_y  = (__global float2 *)((__global uchar *)mat_dst  + y * dst_step);\nfloat value1 = src0_y[x];\nfloat value2 = src1_y[x];\ndst_y[x] = (float2)(value1, value2);\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void merge_vector_C2_D6_1(int rows, int cols,\n__global double *mat_dst,  int dst_step,\n__global double *mat_src0, int src0_step,\n__global double *mat_src1, int src1_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global double  *src0_y = (__global double *)((__global uchar *)mat_src0 + y * src0_step);\n__global double  *src1_y = (__global double *)((__global uchar *)mat_src1 + y * src1_step);\n__global double2 *dst_y  = (__global double2 *)((__global uchar *)mat_dst  + y * dst_step);\ndouble value1 = src0_y[x];\ndouble value2 = src1_y[x];\ndst_y[x] = (double2)(value1, value2);\n}\n}\n#endif\n__kernel void merge_vector_C3_D0_1(int rows, int cols,\n__global uchar *mat_dst,  int dst_step,\n__global uchar *mat_src0, int src0_step,\n__global uchar *mat_src1, int src1_step,\n__global uchar *mat_src2, int src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global uchar4  *src0_y = (__global uchar4 * )(mat_src0 + y * src0_step);\n__global uchar4  *src1_y = (__global uchar4 * )(mat_src1 + y * src1_step);\n__global uchar4  *src2_y = (__global uchar4 * )(mat_src2 + y * src0_step);\n__global uchar4 *dst_y  = (__global uchar4 *)(mat_dst  + y * dst_step);\nuchar4 value0 = src0_y[x];\nuchar4 value1 = src1_y[x];\nuchar4 value2 = src2_y[x];\ndst_y[3 * x + 0] = (uchar4)(value0.s0, value1.s0, value2.s0,\nvalue0.s1);\ndst_y[3 * x + 1] = (uchar4)(value1.s1, value2.s1,\nvalue0.s2, value1.s2);\ndst_y[3 * x + 2] = (uchar4)(value2.s2,\nvalue0.s3, value1.s3, value2.s3);\n}\n}\n__kernel void merge_vector_C3_D1_1(int rows, int cols,\n__global char *mat_dst,  int dst_step,\n__global char *mat_src0, int src0_step,\n__global char *mat_src1, int src1_step,\n__global char *mat_src2, int src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global char4  *src0_y = (__global char4 * )(mat_src0 + y * src0_step);\n__global char4  *src1_y = (__global char4 * )(mat_src1 + y * src1_step);\n__global char4  *src2_y = (__global char4 * )(mat_src2 + y * src0_step);\n__global char4 *dst_y  = (__global char4 *)(mat_dst  + y * dst_step);\nchar4 value0 = src0_y[x];\nchar4 value1 = src1_y[x];\nchar4 value2 = src2_y[x];\ndst_y[3 * x + 0] = (char4)(value0.s0, value1.s0, value2.s0,\nvalue0.s1);\ndst_y[3 * x + 1] = (char4)(value1.s1, value2.s1,\nvalue0.s2, value1.s2);\ndst_y[3 * x + 2] = (char4)(value2.s2,\nvalue0.s3, value1.s3, value2.s3);\n}\n}\n__kernel void merge_vector_C3_D2_1(int rows, int cols,\n__global ushort *mat_dst,  int dst_step,\n__global ushort *mat_src0, int src0_step,\n__global ushort *mat_src1, int src1_step,\n__global ushort *mat_src2, int src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global ushort2  *src0_y = (__global ushort2 * )((__global char *)mat_src0 + y * src0_step);\n__global ushort2  *src1_y = (__global ushort2 * )((__global char *)mat_src1 + y * src1_step);\n__global ushort2  *src2_y = (__global ushort2 * )((__global char *)mat_src2 + y * src0_step);\n__global ushort2 *dst_y  = (__global ushort2 *)((__global char *)mat_dst  + y * dst_step);\nushort2 value0 = src0_y[x];\nushort2 value1 = src1_y[x];\nushort2 value2 = src2_y[x];\ndst_y[3 * x + 0] = (ushort2)(value0.x, value1.x);\ndst_y[3 * x + 1] = (ushort2)(value2.x, value0.y);\ndst_y[3 * x + 2] = (ushort2)(value1.y, value2.y);\n}\n}\n__kernel void merge_vector_C3_D3_1(int rows, int cols,\n__global short *mat_dst,  int dst_step,\n__global short *mat_src0, int src0_step,\n__global short *mat_src1, int src1_step,\n__global short *mat_src2, int src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global short2  *src0_y = (__global short2 * )((__global char *)mat_src0 + y * src0_step);\n__global short2  *src1_y = (__global short2 * )((__global char *)mat_src1 + y * src1_step);\n__global short2  *src2_y = (__global short2 * )((__global char *)mat_src2 + y * src0_step);\n__global short2 *dst_y  = (__global short2 *)((__global char *)mat_dst  + y * dst_step);\nshort2 value0 = src0_y[x];\nshort2 value1 = src1_y[x];\nshort2 value2 = src2_y[x];\ndst_y[3 * x + 0] = (short2)(value0.x, value1.x);\ndst_y[3 * x + 1] = (short2)(value2.x, value0.y);\ndst_y[3 * x + 2] = (short2)(value1.y, value2.y);\n}\n}\n__kernel void merge_vector_C3_D4_1(int rows, int cols,\n__global int *mat_dst,  int dst_step,\n__global int *mat_src0, int src0_step,\n__global int *mat_src1, int src1_step,\n__global int *mat_src2, int src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global int  *src0_y = (__global int * )((__global char *)mat_src0 + y * src0_step);\n__global int  *src1_y = (__global int * )((__global char *)mat_src1 + y * src1_step);\n__global int  *src2_y = (__global int * )((__global char *)mat_src2 + y * src0_step);\n__global int *dst_y  = (__global int *)((__global char *)mat_dst  + y * dst_step);\nint value0 = src0_y[x];\nint value1 = src1_y[x];\nint value2 = src2_y[x];\ndst_y[3 * x + 0] = value0;\ndst_y[3 * x + 1] = value1;\ndst_y[3 * x + 2] = value2;\n}\n}\n__kernel void merge_vector_C3_D5_1(int rows, int cols,\n__global float *mat_dst,  int dst_step,\n__global float *mat_src0, int src0_step,\n__global float *mat_src1, int src1_step,\n__global float *mat_src2, int src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global float  *src0_y = (__global float * )((__global char *)mat_src0 + y * src0_step);\n__global float  *src1_y = (__global float * )((__global char *)mat_src1 + y * src1_step);\n__global float  *src2_y = (__global float * )((__global char *)mat_src2 + y * src0_step);\n__global float *dst_y  = (__global float *)((__global char *)mat_dst  + y * dst_step);\nfloat value0 = src0_y[x];\nfloat value1 = src1_y[x];\nfloat value2 = src2_y[x];\ndst_y[3 * x + 0] = value0;\ndst_y[3 * x + 1] = value1;\ndst_y[3 * x + 2] = value2;\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void merge_vector_C3_D6_1(int rows, int cols,\n__global double *mat_dst,  int dst_step,\n__global double *mat_src0, int src0_step,\n__global double *mat_src1, int src1_step,\n__global double *mat_src2, int src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global double  *src0_y = (__global double * )((__global char *)mat_src0 + y * src0_step);\n__global double  *src1_y = (__global double * )((__global char *)mat_src1 + y * src1_step);\n__global double  *src2_y = (__global double * )((__global char *)mat_src2 + y * src0_step);\n__global double *dst_y  = (__global double *)((__global char *)mat_dst  + y * dst_step);\ndouble value0 = src0_y[x];\ndouble value1 = src1_y[x];\ndouble value2 = src2_y[x];\ndst_y[3 * x + 0] = value0;\ndst_y[3 * x + 1] = value1;\ndst_y[3 * x + 2] = value2;\n}\n}\n#endif\n__kernel void merge_vector_C4_D0_1(int rows, int cols,\n__global uchar *mat_dst,  int dst_step,\n__global uchar *mat_src0, int src0_step,\n__global uchar *mat_src1, int src1_step,\n__global uchar *mat_src2, int src2_step,\n__global uchar *mat_src3, int src3_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global uchar4  *src0_y = (__global uchar4 * )(mat_src0 + y * src0_step);\n__global uchar4  *src1_y = (__global uchar4 * )(mat_src1 + y * src1_step);\n__global uchar4  *src2_y = (__global uchar4 * )(mat_src2 + y * src0_step);\n__global uchar4  *src3_y = (__global uchar4 * )(mat_src3 + y * src1_step);\n__global uchar16 *dst_y  = (__global uchar16 *)(mat_dst  + y * dst_step);\nuchar4 value0 = src0_y[x];\nuchar4 value1 = src1_y[x];\nuchar4 value2 = src2_y[x];\nuchar4 value3 = src3_y[x];\ndst_y[x] = (uchar16)(value0.x, value1.x, value2.x, value3.x,\nvalue0.y, value1.y, value2.y, value3.y,\nvalue0.z, value1.z, value2.z, value3.z,\nvalue0.w, value1.w, value2.w, value3.w);\n}\n}\n__kernel void merge_vector_C4_D1_1(int rows, int cols,\n__global char *mat_dst,  int dst_step,\n__global char *mat_src0, int src0_step,\n__global char *mat_src1, int src1_step,\n__global char *mat_src2, int src2_step,\n__global char *mat_src3, int src3_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global char4  *src0_y = (__global char4 * )(mat_src0 + y * src0_step);\n__global char4  *src1_y = (__global char4 * )(mat_src1 + y * src1_step);\n__global char4  *src2_y = (__global char4 * )(mat_src2 + y * src0_step);\n__global char4  *src3_y = (__global char4 * )(mat_src3 + y * src1_step);\n__global char16 *dst_y  = (__global char16 *)(mat_dst  + y * dst_step);\nchar4 value0 = src0_y[x];\nchar4 value1 = src1_y[x];\nchar4 value2 = src2_y[x];\nchar4 value3 = src3_y[x];\ndst_y[x] = (char16)(value0.x, value1.x, value2.x, value3.x,\nvalue0.y, value1.y, value2.y, value3.y,\nvalue0.z, value1.z, value2.z, value3.z,\nvalue0.w, value1.w, value2.w, value3.w);\n}\n}\n__kernel void merge_vector_C4_D2_1(int rows, int cols,\n__global ushort *mat_dst,  int dst_step,\n__global ushort *mat_src0, int src0_step,\n__global ushort *mat_src1, int src1_step,\n__global ushort *mat_src2, int src2_step,\n__global ushort *mat_src3, int src3_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global ushort2  *src0_y = (__global ushort2 * )((__global uchar*)mat_src0 + y * src0_step);\n__global ushort2  *src1_y = (__global ushort2 * )((__global uchar*)mat_src1 + y * src1_step);\n__global ushort2  *src2_y = (__global ushort2 * )((__global uchar*)mat_src2 + y * src0_step);\n__global ushort2  *src3_y = (__global ushort2 * )((__global uchar*)mat_src3 + y * src1_step);\n__global ushort8 *dst_y  = (__global ushort8 *)((__global uchar*)mat_dst  + y * dst_step);\nushort2 value0 = src0_y[x];\nushort2 value1 = src1_y[x];\nushort2 value2 = src2_y[x];\nushort2 value3 = src3_y[x];\ndst_y[x] = (ushort8)(value0.x, value1.x, value2.x, value3.x,\nvalue0.y, value1.y, value2.y, value3.y);\n}\n}\n__kernel void merge_vector_C4_D3_1(int rows, int cols,\n__global short *mat_dst,  int dst_step,\n__global short *mat_src0, int src0_step,\n__global short *mat_src1, int src1_step,\n__global short *mat_src2, int src2_step,\n__global short *mat_src3, int src3_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global short2  *src0_y = (__global short2 * )((__global uchar*)mat_src0 + y * src0_step);\n__global short2  *src1_y = (__global short2 * )((__global uchar*)mat_src1 + y * src1_step);\n__global short2  *src2_y = (__global short2 * )((__global uchar*)mat_src2 + y * src0_step);\n__global short2  *src3_y = (__global short2 * )((__global uchar*)mat_src3 + y * src1_step);\n__global short8 *dst_y  = (__global short8 *)((__global uchar*)mat_dst  + y * dst_step);\nshort2 value0 = src0_y[x];\nshort2 value1 = src1_y[x];\nshort2 value2 = src2_y[x];\nshort2 value3 = src3_y[x];\ndst_y[x] = (short8)(value0.x, value1.x, value2.x, value3.x,\nvalue0.y, value1.y, value2.y, value3.y);\n}\n}\n__kernel void merge_vector_C4_D4_1(int rows, int cols,\n__global int *mat_dst,  int dst_step,\n__global int *mat_src0, int src0_step,\n__global int *mat_src1, int src1_step,\n__global int *mat_src2, int src2_step,\n__global int *mat_src3, int src3_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global int *src0_y = (__global int * )((__global uchar*)mat_src0 + y * src0_step);\n__global int *src1_y = (__global int * )((__global uchar*)mat_src1 + y * src1_step);\n__global int *src2_y = (__global int * )((__global uchar*)mat_src2 + y * src0_step);\n__global int *src3_y = (__global int * )((__global uchar*)mat_src3 + y * src1_step);\n__global int4 *dst_y  = (__global int4 *)((__global uchar*)mat_dst  + y * dst_step);\nint value0 = src0_y[x];\nint value1 = src1_y[x];\nint value2 = src2_y[x];\nint value3 = src3_y[x];\ndst_y[x] = (int4)(value0, value1, value2, value3);\n}\n}\n__kernel void merge_vector_C4_D5_1(int rows, int cols,\n__global float *mat_dst,  int dst_step,\n__global float *mat_src0, int src0_step,\n__global float *mat_src1, int src1_step,\n__global float *mat_src2, int src2_step,\n__global float *mat_src3, int src3_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global float *src0_y = (__global float * )((__global uchar*)mat_src0 + y * src0_step);\n__global float *src1_y = (__global float * )((__global uchar*)mat_src1 + y * src1_step);\n__global float *src2_y = (__global float * )((__global uchar*)mat_src2 + y * src0_step);\n__global float *src3_y = (__global float * )((__global uchar*)mat_src3 + y * src1_step);\n__global float4 *dst_y  = (__global float4 *)((__global uchar*)mat_dst  + y * dst_step);\nfloat value0 = src0_y[x];\nfloat value1 = src1_y[x];\nfloat value2 = src2_y[x];\nfloat value3 = src3_y[x];\ndst_y[x] = (float4)(value0, value1, value2, value3);\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void merge_vector_C4_D6_1(int rows, int cols,\n__global double *mat_dst,  int dst_step,\n__global double *mat_src0, int src0_step,\n__global double *mat_src1, int src1_step,\n__global double *mat_src2, int src2_step,\n__global double *mat_src3, int src3_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif ((x < cols) && (y < rows))\n{\n__global double *src0_y = (__global double * )((__global uchar*)mat_src0 + y * src0_step);\n__global double *src1_y = (__global double * )((__global uchar*)mat_src1 + y * src1_step);\n__global double *src2_y = (__global double * )((__global uchar*)mat_src2 + y * src0_step);\n__global double *src3_y = (__global double * )((__global uchar*)mat_src3 + y * src1_step);\n__global double4 *dst_y  = (__global double4 *)((__global uchar*)mat_dst  + y * dst_step);\ndouble value0 = src0_y[x];\ndouble value1 = src1_y[x];\ndouble value2 = src2_y[x];\ndouble value3 = src3_y[x];\ndst_y[x] = (double4)(value0, value1, value2, value3);\n}\n}\n#endif\n", "131c0e27e47b2163871bfd35ae8f659b", "meanShift", "short2 do_mean_shift(int x0, int y0, __global uchar4* out,int out_step,\n__global uchar4* in, int in_step, int dst_off, int src_off,\nint cols, int rows, int sp, int sr, int maxIter, float eps)\n{\nint isr2 = sr*sr;\nin_step = in_step >> 2;\nout_step = out_step >> 2;\nsrc_off = src_off >> 2;\ndst_off = dst_off >> 2;\nint idx = src_off + y0 * in_step + x0;\nuchar4 c = in[idx];\nint base = dst_off + get_global_id(1)*out_step + get_global_id(0) ;\nfor( int iter = 0; iter < maxIter; iter++ )\n{\nint count = 0;\nint4 s = (int4)0;\nint sx = 0, sy = 0;\nint minx = (x0-sp)>0 ? x0-sp : 0;\nint miny = (y0-sp)>0 ? y0-sp : 0;\nint maxx = (x0+sp)<cols ? x0+sp : cols-1;\nint maxy = (y0+sp)<rows ? y0+sp : rows-1;\nfor( int y = miny; y <= maxy; y++)\n{\nint rowCount = 0;\nint x = minx;\nfor( ; x+3 <= maxx; x+=4 )\n{\nint id = src_off + y*in_step + x;\nuchar16 t = (uchar16)(in[id],in[id+1],in[id+2],in[id+3]);\nint norm2_1 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n(t.s2 - c.z) * (t.s2 - c.z);\nint norm2_2 = (t.s4 - c.x) * (t.s4 - c.x) + (t.s5 - c.y) * (t.s5 - c.y) +\n(t.s6 - c.z) * (t.s6 - c.z);\nint norm2_3 = (t.s8 - c.x) * (t.s8 - c.x) + (t.s9 - c.y) * (t.s9 - c.y) +\n(t.sa - c.z) * (t.sa - c.z);\nint norm2_4 = (t.sc - c.x) * (t.sc - c.x) + (t.sd - c.y) * (t.sd - c.y) +\n(t.se - c.z) * (t.se - c.z);\nif( norm2_1 <= isr2 )\n{\ns.x += t.s0; s.y += t.s1; s.z += t.s2;\nsx += x; rowCount++;\n}\nif( norm2_2 <= isr2 )\n{\ns.x += t.s4; s.y += t.s5; s.z += t.s6;\nsx += x+1; rowCount++;\n}\nif( norm2_3 <= isr2 )\n{\ns.x += t.s8; s.y += t.s9; s.z += t.sa;\nsx += x+2; rowCount++;\n}\nif( norm2_4 <= isr2 )\n{\ns.x += t.sc; s.y += t.sd; s.z += t.se;\nsx += x+3; rowCount++;\n}\n}\nif(x == maxx)\n{\nint id = src_off + y*in_step + x;\nuchar4 t = in[id];\nint norm2 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n(t.s2 - c.z) * (t.s2 - c.z);\nif( norm2 <= isr2 )\n{\ns.x += t.s0; s.y += t.s1; s.z += t.s2;\nsx += x; rowCount++;\n}\n}\nif(x+1 == maxx)\n{\nint id = src_off + y*in_step + x;\nuchar8 t = (uchar8)(in[id],in[id+1]);\nint norm2_1 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n(t.s2 - c.z) * (t.s2 - c.z);\nint norm2_2 = (t.s4 - c.x) * (t.s4 - c.x) + (t.s5 - c.y) * (t.s5 - c.y) +\n(t.s6 - c.z) * (t.s6 - c.z);\nif( norm2_1 <= isr2 )\n{\ns.x += t.s0; s.y += t.s1; s.z += t.s2;\nsx += x; rowCount++;\n}\nif( norm2_2 <= isr2 )\n{\ns.x += t.s4; s.y += t.s5; s.z += t.s6;\nsx += x+1; rowCount++;\n}\n}\nif(x+2 == maxx)\n{\nint id = src_off + y*in_step + x;\nuchar16 t = (uchar16)(in[id],in[id+1],in[id+2],in[id+3]);\nint norm2_1 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n(t.s2 - c.z) * (t.s2 - c.z);\nint norm2_2 = (t.s4 - c.x) * (t.s4 - c.x) + (t.s5 - c.y) * (t.s5 - c.y) +\n(t.s6 - c.z) * (t.s6 - c.z);\nint norm2_3 = (t.s8 - c.x) * (t.s8 - c.x) + (t.s9 - c.y) * (t.s9 - c.y) +\n(t.sa - c.z) * (t.sa - c.z);\nif( norm2_1 <= isr2 )\n{\ns.x += t.s0; s.y += t.s1; s.z += t.s2;\nsx += x; rowCount++;\n}\nif( norm2_2 <= isr2 )\n{\ns.x += t.s4; s.y += t.s5; s.z += t.s6;\nsx += x+1; rowCount++;\n}\nif( norm2_3 <= isr2 )\n{\ns.x += t.s8; s.y += t.s9; s.z += t.sa;\nsx += x+2; rowCount++;\n}\n}\nif(rowCount == 0)\ncontinue;\ncount += rowCount;\nif(y == 0)\ncontinue;\nsy += y*rowCount;\n}\nif( count == 0 )\nbreak;\nint x1 = sx/count;\nint y1 = sy/count;\ns.x = s.x/count;\ns.y = s.y/count;\ns.z = s.z/count;\nint4 tmp = s - convert_int4(c);\nint norm2 = tmp.x * tmp.x + tmp.y *  tmp.y +\ntmp.z * tmp.z;\nbool stopFlag = (x1 == x0 && y1 == y0) || (abs(x1-x0) + abs(y1-y0) + norm2 <= eps);\nx0 = x1;\ny0 = y1;\nc.x = s.x;\nc.y = s.y;\nc.z = s.z;\nif( stopFlag )\nbreak;\n}\nout[base] = c;\nreturn (short2)((short)x0, (short)y0);\n}\n__kernel void meanshift_kernel(__global uchar4* out, int out_step,\n__global uchar4* in, int in_step,\nint dst_off, int src_off, int cols, int rows,\nint sp, int sr, int maxIter, float eps)\n{\nint x0 = get_global_id(0);\nint y0 = get_global_id(1);\nif( x0 < cols && y0 < rows )\ndo_mean_shift(x0, y0, out, out_step, in, in_step, dst_off, src_off,\ncols, rows, sp, sr, maxIter, eps);\n}\n__kernel void meanshiftproc_kernel( __global uchar4* in, __global uchar4* outr,\n__global short2* outsp, int instep, int outrstep,\nint outspstep, int in_off, int outr_off, int outsp_off,\nint cols, int rows, int sp, int sr, int maxIter, float eps )\n{\nint x0 = get_global_id(0);\nint y0 = get_global_id(1);\nif( x0 < cols && y0 < rows )\n{\noutsp_off >>= 2;\noutspstep >>= 2;\nint basesp = outsp_off + y0 * outspstep + x0;\noutsp[basesp] = do_mean_shift(x0, y0, outr, outrstep, in, instep, outr_off, in_off, cols, rows, sp, sr, maxIter, eps);\n}\n}\n", "14dbf4c2ad30df918cadb74aa130aa77", "match_template", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define TYPE_IMAGE_SQSUM double\n#else\n#define TYPE_IMAGE_SQSUM float\n#endif\n#ifndef CN4\n#define CN4 1\n#else\n#define CN4 4\n#endif\n#define SQSUMS_PTR(ox, oy) mad24(gidy + oy, img_sqsums_step, (gidx + img_sqsums_offset + ox) * CN4)\n#define SUMS_PTR(ox, oy) mad24(gidy + oy, img_sums_step, gidx + img_sums_offset + ox)\nfloat normAcc(float num, float denum)\n{\nif(fabs(num) < denum)\n{\nreturn num / denum;\n}\nif(fabs(num) < denum * 1.125f)\n{\nreturn num > 0 ? 1 : -1;\n}\nreturn 0;\n}\nfloat normAcc_SQDIFF(float num, float denum)\n{\nif(fabs(num) < denum)\n{\nreturn num / denum;\n}\nif(fabs(num) < denum * 1.125f)\n{\nreturn num > 0 ? 1 : -1;\n}\nreturn 1;\n}\n__kernel\nvoid normalizeKernel_C1_D0\n(\n__global const float * img_sqsums,\n__global float * res,\nulong tpl_sqsum,\nint res_rows,\nint res_cols,\nint tpl_rows,\nint tpl_cols,\nint img_sqsums_offset,\nint img_sqsums_step,\nint res_offset,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nimg_sqsums_step /= sizeof(*img_sqsums);\nimg_sqsums_offset /= sizeof(*img_sqsums);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfloat image_sqsum_ = (float)(\n(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\nres[res_idx] = normAcc(res[res_idx], sqrt(image_sqsum_ * tpl_sqsum));\n}\n}\n__kernel\nvoid matchTemplate_Prepared_SQDIFF_C1_D0\n(\n__global const TYPE_IMAGE_SQSUM * img_sqsums,\n__global float * res,\nulong tpl_sqsum,\nint res_rows,\nint res_cols,\nint tpl_rows,\nint tpl_cols,\nint img_sqsums_offset,\nint img_sqsums_step,\nint res_offset,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nimg_sqsums_step /= sizeof(*img_sqsums);\nimg_sqsums_offset /= sizeof(*img_sqsums);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfloat image_sqsum_ = (float)(\n(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\nres[res_idx] = image_sqsum_ - 2.f * res[res_idx] + tpl_sqsum;\n}\n}\n__kernel\nvoid matchTemplate_Prepared_SQDIFF_NORMED_C1_D0\n(\n__global const float * img_sqsums,\n__global float * res,\nulong tpl_sqsum,\nint res_rows,\nint res_cols,\nint tpl_rows,\nint tpl_cols,\nint img_sqsums_offset,\nint img_sqsums_step,\nint res_offset,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nimg_sqsums_step /= sizeof(*img_sqsums);\nimg_sqsums_offset /= sizeof(*img_sqsums);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfloat image_sqsum_ = (float)(\n(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\nres[res_idx] = normAcc_SQDIFF(image_sqsum_ - 2.f * res[res_idx] + tpl_sqsum,\nsqrt(image_sqsum_ * tpl_sqsum));\n}\n}\n__kernel\nvoid matchTemplate_Naive_SQDIFF_C1_D0\n(\n__global const uchar * img,\n__global const uchar * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nint delta;\nint sum = 0;\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const uchar * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const uchar * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\ndelta = img_ptr[j] - tpl_ptr[j];\nsum   = mad24(delta, delta, sum);\n}\n}\nres[res_idx] = sum;\n}\n}\n__kernel\nvoid matchTemplate_Naive_SQDIFF_C1_D5\n(\n__global const float * img,\n__global const float * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nfloat delta;\nfloat sum = 0;\nimg_step   /= sizeof(*img);\nimg_offset /= sizeof(*img);\ntpl_step   /= sizeof(*tpl);\ntpl_offset /= sizeof(*tpl);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const float * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const float * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\ndelta = img_ptr[j] - tpl_ptr[j];\nsum   = mad(delta, delta, sum);\n}\n}\nres[res_idx] = sum;\n}\n}\n__kernel\nvoid matchTemplate_Naive_SQDIFF_C4_D0\n(\n__global const uchar4 * img,\n__global const uchar4 * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nint4 delta;\nint4 sum = (int4)(0, 0, 0, 0);\nimg_step   /= sizeof(*img);\nimg_offset /= sizeof(*img);\ntpl_step   /= sizeof(*tpl);\ntpl_offset /= sizeof(*tpl);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const uchar4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const uchar4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\ndelta.x = img_ptr[j].x - tpl_ptr[j].x;\ndelta.y = img_ptr[j].y - tpl_ptr[j].y;\ndelta.z = img_ptr[j].z - tpl_ptr[j].z;\ndelta.w = img_ptr[j].w - tpl_ptr[j].w;\nsum   = mad24(delta, delta, sum);\n}\n}\nres[res_idx] = sum.x + sum.y + sum.z + sum.w;\n}\n}\n__kernel\nvoid matchTemplate_Naive_SQDIFF_C4_D5\n(\n__global const float4 * img,\n__global const float4 * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nfloat4 delta;\nfloat4 sum = (float4)(0, 0, 0, 0);\nimg_step   /= sizeof(*img);\nimg_offset /= sizeof(*img);\ntpl_step   /= sizeof(*tpl);\ntpl_offset /= sizeof(*tpl);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const float4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const float4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\ndelta.x = img_ptr[j].x - tpl_ptr[j].x;\ndelta.y = img_ptr[j].y - tpl_ptr[j].y;\ndelta.z = img_ptr[j].z - tpl_ptr[j].z;\ndelta.w = img_ptr[j].w - tpl_ptr[j].w;\nsum   = mad(delta, delta, sum);\n}\n}\nres[res_idx] = sum.x + sum.y + sum.z + sum.w;\n}\n}\n__kernel\nvoid matchTemplate_Naive_CCORR_C1_D0\n(\n__global const uchar * img,\n__global const uchar * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nint sum = 0;\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const uchar * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const uchar * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\nsum = mad24(convert_int(img_ptr[j]), convert_int(tpl_ptr[j]), sum);\n}\n}\nres[res_idx] = (float)sum;\n}\n}\n__kernel\nvoid matchTemplate_Naive_CCORR_C1_D5\n(\n__global const float * img,\n__global const float * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nfloat sum = 0;\nimg_step   /= sizeof(*img);\nimg_offset /= sizeof(*img);\ntpl_step   /= sizeof(*tpl);\ntpl_offset /= sizeof(*tpl);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const float * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const float * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\nsum = mad(img_ptr[j], tpl_ptr[j], sum);\n}\n}\nres[res_idx] = sum;\n}\n}\n__kernel\nvoid matchTemplate_Naive_CCORR_C4_D0\n(\n__global const uchar4 * img,\n__global const uchar4 * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nint4 sum = (int4)(0, 0, 0, 0);\nimg_step   /= sizeof(*img);\nimg_offset /= sizeof(*img);\ntpl_step   /= sizeof(*tpl);\ntpl_offset /= sizeof(*tpl);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const uchar4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const uchar4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\nsum   = mad24(convert_int4(img_ptr[j]), convert_int4(tpl_ptr[j]), sum);\n}\n}\nres[res_idx] = (float)(sum.x + sum.y + sum.z + sum.w);\n}\n}\n__kernel\nvoid matchTemplate_Naive_CCORR_C4_D5\n(\n__global const float4 * img,\n__global const float4 * tpl,\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint img_offset,\nint tpl_offset,\nint res_offset,\nint img_step,\nint tpl_step,\nint res_step\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint i,j;\nfloat4 sum = (float4)(0, 0, 0, 0);\nimg_step   /= sizeof(*img);\nimg_offset /= sizeof(*img);\ntpl_step   /= sizeof(*tpl);\ntpl_offset /= sizeof(*tpl);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfor(i = 0; i < tpl_rows; i ++)\n{\n__global const float4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n__global const float4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\nfor(j = 0; j < tpl_cols; j ++)\n{\nsum = mad(convert_float4(img_ptr[j]), convert_float4(tpl_ptr[j]), sum);\n}\n}\nres[res_idx] = sum.x + sum.y + sum.z + sum.w;\n}\n}\n__kernel\nvoid matchTemplate_Prepared_CCOFF_C1_D0\n(\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint res_offset,\nint res_step,\n__global const uint * img_sums,\nint img_sums_offset,\nint img_sums_step,\nfloat tpl_sum\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nimg_sums_offset   /= sizeof(*img_sums);\nimg_sums_step     /= sizeof(*img_sums);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfloat sum = (float)((img_sums[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums[SUMS_PTR(tpl_cols, 0)])\n-(img_sums[SUMS_PTR(0, tpl_rows)] - img_sums[SUMS_PTR(0, 0)]));\nres[res_idx] -= sum * tpl_sum;\n}\n}\n__kernel\nvoid matchTemplate_Prepared_CCOFF_C4_D0\n(\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint res_offset,\nint res_step,\n__global const uint * img_sums_c0,\n__global const uint * img_sums_c1,\n__global const uint * img_sums_c2,\n__global const uint * img_sums_c3,\nint img_sums_offset,\nint img_sums_step,\nfloat tpl_sum_c0,\nfloat tpl_sum_c1,\nfloat tpl_sum_c2,\nfloat tpl_sum_c3\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nimg_sums_offset   /= sizeof(*img_sums_c0);\nimg_sums_step     /= sizeof(*img_sums_c0);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfloat ccorr = res[res_idx];\nccorr -= tpl_sum_c0*(float)(\n(img_sums_c0[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c0[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c0[SUMS_PTR(0, tpl_rows)] - img_sums_c0[SUMS_PTR(0, 0)]));\nccorr -= tpl_sum_c1*(float)(\n(img_sums_c1[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c1[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c1[SUMS_PTR(0, tpl_rows)] - img_sums_c1[SUMS_PTR(0, 0)]));\nccorr -= tpl_sum_c2*(float)(\n(img_sums_c2[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c2[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c2[SUMS_PTR(0, tpl_rows)] - img_sums_c2[SUMS_PTR(0, 0)]));\nccorr -= tpl_sum_c3*(float)(\n(img_sums_c3[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c3[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c3[SUMS_PTR(0, tpl_rows)] - img_sums_c3[SUMS_PTR(0, 0)]));\nres[res_idx] = ccorr;\n}\n}\n__kernel\nvoid matchTemplate_Prepared_CCOFF_NORMED_C1_D0\n(\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint res_offset,\nint res_step,\nfloat weight,\n__global const uint * img_sums,\nint img_sums_offset,\nint img_sums_step,\n__global const float * img_sqsums,\nint img_sqsums_offset,\nint img_sqsums_step,\nfloat tpl_sum,\nfloat tpl_sqsum\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nimg_sqsums_step   /= sizeof(*img_sqsums);\nimg_sqsums_offset /= sizeof(*img_sqsums);\nimg_sums_offset   /= sizeof(*img_sums);\nimg_sums_step     /= sizeof(*img_sums);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfloat image_sum_ =  (float)(\n(img_sums[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums[SUMS_PTR(tpl_cols, 0)])\n- (img_sums[SUMS_PTR(0, tpl_rows)] - img_sums[SUMS_PTR(0, 0)]));\nfloat image_sqsum_ = (float)(\n(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\nres[res_idx] = normAcc(res[res_idx] - image_sum_ * tpl_sum,\nsqrt(tpl_sqsum * (image_sqsum_ - weight * image_sum_ * image_sum_)));\n}\n}\n__kernel\nvoid matchTemplate_Prepared_CCOFF_NORMED_C4_D0\n(\n__global float * res,\nint img_rows,\nint img_cols,\nint tpl_rows,\nint tpl_cols,\nint res_rows,\nint res_cols,\nint res_offset,\nint res_step,\nfloat weight,\n__global const uint * img_sums_c0,\n__global const uint * img_sums_c1,\n__global const uint * img_sums_c2,\n__global const uint * img_sums_c3,\nint img_sums_offset,\nint img_sums_step,\n__global const float * img_sqsums_c0,\n__global const float * img_sqsums_c1,\n__global const float * img_sqsums_c2,\n__global const float * img_sqsums_c3,\nint img_sqsums_offset,\nint img_sqsums_step,\nfloat tpl_sum_c0,\nfloat tpl_sum_c1,\nfloat tpl_sum_c2,\nfloat tpl_sum_c3,\nfloat tpl_sqsum\n)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nimg_sqsums_step   /= sizeof(*img_sqsums_c0);\nimg_sqsums_offset /= sizeof(*img_sqsums_c0);\nimg_sums_offset   /= sizeof(*img_sums_c0);\nimg_sums_step     /= sizeof(*img_sums_c0);\nres_step   /= sizeof(*res);\nres_offset /= sizeof(*res);\nint res_idx = mad24(gidy, res_step, res_offset + gidx);\nif(gidx < res_cols && gidy < res_rows)\n{\nfloat image_sum_c0 =  (float)(\n(img_sums_c0[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c0[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c0[SUMS_PTR(0, tpl_rows)] - img_sums_c0[SUMS_PTR(0, 0)]));\nfloat image_sum_c1 =  (float)(\n(img_sums_c1[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c1[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c1[SUMS_PTR(0, tpl_rows)] - img_sums_c1[SUMS_PTR(0, 0)]));\nfloat image_sum_c2 =  (float)(\n(img_sums_c2[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c2[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c2[SUMS_PTR(0, tpl_rows)] - img_sums_c2[SUMS_PTR(0, 0)]));\nfloat image_sum_c3 =  (float)(\n(img_sums_c3[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c3[SUMS_PTR(tpl_cols, 0)])\n- (img_sums_c3[SUMS_PTR(0, tpl_rows)] - img_sums_c3[SUMS_PTR(0, 0)]));\nfloat image_sqsum_c0 = (float)(\n(img_sqsums_c0[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c0[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums_c0[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c0[SQSUMS_PTR(0, 0)]));\nfloat image_sqsum_c1 = (float)(\n(img_sqsums_c1[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c1[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums_c1[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c1[SQSUMS_PTR(0, 0)]));\nfloat image_sqsum_c2 = (float)(\n(img_sqsums_c2[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c2[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums_c2[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c2[SQSUMS_PTR(0, 0)]));\nfloat image_sqsum_c3 = (float)(\n(img_sqsums_c3[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c3[SQSUMS_PTR(tpl_cols, 0)]) -\n(img_sqsums_c3[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c3[SQSUMS_PTR(0, 0)]));\nfloat num = res[res_idx] -\nimage_sum_c0 * tpl_sum_c0 -\nimage_sum_c1 * tpl_sum_c1 -\nimage_sum_c2 * tpl_sum_c2 -\nimage_sum_c3 * tpl_sum_c3;\nfloat denum = sqrt( tpl_sqsum * (\nimage_sqsum_c0 - weight * image_sum_c0 * image_sum_c0 +\nimage_sqsum_c1 - weight * image_sum_c1 * image_sum_c1 +\nimage_sqsum_c2 - weight * image_sum_c2 * image_sum_c2 +\nimage_sqsum_c3 - weight * image_sum_c0 * image_sum_c3)\n);\nres[res_idx] = normAcc(num, denum);\n}\n}\n__kernel\nvoid extractFirstChannel\n(\nconst __global float4* img,\n__global float* res,\nint rows,\nint cols,\nint img_offset,\nint res_offset,\nint img_step,\nint res_step\n)\n{\nimg_step   /= sizeof(float4);\nres_step   /= sizeof(float);\nimg_offset /= sizeof(float4);\nres_offset /= sizeof(float);\nimg += img_offset;\nres += res_offset;\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nif(gidx < cols && gidy < rows)\n{\nres[gidx + gidy * res_step] = img[gidx + gidy * img_step].x;\n}\n}\n", "2f026d4f003285067e2fc4c6fc5866ba", "knearest", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define TYPE double\n#else\n#define TYPE float\n#endif\n#define CV_SWAP(a,b,t) ((t) = (a), (a) = (b), (b) = (t))\n__kernel void knn_find_nearest(__global float* sample, int sample_row, int sample_col, int sample_step,\nint k, __global float* samples_ocl, int sample_ocl_row, int sample_ocl_step,\n__global float* _results, int _results_step, int _regression, int K1,\nint sample_ocl_col, int nThreads, __local float* nr)\n{\nint k1 = 0;\nint k2 = 0;\nbool regression = false;\nif(_regression)\nregression = true;\nTYPE inv_scale;\n#ifdef DOUBLE_SUPPORT\ninv_scale = 1.0/K1;\n#else\ninv_scale = 1.0f/K1;\n#endif\nint y = get_global_id(1);\nint j, j1;\nint threadY = (y % nThreads);\n__local float* dd = nr + nThreads * k;\nif(y >= sample_row)\n{\nreturn;\n}\nfor(j = 0; j < sample_ocl_row; j++)\n{\nTYPE sum;\n#ifdef DOUBLE_SUPPORT\nsum = 0.0;\n#else\nsum = 0.0f;\n#endif\nfloat si;\nint t, ii, ii1;\nfor(t = 0; t < sample_col - 16; t += 16)\n{\nfloat16 t0 = vload16(0, sample + y * sample_step + t) - vload16(0, samples_ocl + j * sample_ocl_step + t);\nt0 *= t0;\nsum += t0.s0 + t0.s1 + t0.s2 + t0.s3 + t0.s4 + t0.s5 + t0.s6 + t0.s7 +\nt0.s8 + t0.s9 + t0.sa + t0.sb + t0.sc + t0.sd + t0.se + t0.sf;\n}\nfor(; t < sample_col; t++)\n{\n#ifdef DOUBLE_SUPPORT\ndouble t0 = sample[y * sample_step + t] - samples_ocl[j * sample_ocl_step + t];\n#else\nfloat t0 = sample[y * sample_step + t] - samples_ocl[j * sample_ocl_step + t];\n#endif\nsum = sum + t0 * t0;\n}\nsi = (float)sum;\nfor(ii = k1 - 1; ii >= 0; ii--)\n{\nif(as_int(si) > as_int(dd[ii * nThreads + threadY]))\nbreak;\n}\nif(ii < k - 1)\n{\nfor(ii1 = k2 - 1; ii1 > ii; ii1--)\n{\ndd[(ii1 + 1) * nThreads + threadY] = dd[ii1 * nThreads + threadY];\nnr[(ii1 + 1) * nThreads + threadY] = nr[ii1 * nThreads + threadY];\n}\ndd[(ii + 1) * nThreads + threadY] = si;\nnr[(ii + 1) * nThreads + threadY] = samples_ocl[sample_col + j * sample_ocl_step];\n}\nk1 = (k1 + 1) < k ? (k1 + 1) : k;\nk2 = k1 < (k - 1) ? k1 : (k - 1);\n}\nif (regression)\n{\nTYPE s;\n#ifdef DOUBLE_SUPPORT\ns = 0.0;\n#else\ns = 0.0f;\n#endif\nfor(j = 0; j < K1; j++)\ns += nr[j * nThreads + threadY];\n_results[y * _results_step] = (float)(s * inv_scale);\n}\nelse\n{\nint prev_start = 0, best_count = 0, cur_count;\nfloat best_val;\nfor(j = K1 - 1; j > 0; j--)\n{\nbool swap_f1 = false;\nfor(j1 = 0; j1 < j; j1++)\n{\nif(nr[j1 * nThreads + threadY] > nr[(j1 + 1) * nThreads + threadY])\n{\nint t;\nCV_SWAP(nr[j1 * nThreads + threadY], nr[(j1 + 1) * nThreads + threadY], t);\nswap_f1 = true;\n}\n}\nif(!swap_f1)\nbreak;\n}\nbest_val = 0;\nfor(j = 1; j <= K1; j++)\nif(j == K1 || nr[j * nThreads + threadY] != nr[(j - 1) * nThreads + threadY])\n{\ncur_count = j - prev_start;\nif(best_count < cur_count)\n{\nbest_count = cur_count;\nbest_val = nr[(j - 1) * nThreads + threadY];\n}\nprev_start = j;\n}\n_results[y * _results_step] = best_val;\n}\n}\n", "21d1d481592261bb0d7daeef8c69e121", "kmeans_kernel", "float distance_(__global const float * center, __global const float * src, int feature_length)\n{\nfloat res = 0;\nfloat4 v0, v1, v2;\nint i = 0;\n#ifdef L1_DIST\nfloat4 sum = (float4)(0.0f);\n#endif\nfor ( ; i <= feature_length - 4; i += 4)\n{\nv0 = vload4(0, center + i);\nv1 = vload4(0, src + i);\nv2 = v1 - v0;\n#ifdef L1_DIST\nv0 = fabs(v2);\nsum += v0;\n#else\nres += dot(v2, v2);\n#endif\n}\n#ifdef L1_DIST\nres = sum.x + sum.y + sum.z + sum.w;\n#endif\nfor ( ; i < feature_length; ++i)\n{\nfloat t0 = src[i];\nfloat t1 = center[i];\n#ifdef L1_DIST\nres += fabs(t0 - t1);\n#else\nfloat t2 = t0 - t1;\nres += t2 * t2;\n#endif\n}\nreturn res;\n}\n__kernel void distanceToCenters(__global const float * src, __global const float * centers,\n__global float * dists, int feature_length,\nint src_step, int centers_step,\nint features_count, int centers_count,\nint src_offset, int centers_offset)\n{\nint gid = get_global_id(0);\nif (gid < (features_count * centers_count))\n{\nint feature_index = gid / centers_count;\nint center_index = gid % centers_count;\nint center_idx = mad24(center_index, centers_step, centers_offset);\nint src_idx = mad24(feature_index, src_step, src_offset);\ndists[gid] = distance_(centers + center_idx, src + src_idx, feature_length);\n}\n}\n", "f860c405407c40547fd9e1af945944ad", "kernel_stablesort_by_key", "#ifndef K_T\n#define K_T float\n#endif\n#ifndef V_T\n#define V_T float\n#endif\n#ifndef IS_GT\n#define IS_GT false\n#endif\n#if IS_GT\n#define my_comp(x,y) ((x) > (y))\n#else\n#define my_comp(x,y) ((x) < (y))\n#endif\nuint lowerBoundBinary( global K_T* data, uint left, uint right, K_T searchVal)\n{\nuint firstIndex = left;\nuint lastIndex = right;\nwhile( firstIndex < lastIndex )\n{\nuint midIndex = ( firstIndex + lastIndex ) / 2;\nK_T midValue = data[ midIndex ];\nif( my_comp( midValue, searchVal ) )\n{\nfirstIndex = midIndex+1;\n}\nelse\n{\nlastIndex = midIndex;\n}\n}\nreturn firstIndex;\n}\nuint upperBoundBinary( global K_T* data, uint left, uint right, K_T searchVal)\n{\nuint upperBound = lowerBoundBinary( data, left, right, searchVal );\nif( upperBound != right )\n{\nK_T upperValue = data[ upperBound ];\nwhile( !my_comp( upperValue, searchVal ) && !my_comp( searchVal, upperValue) && (upperBound != right) )\n{\nupperBound++;\nupperValue = data[ upperBound ];\n}\n}\nreturn upperBound;\n}\nkernel void merge(\nglobal K_T*   iKey_ptr,\nglobal V_T*   iValue_ptr,\nglobal K_T*   oKey_ptr,\nglobal V_T*   oValue_ptr,\nconst uint    srcVecSize,\nconst uint    srcLogicalBlockSize,\nlocal K_T*    key_lds,\nlocal V_T*    val_lds\n)\n{\nsize_t globalID     = get_global_id( 0 );\nif( globalID >= srcVecSize )\nreturn;\nuint srcBlockNum   = globalID / srcLogicalBlockSize;\nuint srcBlockIndex = globalID % srcLogicalBlockSize;\nuint dstLogicalBlockSize = srcLogicalBlockSize<<1;\nuint leftBlockIndex = globalID & ~((dstLogicalBlockSize) - 1 );\nleftBlockIndex += (srcBlockNum & 0x1) ? 0 : srcLogicalBlockSize;\nleftBlockIndex = min( leftBlockIndex, srcVecSize );\nuint rightBlockIndex = min( leftBlockIndex + srcLogicalBlockSize, srcVecSize );\nuint insertionIndex = 0;\nif( (srcBlockNum & 0x1) == 0 )\n{\ninsertionIndex = lowerBoundBinary( iKey_ptr, leftBlockIndex, rightBlockIndex, iKey_ptr[ globalID ] ) - leftBlockIndex;\n}\nelse\n{\ninsertionIndex = upperBoundBinary( iKey_ptr, leftBlockIndex, rightBlockIndex, iKey_ptr[ globalID ] ) - leftBlockIndex;\n}\nuint dstBlockIndex = srcBlockIndex + insertionIndex;\nuint dstBlockNum = srcBlockNum/2;\noKey_ptr[ (dstBlockNum*dstLogicalBlockSize)+dstBlockIndex ] = iKey_ptr[ globalID ];\noValue_ptr[ (dstBlockNum*dstLogicalBlockSize)+dstBlockIndex ] = iValue_ptr[ globalID ];\n}\nkernel void blockInsertionSort(\nglobal K_T*   key_ptr,\nglobal V_T*   value_ptr,\nconst uint    vecSize,\nlocal K_T*    key_lds,\nlocal V_T*    val_lds\n)\n{\nint gloId    = get_global_id( 0 );\nint groId    = get_group_id( 0 );\nint locId    = get_local_id( 0 );\nint wgSize   = get_local_size( 0 );\nbool in_range = gloId < (int)vecSize;\nK_T key;\nV_T val;\nif (in_range)\n{\nkey = key_ptr[ gloId ];\nval = value_ptr[ gloId ];\nkey_lds[ locId ] = key;\nval_lds[ locId ] = val;\n}\nbarrier( CLK_LOCAL_MEM_FENCE );\nif( locId == 0 && in_range )\n{\nint endIndex = vecSize - ( groId * wgSize );\nendIndex = min( endIndex, wgSize );\nfor( int currIndex = 1; currIndex < endIndex; ++currIndex )\n{\nkey = key_lds[ currIndex ];\nval = val_lds[ currIndex ];\nint scanIndex = currIndex;\nK_T ldsKey = key_lds[scanIndex - 1];\nwhile( scanIndex > 0 && my_comp( key, ldsKey ) )\n{\nV_T ldsVal = val_lds[scanIndex - 1];\nkey_lds[ scanIndex ] = ldsKey;\nval_lds[ scanIndex ] = ldsVal;\nscanIndex = scanIndex - 1;\nldsKey = key_lds[ max( 0, scanIndex - 1 ) ];\n}\nkey_lds[ scanIndex ] = key;\nval_lds[ scanIndex ] = val;\n}\n}\nbarrier( CLK_LOCAL_MEM_FENCE );\nif(in_range)\n{\nkey = key_lds[ locId ];\nkey_ptr[ gloId ] = key;\nval = val_lds[ locId ];\nvalue_ptr[ gloId ] = val;\n}\n}\n", "51ab9beffb4c03717063811491652aa2", "kernel_sort_by_key", "#ifndef K_T\n#define K_T float\n#endif\n#ifndef V_T\n#define V_T float\n#endif\n#ifndef IS_GT\n#define IS_GT false\n#endif\n#if IS_GT\n#define my_comp(x,y) ((x) > (y))\n#else\n#define my_comp(x,y) ((x) < (y))\n#endif\n__kernel\nvoid bitonicSort\n(\n__global K_T * keys,\n__global V_T * vals,\nint count,\nint stage,\nint passOfStage\n)\n{\nconst int threadId = get_global_id(0);\nif(threadId >= count / 2)\n{\nreturn;\n}\nconst int pairDistance = 1 << (stage - passOfStage);\nconst int blockWidth   = 2 * pairDistance;\nint leftId = min( (threadId % pairDistance)\n+ (threadId / pairDistance) * blockWidth, count );\nint rightId = min( leftId + pairDistance, count );\nint temp;\nconst V_T lval = vals[leftId];\nconst V_T rval = vals[rightId];\nconst K_T lkey = keys[leftId];\nconst K_T rkey = keys[rightId];\nint sameDirectionBlockWidth = 1 << stage;\nif((threadId/sameDirectionBlockWidth) % 2 == 1)\n{\ntemp = rightId;\nrightId = leftId;\nleftId = temp;\n}\nconst bool compareResult = my_comp(lkey, rkey);\nif(compareResult)\n{\nkeys[rightId] = rkey;\nkeys[leftId]  = lkey;\nvals[rightId] = rval;\nvals[leftId]  = lval;\n}\nelse\n{\nkeys[rightId] = lkey;\nkeys[leftId]  = rkey;\nvals[rightId] = lval;\nvals[leftId]  = rval;\n}\n}\n__kernel\nvoid selectionSortLocal\n(\n__global K_T * keys,\n__global V_T * vals,\nconst int count,\n__local  K_T * scratch\n)\n{\nint          i  = get_local_id(0);\nint numOfGroups = get_num_groups(0);\nint groupID     = get_group_id(0);\nint         wg  = get_local_size(0);\nint n;\nint offset   = groupID * wg;\nint same     = 0;\nvals      += offset;\nkeys      += offset;\nn = (groupID == (numOfGroups-1))? (count - wg*(numOfGroups-1)) : wg;\nint clamped_i= min(i, n - 1);\nK_T key1 = keys[clamped_i], key2;\nV_T val1 = vals[clamped_i];\nscratch[i] = key1;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(i >= n)\n{\nreturn;\n}\nint pos = 0;\nfor (int j=0;j<n;++j)\n{\nkey2  = scratch[j];\nif(my_comp(key2, key1))\npos++;\nelse\n{\nif(my_comp(key1, key2))\ncontinue;\nelse\n{\nsame++;\n}\n}\n}\nfor (int j=0; j< same; j++)\n{\nvals[pos + j] = val1;\nkeys[pos + j] = key1;\n}\n}\n__kernel\nvoid selectionSortFinal\n(\n__global K_T * keys,\n__global V_T * vals,\nconst int count\n)\n{\nconst int          i  = get_local_id(0);\nconst int numOfGroups = get_num_groups(0);\nconst int         wg  = get_local_size(0);\nint pos = 0, same = 0;\nconst int offset = get_group_id(0) * wg;\nconst int remainder = count - wg*(numOfGroups-1);\nif((offset + i ) >= count)\nreturn;\nV_T val1 = vals[offset + i];\nK_T key1 = keys[offset + i];\nK_T key2;\nfor(int j=0; j<numOfGroups-1; j++ )\n{\nfor(int k=0; k<wg; k++)\n{\nkey2 = keys[j*wg + k];\nif(my_comp(key1, key2))\nbreak;\nelse\n{\nif(my_comp(key2, key1))\npos++;\nelse\nsame++;\n}\n}\n}\nfor(int k=0; k<remainder; k++)\n{\nkey2 = keys[(numOfGroups-1)*wg + k];\nif(my_comp(key1, key2))\nbreak;\nelse\n{\nif(my_comp(key2, key1))\npos++;\nelse\nsame++;\n}\n}\nfor (int j=0; j< same; j++)\n{\nvals[pos + j] = val1;\nkeys[pos + j] = key1;\n}\n}\n", "dcb847ed205163090b935d35efe4b6e6", "kernel_radix_sort_by_key", "#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n#ifndef N\n#define N 4\n#endif\n#ifndef K_T\n#define K_T float\n#endif\n#ifndef V_T\n#define V_T float\n#endif\n#ifndef IS_GT\n#define IS_GT 0\n#endif\nuint convertKey(uint converted_key)\n{\n#ifdef K_FLT\nunsigned int mask = (converted_key & 0x80000000) ? 0xffffffff : 0x80000000;\nconverted_key ^= mask;\n#elif defined(K_INT)\nconst uint SIGN_MASK = 1u << ((sizeof(int) * 8) - 1);\nconverted_key ^= SIGN_MASK;\n#else\n#endif\nreturn converted_key;\n}\nkernel\nvoid naiveScanAddition(\n__global int * input,\n__global int * output,\nint size\n)\n{\nif(get_global_id(0) == 0)\n{\noutput[0] = 0;\nfor(int i = 1; i < size; i ++)\n{\noutput[i] = output[i - 1] + input[i - 1];\n}\n}\n}\nkernel\nvoid histogramRadixN (\n__global K_T* unsortedKeys,\n__global int * buckets,\nuint shiftCount\n)\n{\nconst int RADIX_T     = N;\nconst int RADICES_T   = (1 << RADIX_T);\nconst int NUM_OF_ELEMENTS_PER_WORK_ITEM_T = RADICES_T;\nconst int MASK_T      = (1 << RADIX_T) - 1;\nint localBuckets[16] = {0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0};\nint globalId    = get_global_id(0);\nint numOfGroups = get_num_groups(0);\nfor(int i = 0; i < NUM_OF_ELEMENTS_PER_WORK_ITEM_T; ++i)\n{\nuint value = convertKey(as_uint(unsortedKeys[mad24(globalId, NUM_OF_ELEMENTS_PER_WORK_ITEM_T, i)]));\nvalue = (value >> shiftCount) & MASK_T;\n#if IS_GT\nlocalBuckets[RADICES_T - value - 1]++;\n#else\nlocalBuckets[value]++;\n#endif\n}\nfor(int i = 0; i < NUM_OF_ELEMENTS_PER_WORK_ITEM_T; ++i)\n{\nbuckets[mad24(i, RADICES_T * numOfGroups, globalId) ] = localBuckets[i];\n}\n}\nkernel\nvoid permuteRadixN (\n__global K_T*  unsortedKeys,\n__global V_T*  unsortedVals,\n__global int* scanedBuckets,\nuint shiftCount,\n__global K_T*  sortedKeys,\n__global V_T*  sortedVals\n)\n{\nconst int RADIX_T     = N;\nconst int RADICES_T   = (1 << RADIX_T);\nconst int MASK_T = (1<<RADIX_T)  -1;\nint globalId  = get_global_id(0);\nint numOfGroups = get_num_groups(0);\nconst int NUM_OF_ELEMENTS_PER_WORK_GROUP_T = numOfGroups << N;\nint  localIndex[16];\nfor(int i = 0; i < RADICES_T; ++i)\n{\n#if IS_GT\nlocalIndex[i] = scanedBuckets[mad24(RADICES_T - i - 1, NUM_OF_ELEMENTS_PER_WORK_GROUP_T, globalId)];\n#else\nlocalIndex[i] = scanedBuckets[mad24(i, NUM_OF_ELEMENTS_PER_WORK_GROUP_T, globalId)];\n#endif\n}\nfor(int i = 0; i < RADICES_T; ++i)\n{\nint old_idx = mad24(globalId, RADICES_T, i);\nK_T  ovalue = unsortedKeys[old_idx];\nuint value = convertKey(as_uint(ovalue));\nuint maskedValue = (value >> shiftCount) & MASK_T;\nuint index = localIndex[maskedValue];\nsortedKeys[index] = ovalue;\nsortedVals[index] = unsortedVals[old_idx];\nlocalIndex[maskedValue] = index + 1;\n}\n}\n", "0e6fe5592aca6ddfade79641efe19a59", "interpolate_frames", "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n__constant sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\nvoid atomic_addf(volatile __global float *source, const float operand) {\nunion {\nunsigned int intVal;\nfloat floatVal;\n} newVal;\nunion {\nunsigned int intVal;\nfloat floatVal;\n} prevVal;\ndo {\nprevVal.floatVal = *source;\nnewVal.floatVal = prevVal.floatVal + operand;\n} while (atomic_cmpxchg((volatile __global unsigned int *)source, prevVal.intVal, newVal.intVal) != prevVal.intVal);\n}\n__kernel void memsetKernel(\nfloat val,\n__global float * image,\nint width,\nint height,\nint step,\nint offset\n)\n{\nif(get_global_id(0) >= width || get_global_id(1) >= height)\n{\nreturn;\n}\nimage += offset;\nimage[get_global_id(0) + get_global_id(1) * step] = val;\n}\n__kernel void normalizeKernel(\n__global float * buffer,\nint width,\nint height,\nint step,\nint f_offset,\nint d_offset\n)\n{\n__global float * factors = buffer + f_offset;\n__global float * dst     = buffer + d_offset;\nint j = get_global_id(0);\nint i = get_global_id(1);\nif(j >= width || i >= height)\n{\nreturn;\n}\nfloat scale = factors[step * i + j];\nfloat invScale = (scale == 0.0f) ? 1.0f : (1.0f / scale);\ndst[step * i + j] *= invScale;\n}\n__kernel void forwardWarpKernel(\n__global const float * src,\n__global float * buffer,\n__global const float * u,\n__global const float * v,\nconst int w,\nconst int h,\nconst int flow_stride,\nconst int image_stride,\nconst int factor_offset,\nconst int dst_offset,\nconst float time_scale\n)\n{\nint j = get_global_id(0);\nint i = get_global_id(1);\nif (i >= h || j >= w) return;\nvolatile __global float * normalization_factor = (volatile __global float *) buffer + factor_offset;\nvolatile __global float * dst = (volatile __global float *)buffer + dst_offset;\nint flow_row_offset  = i * flow_stride;\nint image_row_offset = i * image_stride;\nfloat cx = u[flow_row_offset + j] * time_scale + (float)j + 1.0f;\nfloat cy = v[flow_row_offset + j] * time_scale + (float)i + 1.0f;\nfloat px;\nfloat py;\nfloat dx = modf(cx, &px);\nfloat dy = modf(cy, &py);\nint tx;\nint ty;\ntx = (int) px;\nty = (int) py;\nfloat value = src[image_row_offset + j];\nfloat weight;\nif (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n{\nweight = dx * dy;\natomic_addf(dst + ty * image_stride + tx, value * weight);\natomic_addf(normalization_factor + ty * image_stride + tx, weight);\n}\ntx -= 1;\nif (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n{\nweight = (1.0f - dx) * dy;\natomic_addf(dst + ty * image_stride + tx, value * weight);\natomic_addf(normalization_factor + ty * image_stride + tx, weight);\n}\nty -= 1;\nif (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n{\nweight = (1.0f - dx) * (1.0f - dy);\natomic_addf(dst + ty * image_stride + tx, value * weight);\natomic_addf(normalization_factor + ty * image_stride + tx, weight);\n}\ntx += 1;\nif (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n{\nweight = dx * (1.0f - dy);\natomic_addf(dst + ty * image_stride + tx, value * weight);\natomic_addf(normalization_factor + ty * image_stride + tx, weight);\n}\n}\nenum\n{\nO0_OS = 0,\nO1_OS,\nU_OS,\nV_OS,\nUR_OS,\nVR_OS\n};\n__kernel void blendFramesKernel(\nimage2d_t tex_src0,\nimage2d_t tex_src1,\n__global float * buffer,\n__global float * out,\nint w,\nint h,\nint step,\nfloat theta\n)\n{\n__global float * u  = buffer + h * step * U_OS;\n__global float * v  = buffer + h * step * V_OS;\n__global float * ur = buffer + h * step * UR_OS;\n__global float * vr = buffer + h * step * VR_OS;\n__global float * o0 = buffer + h * step * O0_OS;\n__global float * o1 = buffer + h * step * O1_OS;\nint ix = get_global_id(0);\nint iy = get_global_id(1);\nif(ix >= w || iy >= h) return;\nint pos = ix + step * iy;\nfloat _u  = u[pos];\nfloat _v  = v[pos];\nfloat _ur = ur[pos];\nfloat _vr = vr[pos];\nfloat x = (float)ix + 0.5f;\nfloat y = (float)iy + 0.5f;\nbool b0 = o0[pos] > 1e-4f;\nbool b1 = o1[pos] > 1e-4f;\nfloat2 coord0 = (float2)(x - _u * theta, y - _v * theta);\nfloat2 coord1 = (float2)(x + _u * (1.0f - theta), y + _v * (1.0f - theta));\nif (b0 && b1)\n{\nout[pos] = read_imagef(tex_src0, sampler, coord0).x * (1.0f - theta) +\nread_imagef(tex_src1, sampler, coord1).x * theta;\n}\nelse if (b0)\n{\nout[pos] = read_imagef(tex_src0, sampler, coord0).x;\n}\nelse\n{\nout[pos] = read_imagef(tex_src1, sampler, coord1).x;\n}\n}\n", "984886a43f456d32a2f199a31ba3d12a", "imgproc_warpPerspective", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\ntypedef double F;\ntypedef double4 F4;\n#define convert_F4 convert_double4\n#else\ntypedef float F;\ntypedef float4 F4;\n#define convert_F4 convert_float4\n#endif\n#define INTER_BITS 5\n#define INTER_TAB_SIZE (1 << INTER_BITS)\n#define INTER_SCALE 1.f/INTER_TAB_SIZE\n#define AB_BITS max(10, (int)INTER_BITS)\n#define AB_SCALE (1 << AB_BITS)\n#define INTER_REMAP_COEF_BITS 15\n#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\nvoid interpolateCubic( float x, float* coeffs )\n{\nconst float A = -0.75f;\ncoeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\ncoeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\ncoeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\ncoeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n}\n__kernel void warpPerspectiveNN_C1_D0(__global uchar const * restrict src, __global uchar * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\ndx = (dx<<2) - (dst_offset&3);\nF4 DX = (F4)(dx, dx+1, dx+2, dx+3);\nF4 X0 = M[0]*DX + M[1]*dy + M[2];\nF4 Y0 = M[3]*DX + M[4]*dy + M[5];\nF4 W = M[6]*DX + M[7]*dy + M[8],one=1,zero=0;\nW = (W!=zero) ? one/W : zero;\nshort4 X = convert_short4_sat_rte(X0*W);\nshort4 Y = convert_short4_sat_rte(Y0*W);\nint4 sx = convert_int4(X);\nint4 sy = convert_int4(Y);\nint4 DXD = (int4)(dx, dx+1, dx+2, dx+3);\n__global uchar4 * d = (__global uchar4 *)(dst+dst_offset+dy*dstStep+dx);\nuchar4 dval = *d;\nint4 dcon = DXD >= 0 && DXD < dst_cols && dy >= 0 && dy < dst_rows;\nint4 scon = sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows;\nint4 spos = src_offset + sy * srcStep + sx;\nuchar4 sval;\nsval.s0 = scon.s0 ? src[spos.s0] : 0;\nsval.s1 = scon.s1 ? src[spos.s1] : 0;\nsval.s2 = scon.s2 ? src[spos.s2] : 0;\nsval.s3 = scon.s3 ? src[spos.s3] : 0;\ndval = convert_uchar4(dcon) != (uchar4)(0,0,0,0) ? sval : dval;\n*d = dval;\n}\n}\n__kernel void warpPerspectiveLinear_C1_D0(__global const uchar * restrict src, __global uchar * dst,\nint src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\nint dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nint sx = convert_short_sat(X >> INTER_BITS);\nint sy = convert_short_sat(Y >> INTER_BITS);\nint ay = (short)(Y & (INTER_TAB_SIZE-1));\nint ax = (short)(X & (INTER_TAB_SIZE-1));\nuchar v[4];\nint i;\n#pragma unroll 4\nfor(i=0; i<4;  i++)\nv[i] = (sx+(i&1) >= 0 && sx+(i&1) < src_cols && sy+(i>>1) >= 0 && sy+(i>>1) < src_rows) ? src[src_offset + (sy+(i>>1)) * srcStep + (sx+(i&1))] : (uchar)0;\nshort itab[4];\nfloat tab1y[2], tab1x[2];\ntab1y[0] = 1.0f - 1.f/INTER_TAB_SIZE*ay;\ntab1y[1] = 1.f/INTER_TAB_SIZE*ay;\ntab1x[0] = 1.0f - 1.f/INTER_TAB_SIZE*ax;\ntab1x[1] = 1.f/INTER_TAB_SIZE*ax;\n#pragma unroll 4\nfor(i=0; i<4;  i++)\n{\nfloat v = tab1y[(i>>1)] * tab1x[(i&1)];\nitab[i] = convert_short_sat_rte( v * INTER_REMAP_COEF_SCALE );\n}\nif(dx >=0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nint sum = 0;\nfor ( i =0; i<4; i++ )\n{\nsum += v[i] * itab[i] ;\n}\ndst[dst_offset+dy*dstStep+dx] = convert_uchar_sat ( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n}\n}\n}\n__kernel void warpPerspectiveCubic_C1_D0(__global uchar * src, __global uchar * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nshort sx = convert_short_sat(X >> INTER_BITS) - 1;\nshort sy = convert_short_sat(Y >> INTER_BITS) - 1;\nshort ay = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax = (short)(X & (INTER_TAB_SIZE-1));\nuchar v[16];\nint i, j;\n#pragma unroll 4\nfor(i=0; i<4;  i++)\nfor(j=0; j<4;  j++)\n{\nv[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? src[src_offset+(sy+i) * srcStep + (sx+j)] : (uchar)0;\n}\nshort itab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = 1.f/INTER_TAB_SIZE * ay;\naxx = 1.f/INTER_TAB_SIZE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\nint isum = 0;\n#pragma unroll 16\nfor( i=0; i<16; i++ )\n{\nF v = tab1y[(i>>2)] * tab1x[(i&3)];\nisum += itab[i] = convert_short_sat( rint( v * INTER_REMAP_COEF_SCALE ) );\n}\nif( isum != INTER_REMAP_COEF_SCALE )\n{\nint k1, k2;\nint diff = isum - INTER_REMAP_COEF_SCALE;\nint Mk1=2, Mk2=2, mk1=2, mk2=2;\nfor( k1 = 2; k1 < 4; k1++ )\nfor( k2 = 2; k2 < 4; k2++ )\n{\nif( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\nmk1 = k1, mk2 = k2;\nelse if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\nMk1 = k1, Mk2 = k2;\n}\ndiff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nint sum=0;\nfor ( i =0; i<16; i++ )\n{\nsum += v[i] * itab[i] ;\n}\ndst[dst_offset+dy*dstStep+dx] = convert_uchar_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n}\n}\n}\n__kernel void warpPerspectiveNN_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst,\nint src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\nint dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? 1.f/W : 0.0f;\nshort sx = convert_short_sat_rte(X0*W);\nshort sy = convert_short_sat_rte(Y0*W);\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*(dstStep>>2)+dx]= (sx>=0 && sx<src_cols && sy>=0 && sy<src_rows) ? src[(src_offset>>2)+sy*(srcStep>>2)+sx] : (uchar4)0;\n}\n}\n__kernel void warpPerspectiveLinear_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst,\nint src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\nint dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nsrc_offset = (src_offset>>2);\nsrcStep = (srcStep>>2);\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nshort sx = convert_short_sat(X >> INTER_BITS);\nshort sy = convert_short_sat(Y >> INTER_BITS);\nshort ay = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax = (short)(X & (INTER_TAB_SIZE-1));\nint4 v0, v1, v2, v3;\nv0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ? convert_int4(src[src_offset+sy * srcStep + sx]) : (int4)0;\nv1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ? convert_int4(src[src_offset+sy * srcStep + sx+1]) : (int4)0;\nv2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? convert_int4(src[src_offset+(sy+1) * srcStep + sx]) : (int4)0;\nv3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? convert_int4(src[src_offset+(sy+1) * srcStep + sx+1]) : (int4)0;\nint itab0, itab1, itab2, itab3;\nfloat taby, tabx;\ntaby = 1.f/INTER_TAB_SIZE*ay;\ntabx = 1.f/INTER_TAB_SIZE*ax;\nitab0 = convert_short_sat(rint( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\nitab1 = convert_short_sat(rint( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE ));\nitab2 = convert_short_sat(rint( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\nitab3 = convert_short_sat(rint( taby*tabx * INTER_REMAP_COEF_SCALE ));\nint4 val;\nval = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*(dstStep>>2)+dx] =  convert_uchar4_sat ( (val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n}\n}\n__kernel void warpPerspectiveCubic_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst,\nint src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\nint dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nsrc_offset = (src_offset>>2);\nsrcStep = (srcStep>>2);\ndst_offset = (dst_offset>>2);\ndstStep = (dstStep>>2);\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nshort sx = convert_short_sat(X >> INTER_BITS) - 1;\nshort sy = convert_short_sat(Y >> INTER_BITS) - 1;\nshort ay = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax = (short)(X & (INTER_TAB_SIZE-1));\nuchar4 v[16];\nint i,j;\n#pragma unroll 4\nfor(i=0; i<4; i++)\nfor(j=0; j<4; j++)\n{\nv[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? (src[src_offset+(sy+i) * srcStep + (sx+j)])  : (uchar4)0;\n}\nint itab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = INTER_SCALE * ay;\naxx = INTER_SCALE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\nint isum = 0;\n#pragma unroll 16\nfor( i=0; i<16; i++ )\n{\nfloat tmp;\ntmp = tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE;\nitab[i] = rint(tmp);\nisum += itab[i];\n}\nif( isum != INTER_REMAP_COEF_SCALE )\n{\nint k1, k2;\nint diff = isum - INTER_REMAP_COEF_SCALE;\nint Mk1=2, Mk2=2, mk1=2, mk2=2;\nfor( k1 = 2; k1 < 4; k1++ )\nfor( k2 = 2; k2 < 4; k2++ )\n{\nif( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\nmk1 = k1, mk2 = k2;\nelse if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\nMk1 = k1, Mk2 = k2;\n}\ndiff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nint4 sum=0;\nfor ( i =0; i<16; i++ )\n{\nsum += convert_int4(v[i]) * itab[i];\n}\ndst[dst_offset+dy*dstStep+dx] = convert_uchar4_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n}\n}\n}\n__kernel void warpPerspectiveNN_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? 1.f/W : 0.0f;\nshort sx = convert_short_sat_rte(X0*W);\nshort sy = convert_short_sat_rte(Y0*W);\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*dstStep+dx]= (sx>=0 && sx<src_cols && sy>=0 && sy<src_rows) ? src[(src_offset>>2)+sy*srcStep+sx] : 0;\n}\n}\n__kernel void warpPerspectiveLinear_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nsrc_offset = (src_offset>>2);\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nshort sx = convert_short_sat(X >> INTER_BITS);\nshort sy = convert_short_sat(Y >> INTER_BITS);\nshort ay = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax = (short)(X & (INTER_TAB_SIZE-1));\nfloat v0, v1, v2, v3;\nv0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ? src[src_offset+sy * srcStep + sx] : (float)0;\nv1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ? src[src_offset+sy * srcStep + sx+1] : (float)0;\nv2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? src[src_offset+(sy+1) * srcStep + sx] : (float)0;\nv3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? src[src_offset+(sy+1) * srcStep + sx+1] : (float)0;\nfloat tab[4];\nfloat taby[2], tabx[2];\ntaby[0] = 1.0f - 1.f/INTER_TAB_SIZE*ay;\ntaby[1] = 1.f/INTER_TAB_SIZE*ay;\ntabx[0] = 1.0f - 1.f/INTER_TAB_SIZE*ax;\ntabx[1] = 1.f/INTER_TAB_SIZE*ax;\ntab[0] = taby[0] * tabx[0];\ntab[1] = taby[0] * tabx[1];\ntab[2] = taby[1] * tabx[0];\ntab[3] = taby[1] * tabx[1];\nfloat sum = 0;\nsum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*dstStep+dx] = sum;\n}\n}\n__kernel void warpPerspectiveCubic_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nsrc_offset = (src_offset>>2);\ndst_offset = (dst_offset>>2);\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nshort sx = convert_short_sat(X >> INTER_BITS) - 1;\nshort sy = convert_short_sat(Y >> INTER_BITS) - 1;\nshort ay = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax = (short)(X & (INTER_TAB_SIZE-1));\nfloat v[16];\nint i;\nfor(i=0; i<16;  i++)\nv[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : (float)0;\nfloat tab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = 1.f/INTER_TAB_SIZE * ay;\naxx = 1.f/INTER_TAB_SIZE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\n#pragma unroll 4\nfor( i=0; i<16; i++ )\n{\ntab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nfloat sum = 0;\n#pragma unroll 4\nfor ( i =0; i<16; i++ )\n{\nsum += v[i] * tab[i];\n}\ndst[dst_offset+dy*dstStep+dx] = sum;\n}\n}\n}\n__kernel void warpPerspectiveNN_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW =(W != 0.0f)? 1.f/W : 0.0f;\nshort sx = convert_short_sat_rte(X0*W);\nshort sy = convert_short_sat_rte(Y0*W);\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>4)+dy*(dstStep>>2)+dx]= (sx>=0 && sx<src_cols && sy>=0 && sy<src_rows) ? src[(src_offset>>4)+sy*(srcStep>>2)+sx] : (float)0;\n}\n}\n__kernel void warpPerspectiveLinear_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nsrc_offset = (src_offset>>4);\ndst_offset = (dst_offset>>4);\nsrcStep = (srcStep>>2);\ndstStep = (dstStep>>2);\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nshort sx0 = convert_short_sat(X >> INTER_BITS);\nshort sy0 = convert_short_sat(Y >> INTER_BITS);\nshort ay0 = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax0 = (short)(X & (INTER_TAB_SIZE-1));\nfloat4 v0, v1, v2, v3;\nv0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0] : (float4)0;\nv1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0+1] : (float4)0;\nv2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0] : (float4)0;\nv3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0+1] : (float4)0;\nfloat tab[4];\nfloat taby[2], tabx[2];\ntaby[0] = 1.0f - 1.f/INTER_TAB_SIZE*ay0;\ntaby[1] = 1.f/INTER_TAB_SIZE*ay0;\ntabx[0] = 1.0f - 1.f/INTER_TAB_SIZE*ax0;\ntabx[1] = 1.f/INTER_TAB_SIZE*ax0;\ntab[0] = taby[0] * tabx[0];\ntab[1] = taby[0] * tabx[1];\ntab[2] = taby[1] * tabx[0];\ntab[3] = taby[1] * tabx[1];\nfloat4 sum = 0;\nsum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[dst_offset+dy*dstStep+dx] = sum;\n}\n}\n__kernel void warpPerspectiveCubic_C4_D5(__global float4 * src, __global float4 * dst,\nint src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\nint dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows )\n{\nsrc_offset = (src_offset>>4);\ndst_offset = (dst_offset>>4);\nsrcStep = (srcStep>>2);\ndstStep = (dstStep>>2);\nF X0 = M[0]*dx + M[1]*dy + M[2];\nF Y0 = M[3]*dx + M[4]*dy + M[5];\nF W = M[6]*dx + M[7]*dy + M[8];\nW = (W != 0.0f) ? INTER_TAB_SIZE/W : 0.0f;\nint X = rint(X0*W);\nint Y = rint(Y0*W);\nshort sx = convert_short_sat(X >> INTER_BITS)-1;\nshort sy = convert_short_sat(Y >> INTER_BITS)-1;\nshort ay = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax = (short)(X & (INTER_TAB_SIZE-1));\nfloat4 v[16];\nint i;\nfor(i=0; i<16;  i++)\nv[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : (float4)0;\nfloat tab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = 1.f/INTER_TAB_SIZE * ay;\naxx = 1.f/INTER_TAB_SIZE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\n#pragma unroll 4\nfor( i=0; i<16; i++ )\n{\ntab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nfloat4 sum = 0;\n#pragma unroll 4\nfor ( i =0; i<16; i++ )\n{\nsum += v[i] * tab[i];\n}\ndst[dst_offset+dy*dstStep+dx] = sum;\n}\n}\n}\n", "13ff30fed80ece6c6828a26c11a07de7", "imgproc_warpAffine", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\ntypedef double F;\ntypedef double4 F4;\n#define convert_F4 convert_double4\n#else\ntypedef float F;\ntypedef float4 F4;\n#define convert_F4 convert_float4\n#endif\n#define INTER_BITS 5\n#define INTER_TAB_SIZE (1 << INTER_BITS)\n#define INTER_SCALE 1.f/INTER_TAB_SIZE\n#define AB_BITS max(10, (int)INTER_BITS)\n#define AB_SCALE (1 << AB_BITS)\n#define INTER_REMAP_COEF_BITS 15\n#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\nvoid interpolateCubic( float x, float* coeffs )\n{\nconst float A = -0.75f;\ncoeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\ncoeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\ncoeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\ncoeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n}\n__kernel void warpAffineNN_C1_D0(__global uchar const * restrict src, __global uchar * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\ndx = (dx<<2) - (dst_offset&3);\nint round_delta = (AB_SCALE>>1);\nint4 X, Y;\nint4 sx, sy;\nint4 DX = (int4)(dx, dx+1, dx+2, dx+3);\nDX = (DX << AB_BITS);\nF4 M0DX, M3DX;\nM0DX = M[0] * convert_F4(DX);\nM3DX = M[3] * convert_F4(DX);\nX = convert_int4(rint(M0DX));\nY = convert_int4(rint(M3DX));\nint tmp1, tmp2;\ntmp1 = rint((M[1]*dy + M[2]) * AB_SCALE);\ntmp2 = rint((M[4]*dy + M[5]) * AB_SCALE);\nX += tmp1 + round_delta;\nY += tmp2 + round_delta;\nsx = convert_int4(convert_short4(X >> AB_BITS));\nsy = convert_int4(convert_short4(Y >> AB_BITS));\n__global uchar4 * d = (__global uchar4 *)(dst+dst_offset+dy*dstStep+dx);\nuchar4 dval = *d;\nDX = (int4)(dx, dx+1, dx+2, dx+3);\nint4 dcon = DX >= 0 && DX < dst_cols && dy >= 0 && dy < dst_rows;\nint4 scon = sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows;\nint4 spos = src_offset + sy * srcStep + sx;\nuchar4 sval;\nsval.s0 = scon.s0 ? src[spos.s0] : 0;\nsval.s1 = scon.s1 ? src[spos.s1] : 0;\nsval.s2 = scon.s2 ? src[spos.s2] : 0;\nsval.s3 = scon.s3 ? src[spos.s3] : 0;\ndval = convert_uchar4(dcon) != (uchar4)(0,0,0,0) ? sval : dval;\n*d = dval;\n}\n}\n__kernel void warpAffineLinear_C1_D0(__global const uchar * restrict src, __global uchar * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\ndx = (dx<<2) - (dst_offset&3);\nint round_delta = ((AB_SCALE >> INTER_BITS) >> 1);\nint4 X, Y;\nshort4  ax, ay;\nint4 sx, sy;\nint4 DX = (int4)(dx, dx+1, dx+2, dx+3);\nDX = (DX << AB_BITS);\nF4 M0DX, M3DX;\nM0DX = M[0] * convert_F4(DX);\nM3DX = M[3] * convert_F4(DX);\nX = convert_int4(rint(M0DX));\nY = convert_int4(rint(M3DX));\nint tmp1, tmp2;\ntmp1 = rint((M[1]*dy + M[2]) * AB_SCALE);\ntmp2 = rint((M[4]*dy + M[5]) * AB_SCALE);\nX += tmp1 + round_delta;\nY += tmp2 + round_delta;\nX = X >> (AB_BITS - INTER_BITS);\nY = Y >> (AB_BITS - INTER_BITS);\nsx = convert_int4(convert_short4(X >> INTER_BITS));\nsy = convert_int4(convert_short4(Y >> INTER_BITS));\nax = convert_short4(X & (INTER_TAB_SIZE-1));\nay = convert_short4(Y & (INTER_TAB_SIZE-1));\nuchar4 v0, v1, v2,v3;\nint4 scon0, scon1, scon2, scon3;\nint4 spos0, spos1, spos2, spos3;\nscon0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows);\nscon1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows);\nscon2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows);\nscon3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows);\nspos0 = src_offset + sy * srcStep + sx;\nspos1 = src_offset + sy * srcStep + sx + 1;\nspos2 = src_offset + (sy+1) * srcStep + sx;\nspos3 = src_offset + (sy+1) * srcStep + sx + 1;\nv0.s0 = scon0.s0 ? src[spos0.s0] : 0;\nv1.s0 = scon1.s0 ? src[spos1.s0] : 0;\nv2.s0 = scon2.s0 ? src[spos2.s0] : 0;\nv3.s0 = scon3.s0 ? src[spos3.s0] : 0;\nv0.s1 = scon0.s1 ? src[spos0.s1] : 0;\nv1.s1 = scon1.s1 ? src[spos1.s1] : 0;\nv2.s1 = scon2.s1 ? src[spos2.s1] : 0;\nv3.s1 = scon3.s1 ? src[spos3.s1] : 0;\nv0.s2 = scon0.s2 ? src[spos0.s2] : 0;\nv1.s2 = scon1.s2 ? src[spos1.s2] : 0;\nv2.s2 = scon2.s2 ? src[spos2.s2] : 0;\nv3.s2 = scon3.s2 ? src[spos3.s2] : 0;\nv0.s3 = scon0.s3 ? src[spos0.s3] : 0;\nv1.s3 = scon1.s3 ? src[spos1.s3] : 0;\nv2.s3 = scon2.s3 ? src[spos2.s3] : 0;\nv3.s3 = scon3.s3 ? src[spos3.s3] : 0;\nshort4 itab0, itab1, itab2, itab3;\nfloat4 taby, tabx;\ntaby = INTER_SCALE * convert_float4(ay);\ntabx = INTER_SCALE * convert_float4(ax);\nitab0 = convert_short4_sat(( (1.0f-taby)*(1.0f-tabx) * (float4)INTER_REMAP_COEF_SCALE ));\nitab1 = convert_short4_sat(( (1.0f-taby)*tabx * (float4)INTER_REMAP_COEF_SCALE ));\nitab2 = convert_short4_sat(( taby*(1.0f-tabx) * (float4)INTER_REMAP_COEF_SCALE ));\nitab3 = convert_short4_sat(( taby*tabx * (float4)INTER_REMAP_COEF_SCALE ));\nint4 val;\nuchar4 tval;\nval = convert_int4(v0) * convert_int4(itab0) + convert_int4(v1) * convert_int4(itab1)\n+ convert_int4(v2) * convert_int4(itab2) + convert_int4(v3) * convert_int4(itab3);\ntval = convert_uchar4_sat ( (val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n__global uchar4 * d =(__global uchar4 *)(dst+dst_offset+dy*dstStep+dx);\nuchar4 dval = *d;\nDX = (int4)(dx, dx+1, dx+2, dx+3);\nint4 dcon = DX >= 0 && DX < dst_cols && dy >= 0 && dy < dst_rows;\ndval = convert_uchar4(dcon != 0) ? tval : dval;\n*d = dval;\n}\n}\n__kernel void warpAffineCubic_C1_D0(__global uchar * src, __global uchar * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = ((AB_SCALE>>INTER_BITS)>>1);\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nint X = X0 >> (AB_BITS - INTER_BITS);\nint Y = Y0 >> (AB_BITS - INTER_BITS);\nshort sx = (short)(X >> INTER_BITS) - 1;\nshort sy = (short)(Y >> INTER_BITS) - 1;\nshort ay = (short)(Y & (INTER_TAB_SIZE-1));\nshort ax = (short)(X & (INTER_TAB_SIZE-1));\nuchar v[16];\nint i, j;\n#pragma unroll 4\nfor(i=0; i<4;  i++)\nfor(j=0; j<4;  j++)\n{\nv[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? src[src_offset+(sy+i) * srcStep + (sx+j)] : 0;\n}\nshort itab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = 1.f/INTER_TAB_SIZE * ay;\naxx = 1.f/INTER_TAB_SIZE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\nint isum = 0;\n#pragma unroll 16\nfor( i=0; i<16; i++ )\n{\nF v = tab1y[(i>>2)] * tab1x[(i&3)];\nisum += itab[i] = convert_short_sat( rint( v * INTER_REMAP_COEF_SCALE ) );\n}\nif( isum != INTER_REMAP_COEF_SCALE )\n{\nint k1, k2;\nint diff = isum - INTER_REMAP_COEF_SCALE;\nint Mk1=2, Mk2=2, mk1=2, mk2=2;\nfor( k1 = 2; k1 < 4; k1++ )\nfor( k2 = 2; k2 < 4; k2++ )\n{\nif( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\nmk1 = k1, mk2 = k2;\nelse if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\nMk1 = k1, Mk2 = k2;\n}\ndiff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nint sum=0;\nfor ( i =0; i<16; i++ )\n{\nsum += v[i] * itab[i] ;\n}\ndst[dst_offset+dy*dstStep+dx] = convert_uchar_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n}\n}\n}\n__kernel void warpAffineNN_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = (AB_SCALE >> 1);\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nint sx0 = (short)(X0 >> AB_BITS);\nint sy0 = (short)(Y0 >> AB_BITS);\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*(dstStep>>2)+dx]= (sx0>=0 && sx0<src_cols && sy0>=0 && sy0<src_rows) ? src[(src_offset>>2)+sy0*(srcStep>>2)+sx0] : (uchar4)0;\n}\n}\n__kernel void warpAffineLinear_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = AB_SCALE/INTER_TAB_SIZE/2;\nsrc_offset = (src_offset>>2);\nsrcStep = (srcStep>>2);\nint tmp = (dx << AB_BITS);\nint X0 = rint(M[0] * tmp);\nint Y0 = rint(M[3] * tmp);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nX0 = X0 >> (AB_BITS - INTER_BITS);\nY0 = Y0 >> (AB_BITS - INTER_BITS);\nshort sx0 = (short)(X0 >> INTER_BITS);\nshort sy0 = (short)(Y0 >> INTER_BITS);\nshort ax0 = (short)(X0 & (INTER_TAB_SIZE-1));\nshort ay0 = (short)(Y0 & (INTER_TAB_SIZE-1));\nint4 v0, v1, v2, v3;\nv0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? convert_int4(src[src_offset+sy0 * srcStep + sx0]) : 0;\nv1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? convert_int4(src[src_offset+sy0 * srcStep + sx0+1]) : 0;\nv2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? convert_int4(src[src_offset+(sy0+1) * srcStep + sx0]) : 0;\nv3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? convert_int4(src[src_offset+(sy0+1) * srcStep + sx0+1]) : 0;\nint itab0, itab1, itab2, itab3;\nfloat taby, tabx;\ntaby = 1.f/INTER_TAB_SIZE*ay0;\ntabx = 1.f/INTER_TAB_SIZE*ax0;\nitab0 = convert_short_sat(rint( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\nitab1 = convert_short_sat(rint( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE ));\nitab2 = convert_short_sat(rint( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\nitab3 = convert_short_sat(rint( taby*tabx * INTER_REMAP_COEF_SCALE ));\nint4 val;\nval = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*(dstStep>>2)+dx] =  convert_uchar4_sat ( (val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n}\n}\n__kernel void warpAffineCubic_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = ((AB_SCALE>>INTER_BITS)>>1);\nsrc_offset = (src_offset>>2);\nsrcStep = (srcStep>>2);\ndst_offset = (dst_offset>>2);\ndstStep = (dstStep>>2);\nint tmp = (dx << AB_BITS);\nint X0 = rint(M[0] * tmp);\nint Y0 = rint(M[3] * tmp);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nX0 = X0 >> (AB_BITS - INTER_BITS);\nY0 = Y0 >> (AB_BITS - INTER_BITS);\nint sx = (short)(X0 >> INTER_BITS) - 1;\nint sy = (short)(Y0 >> INTER_BITS) - 1;\nint ay = (short)(Y0 & (INTER_TAB_SIZE-1));\nint ax = (short)(X0 & (INTER_TAB_SIZE-1));\nuchar4 v[16];\nint i,j;\n#pragma unroll 4\nfor(i=0; i<4; i++)\nfor(j=0; j<4; j++)\n{\nv[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? (src[src_offset+(sy+i) * srcStep + (sx+j)])  : (uchar4)0;\n}\nint itab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = INTER_SCALE * ay;\naxx = INTER_SCALE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\nint isum = 0;\n#pragma unroll 16\nfor( i=0; i<16; i++ )\n{\nfloat tmp;\ntmp = tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE;\nitab[i] = rint(tmp);\nisum += itab[i];\n}\nif( isum != INTER_REMAP_COEF_SCALE )\n{\nint k1, k2;\nint diff = isum - INTER_REMAP_COEF_SCALE;\nint Mk1=2, Mk2=2, mk1=2, mk2=2;\nfor( k1 = 2; k1 < 4; k1++ )\nfor( k2 = 2; k2 < 4; k2++ )\n{\nif( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\nmk1 = k1, mk2 = k2;\nelse if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\nMk1 = k1, Mk2 = k2;\n}\ndiff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nint4 sum=0;\nfor ( i =0; i<16; i++ )\n{\nsum += convert_int4(v[i]) * itab[i];\n}\ndst[dst_offset+dy*dstStep+dx] = convert_uchar4_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n}\n}\n}\n__kernel void warpAffineNN_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = AB_SCALE/2;\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nshort sx0 = (short)(X0 >> AB_BITS);\nshort sy0 = (short)(Y0 >> AB_BITS);\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*dstStep+dx]= (sx0>=0 && sx0<src_cols && sy0>=0 && sy0<src_rows) ? src[(src_offset>>2)+sy0*srcStep+sx0] : 0;\n}\n}\n__kernel void warpAffineLinear_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = AB_SCALE/INTER_TAB_SIZE/2;\nsrc_offset = (src_offset>>2);\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nX0 = X0 >> (AB_BITS - INTER_BITS);\nY0 = Y0 >> (AB_BITS - INTER_BITS);\nshort sx0 = (short)(X0 >> INTER_BITS);\nshort sy0 = (short)(Y0 >> INTER_BITS);\nshort ax0 = (short)(X0 & (INTER_TAB_SIZE-1));\nshort ay0 = (short)(Y0 & (INTER_TAB_SIZE-1));\nfloat v0, v1, v2, v3;\nv0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0] : 0;\nv1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0+1] : 0;\nv2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0] : 0;\nv3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0+1] : 0;\nfloat tab[4];\nfloat taby[2], tabx[2];\ntaby[0] = 1.0f - 1.f/INTER_TAB_SIZE*ay0;\ntaby[1] = 1.f/INTER_TAB_SIZE*ay0;\ntabx[0] = 1.0f - 1.f/INTER_TAB_SIZE*ax0;\ntabx[1] = 1.f/INTER_TAB_SIZE*ax0;\ntab[0] = taby[0] * tabx[0];\ntab[1] = taby[0] * tabx[1];\ntab[2] = taby[1] * tabx[0];\ntab[3] = taby[1] * tabx[1];\nfloat sum = 0;\nsum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>2)+dy*dstStep+dx] = sum;\n}\n}\n__kernel void warpAffineCubic_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = AB_SCALE/INTER_TAB_SIZE/2;\nsrc_offset = (src_offset>>2);\ndst_offset = (dst_offset>>2);\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nX0 = X0 >> (AB_BITS - INTER_BITS);\nY0 = Y0 >> (AB_BITS - INTER_BITS);\nshort sx = (short)(X0 >> INTER_BITS) - 1;\nshort sy = (short)(Y0 >> INTER_BITS) - 1;\nshort ay = (short)(Y0 & (INTER_TAB_SIZE-1));\nshort ax = (short)(X0 & (INTER_TAB_SIZE-1));\nfloat v[16];\nint i;\nfor(i=0; i<16;  i++)\nv[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : 0;\nfloat tab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = 1.f/INTER_TAB_SIZE * ay;\naxx = 1.f/INTER_TAB_SIZE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\n#pragma unroll 4\nfor( i=0; i<16; i++ )\n{\ntab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nfloat sum = 0;\n#pragma unroll 4\nfor ( i =0; i<16; i++ )\n{\nsum += v[i] * tab[i];\n}\ndst[dst_offset+dy*dstStep+dx] = sum;\n}\n}\n}\n__kernel void warpAffineNN_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = AB_SCALE/2;\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nshort sx0 = (short)(X0 >> AB_BITS);\nshort sy0 = (short)(Y0 >> AB_BITS);\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[(dst_offset>>4)+dy*(dstStep>>2)+dx]= (sx0>=0 && sx0<src_cols && sy0>=0 && sy0<src_rows) ? src[(src_offset>>4)+sy0*(srcStep>>2)+sx0] : (float4)0;\n}\n}\n__kernel void warpAffineLinear_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = AB_SCALE/INTER_TAB_SIZE/2;\nsrc_offset = (src_offset>>4);\ndst_offset = (dst_offset>>4);\nsrcStep = (srcStep>>2);\ndstStep = (dstStep>>2);\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nX0 = X0 >> (AB_BITS - INTER_BITS);\nY0 = Y0 >> (AB_BITS - INTER_BITS);\nshort sx0 = (short)(X0 >> INTER_BITS);\nshort sy0 = (short)(Y0 >> INTER_BITS);\nshort ax0 = (short)(X0 & (INTER_TAB_SIZE-1));\nshort ay0 = (short)(Y0 & (INTER_TAB_SIZE-1));\nfloat4 v0, v1, v2, v3;\nv0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0] : (float4)0;\nv1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0+1] : (float4)0;\nv2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0] : (float4)0;\nv3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0+1] : (float4)0;\nfloat tab[4];\nfloat taby[2], tabx[2];\ntaby[0] = 1.0f - 1.f/INTER_TAB_SIZE*ay0;\ntaby[1] = 1.f/INTER_TAB_SIZE*ay0;\ntabx[0] = 1.0f - 1.f/INTER_TAB_SIZE*ax0;\ntabx[1] = 1.f/INTER_TAB_SIZE*ax0;\ntab[0] = taby[0] * tabx[0];\ntab[1] = taby[0] * tabx[1];\ntab[2] = taby[1] * tabx[0];\ntab[3] = taby[1] * tabx[1];\nfloat4 sum = 0;\nsum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\nif(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\ndst[dst_offset+dy*dstStep+dx] = sum;\n}\n}\n__kernel void warpAffineCubic_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\nint dst_cols, int dst_rows, int srcStep, int dstStep,\nint src_offset, int dst_offset,  __constant F * M, int threadCols )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif( dx < threadCols && dy < dst_rows)\n{\nint round_delta = AB_SCALE/INTER_TAB_SIZE/2;\nsrc_offset = (src_offset>>4);\ndst_offset = (dst_offset>>4);\nsrcStep = (srcStep>>2);\ndstStep = (dstStep>>2);\nint X0 = rint(M[0] * dx * AB_SCALE);\nint Y0 = rint(M[3] * dx * AB_SCALE);\nX0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\nY0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\nX0 = X0 >> (AB_BITS - INTER_BITS);\nY0 = Y0 >> (AB_BITS - INTER_BITS);\nshort sx = (short)(X0 >> INTER_BITS) - 1;\nshort sy = (short)(Y0 >> INTER_BITS) - 1;\nshort ay = (short)(Y0 & (INTER_TAB_SIZE-1));\nshort ax = (short)(X0 & (INTER_TAB_SIZE-1));\nfloat4 v[16];\nint i;\nfor(i=0; i<16;  i++)\nv[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : (float4)0;\nfloat tab[16];\nfloat tab1y[4], tab1x[4];\nfloat axx, ayy;\nayy = 1.f/INTER_TAB_SIZE * ay;\naxx = 1.f/INTER_TAB_SIZE * ax;\ninterpolateCubic(ayy, tab1y);\ninterpolateCubic(axx, tab1x);\n#pragma unroll 4\nfor( i=0; i<16; i++ )\n{\ntab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n}\nif( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n{\nfloat4 sum = 0;\n#pragma unroll 4\nfor ( i =0; i<16; i++ )\n{\nsum += v[i] * tab[i];\n}\ndst[dst_offset+dy*dstStep+dx] = sum;\n}\n}\n}\n", "0a1ddf381453d856788b2d2f92df08a8", "imgproc_threshold", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#ifdef VECTORIZED\n__kernel void threshold(__global const T * restrict src, int src_offset, int src_step,\n__global T * dst, int dst_offset, int dst_step,\nT thresh, T max_val, int max_index, int rows, int cols)\n{\nint gx = get_global_id(0);\nint gy = get_global_id(1);\nif (gx < cols && gy < rows)\n{\ngx *= VECSIZE;\nint src_index = mad24(gy, src_step, src_offset + gx);\nint dst_index = mad24(gy, dst_step, dst_offset + gx);\n#ifdef SRC_ALIGNED\nVT sdata = *((__global VT *)(src + src_index));\n#else\nVT sdata = VLOADN(0, src + src_index);\n#endif\nVT vthresh = (VT)(thresh);\n#ifdef THRESH_BINARY\nVT vecValue = sdata > vthresh ? (VT)max_val : (VT)(0);\n#elif defined THRESH_BINARY_INV\nVT vecValue = sdata > vthresh ? (VT)(0) : (VT)max_val;\n#elif defined THRESH_TRUNC\nVT vecValue = sdata > vthresh ? (VT)thresh : sdata;\n#elif defined THRESH_TOZERO\nVT vecValue = sdata > vthresh ? sdata : (VT)(0);\n#elif defined THRESH_TOZERO_INV\nVT vecValue = sdata > vthresh ? (VT)(0) : sdata;\n#endif\nif (gx + VECSIZE <= max_index)\n#ifdef DST_ALIGNED\n*(__global VT*)(dst + dst_index) = vecValue;\n#else\nVSTOREN(vecValue, 0, dst + dst_index);\n#endif\nelse\n{\n__attribute__(( aligned(sizeof(VT)) )) T array[VECSIZE];\n*((VT*)array) = vecValue;\n#pragma unroll\nfor (int i = 0; i < VECSIZE; ++i)\nif (gx + i < max_index)\ndst[dst_index + i] = array[i];\n}\n}\n}\n#else\n__kernel void threshold(__global const T * restrict src, int src_offset, int src_step,\n__global T * dst, int dst_offset, int dst_step,\nT thresh, T max_val, int rows, int cols)\n{\nint gx = get_global_id(0);\nint gy = get_global_id(1);\nif (gx < cols && gy < rows)\n{\nint src_index = mad24(gy, src_step, src_offset + gx);\nint dst_index = mad24(gy, dst_step, dst_offset + gx);\nT sdata = src[src_index];\n#ifdef THRESH_BINARY\ndst[dst_index] = sdata > thresh ? max_val : (T)(0);\n#elif defined THRESH_BINARY_INV\ndst[dst_index] = sdata > thresh ? (T)(0) : max_val;\n#elif defined THRESH_TRUNC\ndst[dst_index] = sdata > thresh ? thresh : sdata;\n#elif defined THRESH_TOZERO\ndst[dst_index] = sdata > thresh ? sdata : (T)(0);\n#elif defined THRESH_TOZERO_INV\ndst[dst_index] = sdata > thresh ? (T)(0) : sdata;\n#endif\n}\n}\n#endif\n", "3d9631e061a5b037ea5cfb86b156d984", "imgproc_sobel3", "#ifdef BORDER_CONSTANT\n#define EXTRAPOLATE(x, maxV)\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = max(min((x), (maxV) - 1), 0); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = ( (x) + (maxV) ) % (maxV); \\\n}\n#elif defined BORDER_REFLECT\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = min( mad24((maxV)-1,2,-(x))+1 , max((x),-(x)-1) ); \\\n}\n#elif defined BORDER_REFLECT_101\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = min( mad24((maxV)-1,2,-(x)), max((x),-(x)) ); \\\n}\n#else\n#error No extrapolation method\n#endif\n#define SRC(_x,_y) convert_float(((global SRCTYPE*)(Src+(_y)*SrcPitch))[_x])\n#ifdef BORDER_CONSTANT\n#define ELEM(_x,_y,r_edge,t_edge,const_v) (_x)<0 | (_x) >= (r_edge) | (_y)<0 | (_y) >= (t_edge) ? (const_v) : SRC((_x),(_y))\n#else\n#define ELEM(_x,_y,r_edge,t_edge,const_v) SRC((_x),(_y))\n#endif\n#define DSTX(_x,_y) (((global float*)(DstX+DstXOffset+(_y)*DstXPitch))[_x])\n#define DSTY(_x,_y) (((global float*)(DstY+DstYOffset+(_y)*DstYPitch))[_x])\n#define INIT_AND_READ_LOCAL_SOURCE(width, height, fill_const, kernel_border) \\\nint srcX = x + srcOffsetX - (kernel_border); \\\nint srcY = y + srcOffsetY - (kernel_border); \\\nint xb = srcX; \\\nint yb = srcY; \\\n\\\nEXTRAPOLATE(xb, (width)); \\\nEXTRAPOLATE(yb, (height)); \\\nlsmem[liy][lix] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n\\\nif(lix < ((kernel_border)*2)) \\\n{ \\\nint xb = srcX+BLK_X; \\\nEXTRAPOLATE(xb,(width)); \\\nlsmem[liy][lix+BLK_X] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n} \\\nif(liy< ((kernel_border)*2)) \\\n{ \\\nint yb = srcY+BLK_Y; \\\nEXTRAPOLATE(yb, (height)); \\\nlsmem[liy+BLK_Y][lix] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n} \\\nif(lix<((kernel_border)*2) && liy<((kernel_border)*2)) \\\n{ \\\nint xb = srcX+BLK_X; \\\nint yb = srcY+BLK_Y; \\\nEXTRAPOLATE(xb,(width)); \\\nEXTRAPOLATE(yb,(height)); \\\nlsmem[liy+BLK_Y][lix+BLK_X] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n}\n__kernel void sobel3(\n__global uchar* Src,\nconst uint      SrcPitch,\nconst int       srcOffsetX,\nconst int       srcOffsetY,\n__global uchar* DstX,\nconst int       DstXOffset,\nconst uint      DstXPitch,\n__global uchar* DstY,\nconst int       DstYOffset,\nconst uint      DstYPitch,\nint             width,\nint             height,\nint             dstWidth,\nint             dstHeight,\nfloat           scale\n)\n{\n__local float lsmem[BLK_Y+2][BLK_X+2];\nint lix = get_local_id(0);\nint liy = get_local_id(1);\nint x = (int)get_global_id(0);\nint y = (int)get_global_id(1);\nINIT_AND_READ_LOCAL_SOURCE(width, height, 0, 1)\nbarrier(CLK_LOCAL_MEM_FENCE);\nif( x >= dstWidth || y >=dstHeight )  return;\nfloat u1 = lsmem[liy][lix];\nfloat u2 = lsmem[liy][lix+1];\nfloat u3 = lsmem[liy][lix+2];\nfloat m1 = lsmem[liy+1][lix];\nfloat m3 = lsmem[liy+1][lix+2];\nfloat b1 = lsmem[liy+2][lix];\nfloat b2 = lsmem[liy+2][lix+1];\nfloat b3 = lsmem[liy+2][lix+2];\n#ifdef SCHARR\nDSTX(x,y) = mad(10.0f, m3 - m1, 3.0f * (u3 - u1 + b3 - b1)) * scale;\nDSTY(x,y) = mad(10.0f, b2 - u2, 3.0f * (b1 - u1 + b3 - u3)) * scale;\n#else\nDSTX(x,y) = mad(2.0f, m3 - m1, u3 - u1 + b3 - b1) * scale;\nDSTY(x,y) = mad(2.0f, b2 - u2, b1 - u1 + b3 - u3) * scale;\n#endif\n}\n__kernel void sobel5(\n__global uchar* Src,\nconst uint      SrcPitch,\nconst int       srcOffsetX,\nconst int       srcOffsetY,\n__global uchar* DstX,\nconst int       DstXOffset,\nconst uint      DstXPitch,\n__global uchar* DstY,\nconst int       DstYOffset,\nconst uint      DstYPitch,\nint             width,\nint             height,\nint             dstWidth,\nint             dstHeight,\nfloat           scale\n)\n{\n__local float lsmem[BLK_Y+4][BLK_X+4];\nint lix = get_local_id(0);\nint liy = get_local_id(1);\nint x = (int)get_global_id(0);\nint y = (int)get_global_id(1);\nINIT_AND_READ_LOCAL_SOURCE(width, height, 0, 2)\nbarrier(CLK_LOCAL_MEM_FENCE);\nif( x >= dstWidth || y >=dstHeight )  return;\nfloat t1 = lsmem[liy][lix];\nfloat t2 = lsmem[liy][lix+1];\nfloat t3 = lsmem[liy][lix+2];\nfloat t4 = lsmem[liy][lix+3];\nfloat t5 = lsmem[liy][lix+4];\nfloat u1 = lsmem[liy+1][lix];\nfloat u2 = lsmem[liy+1][lix+1];\nfloat u3 = lsmem[liy+1][lix+2];\nfloat u4 = lsmem[liy+1][lix+3];\nfloat u5 = lsmem[liy+1][lix+4];\nfloat m1 = lsmem[liy+2][lix];\nfloat m2 = lsmem[liy+2][lix+1];\nfloat m4 = lsmem[liy+2][lix+3];\nfloat m5 = lsmem[liy+2][lix+4];\nfloat l1 = lsmem[liy+3][lix];\nfloat l2 = lsmem[liy+3][lix+1];\nfloat l3 = lsmem[liy+3][lix+2];\nfloat l4 = lsmem[liy+3][lix+3];\nfloat l5 = lsmem[liy+3][lix+4];\nfloat b1 = lsmem[liy+4][lix];\nfloat b2 = lsmem[liy+4][lix+1];\nfloat b3 = lsmem[liy+4][lix+2];\nfloat b4 = lsmem[liy+4][lix+3];\nfloat b5 = lsmem[liy+4][lix+4];\nDSTX(x,y) = scale *\nmad(12.0f, m4 - m2,\nmad(6.0f, m5 - m1,\nmad(8.0f, u4 - u2 + l4 - l2,\nmad(4.0f, u5 - u1 + l5 - l1,\nmad(2.0f, t4 - t2 + b4 - b2, t5 - t1 + b5 - b1 )\n)\n)\n)\n);\nDSTY(x,y) = scale *\nmad(12.0f, l3 - u3,\nmad(6.0f, b3 - t3,\nmad(8.0f, l2 - u2 + l4 - u4,\nmad(4.0f, b2 - t2 + b4 - t4,\nmad(2.0f, l1 - u1 + l5 - u5, b1 - t1 + b5 - t5 )\n)\n)\n)\n);\n}\n__kernel void sobel7(\n__global uchar* Src,\nconst uint      SrcPitch,\nconst int       srcOffsetX,\nconst int       srcOffsetY,\n__global uchar* DstX,\nconst int       DstXOffset,\nconst uint      DstXPitch,\n__global uchar* DstY,\nconst int       DstYOffset,\nconst uint      DstYPitch,\nint             width,\nint             height,\nint             dstWidth,\nint             dstHeight,\nfloat           scale\n)\n{\n__local float lsmem[BLK_Y+6][BLK_X+6];\nint lix = get_local_id(0);\nint liy = get_local_id(1);\nint x = (int)get_global_id(0);\nint y = (int)get_global_id(1);\nINIT_AND_READ_LOCAL_SOURCE(width, height, 0, 3)\nbarrier(CLK_LOCAL_MEM_FENCE);\nif( x >= dstWidth || y >=dstHeight )  return;\nfloat tt1 = lsmem[liy][lix];\nfloat tt2 = lsmem[liy][lix+1];\nfloat tt3 = lsmem[liy][lix+2];\nfloat tt4 = lsmem[liy][lix+3];\nfloat tt5 = lsmem[liy][lix+4];\nfloat tt6 = lsmem[liy][lix+5];\nfloat tt7 = lsmem[liy][lix+6];\nfloat t1 = lsmem[liy+1][lix];\nfloat t2 = lsmem[liy+1][lix+1];\nfloat t3 = lsmem[liy+1][lix+2];\nfloat t4 = lsmem[liy+1][lix+3];\nfloat t5 = lsmem[liy+1][lix+4];\nfloat t6 = lsmem[liy+1][lix+5];\nfloat t7 = lsmem[liy+1][lix+6];\nfloat u1 = lsmem[liy+2][lix];\nfloat u2 = lsmem[liy+2][lix+1];\nfloat u3 = lsmem[liy+2][lix+2];\nfloat u4 = lsmem[liy+2][lix+3];\nfloat u5 = lsmem[liy+2][lix+4];\nfloat u6 = lsmem[liy+2][lix+5];\nfloat u7 = lsmem[liy+2][lix+6];\nfloat m1 = lsmem[liy+3][lix];\nfloat m2 = lsmem[liy+3][lix+1];\nfloat m3 = lsmem[liy+3][lix+2];\nfloat m5 = lsmem[liy+3][lix+4];\nfloat m6 = lsmem[liy+3][lix+5];\nfloat m7 = lsmem[liy+3][lix+6];\nfloat l1 = lsmem[liy+4][lix];\nfloat l2 = lsmem[liy+4][lix+1];\nfloat l3 = lsmem[liy+4][lix+2];\nfloat l4 = lsmem[liy+4][lix+3];\nfloat l5 = lsmem[liy+4][lix+4];\nfloat l6 = lsmem[liy+4][lix+5];\nfloat l7 = lsmem[liy+4][lix+6];\nfloat b1 = lsmem[liy+5][lix];\nfloat b2 = lsmem[liy+5][lix+1];\nfloat b3 = lsmem[liy+5][lix+2];\nfloat b4 = lsmem[liy+5][lix+3];\nfloat b5 = lsmem[liy+5][lix+4];\nfloat b6 = lsmem[liy+5][lix+5];\nfloat b7 = lsmem[liy+5][lix+6];\nfloat bb1 = lsmem[liy+6][lix];\nfloat bb2 = lsmem[liy+6][lix+1];\nfloat bb3 = lsmem[liy+6][lix+2];\nfloat bb4 = lsmem[liy+6][lix+3];\nfloat bb5 = lsmem[liy+6][lix+4];\nfloat bb6 = lsmem[liy+6][lix+5];\nfloat bb7 = lsmem[liy+6][lix+6];\nDSTX(x,y) = scale *\nmad(100.0f, m5 - m3,\nmad(80.0f, m6 - m2,\nmad(20.0f, m7 - m1,\nmad(75.0f, u5 - u3 + l5 - l3,\nmad(60.0f, u6 - u2 + l6 - l2,\nmad(15.0f, u7 - u1 + l7 - l1,\nmad(30.0f, t5 - t3 + b5 - b3,\nmad(24.0f, t6 - t2 + b6 - b2,\nmad(6.0f, t7 - t1 + b7 - b1,\nmad(5.0f, tt5 - tt3 + bb5 - bb3,\nmad(4.0f, tt6 - tt2 + bb6 - bb2, tt7 - tt1 + bb7 - bb1 )\n)\n)\n)\n)\n)\n)\n)\n)\n)\n);\nDSTY(x,y) = scale *\nmad(100.0f, l4 - u4,\nmad(80.0f, b4 - t4,\nmad(20.0f, bb4 - tt4,\nmad(75.0f, l5 - u5 + l3 - u3,\nmad(60.0f, b5 - t5 + b3 - t3,\nmad(15.0f, bb5 - tt5 + bb3 - tt3,\nmad(30.0f, l6 - u6 + l2 - u2,\nmad(24.0f, b6 - t6 + b2 - t2,\nmad(6.0f, bb6 - tt6 + bb2 - tt2,\nmad(5.0f, l7 - u7 + l1 - u1,\nmad(4.0f, b7 - t7 + b1 - t1, bb7 - tt7 + bb1 - tt1 )\n)\n)\n)\n)\n)\n)\n)\n)\n)\n);\n}\n", "d91d5e7d7c63952c08769030655a5c90", "imgproc_resize", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#define INTER_RESIZE_COEF_BITS 11\n#define INTER_RESIZE_COEF_SCALE (1 << INTER_RESIZE_COEF_BITS)\n#define CAST_BITS (INTER_RESIZE_COEF_BITS << 1)\n#define CAST_SCALE (1.0f/(1<<CAST_BITS))\n#define INC(x,l) ((x+1) >= (l) ? (x):((x)+1))\n#ifdef LN\n__kernel void resizeLN_C1_D0(__global uchar * dst, __global uchar const * restrict src,\nint dst_offset, int src_offset,int dst_step, int src_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n{\nint gx = get_global_id(0);\nint dy = get_global_id(1);\nfloat4  sx, u, xf;\nint4 x, DX;\ngx = (gx<<2) - (dst_offset&3);\nDX = (int4)(gx, gx+1, gx+2, gx+3);\nsx = (convert_float4(DX) + 0.5f) * ifx - 0.5f;\nxf = floor(sx);\nx = convert_int4(xf);\nu = sx - xf;\nfloat sy = ((dy+0.5f) * ify - 0.5f);\nint y = floor(sy);\nfloat v = sy - y;\nu = x < (int4)0 ? (float4)0 : u;\nu = (x >= (int4)src_cols) ? (float4)0 : u;\nx = x < (int4)0 ? (int4)0 : x;\nx = (x >= (int4)src_cols) ? (int4)(src_cols-1) : x;\ny<0 ? y=0,v=0 : y;\ny>=src_rows ? y=src_rows-1,v=0 : y;\nint4 U, U1;\nint V, V1;\nfloat4 utmp1, utmp2;\nfloat vtmp;\nfloat4 scale_vec = INTER_RESIZE_COEF_SCALE;\nutmp1 = u * scale_vec;\nutmp2 = scale_vec - utmp1;\nU = convert_int4(rint(utmp1));\nU1 = convert_int4(rint(utmp2));\nvtmp = v * INTER_RESIZE_COEF_SCALE;\nV = rint(vtmp);\nV1= rint(INTER_RESIZE_COEF_SCALE - vtmp);\nint y_ = INC(y,src_rows);\nint4 x_;\nx_ =  ((x+1 >= src_cols) != 0) ? x : x+1;\nint4 val1, val2, val;\nint4 sdata1, sdata2, sdata3, sdata4;\nint4 pos1 = mad24((int4)y, (int4)src_step, x+(int4)src_offset);\nint4 pos2 = mad24((int4)y, (int4)src_step, x_+(int4)src_offset);\nint4 pos3 = mad24((int4)y_, (int4)src_step, x+(int4)src_offset);\nint4 pos4 = mad24((int4)y_, (int4)src_step, x_+(int4)src_offset);\nsdata1.s0 = src[pos1.s0];\nsdata1.s1 = src[pos1.s1];\nsdata1.s2 = src[pos1.s2];\nsdata1.s3 = src[pos1.s3];\nsdata2.s0 = src[pos2.s0];\nsdata2.s1 = src[pos2.s1];\nsdata2.s2 = src[pos2.s2];\nsdata2.s3 = src[pos2.s3];\nsdata3.s0 = src[pos3.s0];\nsdata3.s1 = src[pos3.s1];\nsdata3.s2 = src[pos3.s2];\nsdata3.s3 = src[pos3.s3];\nsdata4.s0 = src[pos4.s0];\nsdata4.s1 = src[pos4.s1];\nsdata4.s2 = src[pos4.s2];\nsdata4.s3 = src[pos4.s3];\nval1 = mul24(U1 , sdata1) + mul24(U , sdata2);\nval2 = mul24(U1 , sdata3) + mul24(U , sdata4);\nval = mul24((int4)V1 , val1) + mul24((int4)V , val2);\nval = ((val + (1<<(CAST_BITS-1))) >> CAST_BITS);\npos4 = mad24(dy, dst_step, gx+dst_offset);\npos4.y++;\npos4.z+=2;\npos4.w+=3;\nuchar4 uval = convert_uchar4_sat(val);\nint con = (gx >= 0 && gx+3 < dst_cols && dy >= 0 && dy < dst_rows && (dst_offset&3)==0);\nif(con)\n{\n*(__global uchar4*)(dst + pos4.x)=uval;\n}\nelse\n{\nif(gx >= 0 && gx < dst_cols && dy >= 0 && dy < dst_rows)\n{\ndst[pos4.x]=uval.x;\n}\nif(gx+1 >= 0 && gx+1 < dst_cols && dy >= 0 && dy < dst_rows)\n{\ndst[pos4.y]=uval.y;\n}\nif(gx+2 >= 0 && gx+2 < dst_cols && dy >= 0 && dy < dst_rows)\n{\ndst[pos4.z]=uval.z;\n}\nif(gx+3 >= 0 && gx+3 < dst_cols && dy >= 0 && dy < dst_rows)\n{\ndst[pos4.w]=uval.w;\n}\n}\n}\n__kernel void resizeLN_C4_D0(__global uchar4 * dst, __global uchar4 * src,\nint dst_offset, int src_offset,int dst_step, int src_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nfloat sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\nint x = floor(sx), y = floor(sy);\nfloat u = sx - x, v = sy - y;\nif ( x<0 ) x=0,u=0;\nif ( x>=src_cols ) x=src_cols-1,u=0;\nif ( y<0 ) y=0,v=0;\nif (y>=src_rows ) y=src_rows-1,v=0;\nu = u * INTER_RESIZE_COEF_SCALE;\nv = v * INTER_RESIZE_COEF_SCALE;\nint U = rint(u);\nint V = rint(v);\nint U1= rint(INTER_RESIZE_COEF_SCALE - u);\nint V1= rint(INTER_RESIZE_COEF_SCALE - v);\nint y_ = INC(y,src_rows);\nint x_ = INC(x,src_cols);\nint4 srcpos;\nsrcpos.x = mad24(y, src_step, x+src_offset);\nsrcpos.y = mad24(y, src_step, x_+src_offset);\nsrcpos.z = mad24(y_, src_step, x+src_offset);\nsrcpos.w = mad24(y_, src_step, x_+src_offset);\nint4 data0 = convert_int4(src[srcpos.x]);\nint4 data1 = convert_int4(src[srcpos.y]);\nint4 data2 = convert_int4(src[srcpos.z]);\nint4 data3 = convert_int4(src[srcpos.w]);\nint4 val = mul24((int4)mul24(U1, V1) ,  data0) + mul24((int4)mul24(U, V1) ,  data1)\n+mul24((int4)mul24(U1, V) ,  data2)+mul24((int4)mul24(U, V) ,  data3);\nint dstpos = mad24(dy, dst_step, dx+dst_offset);\nuchar4 uval =   convert_uchar4((val + (1<<(CAST_BITS-1)))>>CAST_BITS);\nif(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\ndst[dstpos] = uval;\n}\n__kernel void resizeLN_C1_D5(__global float * dst, __global float * src,\nint dst_offset, int src_offset,int dst_step, int src_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nfloat sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\nint x = floor(sx), y = floor(sy);\nfloat u = sx - x, v = sy - y;\nif ( x<0 ) x=0,u=0;\nif ( x>=src_cols ) x=src_cols-1,u=0;\nif ( y<0 ) y=0,v=0;\nif (y>=src_rows ) y=src_rows-1,v=0;\nint y_ = INC(y,src_rows);\nint x_ = INC(x,src_cols);\nfloat u1 = 1.f-u;\nfloat v1 = 1.f-v;\nint4 srcpos;\nsrcpos.x = mad24(y, src_step, x+src_offset);\nsrcpos.y = mad24(y, src_step, x_+src_offset);\nsrcpos.z = mad24(y_, src_step, x+src_offset);\nsrcpos.w = mad24(y_, src_step, x_+src_offset);\nfloat data0 = src[srcpos.x];\nfloat data1 = src[srcpos.y];\nfloat data2 = src[srcpos.z];\nfloat data3 = src[srcpos.w];\nfloat val1 = u1 *  data0 +\nu  *  data1 ;\nfloat val2 = u1 *  data2 +\nu *  data3;\nfloat val = v1 * val1 + v * val2;\nint dstpos = mad24(dy, dst_step, dx+dst_offset);\nif(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\ndst[dstpos] = val;\n}\n__kernel void resizeLN_C4_D5(__global float4 * dst, __global float4 * src,\nint dst_offset, int src_offset,int dst_step, int src_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nfloat sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\nint x = floor(sx), y = floor(sy);\nfloat u = sx - x, v = sy - y;\nif ( x<0 ) x=0,u=0;\nif ( x>=src_cols ) x=src_cols-1,u=0;\nif ( y<0 ) y=0,v=0;\nif (y>=src_rows ) y=src_rows-1,v=0;\nint y_ = INC(y,src_rows);\nint x_ = INC(x,src_cols);\nfloat u1 = 1.f-u;\nfloat v1 = 1.f-v;\nint4 srcpos;\nsrcpos.x = mad24(y, src_step, x+src_offset);\nsrcpos.y = mad24(y, src_step, x_+src_offset);\nsrcpos.z = mad24(y_, src_step, x+src_offset);\nsrcpos.w = mad24(y_, src_step, x_+src_offset);\nfloat4 s_data1, s_data2, s_data3, s_data4;\ns_data1 = src[srcpos.x];\ns_data2 = src[srcpos.y];\ns_data3 = src[srcpos.z];\ns_data4 = src[srcpos.w];\nfloat4 val = u1 * v1 * s_data1 + u * v1 * s_data2\n+u1 * v *s_data3 + u * v *s_data4;\nint dstpos = mad24(dy, dst_step, dx+dst_offset);\nif(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\ndst[dstpos] = val;\n}\n#elif defined NN\n__kernel void resizeNN(__global T * dst, __global T * src,\nint dst_offset, int src_offset, int dst_step, int src_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify)\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif (dx < dst_cols && dy < dst_rows)\n{\nfloat s1 = dx * ifx, s2 = dy * ify;\nint sx = min(convert_int_sat_rtn(s1), src_cols - 1);\nint sy = min(convert_int_sat_rtn(s2), src_rows - 1);\nint dst_index = mad24(dy, dst_step, dx + dst_offset);\nint src_index = mad24(sy, src_step, sx + src_offset);\ndst[dst_index] = src[src_index];\n}\n}\n#elif defined AREA\n#ifdef AREA_FAST\n__kernel void resizeAREA_FAST(__global T * dst, __global T * src,\nint dst_offset, int src_offset, int dst_step, int src_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, WT ifx, WT ify,\n__global const int * dmap_tab, __global const int * smap_tab)\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif (dx < dst_cols && dy < dst_rows)\n{\nint dst_index = mad24(dy, dst_step, dst_offset + dx);\n__global const int * xmap_tab = dmap_tab;\n__global const int * ymap_tab = dmap_tab + dst_cols;\n__global const int * sxmap_tab = smap_tab;\n__global const int * symap_tab = smap_tab + XSCALE * dst_cols;\nint sx = xmap_tab[dx], sy = ymap_tab[dy];\nWTV sum = (WTV)(0);\n#pragma unroll\nfor (int y = 0; y < YSCALE; ++y)\n{\nint src_index = mad24(symap_tab[y + sy], src_step, src_offset);\n#pragma unroll\nfor (int x = 0; x < XSCALE; ++x)\nsum += convertToWTV(src[src_index + sxmap_tab[sx + x]]);\n}\ndst[dst_index] = convertToT(convertToWT2V(sum) * (WT2V)(SCALE));\n}\n}\n#else\n__kernel void resizeAREA(__global T * dst, __global T * src,\nint dst_offset, int src_offset, int dst_step, int src_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, WT ifx, WT ify,\n__global const int * ofs_tab, __global const int * map_tab,\n__global const float * alpha_tab)\n{\nint dx = get_global_id(0);\nint dy = get_global_id(1);\nif (dx < dst_cols && dy < dst_rows)\n{\nint dst_index = mad24(dy, dst_step, dst_offset + dx);\n__global const int * xmap_tab = map_tab;\n__global const int * ymap_tab = (__global const int *)(map_tab + (src_cols << 1));\n__global const float * xalpha_tab = alpha_tab;\n__global const float * yalpha_tab = (__global const float *)(alpha_tab + (src_cols << 1));\n__global const int * xofs_tab = ofs_tab;\n__global const int * yofs_tab = (__global const int *)(ofs_tab + dst_cols + 1);\nint xk0 = xofs_tab[dx], xk1 = xofs_tab[dx + 1];\nint yk0 = yofs_tab[dy], yk1 = yofs_tab[dy + 1];\nint sy0 = ymap_tab[yk0], sy1 = ymap_tab[yk1 - 1];\nint sx0 = xmap_tab[xk0], sx1 = xmap_tab[xk1 - 1];\nWTV sum = (WTV)(0), buf;\nint src_index = mad24(sy0, src_step, src_offset);\nfor (int sy = sy0, yk = yk0; sy <= sy1; ++sy, src_index += src_step, ++yk)\n{\nWTV beta = (WTV)(yalpha_tab[yk]);\nbuf = (WTV)(0);\nfor (int sx = sx0, xk = xk0; sx <= sx1; ++sx, ++xk)\n{\nWTV alpha = (WTV)(xalpha_tab[xk]);\nbuf += convertToWTV(src[src_index + sx]) * alpha;\n}\nsum += buf * beta;\n}\ndst[dst_index] = convertToT(sum);\n}\n}\n#endif\n#endif\n", "dce4e0232bb7fd3e374f363a5311e3cc", "imgproc_remap", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\nenum\n{\nINTER_BITS = 5,\nINTER_TAB_SIZE = 1 << INTER_BITS,\nINTER_TAB_SIZE2 = INTER_TAB_SIZE * INTER_TAB_SIZE\n};\n#ifdef INTER_NEAREST\n#define convertToWT\n#endif\n#ifdef BORDER_CONSTANT\n#define EXTRAPOLATE(v2, v) v = scalar;\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(v2, v) \\\n{ \\\nv2 = max(min(v2, (int2)(src_cols - 1, src_rows - 1)), (int2)(0)); \\\nv = convertToWT(src[mad24(v2.y, src_step, v2.x + src_offset)]); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(v2, v) \\\n{ \\\nif (v2.x < 0) \\\nv2.x -= ((v2.x - src_cols + 1) / src_cols) * src_cols; \\\nif (v2.x >= src_cols) \\\nv2.x %= src_cols; \\\n\\\nif (v2.y < 0) \\\nv2.y -= ((v2.y - src_rows + 1) / src_rows) * src_rows; \\\nif( v2.y >= src_rows ) \\\nv2.y %= src_rows; \\\nv = convertToWT(src[mad24(v2.y, src_step, v2.x + src_offset)]); \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n#ifdef BORDER_REFLECT\n#define DELTA int delta = 0\n#else\n#define DELTA int delta = 1\n#endif\n#define EXTRAPOLATE(v2, v) \\\n{ \\\nDELTA; \\\nif (src_cols == 1) \\\nv2.x = 0; \\\nelse \\\ndo \\\n{ \\\nif( v2.x < 0 ) \\\nv2.x = -v2.x - 1 + delta; \\\nelse \\\nv2.x = src_cols - 1 - (v2.x - src_cols) - delta; \\\n} \\\nwhile (v2.x >= src_cols || v2.x < 0); \\\n\\\nif (src_rows == 1) \\\nv2.y = 0; \\\nelse \\\ndo \\\n{ \\\nif( v2.y < 0 ) \\\nv2.y = -v2.y - 1 + delta; \\\nelse \\\nv2.y = src_rows - 1 - (v2.y - src_rows) - delta; \\\n} \\\nwhile (v2.y >= src_rows || v2.y < 0); \\\nv = convertToWT(src[mad24(v2.y, src_step, v2.x + src_offset)]); \\\n}\n#else\n#error No extrapolation method\n#endif\n#define NEED_EXTRAPOLATION(gx, gy) (gx >= src_cols || gy >= src_rows || gx < 0 || gy < 0)\n#ifdef INTER_NEAREST\n__kernel void remap_2_32FC1(__global const T * restrict src, __global T * dst,\n__global float * map1, __global float * map2,\nint src_offset, int dst_offset, int map1_offset, int map2_offset,\nint src_step, int dst_step, int map1_step, int map2_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, T scalar)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint dstIdx = mad24(y, dst_step, x + dst_offset);\nint map1Idx = mad24(y, map1_step, x + map1_offset);\nint map2Idx = mad24(y, map2_step, x + map2_offset);\nint gx = convert_int_sat_rte(map1[map1Idx]);\nint gy = convert_int_sat_rte(map2[map2Idx]);\nif (NEED_EXTRAPOLATION(gx, gy))\n{\n#ifndef BORDER_CONSTANT\nint2 gxy = (int2)(gx, gy);\n#endif\nEXTRAPOLATE(gxy, dst[dstIdx]);\n}\nelse\n{\nint srcIdx = mad24(gy, src_step, gx + src_offset);\ndst[dstIdx] = src[srcIdx];\n}\n}\n}\n__kernel void remap_32FC2(__global const T * restrict src, __global T * dst, __global float2 * map1,\nint src_offset, int dst_offset, int map1_offset,\nint src_step, int dst_step, int map1_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, T scalar)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint dstIdx = mad24(y, dst_step, x + dst_offset);\nint map1Idx = mad24(y, map1_step, x + map1_offset);\nint2 gxy = convert_int2_sat_rte(map1[map1Idx]);\nint gx = gxy.x, gy = gxy.y;\nif (NEED_EXTRAPOLATION(gx, gy))\nEXTRAPOLATE(gxy, dst[dstIdx])\nelse\n{\nint srcIdx = mad24(gy, src_step, gx + src_offset);\ndst[dstIdx] = src[srcIdx];\n}\n}\n}\n__kernel void remap_16SC2(__global const T * restrict src, __global T * dst, __global short2 * map1,\nint src_offset, int dst_offset, int map1_offset,\nint src_step, int dst_step, int map1_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, T scalar)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint dstIdx = mad24(y, dst_step, x + dst_offset);\nint map1Idx = mad24(y, map1_step, x + map1_offset);\nint2 gxy = convert_int2(map1[map1Idx]);\nint gx = gxy.x, gy = gxy.y;\nif (NEED_EXTRAPOLATION(gx, gy))\nEXTRAPOLATE(gxy, dst[dstIdx])\nelse\n{\nint srcIdx = mad24(gy, src_step, gx + src_offset);\ndst[dstIdx] = src[srcIdx];\n}\n}\n}\n__kernel void remap_16SC2_16UC1(__global const T * restrict src, __global T * dst, __global short2 * map1, __global ushort * map2,\nint src_offset, int dst_offset, int map1_offset, int map2_offset,\nint src_step, int dst_step, int map1_step, int map2_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, T scalar)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint dstIdx = mad24(y, dst_step, x + dst_offset);\nint map1Idx = mad24(y, map1_step, x + map1_offset);\nint map2Idx = mad24(y, map2_step, x + map2_offset);\nint map2Value = convert_int(map2[map2Idx]) & (INTER_TAB_SIZE2 - 1);\nint dx = (map2Value & (INTER_TAB_SIZE - 1)) < (INTER_TAB_SIZE >> 1) ? 1 : 0;\nint dy = (map2Value >> INTER_BITS) < (INTER_TAB_SIZE >> 1) ? 1 : 0;\nint2 gxy = convert_int2(map1[map1Idx]) + (int2)(dx, dy);\nint gx = gxy.x, gy = gxy.y;\nif (NEED_EXTRAPOLATION(gx, gy))\nEXTRAPOLATE(gxy, dst[dstIdx])\nelse\n{\nint srcIdx = mad24(gy, src_step, gx + src_offset);\ndst[dstIdx] = src[srcIdx];\n}\n}\n}\n#elif INTER_LINEAR\n__kernel void remap_16SC2_16UC1(__global T const * restrict src, __global T * dst,\n__global short2 * restrict map1, __global ushort * restrict map2,\nint src_offset, int dst_offset, int map1_offset, int map2_offset,\nint src_step, int dst_step, int map1_step, int map2_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, T nVal)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint dstIdx = mad24(y, dst_step, x + dst_offset);\nint map1Idx = mad24(y, map1_step, x + map1_offset);\nint map2Idx = mad24(y, map2_step, x + map2_offset);\nint2 map_dataA = convert_int2(map1[map1Idx]);\nint2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\nint2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\nint2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\nushort map2Value = (ushort)(map2[map2Idx] & (INTER_TAB_SIZE2 - 1));\nWT2 u = (WT2)(map2Value & (INTER_TAB_SIZE - 1), map2Value >> INTER_BITS) / (WT2)(INTER_TAB_SIZE);\nWT scalar = convertToWT(nVal);\nWT a = scalar, b = scalar, c = scalar, d = scalar;\nif (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\na = convertToWT(src[mad24(map_dataA.y, src_step, map_dataA.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataA, a);\nif (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\nb = convertToWT(src[mad24(map_dataB.y, src_step, map_dataB.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataB, b);\nif (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\nc = convertToWT(src[mad24(map_dataC.y, src_step, map_dataC.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataC, c);\nif (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\nd = convertToWT(src[mad24(map_dataD.y, src_step, map_dataD.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataD, d);\nWT dst_data = a * (1 - u.x) * (1 - u.y) +\nb * (u.x)     * (1 - u.y) +\nc * (1 - u.x) * (u.y) +\nd * (u.x)     * (u.y);\ndst[dstIdx] = convertToT(dst_data);\n}\n}\n__kernel void remap_2_32FC1(__global T const * restrict  src, __global T * dst,\n__global float * map1, __global float * map2,\nint src_offset, int dst_offset, int map1_offset, int map2_offset,\nint src_step, int dst_step, int map1_step, int map2_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, T nVal)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint dstIdx = mad24(y, dst_step, x + dst_offset);\nint map1Idx = mad24(y, map1_step, x + map1_offset);\nint map2Idx = mad24(y, map2_step, x + map2_offset);\nfloat2 map_data = (float2)(map1[map1Idx], map2[map2Idx]);\nint2 map_dataA = convert_int2_sat_rtn(map_data);\nint2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\nint2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\nint2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\nfloat2 _u = map_data - convert_float2(map_dataA);\nWT2 u = convertToWT2(convert_int2_rte(convertToWT2(_u) * (WT2)INTER_TAB_SIZE)) / (WT2)INTER_TAB_SIZE;\nWT scalar = convertToWT(nVal);\nWT a = scalar, b = scalar, c = scalar, d = scalar;\nif (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\na = convertToWT(src[mad24(map_dataA.y, src_step, map_dataA.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataA, a);\nif (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\nb = convertToWT(src[mad24(map_dataB.y, src_step, map_dataB.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataB, b);\nif (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\nc = convertToWT(src[mad24(map_dataC.y, src_step, map_dataC.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataC, c);\nif (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\nd = convertToWT(src[mad24(map_dataD.y, src_step, map_dataD.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataD, d);\nWT dst_data = a * (1 - u.x) * (1 - u.y) +\nb * (u.x)     * (1 - u.y) +\nc * (1 - u.x) * (u.y) +\nd * (u.x)     * (u.y);\ndst[dstIdx] = convertToT(dst_data);\n}\n}\n__kernel void remap_32FC2(__global T const * restrict  src, __global T * dst,\n__global float2 * map1,\nint src_offset, int dst_offset, int map1_offset,\nint src_step, int dst_step, int map1_step,\nint src_cols, int src_rows, int dst_cols, int dst_rows, T nVal)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint dstIdx = mad24(y, dst_step, x + dst_offset);\nint map1Idx = mad24(y, map1_step, x + map1_offset);\nfloat2 map_data = map1[map1Idx];\nint2 map_dataA = convert_int2_sat_rtn(map_data);\nint2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\nint2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\nint2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\nfloat2 _u = map_data - convert_float2(map_dataA);\nWT2 u = convertToWT2(convert_int2_rte(convertToWT2(_u) * (WT2)INTER_TAB_SIZE)) / (WT2)INTER_TAB_SIZE;\nWT scalar = convertToWT(nVal);\nWT a = scalar, b = scalar, c = scalar, d = scalar;\nif (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\na = convertToWT(src[mad24(map_dataA.y, src_step, map_dataA.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataA, a);\nif (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\nb = convertToWT(src[mad24(map_dataB.y, src_step, map_dataB.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataB, b);\nif (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\nc = convertToWT(src[mad24(map_dataC.y, src_step, map_dataC.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataC, c);\nif (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\nd = convertToWT(src[mad24(map_dataD.y, src_step, map_dataD.x + src_offset)]);\nelse\nEXTRAPOLATE(map_dataD, d);\nWT dst_data = a * (1 - u.x) * (1 - u.y) +\nb * (u.x)     * (1 - u.y) +\nc * (1 - u.x) * (u.y) +\nd * (u.x)     * (u.y);\ndst[dstIdx] = convertToT(dst_data);\n}\n}\n#endif\n", "97286bf2357a81af2a1da7e008a02729", "imgproc_median", "#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter3_C4_D0(__global uchar4 * src, __global uchar4 * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local uchar4 data[18][18];\n__global uchar4* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -1;\nint dy = get_global_id(1) - get_local_id(1) -1;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\nint dr=id/18;\nint dc=id%18;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+9, 0, rows-1);\ndata[dr+9][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nuchar4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\nuchar4 p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\nuchar4 p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\nuchar4 mid;\nop(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\nop(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\nop(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\nop(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\nop(p4, p2); op(p6, p4); op(p4, p2);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n}\n#undef op\n#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter3_C1_D0(__global uchar * src, __global uchar * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local uchar data[18][18];\n__global uchar* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -1;\nint dy = get_global_id(1) - get_local_id(1) -1;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\nint dr=id/18;\nint dc=id%18;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+9, 0, rows-1);\ndata[dr+9][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nuchar p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\nuchar p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\nuchar p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\nuchar mid;\nop(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\nop(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\nop(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\nop(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\nop(p4, p2); op(p6, p4); op(p4, p2);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n}\n#undef op\n#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter3_C1_D5(__global float * src, __global float * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local float data[18][18];\n__global float* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -1;\nint dy = get_global_id(1) - get_local_id(1) -1;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\nint dr=id/18;\nint dc=id%18;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+9, 0, rows-1);\ndata[dr+9][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nfloat p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\nfloat p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\nfloat p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\nfloat mid;\nop(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\nop(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\nop(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\nop(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\nop(p4, p2); op(p6, p4); op(p4, p2);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n}\n#undef op\n#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter3_C4_D5(__global float4 * src, __global float4 * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local float4 data[18][18];\n__global float4* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -1;\nint dy = get_global_id(1) - get_local_id(1) -1;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\nint dr=id/18;\nint dc=id%18;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+9, 0, rows-1);\ndata[dr+9][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nfloat4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\nfloat4 p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\nfloat4 p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\nfloat4 mid;\nop(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\nop(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\nop(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\nop(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\nop(p4, p2); op(p6, p4); op(p4, p2);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n}\n#undef op\n#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter5_C4_D0(__global uchar4 * src, __global uchar4 * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local uchar4 data[20][20];\n__global uchar4* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -2;\nint dy = get_global_id(1) - get_local_id(1) -2;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\nint dr=id/20;\nint dc=id%20;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+10, 0, rows-1);\ndata[dr+10][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nuchar4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\nuchar4 p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\nuchar4 p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\nuchar4 p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\nuchar4 p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\nuchar4 mid;\nop(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\nop(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\nop(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\nop(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\nop(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\nop(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\nop(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\nop(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\nop(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\nop(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\nop(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\nop(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\nop(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\nop(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\nop(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\nop(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\nop(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\nop(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\nop(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\nop(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\nop(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\nop(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\nop(p7, p11); op(p11, p13); op(p11, p12);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n}\n#undef op\n#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter5_C1_D0(__global uchar * src, __global uchar * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local uchar data[20][20];\n__global uchar* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -2;\nint dy = get_global_id(1) - get_local_id(1) -2;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\nint dr=id/20;\nint dc=id%20;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+10, 0, rows-1);\ndata[dr+10][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nuchar p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\nuchar p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\nuchar p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\nuchar p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\nuchar p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\nuchar mid;\nop(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\nop(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\nop(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\nop(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\nop(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\nop(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\nop(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\nop(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\nop(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\nop(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\nop(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\nop(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\nop(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\nop(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\nop(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\nop(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\nop(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\nop(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\nop(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\nop(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\nop(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\nop(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\nop(p7, p11); op(p11, p13); op(p11, p12);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n}\n#undef op\n#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter5_C4_D5(__global float4 * src, __global float4 * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local float4 data[20][20];\n__global float4* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -2;\nint dy = get_global_id(1) - get_local_id(1) -2;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\nint dr=id/20;\nint dc=id%20;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+10, 0, rows-1);\ndata[dr+10][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nfloat4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\nfloat4 p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\nfloat4 p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\nfloat4 p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\nfloat4 p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\nfloat4 mid;\nop(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\nop(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\nop(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\nop(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\nop(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\nop(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\nop(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\nop(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\nop(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\nop(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\nop(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\nop(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\nop(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\nop(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\nop(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\nop(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\nop(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\nop(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\nop(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\nop(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\nop(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\nop(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\nop(p7, p11); op(p11, p13); op(p11, p12);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n}\n#undef op\n#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n__kernel void medianFilter5_C1_D5(__global float * src, __global float * dst,  int srcOffset, int dstOffset, int cols,\nint rows, int srcStep, int dstStep)\n{\n__local float data[20][20];\n__global float* source=src + srcOffset;\nint dx = get_global_id(0) - get_local_id(0) -2;\nint dy = get_global_id(1) - get_local_id(1) -2;\nconst int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\nint dr=id/20;\nint dc=id%20;\nint r=clamp(dy+dr, 0, rows-1);\nint c=clamp(dx+dc, 0, cols-1);\ndata[dr][dc] = source[r*srcStep + c];\nr=clamp(dy+dr+10, 0, rows-1);\ndata[dr+10][dc] = source[r*srcStep + c];\nbarrier(CLK_LOCAL_MEM_FENCE);\nint x =get_local_id(0);\nint y =get_local_id(1);\nfloat p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\nfloat p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\nfloat p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\nfloat p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\nfloat p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\nfloat mid;\nop(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\nop(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\nop(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\nop(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\nop(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\nop(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\nop(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\nop(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\nop(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\nop(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\nop(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\nop(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\nop(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\nop(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\nop(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\nop(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\nop(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\nop(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\nop(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\nop(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\nop(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\nop(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\nop(p7, p11); op(p11, p13); op(p11, p12);\nif((int)get_global_id(1)<rows && (int)get_global_id(0)<cols)\ndst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n}\n#undef op\n", "6a58f04e0619c3c5c81f91b56c469553", "imgproc_integral_sum", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#define LSIZE 256\n#define LSIZE_1 255\n#define LSIZE_2 254\n#define HF_LSIZE 128\n#define LOG_LSIZE 8\n#define LOG_NUM_BANKS 5\n#define NUM_BANKS 32\n#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\nkernel void integral_sum_cols_D4(__global uchar4 *src,__global int *sum ,\nint src_offset,int pre_invalid,int rows,int cols,int src_step,int dst_step)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint4 src_t[2], sum_t[2];\n__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local int* sum_p;\nsrc_step = src_step >> 2;\ngid = gid << 1;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid]) : 0);\nsrc_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid + 1]) : 0);\nsum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sum[1][bf_loc] = src_t[1];\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid > 0 && (i+lid) <= rows)\n{\nint loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nsum_p = (__local int*)(&(lm_sum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\nsum[loc_s0 + k * dst_step / 4] = sum_p[k];\n}\nsum_p = (__local int*)(&(lm_sum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k + 4 >= cols + pre_invalid) break;\nsum[loc_s1 + k * dst_step / 4] = sum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nkernel void integral_sum_rows_D4(__global int4 *srcsum,__global int *sum ,\nint rows,int cols,int src_step,int sum_step,\nint sum_offset)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint4 src_t[2], sum_t[2];\n__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local int *sum_p;\nsrc_step = src_step >> 4;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : 0;\nsrc_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : 0;\nsum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sum[1][bf_loc] = src_t[1];\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gid == 0 && (i + lid) <= rows)\n{\nsum[sum_offset + i + lid] = 0;\n}\nif(i + lid == 0)\n{\nint loc0 = gid * 2 * sum_step;\nfor(int k = 1; k <= 8; k++)\n{\nif(gid * 8 + k > cols) break;\nsum[sum_offset + loc0 + k * sum_step / 4] = 0;\n}\n}\nif(lid > 0 && (i+lid) <= rows)\n{\nint loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nsum_p = (__local int*)(&(lm_sum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + k >= cols) break;\nsum[loc_s0 + k * sum_step / 4] = sum_p[k];\n}\nsum_p = (__local int*)(&(lm_sum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + 4 + k >= cols) break;\nsum[loc_s1 + k * sum_step / 4] = sum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nkernel void integral_sum_cols_D5(__global uchar4 *src,__global float *sum ,\nint src_offset,int pre_invalid,int rows,int cols,int src_step,int dst_step)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nfloat4 src_t[2], sum_t[2];\n__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local float* sum_p;\nsrc_step = src_step >> 2;\ngid = gid << 1;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + gid]) : (float4)0);\nsrc_t[1] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + gid + 1]) : (float4)0);\nsum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sum[1][bf_loc] = src_t[1];\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid > 0 && (i+lid) <= rows)\n{\nint loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nsum_p = (__local float*)(&(lm_sum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\nsum[loc_s0 + k * dst_step / 4] = sum_p[k];\n}\nsum_p = (__local float*)(&(lm_sum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k + 4 >= cols + pre_invalid) break;\nsum[loc_s1 + k * dst_step / 4] = sum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nkernel void integral_sum_rows_D5(__global float4 *srcsum,__global float *sum ,\nint rows,int cols,int src_step,int sum_step,\nint sum_offset)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nfloat4 src_t[2], sum_t[2];\n__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local float *sum_p;\nsrc_step = src_step >> 4;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : (float4)0;\nsrc_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\nsum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sum[1][bf_loc] = src_t[1];\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gid == 0 && (i + lid) <= rows)\n{\nsum[sum_offset + i + lid] = 0;\n}\nif(i + lid == 0)\n{\nint loc0 = gid * 2 * sum_step;\nfor(int k = 1; k <= 8; k++)\n{\nif(gid * 8 + k > cols) break;\nsum[sum_offset + loc0 + k * sum_step / 4] = 0;\n}\n}\nif(lid > 0 && (i+lid) <= rows)\n{\nint loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nsum_p = (__local float*)(&(lm_sum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + k >= cols) break;\nsum[loc_s0 + k * sum_step / 4] = sum_p[k];\n}\nsum_p = (__local float*)(&(lm_sum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + 4 + k >= cols) break;\nsum[loc_s1 + k * sum_step / 4] = sum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\n", "e59da438d1e7b62e64504698acb985b2", "imgproc_integral", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#define LSIZE 256\n#define LSIZE_1 255\n#define LSIZE_2 254\n#define HF_LSIZE 128\n#define LOG_LSIZE 8\n#define LOG_NUM_BANKS 5\n#define NUM_BANKS 32\n#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\nkernel void integral_cols_D4(__global uchar4 *src,__global int *sum ,__global float *sqsum,\nint src_offset,int pre_invalid,int rows,int cols,int src_step,int dst_step)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint4 src_t[2], sum_t[2];\nfloat4 sqsum_t[2];\n__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local float4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n__local int* sum_p;\n__local float* sqsum_p;\nsrc_step = src_step >> 2;\ngid = gid << 1;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + min(gid, cols - 1)]) : 0);\nsrc_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + min(gid + 1, cols - 1)]) : 0);\nsum_t[0] = (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[0] = (i == 0 ? (float4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[1] =  (i == 0 ? (float4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sqsum[0][bf_loc] = convert_float4(src_t[0] * src_t[0]);\nlm_sum[1][bf_loc] = src_t[1];\nlm_sqsum[1][bf_loc] = convert_float4(src_t[1] * src_t[1]);\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\nlm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\nlm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\nif(lid > 0 && (i+lid) <= rows)\n{\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nlm_sqsum[0][bf_loc] += sqsum_t[0];\nlm_sqsum[1][bf_loc] += sqsum_t[1];\nsum_p = (__local int*)(&(lm_sum[0][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\nsum[loc_s0 + k * dst_step / 4] = sum_p[k];\nsqsum[loc_s0 + k * dst_step / 4] = sqsum_p[k];\n}\nsum_p = (__local int*)(&(lm_sum[1][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k + 4 >= cols + pre_invalid) break;\nsum[loc_s1 + k * dst_step / 4] = sum_p[k];\nsqsum[loc_s1 + k * dst_step / 4] = sqsum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nkernel void integral_rows_D4(__global int4 *srcsum,__global float4 * srcsqsum,__global int *sum ,\n__global float *sqsum,int rows,int cols,int src_step,int sum_step,\nint sqsum_step,int sum_offset,int sqsum_offset)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint4 src_t[2], sum_t[2];\nfloat4 sqsrc_t[2],sqsum_t[2];\n__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local float4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n__local int *sum_p;\n__local float *sqsum_p;\nsrc_step = src_step >> 4;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : (int4)0;\nsqsrc_t[0] = i + lid < rows ? srcsqsum[(lid+i) * src_step + gid * 2] : (float4)0;\nsrc_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : (int4)0;\nsqsrc_t[1] = i + lid < rows ? srcsqsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\nsum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[0] =  (i == 0 ? (float4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[1] =  (i == 0 ? (float4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sqsum[0][bf_loc] = sqsrc_t[0];\nlm_sum[1][bf_loc] = src_t[1];\nlm_sqsum[1][bf_loc] = sqsrc_t[1];\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\nlm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\nlm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gid == 0 && (i + lid) <= rows)\n{\nsum[sum_offset + i + lid] = 0;\nsqsum[sqsum_offset + i + lid] = 0;\n}\nif(i + lid == 0)\n{\nint loc0 = gid * 2 * sum_step;\nint loc1 = gid * 2 * sqsum_step;\nfor(int k = 1; k <= 8; k++)\n{\nif(gid * 8 + k > cols) break;\nsum[sum_offset + loc0 + k * sum_step / 4] = 0;\nsqsum[sqsum_offset + loc1 + k * sqsum_step / 4] = 0;\n}\n}\nint loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\nint loc_sq0 = sqsum_offset + gid * 2 * sqsum_step + sqsum_step / 4 + i + lid, loc_sq1 = loc_sq0 + sqsum_step ;\nif(lid > 0 && (i+lid) <= rows)\n{\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nlm_sqsum[0][bf_loc] += sqsum_t[0];\nlm_sqsum[1][bf_loc] += sqsum_t[1];\nsum_p = (__local int*)(&(lm_sum[0][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + k >= cols) break;\nsum[loc_s0 + k * sum_step / 4] = sum_p[k];\nsqsum[loc_sq0 + k * sqsum_step / 4] = sqsum_p[k];\n}\nsum_p = (__local int*)(&(lm_sum[1][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + 4 + k >= cols) break;\nsum[loc_s1 + k * sum_step / 4] = sum_p[k];\nsqsum[loc_sq1 + k * sqsum_step / 4] = sqsum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nkernel void integral_cols_D5(__global uchar4 *src,__global float *sum ,__global float *sqsum,\nint src_offset,int pre_invalid,int rows,int cols,int src_step,int dst_step)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nfloat4 src_t[2], sum_t[2];\nfloat4 sqsum_t[2];\n__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local float4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n__local float* sum_p;\n__local float* sqsum_p;\nsrc_step = src_step >> 2;\ngid = gid << 1;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + min(gid, cols - 1)]) : (float4)0);\nsrc_t[1] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + min(gid + 1, cols - 1)]) : (float4)0);\nsum_t[0] = (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[0] = (i == 0 ? (float4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[1] =  (i == 0 ? (float4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sqsum[0][bf_loc] = convert_float4(src_t[0] * src_t[0]);\nlm_sum[1][bf_loc] = src_t[1];\nlm_sqsum[1][bf_loc] = convert_float4(src_t[1] * src_t[1]);\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\nlm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\nlm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\nif(lid > 0 && (i+lid) <= rows)\n{\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nlm_sqsum[0][bf_loc] += sqsum_t[0];\nlm_sqsum[1][bf_loc] += sqsum_t[1];\nsum_p = (__local float*)(&(lm_sum[0][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\nsum[loc_s0 + k * dst_step / 4] = sum_p[k];\nsqsum[loc_s0 + k * dst_step / 4] = sqsum_p[k];\n}\nsum_p = (__local float*)(&(lm_sum[1][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 4 + k + 4 >= cols + pre_invalid) break;\nsum[loc_s1 + k * dst_step / 4] = sum_p[k];\nsqsum[loc_s1 + k * dst_step / 4] = sqsum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\nkernel void integral_rows_D5(__global float4 *srcsum,__global float4 * srcsqsum,__global float *sum ,\n__global float *sqsum,int rows,int cols,int src_step,int sum_step,\nint sqsum_step,int sum_offset,int sqsum_offset)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nfloat4 src_t[2], sum_t[2];\nfloat4 sqsrc_t[2],sqsum_t[2];\n__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n__local float4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n__local float *sum_p;\n__local float *sqsum_p;\nsrc_step = src_step >> 4;\nfor(int i = 0; i < rows; i =i + LSIZE_1)\n{\nsrc_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : (float4)0;\nsqsrc_t[0] = i + lid < rows ? srcsqsum[(lid+i) * src_step + gid * 2] : (float4)0;\nsrc_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\nsqsrc_t[1] = i + lid < rows ? srcsqsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\nsum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[0] =  (i == 0 ? (float4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\nsum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\nsqsum_t[1] =  (i == 0 ? (float4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bf_loc = lid + GET_CONFLICT_OFFSET(lid);\nlm_sum[0][bf_loc] = src_t[0];\nlm_sqsum[0][bf_loc] = sqsrc_t[0];\nlm_sum[1][bf_loc] = src_t[1];\nlm_sqsum[1][bf_loc] = sqsrc_t[1];\nint offset = 1;\nfor(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n}\noffset <<= 1;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 2)\n{\nlm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\nlm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n}\nfor(int d = 1;  d < LSIZE; d <<= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\noffset >>= 1;\nint ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\nai += GET_CONFLICT_OFFSET(ai);\nbi += GET_CONFLICT_OFFSET(bi);\nif((lid & 127) < d)\n{\nlm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\nlm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\nlm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\nlm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gid == 0 && (i + lid) <= rows)\n{\nsum[sum_offset + i + lid] = 0;\nsqsum[sqsum_offset + i + lid] = 0;\n}\nif(i + lid == 0)\n{\nint loc0 = gid * 2 * sum_step;\nint loc1 = gid * 2 * sqsum_step;\nfor(int k = 1; k <= 8; k++)\n{\nif(gid * 8 + k > cols) break;\nsum[sum_offset + loc0 + k * sum_step / 4] = 0;\nsqsum[sqsum_offset + loc1 + k * sqsum_step / 4] = 0;\n}\n}\nint loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\nint loc_sq0 = sqsum_offset + gid * 2 * sqsum_step + sqsum_step / 4 + i + lid, loc_sq1 = loc_sq0 + sqsum_step ;\nif(lid > 0 && (i+lid) <= rows)\n{\nlm_sum[0][bf_loc] += sum_t[0];\nlm_sum[1][bf_loc] += sum_t[1];\nlm_sqsum[0][bf_loc] += sqsum_t[0];\nlm_sqsum[1][bf_loc] += sqsum_t[1];\nsum_p = (__local float*)(&(lm_sum[0][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[0][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + k >= cols) break;\nsum[loc_s0 + k * sum_step / 4] = sum_p[k];\nsqsum[loc_sq0 + k * sqsum_step / 4] = sqsum_p[k];\n}\nsum_p = (__local float*)(&(lm_sum[1][bf_loc]));\nsqsum_p = (__local float*)(&(lm_sqsum[1][bf_loc]));\nfor(int k = 0; k < 4; k++)\n{\nif(gid * 8 + 4 + k >= cols) break;\nsum[loc_s1 + k * sum_step / 4] = sum_p[k];\nsqsum[loc_sq1 + k * sqsum_step / 4] = sqsum_p[k];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\n", "5e6a87796fabb22a98ead9c7596269eb", "imgproc_histogram", "#define PARTIAL_HISTOGRAM256_COUNT     (256)\n#define HISTOGRAM256_BIN_COUNT         (256)\n#define HISTOGRAM256_WORK_GROUP_SIZE     (256)\n#define HISTOGRAM256_LOCAL_MEM_SIZE      (HISTOGRAM256_BIN_COUNT)\n#define NBANKS (16)\n#define NBANKS_BIT (4)\n__kernel __attribute__((reqd_work_group_size(HISTOGRAM256_BIN_COUNT,1,1)))void calc_sub_hist_D0(\n__global const uint4* src,\nint src_step, int src_offset,\n__global int* globalHist,\nint dataCount,  int cols,\nint inc_x, int inc_y,\nint hist_step)\n{\n__local int subhist[(HISTOGRAM256_BIN_COUNT << NBANKS_BIT)];\nint gid = get_global_id(0);\nint lid = get_local_id(0);\nint gx  = get_group_id(0);\nint gsize = get_global_size(0);\nint lsize  = get_local_size(0);\nconst int shift = 8;\nconst int mask = HISTOGRAM256_BIN_COUNT-1;\nint offset = (lid & (NBANKS-1));\nuint4 data, temp1, temp2, temp3, temp4;\nsrc += src_offset;\nfor(int i=0, idx=lid; i<(NBANKS >> 2); i++, idx += lsize)\n{\nsubhist[idx] = 0;\nsubhist[idx+=lsize] = 0;\nsubhist[idx+=lsize] = 0;\nsubhist[idx+=lsize] = 0;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint y = gid/cols;\nint x = gid - mul24(y, cols);\nfor(int idx=gid; idx<dataCount; idx+=gsize)\n{\ndata = src[mad24(y, src_step, x)];\ntemp1 = ((data & mask) << NBANKS_BIT) + offset;\ndata >>= shift;\ntemp2 = ((data & mask) << NBANKS_BIT) + offset;\ndata >>= shift;\ntemp3 = ((data & mask) << NBANKS_BIT) + offset;\ndata >>= shift;\ntemp4 = ((data & mask) << NBANKS_BIT) + offset;\natomic_inc(subhist + temp1.x);\natomic_inc(subhist + temp1.y);\natomic_inc(subhist + temp1.z);\natomic_inc(subhist + temp1.w);\natomic_inc(subhist + temp2.x);\natomic_inc(subhist + temp2.y);\natomic_inc(subhist + temp2.z);\natomic_inc(subhist + temp2.w);\natomic_inc(subhist + temp3.x);\natomic_inc(subhist + temp3.y);\natomic_inc(subhist + temp3.z);\natomic_inc(subhist + temp3.w);\natomic_inc(subhist + temp4.x);\natomic_inc(subhist + temp4.y);\natomic_inc(subhist + temp4.z);\natomic_inc(subhist + temp4.w);\nx += inc_x;\nint off = ((x>=cols) ? -1 : 0);\nx = mad24(off, cols, x);\ny += inc_y - off;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint bin1=0, bin2=0, bin3=0, bin4=0;\nfor(int i=0; i<NBANKS; i+=4)\n{\nbin1 += subhist[(lid << NBANKS_BIT) + i];\nbin2 += subhist[(lid << NBANKS_BIT) + i+1];\nbin3 += subhist[(lid << NBANKS_BIT) + i+2];\nbin4 += subhist[(lid << NBANKS_BIT) + i+3];\n}\nglobalHist[mad24(gx, hist_step, lid)] = bin1+bin2+bin3+bin4;\n}\n__kernel void __attribute__((reqd_work_group_size(1,HISTOGRAM256_BIN_COUNT,1)))\ncalc_sub_hist_border_D0(__global const uchar* src, int src_step, int src_offset,\n__global int* globalHist, int left_col, int cols,\nint rows, int hist_step)\n{\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint lidy = get_local_id(1);\nint gx = get_group_id(0);\nint gy = get_group_id(1);\nint gn = get_num_groups(0);\nint rowIndex = mad24(gy, gn, gx);\n__local int subhist[HISTOGRAM256_LOCAL_MEM_SIZE];\nsubhist[lidy] = 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\ngidx = ((gidx>=left_col) ? (gidx+cols) : gidx);\nif(gidy<rows)\n{\nint src_index = src_offset + mad24(gidy, src_step, gidx);\nint p = (int)src[src_index];\natomic_inc(subhist + p);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nglobalHist[mad24(rowIndex, hist_step, lidy)] += subhist[lidy];\n}\n__kernel __attribute__((reqd_work_group_size(256,1,1)))void merge_hist(__global int* buf,\n__global int* hist,\nint src_step)\n{\nint lx = get_local_id(0);\nint gx = get_group_id(0);\nint sum = 0;\nfor(int i = lx; i < PARTIAL_HISTOGRAM256_COUNT; i += HISTOGRAM256_WORK_GROUP_SIZE)\nsum += buf[ mad24(i, src_step, gx)];\n__local int data[HISTOGRAM256_WORK_GROUP_SIZE];\ndata[lx] = sum;\nfor(int stride = HISTOGRAM256_WORK_GROUP_SIZE /2; stride > 0; stride >>= 1)\n{\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lx < stride)\ndata[lx] += data[lx + stride];\n}\nif(lx == 0)\nhist[gx] = data[0];\n}\n__kernel __attribute__((reqd_work_group_size(256,1,1)))\nvoid calLUT(__global uchar * dst, __constant int * hist, int total)\n{\nint lid = get_local_id(0);\n__local int sumhist[HISTOGRAM256_BIN_COUNT];\n__local float scale;\nsumhist[lid] = hist[lid];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lid == 0)\n{\nint sum = 0, i = 0;\nwhile (!sumhist[i])\n++i;\nif (total == sumhist[i])\n{\nscale = 1;\nfor (int j = 0; j < HISTOGRAM256_BIN_COUNT; ++j)\nsumhist[i] = i;\n}\nelse\n{\nscale = 255.f/(total - sumhist[i]);\nfor (sumhist[i++] = 0; i < HISTOGRAM256_BIN_COUNT; i++)\n{\nsum += sumhist[i];\nsumhist[i] = sum;\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\ndst[lid]= convert_uchar_sat_rte(convert_float(sumhist[lid])*scale);\n}\n", "c7700f9857976933b98297cf20dfc711", "imgproc_gftt", "#ifndef WITH_MASK\n#define WITH_MASK 0\n#endif\n#define GET_SRC_32F(_x, _y) ((__global const float*)(eig + (_y)*eig_pitch))[_x]\n__kernel\nvoid findCorners\n(\n__global const char*    eig,\nconst int               eig_pitch,\n__global const char*    mask,\n__global float2*        corners,\nconst int               mask_strip,\n__global const float*   pMinMax,\nconst float             qualityLevel,\nconst int               rows,\nconst int               cols,\nconst int               max_count,\n__global int*           g_counter\n)\n{\nfloat threshold = qualityLevel*pMinMax[1];\nconst int j = get_global_id(0);\nconst int i = get_global_id(1);\nif (i > 0 && i < rows - 1 && j > 0 && j < cols - 1\n#if WITH_MASK\n&& mask[i * mask_strip + j] != 0\n#endif\n)\n{\nconst float val = GET_SRC_32F(j, i);\nif (val > threshold)\n{\nfloat maxVal = val;\nmaxVal = fmax(GET_SRC_32F(j - 1, i - 1), maxVal);\nmaxVal = fmax(GET_SRC_32F(j    , i - 1), maxVal);\nmaxVal = fmax(GET_SRC_32F(j + 1, i - 1), maxVal);\nmaxVal = fmax(GET_SRC_32F(j - 1, i), maxVal);\nmaxVal = fmax(GET_SRC_32F(j + 1, i), maxVal);\nmaxVal = fmax(GET_SRC_32F(j - 1, i + 1), maxVal);\nmaxVal = fmax(GET_SRC_32F(j    , i + 1), maxVal);\nmaxVal = fmax(GET_SRC_32F(j + 1, i + 1), maxVal);\nif (val == maxVal)\n{\nconst int ind = atomic_inc(g_counter);\nif (ind < max_count)\n{\ncorners[ind].x = val;\ncorners[ind].y = as_float(j|(i<<16));\n}\n}\n}\n}\n}\n#undef GET_SRC_32F\n__kernel\nvoid sortCorners_bitonicSort\n(\n__global float2 * corners,\nconst int count,\nconst int stage,\nconst int passOfStage\n)\n{\nconst int threadId = get_global_id(0);\nif(threadId >= count / 2)\n{\nreturn;\n}\nconst int sortOrder = (((threadId/(1 << stage)) % 2)) == 1 ? 1 : 0;\nconst int pairDistance = 1 << (stage - passOfStage);\nconst int blockWidth   = 2 * pairDistance;\nconst int leftId = min( (threadId % pairDistance)\n+ (threadId / pairDistance) * blockWidth, count );\nconst int rightId = min( leftId + pairDistance, count );\nconst float2 leftPt  = corners[leftId];\nconst float2 rightPt = corners[rightId];\nconst float leftVal  = leftPt.x;\nconst float rightVal = rightPt.x;\nconst bool compareResult = leftVal > rightVal;\nfloat2 greater = compareResult ? leftPt:rightPt;\nfloat2 lesser  = compareResult ? rightPt:leftPt;\ncorners[leftId]  = sortOrder ? lesser : greater;\ncorners[rightId] = sortOrder ? greater : lesser;\n}\n__kernel void arithm_op_minMax_final(__global float * data, int groupnum,__global int * g_counter)\n{\ng_counter[0] = 0;\nfloat minVal = data[0];\nfloat maxVal = data[groupnum];\nfor(int i=1;i<groupnum;++i)\n{\nminVal = min(minVal,data[i]);\nmaxVal = max(maxVal,data[i+groupnum]);\n}\ndata[0] = minVal;\ndata[1] = maxVal;\n}\n", "465db4ad20d408ebbb09576d85e4c452", "imgproc_copymakeboder", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#ifdef BORDER_CONSTANT\n#define EXTRAPOLATE(x, y, v) v = scalar;\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, y, v) \\\n{ \\\nx = max(min(x, src_cols - 1), 0); \\\ny = max(min(y, src_rows - 1), 0); \\\nv = src[mad24(y, src_step, x + src_offset)]; \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, y, v) \\\n{ \\\nif (x < 0) \\\nx -= ((x - src_cols + 1) / src_cols) * src_cols; \\\nif (x >= src_cols) \\\nx %= src_cols; \\\n\\\nif (y < 0) \\\ny -= ((y - src_rows + 1) / src_rows) * src_rows; \\\nif( y >= src_rows ) \\\ny %= src_rows; \\\nv = src[mad24(y, src_step, x + src_offset)]; \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n#ifdef BORDER_REFLECT\n#define DELTA int delta = 0\n#else\n#define DELTA int delta = 1\n#endif\n#define EXTRAPOLATE(x, y, v) \\\n{ \\\nDELTA; \\\nif (src_cols == 1) \\\nx = 0; \\\nelse \\\ndo \\\n{ \\\nif( x < 0 ) \\\nx = -x - 1 + delta; \\\nelse \\\nx = src_cols - 1 - (x - src_cols) - delta; \\\n} \\\nwhile (x >= src_cols || x < 0); \\\n\\\nif (src_rows == 1) \\\ny = 0; \\\nelse \\\ndo \\\n{ \\\nif( y < 0 ) \\\ny = -y - 1 + delta; \\\nelse \\\ny = src_rows - 1 - (y - src_rows) - delta; \\\n} \\\nwhile (y >= src_rows || y < 0); \\\nv = src[mad24(y, src_step, x + src_offset)]; \\\n}\n#else\n#error No extrapolation method\n#endif\n#define NEED_EXTRAPOLATION(gx, gy) (gx >= src_cols || gy >= src_rows || gx < 0 || gy < 0)\n__kernel void copymakeborder\n(__global const GENTYPE *src,\n__global GENTYPE *dst,\nint dst_cols, int dst_rows,\nint src_cols, int src_rows,\nint src_step, int src_offset,\nint dst_step, int dst_offset,\nint top, int left, GENTYPE scalar)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\nint src_x = x - left;\nint src_y = y - top;\nint dst_index = mad24(y, dst_step, x + dst_offset);\nif (NEED_EXTRAPOLATION(src_x, src_y))\nEXTRAPOLATE(src_x, src_y, dst[dst_index])\nelse\n{\nint src_index = mad24(src_y, src_step, src_x + src_offset);\ndst[dst_index] = src[src_index];\n}\n}\n}\n", "d7165bbf10e602973a40db33d5cfc4ad", "imgproc_convolve", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void convolve_D5(__global float *src, __global float *temp1, __global float *dst,\nint rows, int cols, int src_step, int dst_step,int k_step, int kWidth, int kHeight,\nint src_offset, int dst_offset, int koffset)\n{\n__local float smem[16 + 2 * 8][16 + 2 * 8];\nint x = get_local_id(0);\nint y = get_local_id(1);\nint gx = get_global_id(0);\nint gy = get_global_id(1);\nsmem[y][x] = src[min(max(gy - 8, 0), rows - 1) * src_step + min(max(gx - 8, 0), cols - 1) + src_offset];\nsmem[y][x + 16] = src[min(max(gy - 8, 0), rows - 1) * src_step + min(gx + 8, cols - 1) + src_offset];\nsmem[y + 16][x] = src[min(gy + 8, rows - 1) * src_step + min(max(gx - 8, 0), cols - 1) + src_offset];\nsmem[y + 16][x + 16] = src[min(gy + 8, rows - 1) * src_step + min(gx + 8, cols - 1) + src_offset];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (gx < cols && gy < rows)\n{\nfloat res = 0;\nfor (int i = 0; i < kHeight; ++i)\nfor (int j = 0; j < kWidth; ++j)\nres += smem[y + 8 - kHeight / 2 + i][x + 8 - kWidth / 2 + j] * temp1[i * k_step + j + koffset];\ndst[gy * dst_step + gx + dst_offset] = res;\n}\n}\n", "f7190f8357538986dbf934323c735bd8", "imgproc_columnsum", "__kernel void columnSum_C1_D5(__global float * src, __global float * dst,\nint cols, int rows, int src_step, int dst_step, int src_offset, int dst_offset)\n{\nconst int x = get_global_id(0);\nif (x < cols)\n{\nint srcIdx = x + src_offset;\nint dstIdx = x + dst_offset;\nfloat sum = 0;\nfor (int y = 0; y < rows; ++y)\n{\nsum += src[srcIdx];\ndst[dstIdx] = sum;\nsrcIdx += src_step;\ndstIdx += dst_step;\n}\n}\n}\n", "b6c673aadf09dcda2c42262f9d0d8f40", "imgproc_clahe", "#ifndef WAVE_SIZE\n#define WAVE_SIZE 1\n#endif\nint calc_lut(__local int* smem, int val, int tid)\n{\nsmem[tid] = val;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid == 0)\nfor (int i = 1; i < 256; ++i)\nsmem[i] += smem[i - 1];\nbarrier(CLK_LOCAL_MEM_FENCE);\nreturn smem[tid];\n}\n#ifdef CPU\nvoid reduce(volatile __local int* smem, int val, int tid)\n{\nsmem[tid] = val;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 128)\nsmem[tid] = val += smem[tid + 128];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 64)\nsmem[tid] = val += smem[tid + 64];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 32)\nsmem[tid] += smem[tid + 32];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16)\nsmem[tid] += smem[tid + 16];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 8)\nsmem[tid] += smem[tid + 8];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 4)\nsmem[tid] += smem[tid + 4];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 2)\nsmem[tid] += smem[tid + 2];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 1)\nsmem[256] = smem[tid] + smem[tid + 1];\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n#else\nvoid reduce(__local volatile int* smem, int val, int tid)\n{\nsmem[tid] = val;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 128)\nsmem[tid] = val += smem[tid + 128];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 64)\nsmem[tid] = val += smem[tid + 64];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 32)\n{\nsmem[tid] += smem[tid + 32];\n#if WAVE_SIZE < 32\n} barrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 16)\n{\n#endif\nsmem[tid] += smem[tid + 16];\n#if WAVE_SIZE < 16\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (tid < 8)\n{\n#endif\nsmem[tid] += smem[tid + 8];\nsmem[tid] += smem[tid + 4];\nsmem[tid] += smem[tid + 2];\nsmem[tid] += smem[tid + 1];\n}\n}\n#endif\n__kernel void calcLut(__global __const uchar * src, __global uchar * lut,\nconst int srcStep, const int dstStep,\nconst int2 tileSize, const int tilesX,\nconst int clipLimit, const float lutScale,\nconst int src_offset, const int dst_offset)\n{\n__local int smem[512];\nint tx = get_group_id(0);\nint ty = get_group_id(1);\nint tid = get_local_id(1) * get_local_size(0)\n+ get_local_id(0);\nsmem[tid] = 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int i = get_local_id(1); i < tileSize.y; i += get_local_size(1))\n{\n__global const uchar* srcPtr = src + mad24(ty * tileSize.y + i, srcStep, tx * tileSize.x + src_offset);\nfor (int j = get_local_id(0); j < tileSize.x; j += get_local_size(0))\n{\nconst int data = srcPtr[j];\natomic_inc(&smem[data]);\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint tHistVal = smem[tid];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (clipLimit > 0)\n{\nint clipped = 0;\nif (tHistVal > clipLimit)\n{\nclipped = tHistVal - clipLimit;\ntHistVal = clipLimit;\n}\nreduce(smem, clipped, tid);\nbarrier(CLK_LOCAL_MEM_FENCE);\n#ifdef CPU\nclipped = smem[256];\n#else\nclipped = smem[0];\n#endif\n__local int totalClipped;\nif (tid == 0)\ntotalClipped = clipped;\nbarrier(CLK_LOCAL_MEM_FENCE);\nint redistBatch = totalClipped / 256;\ntHistVal += redistBatch;\nint residual = totalClipped - redistBatch * 256;\nif (tid < residual)\n++tHistVal;\n}\nconst int lutVal = calc_lut(smem, tHistVal, tid);\nuint ires = (uint)convert_int_rte(lutScale * lutVal);\nlut[(ty * tilesX + tx) * dstStep + tid + dst_offset] =\nconvert_uchar(clamp(ires, (uint)0, (uint)255));\n}\n__kernel void transform(__global __const uchar * src,\n__global uchar * dst,\n__global uchar * lut,\nconst int srcStep, const int dstStep, const int lutStep,\nconst int cols, const int rows,\nconst int2 tileSize,\nconst int tilesX, const int tilesY,\nconst int src_offset, const int dst_offset, int lut_offset)\n{\nconst int x = get_global_id(0);\nconst int y = get_global_id(1);\nif (x >= cols || y >= rows)\nreturn;\nconst float tyf = (convert_float(y) / tileSize.y) - 0.5f;\nint ty1 = convert_int_rtn(tyf);\nint ty2 = ty1 + 1;\nconst float ya = tyf - ty1;\nty1 = max(ty1, 0);\nty2 = min(ty2, tilesY - 1);\nconst float txf = (convert_float(x) / tileSize.x) - 0.5f;\nint tx1 = convert_int_rtn(txf);\nint tx2 = tx1 + 1;\nconst float xa = txf - tx1;\ntx1 = max(tx1, 0);\ntx2 = min(tx2, tilesX - 1);\nconst int srcVal = src[mad24(y, srcStep, x + src_offset)];\nfloat res = 0;\nres += lut[mad24(ty1 * tilesX + tx1, lutStep, srcVal + lut_offset)] * ((1.0f - xa) * (1.0f - ya));\nres += lut[mad24(ty1 * tilesX + tx2, lutStep, srcVal + lut_offset)] * ((xa) * (1.0f - ya));\nres += lut[mad24(ty2 * tilesX + tx1, lutStep, srcVal + lut_offset)] * ((1.0f - xa) * (ya));\nres += lut[mad24(ty2 * tilesX + tx2, lutStep, srcVal + lut_offset)] * ((xa) * (ya));\nuint ires = (uint)convert_int_rte(res);\ndst[mad24(y, dstStep, x + dst_offset)] = convert_uchar(clamp(ires, (uint)0, (uint)255));\n}\n", "8b121e325b7df292f7ca7b394daddbbe", "imgproc_canny", "#ifdef L2GRAD\nfloat calc(int x, int y)\n{\nreturn sqrt((float)(x * x + y * y));\n}\n#else\nfloat calc(int x, int y)\n{\nreturn (float)abs(x) + abs(y);\n}\n#endif\n__kernel\nvoid\n__attribute__((reqd_work_group_size(16,16,1)))\ncalcSobelRowPass\n(\n__global const uchar * src,\n__global int * dx_buf,\n__global int * dy_buf,\nint rows,\nint cols,\nint src_step,\nint src_offset,\nint dx_buf_step,\nint dx_buf_offset,\nint dy_buf_step,\nint dy_buf_offset\n)\n{\ndx_buf_step   /= sizeof(*dx_buf);\ndx_buf_offset /= sizeof(*dx_buf);\ndy_buf_step   /= sizeof(*dy_buf);\ndy_buf_offset /= sizeof(*dy_buf);\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint lidx = get_local_id(0);\nint lidy = get_local_id(1);\n__local int smem[16][18];\nsmem[lidy][lidx + 1] =\nsrc[gidx + min(gidy, rows - 1) * src_step + src_offset];\nif(lidx == 0)\n{\nsmem[lidy][0]  =\nsrc[max(gidx - 1,  0)        + min(gidy, rows - 1) * src_step + src_offset];\nsmem[lidy][17] =\nsrc[min(gidx + 16, cols - 1) + min(gidy, rows - 1) * src_step + src_offset];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gidy < rows && gidx < cols)\n{\ndx_buf[gidx + gidy * dx_buf_step + dx_buf_offset] =\n-smem[lidy][lidx] + smem[lidy][lidx + 2];\ndy_buf[gidx + gidy * dy_buf_step + dy_buf_offset] =\nsmem[lidy][lidx] + 2 * smem[lidy][lidx + 1] + smem[lidy][lidx + 2];\n}\n}\n__kernel\nvoid\n__attribute__((reqd_work_group_size(16,16,1)))\ncalcMagnitude_buf\n(\n__global const int * dx_buf,\n__global const int * dy_buf,\n__global int * dx,\n__global int * dy,\n__global float * mag,\nint rows,\nint cols,\nint dx_buf_step,\nint dx_buf_offset,\nint dy_buf_step,\nint dy_buf_offset,\nint dx_step,\nint dx_offset,\nint dy_step,\nint dy_offset,\nint mag_step,\nint mag_offset\n)\n{\ndx_buf_step    /= sizeof(*dx_buf);\ndx_buf_offset  /= sizeof(*dx_buf);\ndy_buf_step    /= sizeof(*dy_buf);\ndy_buf_offset  /= sizeof(*dy_buf);\ndx_step    /= sizeof(*dx);\ndx_offset  /= sizeof(*dx);\ndy_step    /= sizeof(*dy);\ndy_offset  /= sizeof(*dy);\nmag_step   /= sizeof(*mag);\nmag_offset /= sizeof(*mag);\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint lidx = get_local_id(0);\nint lidy = get_local_id(1);\n__local int sdx[18][16];\n__local int sdy[18][16];\nsdx[lidy + 1][lidx] =\ndx_buf[gidx + min(gidy, rows - 1) * dx_buf_step + dx_buf_offset];\nsdy[lidy + 1][lidx] =\ndy_buf[gidx + min(gidy, rows - 1) * dy_buf_step + dy_buf_offset];\nif(lidy == 0)\n{\nsdx[0][lidx]  =\ndx_buf[gidx + min(max(gidy-1,0),rows-1) * dx_buf_step + dx_buf_offset];\nsdx[17][lidx] =\ndx_buf[gidx + min(gidy + 16, rows - 1)  * dx_buf_step + dx_buf_offset];\nsdy[0][lidx]  =\ndy_buf[gidx + min(max(gidy-1,0),rows-1) * dy_buf_step + dy_buf_offset];\nsdy[17][lidx] =\ndy_buf[gidx + min(gidy + 16, rows - 1)  * dy_buf_step + dy_buf_offset];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gidx < cols && gidy < rows)\n{\nint x =  sdx[lidy][lidx] + 2 * sdx[lidy + 1][lidx] + sdx[lidy + 2][lidx];\nint y = -sdy[lidy][lidx] + sdy[lidy + 2][lidx];\ndx[gidx + gidy * dx_step + dx_offset] = x;\ndy[gidx + gidy * dy_step + dy_offset] = y;\nmag[(gidx + 1) + (gidy + 1) * mag_step + mag_offset] = calc(x, y);\n}\n}\n__kernel\nvoid calcMagnitude\n(\n__global const int * dx,\n__global const int * dy,\n__global float * mag,\nint rows,\nint cols,\nint dx_step,\nint dx_offset,\nint dy_step,\nint dy_offset,\nint mag_step,\nint mag_offset\n)\n{\ndx_step    /= sizeof(*dx);\ndx_offset  /= sizeof(*dx);\ndy_step    /= sizeof(*dy);\ndy_offset  /= sizeof(*dy);\nmag_step   /= sizeof(*mag);\nmag_offset /= sizeof(*mag);\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nif(gidy < rows && gidx < cols)\n{\nmag[(gidx + 1) + (gidy + 1) * mag_step + mag_offset] =\ncalc(\ndx[gidx + gidy * dx_step + dx_offset],\ndy[gidx + gidy * dy_step + dy_offset]\n);\n}\n}\n#define CANNY_SHIFT 15\n#ifdef DOUBLE_SUPPORT\n#define TG22        (int)(0.4142135623730950488016887242097*(1<<CANNY_SHIFT) + 0.5)\n#else\n#define TG22        (int)(0.4142135623730950488016887242097f*(1<<CANNY_SHIFT) + 0.5f)\n#endif\n__kernel\nvoid\n__attribute__((reqd_work_group_size(16,16,1)))\ncalcMap\n(\n__global const int * dx,\n__global const int * dy,\n__global const float * mag,\n__global int * map,\nint rows,\nint cols,\nfloat low_thresh,\nfloat high_thresh,\nint dx_step,\nint dx_offset,\nint dy_step,\nint dy_offset,\nint mag_step,\nint mag_offset,\nint map_step,\nint map_offset\n)\n{\ndx_step    /= sizeof(*dx);\ndx_offset  /= sizeof(*dx);\ndy_step    /= sizeof(*dy);\ndy_offset  /= sizeof(*dy);\nmag_step   /= sizeof(*mag);\nmag_offset /= sizeof(*mag);\nmap_step   /= sizeof(*map);\nmap_offset /= sizeof(*map);\nmag += mag_offset;\nmap += map_offset;\n__local float smem[18][18];\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint lidx = get_local_id(0);\nint lidy = get_local_id(1);\nint grp_idx = get_global_id(0) & 0xFFFFF0;\nint grp_idy = get_global_id(1) & 0xFFFFF0;\nint tid = lidx + lidy * 16;\nint lx = tid % 18;\nint ly = tid / 18;\nif(ly < 14)\n{\nsmem[ly][lx] =\nmag[grp_idx + lx + min(grp_idy + ly, rows - 1) * mag_step];\n}\nif(ly < 4 && grp_idy + ly + 14 <= rows && grp_idx + lx <= cols)\n{\nsmem[ly + 14][lx] =\nmag[grp_idx + lx + min(grp_idy + ly + 14, rows -1) * mag_step];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gidy < rows && gidx < cols)\n{\nint x = dx[gidx + gidy * dx_step];\nint y = dy[gidx + gidy * dy_step];\nconst int s = (x ^ y) < 0 ? -1 : 1;\nconst float m = smem[lidy + 1][lidx + 1];\nx = abs(x);\ny = abs(y);\nint edge_type = 0;\nif(m > low_thresh)\n{\nconst int tg22x = x * TG22;\nconst int tg67x = tg22x + (x << (1 + CANNY_SHIFT));\ny <<= CANNY_SHIFT;\nif(y < tg22x)\n{\nif(m > smem[lidy + 1][lidx] && m >= smem[lidy + 1][lidx + 2])\n{\nedge_type = 1 + (int)(m > high_thresh);\n}\n}\nelse if (y > tg67x)\n{\nif(m > smem[lidy][lidx + 1]&& m >= smem[lidy + 2][lidx + 1])\n{\nedge_type = 1 + (int)(m > high_thresh);\n}\n}\nelse\n{\nif(m > smem[lidy][lidx + 1 - s]&& m > smem[lidy + 2][lidx + 1 + s])\n{\nedge_type = 1 + (int)(m > high_thresh);\n}\n}\n}\nmap[gidx + 1 + (gidy + 1) * map_step] = edge_type;\n}\n}\n#undef CANNY_SHIFT\n#undef TG22\nstruct PtrStepSz {\n__global int *ptr;\nint step;\nint rows, cols;\n};\nint get(struct PtrStepSz data, int y, int x) { return *((__global int *)((__global char*)data.ptr + data.step * (y + 1) + sizeof(int) * (x + 1))); }\nvoid set(struct PtrStepSz data, int y, int x, int value) { *((__global int *)((__global char*)data.ptr + data.step * (y + 1) + sizeof(int) * (x + 1))) = value; }\n__kernel\nvoid\n__attribute__((reqd_work_group_size(16,16,1)))\nedgesHysteresisLocal\n(\n__global int * map_ptr,\n__global ushort2 * st,\n__global unsigned int * counter,\nint rows,\nint cols,\nint map_step,\nint map_offset\n)\n{\n#if 0\nmap_step   /= sizeof(*map);\nmap_offset /= sizeof(*map);\nconst __global int* map = map_ptr + map_offset;\n__local int smem[18][18];\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint lidx = get_local_id(0);\nint lidy = get_local_id(1);\nint grp_idx = get_global_id(0) & 0xFFFFF0;\nint grp_idy = get_global_id(1) & 0xFFFFF0;\nint tid = lidx + lidy * 16;\nint lx = tid % 18;\nint ly = tid / 18;\nif(ly < 14)\n{\nsmem[ly][lx] =\nmap[grp_idx + lx + min(grp_idy + ly, rows - 1) * map_step];\n}\nif(ly < 4 && grp_idy + ly + 14 <= rows && grp_idx + lx <= cols)\n{\nsmem[ly + 14][lx] =\nmap[grp_idx + lx + min(grp_idy + ly + 14, rows - 1) * map_step];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(gidy < rows && gidx < cols)\n{\nint n;\n#pragma unroll\nfor (int k = 0; k < 16; ++k)\n{\nn = 0;\nif (smem[lidy + 1][lidx + 1] == 1)\n{\nn += smem[lidy    ][lidx    ] == 2;\nn += smem[lidy    ][lidx + 1] == 2;\nn += smem[lidy    ][lidx + 2] == 2;\nn += smem[lidy + 1][lidx    ] == 2;\nn += smem[lidy + 1][lidx + 2] == 2;\nn += smem[lidy + 2][lidx    ] == 2;\nn += smem[lidy + 2][lidx + 1] == 2;\nn += smem[lidy + 2][lidx + 2] == 2;\n}\nif (n > 0)\nsmem[lidy + 1][lidx + 1] = 2;\n}\nconst int e = smem[lidy + 1][lidx + 1];\nmap[gidx + 1 + (gidy + 1) * map_step] = e;\nn = 0;\nif(e == 2)\n{\nn += smem[lidy    ][lidx    ] == 1;\nn += smem[lidy    ][lidx + 1] == 1;\nn += smem[lidy    ][lidx + 2] == 1;\nn += smem[lidy + 1][lidx    ] == 1;\nn += smem[lidy + 1][lidx + 2] == 1;\nn += smem[lidy + 2][lidx    ] == 1;\nn += smem[lidy + 2][lidx + 1] == 1;\nn += smem[lidy + 2][lidx + 2] == 1;\n}\nif(n > 0)\n{\nunsigned int ind = atomic_inc(counter);\nst[ind] = (ushort2)(gidx + 1, gidy + 1);\n}\n}\n#else\nstruct PtrStepSz map = {((__global int *)((__global char*)map_ptr + map_offset)), map_step, rows + 1, cols + 1};\n__local int smem[18][18];\nint2 blockIdx = (int2)(get_group_id(0), get_group_id(1));\nint2 blockDim = (int2)(get_local_size(0), get_local_size(1));\nint2 threadIdx = (int2)(get_local_id(0), get_local_id(1));\nconst int x = blockIdx.x * blockDim.x + threadIdx.x;\nconst int y = blockIdx.y * blockDim.y + threadIdx.y;\nsmem[threadIdx.y + 1][threadIdx.x + 1] = x < map.cols && y < map.rows ? get(map, y, x) : 0;\nif (threadIdx.y == 0)\nsmem[0][threadIdx.x + 1] = x < map.cols ? get(map, y - 1, x) : 0;\nif (threadIdx.y == blockDim.y - 1)\nsmem[blockDim.y + 1][threadIdx.x + 1] = y + 1 < map.rows ? get(map, y + 1, x) : 0;\nif (threadIdx.x == 0)\nsmem[threadIdx.y + 1][0] = y < map.rows ? get(map, y, x - 1) : 0;\nif (threadIdx.x == blockDim.x - 1)\nsmem[threadIdx.y + 1][blockDim.x + 1] = x + 1 < map.cols && y < map.rows ? get(map, y, x + 1) : 0;\nif (threadIdx.x == 0 && threadIdx.y == 0)\nsmem[0][0] = y > 0 && x > 0 ? get(map, y - 1, x - 1) : 0;\nif (threadIdx.x == blockDim.x - 1 && threadIdx.y == 0)\nsmem[0][blockDim.x + 1] = y > 0 && x + 1 < map.cols ? get(map, y - 1, x + 1) : 0;\nif (threadIdx.x == 0 && threadIdx.y == blockDim.y - 1)\nsmem[blockDim.y + 1][0] = y + 1 < map.rows && x > 0 ? get(map, y + 1, x - 1) : 0;\nif (threadIdx.x == blockDim.x - 1 && threadIdx.y == blockDim.y - 1)\nsmem[blockDim.y + 1][blockDim.x + 1] = y + 1 < map.rows && x + 1 < map.cols ? get(map, y + 1, x + 1) : 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (x >= cols || y >= rows)\nreturn;\nint n;\n#pragma unroll\nfor (int k = 0; k < 16; ++k)\n{\nn = 0;\nif (smem[threadIdx.y + 1][threadIdx.x + 1] == 1)\n{\nn += smem[threadIdx.y    ][threadIdx.x    ] == 2;\nn += smem[threadIdx.y    ][threadIdx.x + 1] == 2;\nn += smem[threadIdx.y    ][threadIdx.x + 2] == 2;\nn += smem[threadIdx.y + 1][threadIdx.x    ] == 2;\nn += smem[threadIdx.y + 1][threadIdx.x + 2] == 2;\nn += smem[threadIdx.y + 2][threadIdx.x    ] == 2;\nn += smem[threadIdx.y + 2][threadIdx.x + 1] == 2;\nn += smem[threadIdx.y + 2][threadIdx.x + 2] == 2;\n}\nif (n > 0)\nsmem[threadIdx.y + 1][threadIdx.x + 1] = 2;\n}\nconst int e = smem[threadIdx.y + 1][threadIdx.x + 1];\nset(map, y, x, e);\nn = 0;\nif (e == 2)\n{\nn += smem[threadIdx.y    ][threadIdx.x    ] == 1;\nn += smem[threadIdx.y    ][threadIdx.x + 1] == 1;\nn += smem[threadIdx.y    ][threadIdx.x + 2] == 1;\nn += smem[threadIdx.y + 1][threadIdx.x    ] == 1;\nn += smem[threadIdx.y + 1][threadIdx.x + 2] == 1;\nn += smem[threadIdx.y + 2][threadIdx.x    ] == 1;\nn += smem[threadIdx.y + 2][threadIdx.x + 1] == 1;\nn += smem[threadIdx.y + 2][threadIdx.x + 2] == 1;\n}\nif (n > 0)\n{\nconst int ind = atomic_inc(counter);\nst[ind] = (ushort2)(x + 1, y + 1);\n}\n#endif\n}\n__constant int c_dx[8] = {-1,  0,  1, -1, 1, -1, 0, 1};\n__constant int c_dy[8] = {-1, -1, -1,  0, 0,  1, 1, 1};\n#define stack_size 512\n__kernel\nvoid\n__attribute__((reqd_work_group_size(128,1,1)))\nedgesHysteresisGlobal\n(\n__global int * map,\n__global ushort2 * st1,\n__global ushort2 * st2,\n__global int * counter,\nint rows,\nint cols,\nint count,\nint map_step,\nint map_offset\n)\n{\nmap_step   /= sizeof(*map);\nmap_offset /= sizeof(*map);\nmap += map_offset;\nint lidx = get_local_id(0);\nint grp_idx = get_group_id(0);\nint grp_idy = get_group_id(1);\n__local unsigned int s_counter;\n__local unsigned int s_ind;\n__local ushort2 s_st[stack_size];\nif(lidx == 0)\n{\ns_counter = 0;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint ind = mad24(grp_idy, (int)get_local_size(0), grp_idx);\nif(ind < count)\n{\nushort2 pos = st1[ind];\nif (lidx < 8)\n{\npos.x += c_dx[lidx];\npos.y += c_dy[lidx];\nif (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows && map[pos.x + pos.y * map_step] == 1)\n{\nmap[pos.x + pos.y * map_step] = 2;\nind = atomic_inc(&s_counter);\ns_st[ind] = pos;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nwhile (s_counter > 0 && s_counter <= stack_size - get_local_size(0))\n{\nconst int subTaskIdx = lidx >> 3;\nconst int portion = min(s_counter, (uint)(get_local_size(0)>> 3));\nif (subTaskIdx < portion)\npos = s_st[s_counter - 1 - subTaskIdx];\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lidx == 0)\ns_counter -= portion;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (subTaskIdx < portion)\n{\npos.x += c_dx[lidx & 7];\npos.y += c_dy[lidx & 7];\nif (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows && map[pos.x + pos.y * map_step] == 1)\n{\nmap[pos.x + pos.y * map_step] = 2;\nind = atomic_inc(&s_counter);\ns_st[ind] = pos;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif (s_counter > 0)\n{\nif (lidx == 0)\n{\nind = atomic_add(counter, s_counter);\ns_ind = ind - s_counter;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nind = s_ind;\nfor (int i = lidx; i < (int)s_counter; i += get_local_size(0))\n{\nst2[ind + i] = s_st[i];\n}\n}\n}\n}\n#undef stack_size\n__kernel\nvoid getEdges\n(\n__global const int * map,\n__global uchar * dst,\nint rows,\nint cols,\nint map_step,\nint map_offset,\nint dst_step,\nint dst_offset\n)\n{\nmap_step   /= sizeof(*map);\nmap_offset /= sizeof(*map);\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nif(gidy < rows && gidx < cols)\n{\ndst[gidx + gidy * dst_step] = (uchar)(-(map[gidx + 1 + (gidy + 1) * map_step + map_offset] >> 1));\n}\n}\n", "917a8bcd294871fe5c17dc71f6d660e8", "imgproc_calcMinEigenVal", "#ifdef BORDER_CONSTANT\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nx = max(min(x, maxV - 1), 0); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nif (x < 0) \\\nx -= ((x - maxV + 1) / maxV) * maxV; \\\nif (x >= maxV) \\\nx %= maxV; \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT101)\n#define EXTRAPOLATE_(x, maxV, delta) \\\n{ \\\nif (maxV == 1) \\\nx = 0; \\\nelse \\\ndo \\\n{ \\\nif ( x < 0 ) \\\nx = -x - 1 + delta; \\\nelse \\\nx = maxV - 1 - (x - maxV) - delta; \\\n} \\\nwhile (x >= maxV || x < 0); \\\n}\n#ifdef BORDER_REFLECT\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 0)\n#else\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 1)\n#endif\n#else\n#error No extrapolation method\n#endif\n#define THREADS 256\n__kernel void calcMinEigenVal(__global const float *Dx,__global const float *Dy, __global float *dst,\nint dx_offset, int dx_whole_rows, int dx_whole_cols, int dx_step,\nint dy_offset, int dy_whole_rows, int dy_whole_cols, int dy_step,\nint dst_offset, int dst_rows, int dst_cols, int dst_step, float k)\n{\nint col = get_local_id(0);\nint gX = get_group_id(0);\nint gY = get_group_id(1);\nint gly = get_global_id(1);\nint dx_x_off = (dx_offset % dx_step) >> 2;\nint dx_y_off = dx_offset / dx_step;\nint dy_x_off = (dy_offset % dy_step) >> 2;\nint dy_y_off = dy_offset / dy_step;\nint dst_x_off = (dst_offset % dst_step) >> 2;\nint dst_y_off = dst_offset / dst_step;\nint dx_startX = gX * (THREADS-ksX+1) - anX + dx_x_off;\nint dx_startY = (gY << 1) - anY + dx_y_off;\nint dy_startX = gX * (THREADS-ksX+1) - anX + dy_x_off;\nint dy_startY = (gY << 1) - anY + dy_y_off;\nint dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\nint dst_startY = (gY << 1) + dst_y_off;\nfloat dx_data[ksY+1], dy_data[ksY+1], data[3][ksY+1];\n__local float temp[6][THREADS];\n#ifdef BORDER_CONSTANT\nfor (int i=0; i < ksY+1; i++)\n{\nbool dx_con = dx_startX+col >= 0 && dx_startX+col < dx_whole_cols && dx_startY+i >= 0 && dx_startY+i < dx_whole_rows;\nint indexDx = (dx_startY+i)*(dx_step>>2)+(dx_startX+col);\nfloat dx_s = dx_con ? Dx[indexDx] : 0.0f;\ndx_data[i] = dx_s;\nbool dy_con = dy_startX+col >= 0 && dy_startX+col < dy_whole_cols && dy_startY+i >= 0 && dy_startY+i < dy_whole_rows;\nint indexDy = (dy_startY+i)*(dy_step>>2)+(dy_startX+col);\nfloat dy_s = dy_con ? Dy[indexDy] : 0.0f;\ndy_data[i] = dy_s;\ndata[0][i] = dx_data[i] * dx_data[i];\ndata[1][i] = dx_data[i] * dy_data[i];\ndata[2][i] = dy_data[i] * dy_data[i];\n}\n#else\nint clamped_col = min(dst_cols, col);\nfor (int i=0; i < ksY+1; i++)\n{\nint dx_selected_row = dx_startY+i, dx_selected_col = dx_startX+clamped_col;\nEXTRAPOLATE(dx_selected_row, dx_whole_rows)\nEXTRAPOLATE(dx_selected_col, dx_whole_cols)\ndx_data[i] = Dx[dx_selected_row * (dx_step>>2) + dx_selected_col];\nint dy_selected_row = dy_startY+i, dy_selected_col = dy_startX+clamped_col;\nEXTRAPOLATE(dy_selected_row, dy_whole_rows)\nEXTRAPOLATE(dy_selected_col, dy_whole_cols)\ndy_data[i] = Dy[dy_selected_row * (dy_step>>2) + dy_selected_col];\ndata[0][i] = dx_data[i] * dx_data[i];\ndata[1][i] = dx_data[i] * dy_data[i];\ndata[2][i] = dy_data[i] * dy_data[i];\n}\n#endif\nfloat sum0 = 0.0f, sum1 = 0.0f, sum2 = 0.0f;\nfor (int i=1; i < ksY; i++)\n{\nsum0 += (data[0][i]);\nsum1 += (data[1][i]);\nsum2 += (data[2][i]);\n}\nfloat sum01 = sum0 + (data[0][0]);\nfloat sum02 = sum0 + (data[0][ksY]);\ntemp[0][col] = sum01;\ntemp[1][col] = sum02;\nfloat sum11 = sum1 + (data[1][0]);\nfloat sum12 = sum1 + (data[1][ksY]);\ntemp[2][col] = sum11;\ntemp[3][col] = sum12;\nfloat sum21 = sum2 + (data[2][0]);\nfloat sum22 = sum2 + (data[2][ksY]);\ntemp[4][col] = sum21;\ntemp[5][col] = sum22;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(col < (THREADS-(ksX-1)))\n{\ncol += anX;\nint posX = dst_startX - dst_x_off + col - anX;\nint posY = (gly << 1);\nint till = (ksX + 1)%2;\nfloat tmp_sum[6] = { 0.0f, 0.0f , 0.0f, 0.0f, 0.0f, 0.0f };\nfor (int k=0; k<6; k++)\nfor (int i=-anX; i<=anX - till; i++)\ntmp_sum[k] += temp[k][col+i];\nif(posX < dst_cols && (posY) < dst_rows)\n{\nfloat a = tmp_sum[0] * 0.5f;\nfloat b = tmp_sum[2];\nfloat c = tmp_sum[4] * 0.5f;\ndst[(dst_startY+0) * (dst_step>>2)+ dst_startX + col - anX] = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n}\nif (posX < dst_cols && (posY + 1) < dst_rows)\n{\nfloat a = tmp_sum[1] * 0.5f;\nfloat b = tmp_sum[3];\nfloat c = tmp_sum[5] * 0.5f;\ndst[(dst_startY+1) * (dst_step>>2)+ dst_startX + col - anX] = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n}\n}\n}\n", "af755a2a32c7b43016576fecac43fa29", "imgproc_calcHarris", "#if defined (DOUBLE_SUPPORT) && defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#define FPTYPE double\n#else\n#define FPTYPE float\n#endif\n#ifdef BORDER_CONSTANT\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nx = max(min(x, maxV - 1), 0); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nif (x < 0) \\\nx -= ((x - maxV + 1) / maxV) * maxV; \\\nif (x >= maxV) \\\nx %= maxV; \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT101)\n#define EXTRAPOLATE_(x, maxV, delta) \\\n{ \\\nif (maxV == 1) \\\nx = 0; \\\nelse \\\ndo \\\n{ \\\nif ( x < 0 ) \\\nx = -x - 1 + delta; \\\nelse \\\nx = maxV - 1 - (x - maxV) - delta; \\\n} \\\nwhile (x >= maxV || x < 0); \\\n}\n#ifdef BORDER_REFLECT\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 0)\n#else\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 1)\n#endif\n#else\n#error No extrapolation method\n#endif\n#define THREADS 256\n__kernel void calcHarris(__global const float *Dx, __global const float *Dy, __global float *dst,\nint dx_offset, int dx_whole_rows, int dx_whole_cols, int dx_step,\nint dy_offset, int dy_whole_rows, int dy_whole_cols, int dy_step,\nint dst_offset, int dst_rows, int dst_cols, int dst_step, float k)\n{\nint col = get_local_id(0);\nint gX = get_group_id(0);\nint gY = get_group_id(1);\nint gly = get_global_id(1);\nint dx_x_off = (dx_offset % dx_step) >> 2;\nint dx_y_off = dx_offset / dx_step;\nint dy_x_off = (dy_offset % dy_step) >> 2;\nint dy_y_off = dy_offset / dy_step;\nint dst_x_off = (dst_offset % dst_step) >> 2;\nint dst_y_off = dst_offset / dst_step;\nint dx_startX = gX * (THREADS-ksX+1) - anX + dx_x_off;\nint dx_startY = (gY << 1) - anY + dx_y_off;\nint dy_startX = gX * (THREADS-ksX+1) - anX + dy_x_off;\nint dy_startY = (gY << 1) - anY + dy_y_off;\nint dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\nint dst_startY = (gY << 1) + dst_y_off;\nfloat dx_data[ksY+1],dy_data[ksY+1], data[3][ksY+1];\n__local FPTYPE temp[6][THREADS];\n#ifdef BORDER_CONSTANT\nfor (int i=0; i < ksY+1; i++)\n{\nbool dx_con = dx_startX+col >= 0 && dx_startX+col < dx_whole_cols && dx_startY+i >= 0 && dx_startY+i < dx_whole_rows;\nint indexDx = (dx_startY+i)*(dx_step>>2)+(dx_startX+col);\nfloat dx_s = dx_con ? Dx[indexDx] : 0.0f;\ndx_data[i] = dx_s;\nbool dy_con = dy_startX+col >= 0 && dy_startX+col < dy_whole_cols && dy_startY+i >= 0 && dy_startY+i < dy_whole_rows;\nint indexDy = (dy_startY+i)*(dy_step>>2)+(dy_startX+col);\nfloat dy_s = dy_con ? Dy[indexDy] : 0.0f;\ndy_data[i] = dy_s;\ndata[0][i] = dx_data[i] * dx_data[i];\ndata[1][i] = dx_data[i] * dy_data[i];\ndata[2][i] = dy_data[i] * dy_data[i];\n}\n#else\nint clamped_col = min(2*dst_cols, col);\nfor (int i=0; i < ksY+1; i++)\n{\nint dx_selected_row = dx_startY+i, dx_selected_col = dx_startX+clamped_col;\nEXTRAPOLATE(dx_selected_row, dx_whole_rows)\nEXTRAPOLATE(dx_selected_col, dx_whole_cols)\ndx_data[i] = Dx[dx_selected_row * (dx_step>>2) + dx_selected_col];\nint dy_selected_row = dy_startY+i, dy_selected_col = dy_startX+clamped_col;\nEXTRAPOLATE(dy_selected_row, dy_whole_rows)\nEXTRAPOLATE(dy_selected_col, dy_whole_cols)\ndy_data[i] = Dy[dy_selected_row * (dy_step>>2) + dy_selected_col];\ndata[0][i] = dx_data[i] * dx_data[i];\ndata[1][i] = dx_data[i] * dy_data[i];\ndata[2][i] = dy_data[i] * dy_data[i];\n}\n#endif\nFPTYPE sum0 = 0.0f, sum1 = 0.0f, sum2 = 0.0f;\nfor (int i=1; i < ksY; i++)\n{\nsum0 += data[0][i];\nsum1 += data[1][i];\nsum2 += data[2][i];\n}\nFPTYPE sum01 = sum0 + data[0][0];\nFPTYPE sum02 = sum0 + data[0][ksY];\ntemp[0][col] = sum01;\ntemp[1][col] = sum02;\nFPTYPE sum11 = sum1 + data[1][0];\nFPTYPE sum12 = sum1 + data[1][ksY];\ntemp[2][col] = sum11;\ntemp[3][col] = sum12;\nFPTYPE sum21 = sum2 + data[2][0];\nFPTYPE sum22 = sum2 + data[2][ksY];\ntemp[4][col] = sum21;\ntemp[5][col] = sum22;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (col < (THREADS- (ksX - 1)))\n{\ncol += anX;\nint posX = dst_startX - dst_x_off + col - anX;\nint posY = (gly << 1);\nint till = (ksX + 1)%2;\nfloat tmp_sum[6] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };\nfor (int k=0; k<6; k++)\n{\nFPTYPE temp_sum = 0;\nfor (int i=-anX; i<=anX - till; i++)\n{\ntemp_sum += temp[k][col+i];\n}\ntmp_sum[k] = temp_sum;\n}\nif (posX < dst_cols && (posY) < dst_rows)\n{\ndst[(dst_startY+0) * (dst_step>>2)+ dst_startX + col - anX] =\ntmp_sum[0] * tmp_sum[4] - tmp_sum[2] * tmp_sum[2] - k * (tmp_sum[0] + tmp_sum[4]) * (tmp_sum[0] + tmp_sum[4]);\n}\nif (posX < dst_cols && (posY + 1) < dst_rows)\n{\ndst[(dst_startY+1) * (dst_step>>2)+ dst_startX + col - anX] =\ntmp_sum[1] * tmp_sum[5] - tmp_sum[3] * tmp_sum[3] - k * (tmp_sum[1] + tmp_sum[5]) * (tmp_sum[1] + tmp_sum[5]);\n}\n}\n}\n", "f2c0f92edc8f64eb31dc2f2034bc799f", "imgproc_bilateral", "__kernel void bilateral_C1_D0(__global uchar *dst,\n__global const uchar *src,\nconst int dst_rows,\nconst int dst_cols,\nconst int maxk,\nconst int radius,\nconst int dst_step,\nconst int dst_offset,\nconst int src_step,\nconst int src_rows,\nconst int src_cols,\n__constant float *color_weight,\n__constant float *space_weight,\n__constant int *space_ofs)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < dst_rows && x < dst_cols)\n{\nint src_index = mad24(y + radius, src_step, x + radius);\nint dst_index = mad24(y, dst_step, x + dst_offset);\nfloat sum = 0.f, wsum = 0.f;\nint val0 = (int)src[src_index];\nfor(int k = 0; k < maxk; k++ )\n{\nint val = (int)src[src_index + space_ofs[k]];\nfloat w = space_weight[k] * color_weight[abs(val - val0)];\nsum += (float)(val) * w;\nwsum += w;\n}\ndst[dst_index] = convert_uchar_rtz(sum / wsum + 0.5f);\n}\n}\n__kernel void bilateral2_C1_D0(__global uchar *dst,\n__global const uchar *src,\nconst int dst_rows,\nconst int dst_cols,\nconst int maxk,\nconst int radius,\nconst int dst_step,\nconst int dst_offset,\nconst int src_step,\nconst int src_rows,\nconst int src_cols,\n__constant float *color_weight,\n__constant float *space_weight,\n__constant int *space_ofs)\n{\nint x = get_global_id(0) << 2;\nint y = get_global_id(1);\nif (y < dst_rows && x < dst_cols)\n{\nint src_index = mad24(y + radius, src_step, x + radius);\nint dst_index = mad24(y, dst_step, x + dst_offset);\nfloat4 sum = (float4)(0.f), wsum = (float4)(0.f);\nint4 val0 = convert_int4(vload4(0,src + src_index));\nfor(int k = 0; k < maxk; k++ )\n{\nint4 val = convert_int4(vload4(0,src+src_index + space_ofs[k]));\nfloat4 w = (float4)(space_weight[k]) * (float4)(color_weight[abs(val.x - val0.x)], color_weight[abs(val.y - val0.y)],\ncolor_weight[abs(val.z - val0.z)], color_weight[abs(val.w - val0.w)]);\nsum += convert_float4(val) * w;\nwsum += w;\n}\n*(__global uchar4*)(dst+dst_index) = convert_uchar4_rtz(sum/wsum+0.5f);\n}\n}\n__kernel void bilateral_C4_D0(__global uchar4 *dst,\n__global const uchar4 *src,\nconst int dst_rows,\nconst int dst_cols,\nconst int maxk,\nconst int radius,\nconst int dst_step,\nconst int dst_offset,\nconst int src_step,\nconst int src_rows,\nconst int src_cols,\n__constant float *color_weight,\n__constant float *space_weight,\n__constant int *space_ofs)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < dst_rows && x < dst_cols)\n{\nint src_index = mad24(y + radius, src_step, x + radius);\nint dst_index = mad24(y, dst_step, x + dst_offset);\nfloat4 sum = (float4)0.f;\nfloat wsum = 0.f;\nint4 val0 = convert_int4(src[src_index]);\nfor(int k = 0; k < maxk; k++ )\n{\nint4 val = convert_int4(src[src_index + space_ofs[k]]);\nfloat w = space_weight[k] * color_weight[abs(val.x - val0.x) + abs(val.y - val0.y) + abs(val.z - val0.z)];\nsum += convert_float4(val) * (float4)w;\nwsum += w;\n}\nwsum = 1.f / wsum;\ndst[dst_index] = convert_uchar4_rtz(sum * (float4)wsum + (float4)0.5f);\n}\n}\n", "9b8b7d38ce4703393eef8505f1b2c7d3", "haarobjectdetect_scaled2", "#define CV_HAAR_FEATURE_MAX           3\ntypedef int   sumtype;\ntypedef float sqsumtype;\ntypedef struct __attribute__((aligned(128))) GpuHidHaarTreeNode\n{\nint p[CV_HAAR_FEATURE_MAX][4] __attribute__((aligned(64)));\nfloat weight[CV_HAAR_FEATURE_MAX] ;\nfloat threshold ;\nfloat alpha[3] __attribute__((aligned(16)));\nint left __attribute__((aligned(4)));\nint right __attribute__((aligned(4)));\n}\nGpuHidHaarTreeNode;\ntypedef struct __attribute__((aligned(32))) GpuHidHaarClassifier\n{\nint count __attribute__((aligned(4)));\nGpuHidHaarTreeNode *node __attribute__((aligned(8)));\nfloat *alpha __attribute__((aligned(8)));\n}\nGpuHidHaarClassifier;\ntypedef struct __attribute__((aligned(64))) GpuHidHaarStageClassifier\n{\nint  count __attribute__((aligned(4)));\nfloat threshold __attribute__((aligned(4)));\nint two_rects __attribute__((aligned(4)));\nint reserved0 __attribute__((aligned(8)));\nint reserved1 __attribute__((aligned(8)));\nint reserved2 __attribute__((aligned(8)));\nint reserved3 __attribute__((aligned(8)));\n}\nGpuHidHaarStageClassifier;\ntypedef struct __attribute__((aligned(64))) GpuHidHaarClassifierCascade\n{\nint  count __attribute__((aligned(4)));\nint  is_stump_based __attribute__((aligned(4)));\nint  has_tilted_features __attribute__((aligned(4)));\nint  is_tree __attribute__((aligned(4)));\nint pq0 __attribute__((aligned(4)));\nint pq1 __attribute__((aligned(4)));\nint pq2 __attribute__((aligned(4)));\nint pq3 __attribute__((aligned(4)));\nint p0 __attribute__((aligned(4)));\nint p1 __attribute__((aligned(4)));\nint p2 __attribute__((aligned(4)));\nint p3 __attribute__((aligned(4)));\nfloat inv_window_area __attribute__((aligned(4)));\n} GpuHidHaarClassifierCascade;\n__kernel void gpuRunHaarClassifierCascade_scaled2(\nglobal GpuHidHaarStageClassifier *stagecascadeptr,\nglobal int4 *info,\nglobal GpuHidHaarTreeNode *nodeptr,\nglobal const int *restrict sum,\nglobal const float   *restrict sqsum,\nglobal int4 *candidate,\nconst int rows,\nconst int cols,\nconst int step,\nconst int loopcount,\nconst int start_stage,\nconst int split_stage,\nconst int end_stage,\nconst int startnode,\nglobal int4 *p,\nglobal float *correction,\nconst int nodecount)\n{\nint grpszx = get_local_size(0);\nint grpszy = get_local_size(1);\nint grpnumx = get_num_groups(0);\nint grpidx = get_group_id(0);\nint lclidx = get_local_id(0);\nint lclidy = get_local_id(1);\nint lcl_id = mad24(lclidy, grpszx, lclidx);\n__local int glboutindex[1];\n__local int lclcount[1];\n__local int lcloutindex[64];\nglboutindex[0] = 0;\nint outputoff = mul24(grpidx, 256);\ncandidate[outputoff + (lcl_id << 2)] = (int4)0;\ncandidate[outputoff + (lcl_id << 2) + 1] = (int4)0;\ncandidate[outputoff + (lcl_id << 2) + 2] = (int4)0;\ncandidate[outputoff + (lcl_id << 2) + 3] = (int4)0;\nint max_idx = rows * cols - 1;\nfor (int scalei = 0; scalei < loopcount; scalei++)\n{\nint4 scaleinfo1;\nscaleinfo1 = info[scalei];\nint grpnumperline = (scaleinfo1.y & 0xffff0000) >> 16;\nint totalgrp = scaleinfo1.y & 0xffff;\nfloat factor = as_float(scaleinfo1.w);\nfloat correction_t = correction[scalei];\nfloat ystep = max(2.0f, factor);\nfor (int grploop = get_group_id(0); grploop < totalgrp; grploop += grpnumx)\n{\nint4 cascadeinfo = p[scalei];\nint grpidy = grploop / grpnumperline;\nint grpidx = grploop - mul24(grpidy, grpnumperline);\nint ix = mad24(grpidx, grpszx, lclidx);\nint iy = mad24(grpidy, grpszy, lclidy);\nint x = round(ix * ystep);\nint y = round(iy * ystep);\nlcloutindex[lcl_id] = 0;\nlclcount[0] = 0;\nint nodecounter;\nfloat mean, variance_norm_factor;\n{\nconst int p_offset = mad24(y, step, x);\ncascadeinfo.x += p_offset;\ncascadeinfo.z += p_offset;\nmean = (sum[clamp(mad24(cascadeinfo.y, step, cascadeinfo.x), 0, max_idx)]\n- sum[clamp(mad24(cascadeinfo.y, step, cascadeinfo.z), 0, max_idx)] -\nsum[clamp(mad24(cascadeinfo.w, step, cascadeinfo.x), 0, max_idx)]\n+ sum[clamp(mad24(cascadeinfo.w, step, cascadeinfo.z), 0, max_idx)])\n* correction_t;\nvariance_norm_factor = sqsum[clamp(mad24(cascadeinfo.y, step, cascadeinfo.x), 0, max_idx)]\n- sqsum[clamp(mad24(cascadeinfo.y, step, cascadeinfo.z), 0, max_idx)] -\nsqsum[clamp(mad24(cascadeinfo.w, step, cascadeinfo.x), 0, max_idx)]\n+ sqsum[clamp(mad24(cascadeinfo.w, step, cascadeinfo.z), 0, max_idx)];\nvariance_norm_factor = variance_norm_factor * correction_t - mean * mean;\nvariance_norm_factor = variance_norm_factor >= 0.f ? sqrt(variance_norm_factor) : 1.f;\nbool result = true;\nnodecounter = startnode + nodecount * scalei;\nfor (int stageloop = start_stage; (stageloop < end_stage) && result; stageloop++)\n{\nfloat stage_sum = 0.f;\nint   stagecount = stagecascadeptr[stageloop].count;\nfor (int nodeloop = 0; nodeloop < stagecount;)\n{\n__global GpuHidHaarTreeNode *currentnodeptr = (nodeptr + nodecounter);\nint4 info1 = *(__global int4 *)(&(currentnodeptr->p[0][0]));\nint4 info2 = *(__global int4 *)(&(currentnodeptr->p[1][0]));\nint4 info3 = *(__global int4 *)(&(currentnodeptr->p[2][0]));\nfloat4 w = *(__global float4 *)(&(currentnodeptr->weight[0]));\nfloat3 alpha3 = *(__global float3 *)(&(currentnodeptr->alpha[0]));\nfloat nodethreshold  = w.w * variance_norm_factor;\ninfo1.x += p_offset;\ninfo1.z += p_offset;\ninfo2.x += p_offset;\ninfo2.z += p_offset;\ninfo3.x += p_offset;\ninfo3.z += p_offset;\nfloat classsum = (sum[clamp(mad24(info1.y, step, info1.x), 0, max_idx)]\n- sum[clamp(mad24(info1.y, step, info1.z), 0, max_idx)] -\nsum[clamp(mad24(info1.w, step, info1.x), 0, max_idx)]\n+ sum[clamp(mad24(info1.w, step, info1.z), 0, max_idx)]) * w.x;\nclasssum += (sum[clamp(mad24(info2.y, step, info2.x), 0, max_idx)]\n- sum[clamp(mad24(info2.y, step, info2.z), 0, max_idx)] -\nsum[clamp(mad24(info2.w, step, info2.x), 0, max_idx)]\n+ sum[clamp(mad24(info2.w, step, info2.z), 0, max_idx)]) * w.y;\nclasssum += (sum[clamp(mad24(info3.y, step, info3.x), 0, max_idx)]\n- sum[clamp(mad24(info3.y, step, info3.z), 0, max_idx)] -\nsum[clamp(mad24(info3.w, step, info3.x), 0, max_idx)]\n+ sum[clamp(mad24(info3.w, step, info3.z), 0, max_idx)]) * w.z;\nbool passThres = classsum >= nodethreshold;\n#if STUMP_BASED\nstage_sum += passThres ? alpha3.y : alpha3.x;\nnodecounter++;\nnodeloop++;\n#else\nbool isRootNode = (nodecounter & 1) == 0;\nif(isRootNode)\n{\nif( (passThres && currentnodeptr->right) ||\n(!passThres && currentnodeptr->left))\n{\nnodecounter ++;\n}\nelse\n{\nstage_sum += alpha3.x;\nnodecounter += 2;\nnodeloop ++;\n}\n}\nelse\n{\nstage_sum += (passThres ? alpha3.z : alpha3.y);\nnodecounter ++;\nnodeloop ++;\n}\n#endif\n}\nresult = (int)(stage_sum >= stagecascadeptr[stageloop].threshold);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (result)\n{\nint queueindex = atomic_inc(lclcount);\nlcloutindex[queueindex] = (y << 16) | x;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint queuecount = lclcount[0];\nif (lcl_id < queuecount)\n{\nint temp = lcloutindex[lcl_id];\nint x = temp & 0xffff;\nint y = (temp & (int)0xffff0000) >> 16;\ntemp = atomic_inc(glboutindex);\nint4 candidate_result;\ncandidate_result.zw = (int2)convert_int_rte(factor * 20.f);\ncandidate_result.x = x;\ncandidate_result.y = y;\nint i = outputoff+temp+lcl_id;\nif(candidate[i].z == 0)\n{\ncandidate[i] = candidate_result;\n}\nelse\n{\nfor(i=i+1;;i++)\n{\nif(candidate[i].z == 0)\n{\ncandidate[i] = candidate_result;\nbreak;\n}\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\n}\n}\n__kernel void gpuscaleclassifier(global GpuHidHaarTreeNode *orinode, global GpuHidHaarTreeNode *newnode, float scale, float weight_scale, int nodenum)\n{\nint counter = get_global_id(0);\nint tr_x[3], tr_y[3], tr_h[3], tr_w[3], i = 0;\nGpuHidHaarTreeNode t1 = *(orinode + counter);\n#pragma unroll\nfor (i = 0; i < 3; i++)\n{\ntr_x[i] = (int)(t1.p[i][0] * scale + 0.5f);\ntr_y[i] = (int)(t1.p[i][1] * scale + 0.5f);\ntr_w[i] = (int)(t1.p[i][2] * scale + 0.5f);\ntr_h[i] = (int)(t1.p[i][3] * scale + 0.5f);\n}\nt1.weight[0] = -(t1.weight[1] * tr_h[1] * tr_w[1] + t1.weight[2] * tr_h[2] * tr_w[2]) / (tr_h[0] * tr_w[0]);\ncounter += nodenum;\n#pragma unroll\nfor (i = 0; i < 3; i++)\n{\nnewnode[counter].p[i][0] = tr_x[i];\nnewnode[counter].p[i][1] = tr_y[i];\nnewnode[counter].p[i][2] = tr_x[i] + tr_w[i];\nnewnode[counter].p[i][3] = tr_y[i] + tr_h[i];\nnewnode[counter].weight[i] = t1.weight[i] * weight_scale;\n}\nnewnode[counter].left = t1.left;\nnewnode[counter].right = t1.right;\nnewnode[counter].threshold = t1.threshold;\nnewnode[counter].alpha[0] = t1.alpha[0];\nnewnode[counter].alpha[1] = t1.alpha[1];\nnewnode[counter].alpha[2] = t1.alpha[2];\n}\n", "37a0dce47f004dc26ec48a141c200e2d", "haarobjectdetect", "#define CV_HAAR_FEATURE_MAX           3\n#define calc_sum(rect,offset)        (sum[(rect).p0+offset] - sum[(rect).p1+offset] - sum[(rect).p2+offset] + sum[(rect).p3+offset])\n#define calc_sum1(rect,offset,i)     (sum[(rect).p0[i]+offset] - sum[(rect).p1[i]+offset] - sum[(rect).p2[i]+offset] + sum[(rect).p3[i]+offset])\ntypedef int   sumtype;\ntypedef float sqsumtype;\n#ifndef STUMP_BASED\n#define STUMP_BASED 1\n#endif\ntypedef struct __attribute__((aligned (128) )) GpuHidHaarTreeNode\n{\nint p[CV_HAAR_FEATURE_MAX][4] __attribute__((aligned (64)));\nfloat weight[CV_HAAR_FEATURE_MAX];\nfloat threshold;\nfloat alpha[3] __attribute__((aligned (16)));\nint left __attribute__((aligned (4)));\nint right __attribute__((aligned (4)));\n}\nGpuHidHaarTreeNode;\ntypedef struct __attribute__((aligned (32))) GpuHidHaarClassifier\n{\nint count __attribute__((aligned (4)));\nGpuHidHaarTreeNode* node __attribute__((aligned (8)));\nfloat* alpha __attribute__((aligned (8)));\n}\nGpuHidHaarClassifier;\ntypedef struct __attribute__((aligned (64))) GpuHidHaarStageClassifier\n{\nint  count __attribute__((aligned (4)));\nfloat threshold __attribute__((aligned (4)));\nint two_rects __attribute__((aligned (4)));\nint reserved0 __attribute__((aligned (8)));\nint reserved1 __attribute__((aligned (8)));\nint reserved2 __attribute__((aligned (8)));\nint reserved3 __attribute__((aligned (8)));\n}\nGpuHidHaarStageClassifier;\ntypedef struct __attribute__((aligned (64))) GpuHidHaarClassifierCascade\n{\nint  count __attribute__((aligned (4)));\nint  is_stump_based __attribute__((aligned (4)));\nint  has_tilted_features __attribute__((aligned (4)));\nint  is_tree __attribute__((aligned (4)));\nint pq0 __attribute__((aligned (4)));\nint pq1 __attribute__((aligned (4)));\nint pq2 __attribute__((aligned (4)));\nint pq3 __attribute__((aligned (4)));\nint p0 __attribute__((aligned (4)));\nint p1 __attribute__((aligned (4)));\nint p2 __attribute__((aligned (4)));\nint p3 __attribute__((aligned (4)));\nfloat inv_window_area __attribute__((aligned (4)));\n} GpuHidHaarClassifierCascade;\n#ifdef PACKED_CLASSIFIER\n__kernel void gpuRunHaarClassifierCascadePacked(\nglobal const GpuHidHaarStageClassifier * stagecascadeptr,\nglobal const int4 * info,\nglobal const GpuHidHaarTreeNode * nodeptr,\nglobal const int * restrict sum,\nglobal const float * restrict sqsum,\nvolatile global int4 * candidate,\nconst int pixelstep,\nconst int loopcount,\nconst int start_stage,\nconst int split_stage,\nconst int end_stage,\nconst int startnode,\nconst int splitnode,\nconst int4 p,\nconst int4 pq,\nconst float correction,\nglobal const int* pNodesPK,\nglobal const int4* pWGInfo\n)\n{\nint     gid = (int)get_group_id(0);\nint     lid_x = (int)get_local_id(0);\nint     lid_y = (int)get_local_id(1);\nint     lid = lid_y*LSx+lid_x;\nint4    WGInfo = pWGInfo[WGSTART+gid];\nint     GroupX = (WGInfo.y >> 16)&0xFFFF;\nint     GroupY = (WGInfo.y >> 0 )& 0xFFFF;\nint     Width  = (WGInfo.x >> 16)&0xFFFF;\nint     Height = (WGInfo.x >> 0 )& 0xFFFF;\nint     ImgOffset = WGInfo.z;\nfloat   ScaleFactor = as_float(WGInfo.w);\n#define DATA_SIZE_X (PIXEL_STEP*LSx+WND_SIZE_X)\n#define DATA_SIZE_Y (PIXEL_STEP*LSy+WND_SIZE_Y)\n#define DATA_SIZE (DATA_SIZE_X*DATA_SIZE_Y)\nlocal int SumL[DATA_SIZE];\nfor(int i = 0; i<DATA_SIZE; i+=(LSx*LSy))\n{\nint     index = i+lid;\nif(index<DATA_SIZE)\n{\nint     x = min(GroupX + (index % (DATA_SIZE_X)),Width-1+WND_SIZE_X);\nint     y = min(GroupY + (index / (DATA_SIZE_X)),Height-1+WND_SIZE_Y);\nSumL[index] = sum[ImgOffset+y*pixelstep+x];\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat   variance_norm_factor;\nint     nodecounter= startnode;\nint4    info1 = p;\nint4    info2 = pq;\nint     xl = lid_x*PIXEL_STEP;\nint     yl = lid_y*PIXEL_STEP;\n{\nint     OffsetLocal =          yl * DATA_SIZE_X +         xl;\nint     OffsetGlobal = (GroupY+yl)* pixelstep   + (GroupX+xl);\nOffsetGlobal += ImgOffset;\nfloat   mean =\nSumL[info1.y*DATA_SIZE_X+info1.x+OffsetLocal] -\nSumL[info1.y*DATA_SIZE_X+info1.z+OffsetLocal] -\nSumL[info1.w*DATA_SIZE_X+info1.x+OffsetLocal] +\nSumL[info1.w*DATA_SIZE_X+info1.z+OffsetLocal];\nfloat sq =\nsqsum[info2.y*pixelstep+info2.x+OffsetGlobal] -\nsqsum[info2.y*pixelstep+info2.z+OffsetGlobal] -\nsqsum[info2.w*pixelstep+info2.x+OffsetGlobal] +\nsqsum[info2.w*pixelstep+info2.z+OffsetGlobal];\nmean *= correction;\nsq *= correction;\nvariance_norm_factor = sq - mean * mean;\nvariance_norm_factor = (variance_norm_factor >=0.f) ? sqrt(variance_norm_factor) : 1.f;\n}\nint result = (1.0f>0.0f);\nfor(int stageloop = start_stage; (stageloop < end_stage) && result; stageloop++ )\n{\nfloat   stage_sum = 0.0f;\nint2    stageinfo = *(global int2*)(stagecascadeptr+stageloop);\nfloat   stagethreshold = as_float(stageinfo.y);\nint     lcl_off = (lid_y*DATA_SIZE_X)+(lid_x);\nfor(int nodeloop = 0; nodeloop < stageinfo.x; nodecounter++,nodeloop++ )\n{\n#define M0(_t) ((_t)&0xFFFF)\n#define M1(_t) (((_t)>>16)&0xFFFF)\nglobal const int4* pN = (__global int4*)(pNodesPK+nodecounter*NODE_SIZE);\nint4    n0 = pN[0];\nint4    n1 = pN[1];\nint4    n2 = pN[2];\nfloat   nodethreshold  = as_float(n2.y) * variance_norm_factor;\nfloat classsum =\n(SumL[M0(n0.x)+lcl_off] - SumL[M1(n0.x)+lcl_off] - SumL[M0(n0.y)+lcl_off] + SumL[M1(n0.y)+lcl_off]) * as_float(n1.z) +\n(SumL[M0(n0.z)+lcl_off] - SumL[M1(n0.z)+lcl_off] - SumL[M0(n0.w)+lcl_off] + SumL[M1(n0.w)+lcl_off]) * as_float(n1.w) +\n(SumL[M0(n1.x)+lcl_off] - SumL[M1(n1.x)+lcl_off] - SumL[M0(n1.y)+lcl_off] + SumL[M1(n1.y)+lcl_off]) * as_float(n2.x);\nstage_sum += (classsum >= nodethreshold) ? as_float(n2.w) : as_float(n2.z);\n}\nresult = (stage_sum >= stagethreshold);\n}\nif(result)\n{\nint index = 1+atomic_inc((volatile global int*)candidate);\nif(index<OUTPUTSZ)\n{\nint     x = GroupX+xl;\nint     y = GroupY+yl;\nint4 candidate_result;\ncandidate_result.x = convert_int_rtn(x*ScaleFactor);\ncandidate_result.y = convert_int_rtn(y*ScaleFactor);\ncandidate_result.z = convert_int_rtn(ScaleFactor*WND_SIZE_X);\ncandidate_result.w = convert_int_rtn(ScaleFactor*WND_SIZE_Y);\ncandidate[index] = candidate_result;\n}\n}\n}\n#else\n__kernel void __attribute__((reqd_work_group_size(8,8,1)))gpuRunHaarClassifierCascade(\nglobal GpuHidHaarStageClassifier * stagecascadeptr,\nglobal int4 * info,\nglobal GpuHidHaarTreeNode * nodeptr,\nglobal const int * restrict sum1,\nglobal const float * restrict sqsum1,\nglobal int4 * candidate,\nconst int pixelstep,\nconst int loopcount,\nconst int start_stage,\nconst int split_stage,\nconst int end_stage,\nconst int startnode,\nconst int splitnode,\nconst int4 p,\nconst int4 pq,\nconst float correction)\n{\nint grpszx = get_local_size(0);\nint grpszy = get_local_size(1);\nint grpnumx = get_num_groups(0);\nint grpidx = get_group_id(0);\nint lclidx = get_local_id(0);\nint lclidy = get_local_id(1);\nint lcl_sz = mul24(grpszx,grpszy);\nint lcl_id = mad24(lclidy,grpszx,lclidx);\n__local int lclshare[1024];\n__local int* lcldata = lclshare;\n__local int* glboutindex = lcldata + 28*28;\n__local int* lclcount = glboutindex + 1;\n__local int* lcloutindex = lclcount + 1;\n__local float* partialsum = (__local float*)(lcloutindex + (lcl_sz<<1));\nglboutindex[0]=0;\nint outputoff = mul24(grpidx,256);\n#define WINDOWSIZE 20+1\nint readwidth = ((grpszx-1 + WINDOWSIZE+3)>>2)<<2;\nint readheight = grpszy-1+WINDOWSIZE;\nint read_horiz_cnt = readwidth >> 2;\nint total_read = mul24(read_horiz_cnt,readheight);\nint read_loop = (total_read + lcl_sz - 1) >> 6;\ncandidate[outputoff+(lcl_id<<2)] = (int4)0;\ncandidate[outputoff+(lcl_id<<2)+1] = (int4)0;\ncandidate[outputoff+(lcl_id<<2)+2] = (int4)0;\ncandidate[outputoff+(lcl_id<<2)+3] = (int4)0;\nfor(int scalei = 0; scalei <loopcount; scalei++)\n{\nint4 scaleinfo1= info[scalei];\nint height = scaleinfo1.x & 0xffff;\nint grpnumperline =(scaleinfo1.y & 0xffff0000) >> 16;\nint totalgrp = scaleinfo1.y & 0xffff;\nint imgoff = scaleinfo1.z;\nfloat factor = as_float(scaleinfo1.w);\n__global const int * sum = sum1 + imgoff;\n__global const float * sqsum = sqsum1 + imgoff;\nfor(int grploop=grpidx; grploop<totalgrp; grploop+=grpnumx)\n{\nint grpidy = grploop / grpnumperline;\nint grpidx = grploop - mul24(grpidy, grpnumperline);\nint x = mad24(grpidx,grpszx,lclidx);\nint y = mad24(grpidy,grpszy,lclidy);\nint grpoffx = x-lclidx;\nint grpoffy = y-lclidy;\nfor(int i=0; i<read_loop; i++)\n{\nint pos_id = mad24(i,lcl_sz,lcl_id);\npos_id = pos_id < total_read ? pos_id : 0;\nint lcl_y = pos_id / read_horiz_cnt;\nint lcl_x = pos_id - mul24(lcl_y, read_horiz_cnt);\nint glb_x = grpoffx + (lcl_x<<2);\nint glb_y = grpoffy + lcl_y;\nint glb_off = mad24(min(glb_y, height + WINDOWSIZE - 1),pixelstep,glb_x);\nint4 data = *(__global int4*)&sum[glb_off];\nint lcl_off = mad24(lcl_y, readwidth, lcl_x<<2);\nvstore4(data, 0, &lcldata[lcl_off]);\n}\nlcloutindex[lcl_id] = 0;\nlclcount[0] = 0;\nint result = 1;\nint nodecounter= startnode;\nfloat mean, variance_norm_factor;\nbarrier(CLK_LOCAL_MEM_FENCE);\nint lcl_off = mad24(lclidy,readwidth,lclidx);\nint4 cascadeinfo1, cascadeinfo2;\ncascadeinfo1 = p;\ncascadeinfo2 = pq;\ncascadeinfo1.x +=lcl_off;\ncascadeinfo1.z +=lcl_off;\nmean = (lcldata[mad24(cascadeinfo1.y,readwidth,cascadeinfo1.x)] - lcldata[mad24(cascadeinfo1.y,readwidth,cascadeinfo1.z)] -\nlcldata[mad24(cascadeinfo1.w,readwidth,cascadeinfo1.x)] + lcldata[mad24(cascadeinfo1.w,readwidth,cascadeinfo1.z)])\n*correction;\nint p_offset = mad24(y, pixelstep, x);\ncascadeinfo2.x +=p_offset;\ncascadeinfo2.z +=p_offset;\nvariance_norm_factor =sqsum[mad24(cascadeinfo2.y, pixelstep, cascadeinfo2.x)] - sqsum[mad24(cascadeinfo2.y, pixelstep, cascadeinfo2.z)] -\nsqsum[mad24(cascadeinfo2.w, pixelstep, cascadeinfo2.x)] + sqsum[mad24(cascadeinfo2.w, pixelstep, cascadeinfo2.z)];\nvariance_norm_factor = variance_norm_factor * correction - mean * mean;\nvariance_norm_factor = variance_norm_factor >=0.f ? sqrt(variance_norm_factor) : 1.f;\nfor(int stageloop = start_stage; (stageloop < split_stage)  && result; stageloop++ )\n{\nfloat stage_sum = 0.f;\nint2 stageinfo = *(global int2*)(stagecascadeptr+stageloop);\nfloat stagethreshold = as_float(stageinfo.y);\nfor(int nodeloop = 0; nodeloop < stageinfo.x; )\n{\n__global GpuHidHaarTreeNode* currentnodeptr = (nodeptr + nodecounter);\nint4 info1 = *(__global int4*)(&(currentnodeptr->p[0][0]));\nint4 info2 = *(__global int4*)(&(currentnodeptr->p[1][0]));\nint4 info3 = *(__global int4*)(&(currentnodeptr->p[2][0]));\nfloat4 w = *(__global float4*)(&(currentnodeptr->weight[0]));\nfloat3 alpha3 = *(__global float3*)(&(currentnodeptr->alpha[0]));\nfloat nodethreshold  = w.w * variance_norm_factor;\ninfo1.x +=lcl_off;\ninfo1.z +=lcl_off;\ninfo2.x +=lcl_off;\ninfo2.z +=lcl_off;\nfloat classsum = (lcldata[mad24(info1.y,readwidth,info1.x)] - lcldata[mad24(info1.y,readwidth,info1.z)] -\nlcldata[mad24(info1.w,readwidth,info1.x)] + lcldata[mad24(info1.w,readwidth,info1.z)]) * w.x;\nclasssum += (lcldata[mad24(info2.y,readwidth,info2.x)] - lcldata[mad24(info2.y,readwidth,info2.z)] -\nlcldata[mad24(info2.w,readwidth,info2.x)] + lcldata[mad24(info2.w,readwidth,info2.z)]) * w.y;\ninfo3.x +=lcl_off;\ninfo3.z +=lcl_off;\nclasssum += (lcldata[mad24(info3.y,readwidth,info3.x)] - lcldata[mad24(info3.y,readwidth,info3.z)] -\nlcldata[mad24(info3.w,readwidth,info3.x)] + lcldata[mad24(info3.w,readwidth,info3.z)]) * w.z;\nbool passThres = classsum >= nodethreshold;\n#if STUMP_BASED\nstage_sum += passThres ? alpha3.y : alpha3.x;\nnodecounter++;\nnodeloop++;\n#else\nbool isRootNode = (nodecounter & 1) == 0;\nif(isRootNode)\n{\nif( (passThres && currentnodeptr->right) ||\n(!passThres && currentnodeptr->left))\n{\nnodecounter ++;\n}\nelse\n{\nstage_sum += alpha3.x;\nnodecounter += 2;\nnodeloop ++;\n}\n}\nelse\n{\nstage_sum += passThres ? alpha3.z : alpha3.y;\nnodecounter ++;\nnodeloop ++;\n}\n#endif\n}\nresult = (stage_sum >= stagethreshold);\n}\nif(factor < 2)\n{\nif(result && lclidx %2 ==0 && lclidy %2 ==0 )\n{\nint queueindex = atomic_inc(lclcount);\nlcloutindex[queueindex<<1] = (lclidy << 16) | lclidx;\nlcloutindex[(queueindex<<1)+1] = as_int((float)variance_norm_factor);\n}\n}\nelse\n{\nif(result)\n{\nint queueindex = atomic_inc(lclcount);\nlcloutindex[queueindex<<1] = (lclidy << 16) | lclidx;\nlcloutindex[(queueindex<<1)+1] = as_int((float)variance_norm_factor);\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nint queuecount  = lclcount[0];\nbarrier(CLK_LOCAL_MEM_FENCE);\nnodecounter = splitnode;\nfor(int stageloop = split_stage; stageloop< end_stage && queuecount>0; stageloop++)\n{\nlclcount[0]=0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nint2 stageinfo = *(global int2*)(stagecascadeptr+stageloop);\nfloat stagethreshold = as_float(stageinfo.y);\nint perfscale = queuecount > 4 ? 3 : 2;\nint queuecount_loop = (queuecount + (1<<perfscale)-1) >> perfscale;\nint lcl_compute_win = lcl_sz >> perfscale;\nint lcl_compute_win_id = (lcl_id >>(6-perfscale));\nint lcl_loops = (stageinfo.x + lcl_compute_win -1) >> (6-perfscale);\nint lcl_compute_id = lcl_id - (lcl_compute_win_id << (6-perfscale));\nfor(int queueloop=0; queueloop<queuecount_loop; queueloop++)\n{\nfloat stage_sum = 0.f;\nint temp_coord = lcloutindex[lcl_compute_win_id<<1];\nfloat variance_norm_factor = as_float(lcloutindex[(lcl_compute_win_id<<1)+1]);\nint queue_pixel = mad24(((temp_coord  & (int)0xffff0000)>>16),readwidth,temp_coord & 0xffff);\nif(lcl_compute_win_id < queuecount)\n{\nint tempnodecounter = lcl_compute_id;\nfloat part_sum = 0.f;\nconst int stump_factor = STUMP_BASED ? 1 : 2;\nint root_offset = 0;\nfor(int lcl_loop=0; lcl_loop<lcl_loops && tempnodecounter<stageinfo.x;)\n{\n__global GpuHidHaarTreeNode* currentnodeptr =\nnodeptr + (nodecounter + tempnodecounter) * stump_factor + root_offset;\nint4 info1 = *(__global int4*)(&(currentnodeptr->p[0][0]));\nint4 info2 = *(__global int4*)(&(currentnodeptr->p[1][0]));\nint4 info3 = *(__global int4*)(&(currentnodeptr->p[2][0]));\nfloat4 w = *(__global float4*)(&(currentnodeptr->weight[0]));\nfloat3 alpha3 = *(__global float3*)(&(currentnodeptr->alpha[0]));\nfloat nodethreshold  = w.w * variance_norm_factor;\ninfo1.x +=queue_pixel;\ninfo1.z +=queue_pixel;\ninfo2.x +=queue_pixel;\ninfo2.z +=queue_pixel;\nfloat classsum = (lcldata[mad24(info1.y,readwidth,info1.x)] - lcldata[mad24(info1.y,readwidth,info1.z)] -\nlcldata[mad24(info1.w,readwidth,info1.x)] + lcldata[mad24(info1.w,readwidth,info1.z)]) * w.x;\nclasssum += (lcldata[mad24(info2.y,readwidth,info2.x)] - lcldata[mad24(info2.y,readwidth,info2.z)] -\nlcldata[mad24(info2.w,readwidth,info2.x)] + lcldata[mad24(info2.w,readwidth,info2.z)]) * w.y;\ninfo3.x +=queue_pixel;\ninfo3.z +=queue_pixel;\nclasssum += (lcldata[mad24(info3.y,readwidth,info3.x)] - lcldata[mad24(info3.y,readwidth,info3.z)] -\nlcldata[mad24(info3.w,readwidth,info3.x)] + lcldata[mad24(info3.w,readwidth,info3.z)]) * w.z;\nbool passThres = classsum >= nodethreshold;\n#if STUMP_BASED\npart_sum += passThres ? alpha3.y : alpha3.x;\ntempnodecounter += lcl_compute_win;\nlcl_loop++;\n#else\nif(root_offset == 0)\n{\nif( (passThres && currentnodeptr->right) ||\n(!passThres && currentnodeptr->left))\n{\nroot_offset = 1;\n}\nelse\n{\npart_sum += alpha3.x;\ntempnodecounter += lcl_compute_win;\nlcl_loop++;\n}\n}\nelse\n{\npart_sum += passThres ? alpha3.z : alpha3.y;\ntempnodecounter += lcl_compute_win;\nlcl_loop++;\nroot_offset = 0;\n}\n#endif\n}\npartialsum[lcl_id]=part_sum;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lcl_compute_win_id < queuecount)\n{\nfor(int i=0; i<lcl_compute_win && (lcl_compute_id==0); i++)\n{\nstage_sum += partialsum[lcl_id+i];\n}\nif(stage_sum >= stagethreshold && (lcl_compute_id==0))\n{\nint queueindex = atomic_inc(lclcount);\nlcloutindex[queueindex<<1] = temp_coord;\nlcloutindex[(queueindex<<1)+1] = as_int(variance_norm_factor);\n}\nlcl_compute_win_id +=(1<<perfscale);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nqueuecount = lclcount[0];\nbarrier(CLK_LOCAL_MEM_FENCE);\nnodecounter += stageinfo.x;\n}\nif(lcl_id<queuecount)\n{\nint temp = lcloutindex[lcl_id<<1];\nint x = mad24(grpidx,grpszx,temp & 0xffff);\nint y = mad24(grpidy,grpszy,((temp & (int)0xffff0000) >> 16));\ntemp = glboutindex[0];\nint4 candidate_result;\ncandidate_result.zw = (int2)convert_int_rte(factor*20.f);\ncandidate_result.x = convert_int_rte(x*factor);\ncandidate_result.y = convert_int_rte(y*factor);\natomic_inc(glboutindex);\nint i = outputoff+temp+lcl_id;\nif(candidate[i].z == 0)\n{\ncandidate[i] = candidate_result;\n}\nelse\n{\nfor(i=i+1;;i++)\n{\nif(candidate[i].z == 0)\n{\ncandidate[i] = candidate_result;\nbreak;\n}\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\n}\n}\n#endif\n", "590337901df52f2d5c88385fa212f8b5", "filtering_sep_filter_singlepass", "#ifdef BORDER_CONSTANT\n#define EXTRAPOLATE(x, maxV)\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = max(min((x), (maxV) - 1), 0); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = ( (x) + (maxV) ) % (maxV); \\\n}\n#elif defined BORDER_REFLECT\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = min(((maxV)-1)*2-(x)+1, max((x),-(x)-1) ); \\\n}\n#elif defined BORDER_REFLECT_101\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\n(x) = min(((maxV)-1)*2-(x), max((x),-(x)) ); \\\n}\n#else\n#error No extrapolation method\n#endif\n#define SRC(_x,_y) CONVERT_SRCTYPE(((global SRCTYPE*)(Src+(_y)*SrcPitch))[_x])\n#ifdef BORDER_CONSTANT\n#define ELEM(_x,_y,r_edge,t_edge,const_v) (_x)<0 | (_x) >= (r_edge) | (_y)<0 | (_y) >= (t_edge) ? (const_v) : SRC((_x),(_y))\n#else\n#define ELEM(_x,_y,r_edge,t_edge,const_v) SRC((_x),(_y))\n#endif\n#define DST(_x,_y) (((global DSTTYPE*)(Dst+DstOffset+(_y)*DstPitch))[_x])\n#define DIG(a) a,\n__constant uint mat_kernelX[] = {KERNEL_MATRIX_X};\n__constant uint mat_kernelY[] = {KERNEL_MATRIX_Y};\n__kernel __attribute__((reqd_work_group_size(BLK_X,BLK_Y,1))) void sep_filter_singlepass\n(\n__global uchar* Src,\nconst uint      SrcPitch,\nconst int       srcOffsetX,\nconst int       srcOffsetY,\n__global uchar* Dst,\nconst int       DstOffset,\nconst uint      DstPitch,\nint             width,\nint             height,\nint             dstWidth,\nint             dstHeight\n)\n{\n__local WORKTYPE lsmem[BLK_Y+2*RADIUSY][BLK_X+2*RADIUSX];\n__local WORKTYPE lsmemDy[BLK_Y][BLK_X+2*RADIUSX];\nint lix = get_local_id(0);\nint liy = get_local_id(1);\nint x = (int)get_global_id(0);\nint y = (int)get_global_id(1);\nint srcX = x + srcOffsetX - RADIUSX;\nint srcY = y + srcOffsetY - RADIUSY;\nint xb = srcX;\nint yb = srcY;\nint clocY = liy;\nint cSrcY = srcY;\ndo\n{\nint yb = cSrcY;\nEXTRAPOLATE(yb, (height));\nint clocX = lix;\nint cSrcX = srcX;\ndo\n{\nint xb = cSrcX;\nEXTRAPOLATE(xb,(width));\nlsmem[clocY][clocX] = ELEM(xb, yb, (width), (height), 0 );\nclocX += BLK_X;\ncSrcX += BLK_X;\n}\nwhile(clocX < BLK_X+(RADIUSX*2));\nclocY += BLK_Y;\ncSrcY += BLK_Y;\n}\nwhile(clocY < BLK_Y+(RADIUSY*2));\nbarrier(CLK_LOCAL_MEM_FENCE);\nint i;\nWORKTYPE sum = 0.0f;\nint clocX = lix;\ndo\n{\nsum = 0.0f;\nfor(i=0; i<=2*RADIUSY; i++)\nsum = mad(lsmem[liy+i][clocX], as_float(mat_kernelY[i]), sum);\nlsmemDy[liy][clocX] = sum;\nclocX += BLK_X;\n}\nwhile(clocX < BLK_X+(RADIUSX*2));\nbarrier(CLK_LOCAL_MEM_FENCE);\nif( x >= dstWidth || y >=dstHeight )  return;\nsum = 0.0f;\nfor(i=0; i<=2*RADIUSX; i++)\nsum = mad(lsmemDy[liy][lix+i], as_float(mat_kernelX[i]), sum);\nDST(x,y) = CONVERT_DSTTYPE(sum);\n}\n", "f48a37bd2a76b2d14666ef7fc1f6d88e", "filtering_morph", "#ifdef ERODE\n#define MORPH_OP(A,B) min((A),(B))\n#endif\n#ifdef DILATE\n#define MORPH_OP(A,B) max((A),(B))\n#endif\n#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n#ifndef GENTYPE\n__kernel void morph_C1_D0(__global const uchar * restrict src,\n__global uchar *dst,\nint src_offset_x, int src_offset_y,\nint cols, int rows,\nint src_step_in_pixel, int dst_step_in_pixel,\n__constant uchar * mat_kernel,\nint src_whole_cols, int src_whole_rows,\nint dst_offset_in_pixel)\n{\nint l_x = get_local_id(0);\nint l_y = get_local_id(1);\nint x = get_group_id(0)*4*LSIZE0;\nint y = get_group_id(1)*LSIZE1;\nint start_x = x+src_offset_x-RADIUSX & 0xfffffffc;\nint end_x = x + src_offset_x+LSIZE0*4+RADIUSX & 0xfffffffc;\nint width = (end_x -start_x+4)>>2;\nint offset = src_offset_x-RADIUSX & 3;\nint start_y = y+src_offset_y-RADIUSY;\nint point1 = mad24(l_y,LSIZE0,l_x);\nint point2 = point1 + LSIZE0*LSIZE1;\nint tl_x = (point1 % width)<<2;\nint tl_y = point1 / width;\nint tl_x2 = (point2 % width)<<2;\nint tl_y2 = point2 / width;\nint cur_x = start_x + tl_x;\nint cur_y = start_y + tl_y;\nint cur_x2 = start_x + tl_x2;\nint cur_y2 = start_y + tl_y2;\nint start_addr = mad24(cur_y,src_step_in_pixel,cur_x);\nint start_addr2 = mad24(cur_y2,src_step_in_pixel,cur_x2);\nuchar4 temp0,temp1;\n__local uchar4 LDS_DAT[2*LSIZE1*LSIZE0];\nint end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\nstart_addr = ((start_addr < end_addr) && (start_addr > 0)) ? start_addr : 0;\nstart_addr2 = ((start_addr2 < end_addr) && (start_addr2 > 0)) ? start_addr2 : 0;\ntemp0 = *(__global uchar4*)&src[start_addr];\ntemp1 = *(__global uchar4*)&src[start_addr2];\ntemp0.x= ELEM(cur_x,0,src_whole_cols,VAL,temp0.x);\ntemp0.y= ELEM(cur_x+1,0,src_whole_cols,VAL,temp0.y);\ntemp0.z= ELEM(cur_x+2,0,src_whole_cols,VAL,temp0.z);\ntemp0.w= ELEM(cur_x+3,0,src_whole_cols,VAL,temp0.w);\ntemp0= ELEM(cur_y,0,src_whole_rows,(uchar4)VAL,temp0);\ntemp1.x= ELEM(cur_x2,0,src_whole_cols,VAL,temp1.x);\ntemp1.y= ELEM(cur_x2+1,0,src_whole_cols,VAL,temp1.y);\ntemp1.z= ELEM(cur_x2+2,0,src_whole_cols,VAL,temp1.z);\ntemp1.w= ELEM(cur_x2+3,0,src_whole_cols,VAL,temp1.w);\ntemp1= ELEM(cur_y2,0,src_whole_rows,(uchar4)VAL,temp1);\nLDS_DAT[point1] = temp0;\nLDS_DAT[point2] = temp1;\nbarrier(CLK_LOCAL_MEM_FENCE);\nuchar4 res = (uchar4)VAL;\nfor(int i=0; i<2*RADIUSY+1; i++)\nfor(int j=0; j<2*RADIUSX+1; j++)\n{\nres =\n#ifndef RECTKERNEL\nmat_kernel[i*(2*RADIUSX+1)+j] ?\n#endif\nMORPH_OP(res,vload4(0,(__local uchar*)&LDS_DAT[mad24((l_y+i),width,l_x)]+offset+j))\n#ifndef RECTKERNEL\n:res\n#endif\n;\n}\nint gidx = get_global_id(0)<<2;\nint gidy = get_global_id(1);\nint out_addr = mad24(gidy,dst_step_in_pixel,gidx+dst_offset_in_pixel);\nif(gidx+3<cols && gidy<rows && ((dst_offset_in_pixel&3)==0))\n{\n*(__global uchar4*)&dst[out_addr] = res;\n}\nelse\n{\nif(gidx+3<cols && gidy<rows)\n{\ndst[out_addr] = res.x;\ndst[out_addr+1] = res.y;\ndst[out_addr+2] = res.z;\ndst[out_addr+3] = res.w;\n}\nelse if(gidx+2<cols && gidy<rows)\n{\ndst[out_addr] = res.x;\ndst[out_addr+1] = res.y;\ndst[out_addr+2] = res.z;\n}\nelse if(gidx+1<cols && gidy<rows)\n{\ndst[out_addr] = res.x;\ndst[out_addr+1] = res.y;\n}\nelse if(gidx<cols && gidy<rows)\n{\ndst[out_addr] = res.x;\n}\n}\n}\n#else\n__kernel void morph(__global const GENTYPE * restrict src,\n__global GENTYPE *dst,\nint src_offset_x, int src_offset_y,\nint cols, int rows,\nint src_step_in_pixel, int dst_step_in_pixel,\n__constant uchar * mat_kernel,\nint src_whole_cols, int src_whole_rows,\nint dst_offset_in_pixel)\n{\nint l_x = get_local_id(0);\nint l_y = get_local_id(1);\nint x = get_group_id(0)*LSIZE0;\nint y = get_group_id(1)*LSIZE1;\nint start_x = x+src_offset_x-RADIUSX;\nint end_x = x + src_offset_x+LSIZE0+RADIUSX;\nint width = end_x -(x+src_offset_x-RADIUSX)+1;\nint start_y = y+src_offset_y-RADIUSY;\nint point1 = mad24(l_y,LSIZE0,l_x);\nint point2 = point1 + LSIZE0*LSIZE1;\nint tl_x = point1 % width;\nint tl_y = point1 / width;\nint tl_x2 = point2 % width;\nint tl_y2 = point2 / width;\nint cur_x = start_x + tl_x;\nint cur_y = start_y + tl_y;\nint cur_x2 = start_x + tl_x2;\nint cur_y2 = start_y + tl_y2;\nint start_addr = mad24(cur_y,src_step_in_pixel,cur_x);\nint start_addr2 = mad24(cur_y2,src_step_in_pixel,cur_x2);\nGENTYPE temp0,temp1;\n__local GENTYPE LDS_DAT[2*LSIZE1*LSIZE0];\nint end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\nstart_addr = ((start_addr < end_addr) && (start_addr > 0)) ? start_addr : 0;\nstart_addr2 = ((start_addr2 < end_addr) && (start_addr2 > 0)) ? start_addr2 : 0;\ntemp0 = src[start_addr];\ntemp1 = src[start_addr2];\ntemp0= ELEM(cur_x,0,src_whole_cols,(GENTYPE)VAL,temp0);\ntemp0= ELEM(cur_y,0,src_whole_rows,(GENTYPE)VAL,temp0);\ntemp1= ELEM(cur_x2,0,src_whole_cols,(GENTYPE)VAL,temp1);\ntemp1= ELEM(cur_y2,0,src_whole_rows,(GENTYPE)VAL,temp1);\nLDS_DAT[point1] = temp0;\nLDS_DAT[point2] = temp1;\nbarrier(CLK_LOCAL_MEM_FENCE);\nGENTYPE res = (GENTYPE)VAL;\nfor(int i=0; i<2*RADIUSY+1; i++)\nfor(int j=0; j<2*RADIUSX+1; j++)\n{\nres =\n#ifndef RECTKERNEL\nmat_kernel[i*(2*RADIUSX+1)+j] ?\n#endif\nMORPH_OP(res,LDS_DAT[mad24(l_y+i,width,l_x+j)])\n#ifndef RECTKERNEL\n:res\n#endif\n;\n}\nint gidx = get_global_id(0);\nint gidy = get_global_id(1);\nint out_addr = mad24(gidy,dst_step_in_pixel,gidx+dst_offset_in_pixel);\nif(gidx<cols && gidy<rows)\n{\ndst[out_addr] = res;\n}\n}\n#endif\n", "01cdf6da352386c7aab3e65cfb1f7e39", "filtering_filter2D", "#ifdef BORDER_REPLICATE\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n#endif\n#ifdef BORDER_REFLECT\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n#endif\n#ifdef BORDER_REFLECT_101\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n#endif\n#ifdef BORDER_WRAP\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n#endif\n#ifdef EXTRA_EXTRAPOLATION\n#ifdef BORDER_CONSTANT\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n{ \\\nx = max(min(x, maxX - 1), minX); \\\ny = max(min(y, maxY - 1), minY); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n{ \\\nif (x < minX) \\\nx -= ((x - maxX + 1) / maxX) * maxX; \\\nif (x >= maxX) \\\nx %= maxX; \\\nif (y < minY) \\\ny -= ((y - maxY + 1) / maxY) * maxY; \\\nif (y >= maxY) \\\ny %= maxY; \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n#define EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, delta) \\\n{ \\\nif (maxX - minX == 1) \\\nx = minX; \\\nelse \\\ndo \\\n{ \\\nif (x < minX) \\\nx = -(x - minX) - 1 + delta; \\\nelse \\\nx = maxX - 1 - (x - maxX) - delta; \\\n} \\\nwhile (x >= maxX || x < minX); \\\n\\\nif (maxY - minY == 1) \\\ny = minY; \\\nelse \\\ndo \\\n{ \\\nif (y < minY) \\\ny = -(y - minY) - 1 + delta; \\\nelse \\\ny = maxY - 1 - (y - maxY) - delta; \\\n} \\\nwhile (y >= maxY || y < minY); \\\n}\n#ifdef BORDER_REFLECT\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 0)\n#elif defined(BORDER_REFLECT_101)\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 1)\n#endif\n#else\n#error No extrapolation method\n#endif\n#else\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n{ \\\nint _row = y - minY, _col = x - minX; \\\n_row = ADDR_H(_row, 0, maxY - minY); \\\n_row = ADDR_B(_row, maxY - minY, _row); \\\ny = _row + minY; \\\n\\\n_col = ADDR_L(_col, 0, maxX - minX); \\\n_col = ADDR_R(_col, maxX - minX, _col); \\\nx = _col + minX; \\\n}\n#endif\n#if USE_DOUBLE\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define FPTYPE double\n#define CONVERT_TO_FPTYPE CAT(convert_double, VEC_SIZE)\n#else\n#define FPTYPE float\n#define CONVERT_TO_FPTYPE CAT(convert_float, VEC_SIZE)\n#endif\n#if DATA_DEPTH == 0\n#define BASE_TYPE uchar\n#elif DATA_DEPTH == 1\n#define BASE_TYPE char\n#elif DATA_DEPTH == 2\n#define BASE_TYPE ushort\n#elif DATA_DEPTH == 3\n#define BASE_TYPE short\n#elif DATA_DEPTH == 4\n#define BASE_TYPE int\n#elif DATA_DEPTH == 5\n#define BASE_TYPE float\n#elif DATA_DEPTH == 6\n#define BASE_TYPE double\n#else\n#error data_depth\n#endif\n#define __CAT(x, y) x##y\n#define CAT(x, y) __CAT(x, y)\n#define uchar1 uchar\n#define char1 char\n#define ushort1 ushort\n#define short1 short\n#define int1 int\n#define float1 float\n#define double1 double\n#define convert_uchar1_sat_rte convert_uchar_sat_rte\n#define convert_char1_sat_rte convert_char_sat_rte\n#define convert_ushort1_sat_rte convert_ushort_sat_rte\n#define convert_short1_sat_rte convert_short_sat_rte\n#define convert_int1_sat_rte convert_int_sat_rte\n#define convert_float1\n#define convert_double1\n#if DATA_DEPTH == 5 || DATA_DEPTH == 6\n#define CONVERT_TO_TYPE CAT(CAT(convert_, BASE_TYPE), VEC_SIZE)\n#else\n#define CONVERT_TO_TYPE CAT(CAT(CAT(convert_, BASE_TYPE), VEC_SIZE), _sat_rte)\n#endif\n#define VEC_SIZE DATA_CHAN\n#define VEC_TYPE CAT(BASE_TYPE, VEC_SIZE)\n#define TYPE VEC_TYPE\n#define SCALAR_TYPE CAT(FPTYPE, VEC_SIZE)\n#define INTERMEDIATE_TYPE CAT(FPTYPE, VEC_SIZE)\nstruct RectCoords\n{\nint x1, y1, x2, y2;\n};\n#ifdef DEBUG\n#define DEBUG_ONLY(x) x\n#define ASSERT(condition) do { if (!(condition)) { printf(\"BUG in boxFilter kernel (global=%d,%d): \" #condition \"\\n\", get_global_id(0), get_global_id(1)); } } while (0)\n#else\n#define DEBUG_ONLY(x) (void)0\n#define ASSERT(condition) (void)0\n#endif\nINTERMEDIATE_TYPE readSrcPixel(int2 pos, __global TYPE *src, const unsigned int srcStepBytes, const struct RectCoords srcCoords\n#ifdef BORDER_CONSTANT\n, SCALAR_TYPE borderValue\n#endif\n)\n{\n#ifdef BORDER_ISOLATED\nif(pos.x >= srcCoords.x1 && pos.y >= srcCoords.y1 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n#else\nif(pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n#endif\n{\n__global TYPE* ptr = (__global TYPE*)((__global char*)src + pos.x * sizeof(TYPE) + pos.y * srcStepBytes);\nreturn CONVERT_TO_FPTYPE(*ptr);\n}\nelse\n{\n#ifdef BORDER_CONSTANT\nreturn borderValue;\n#else\nint selected_col = pos.x;\nint selected_row = pos.y;\nEXTRAPOLATE(selected_col, selected_row,\n#ifdef BORDER_ISOLATED\nsrcCoords.x1, srcCoords.y1,\n#else\n0, 0,\n#endif\nsrcCoords.x2, srcCoords.y2\n);\npos = (int2)(selected_col, selected_row);\nif(pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n{\n__global TYPE* ptr = (__global TYPE*)((__global char*)src + pos.x * sizeof(TYPE) + pos.y * srcStepBytes);\nreturn CONVERT_TO_FPTYPE(*ptr);\n}\nelse\n{\nDEBUG_ONLY(printf(\"BUG in boxFilter kernel\\n\"));\nreturn (FPTYPE)(0.0f);\n}\n#endif\n}\n}\n__kernel\n__attribute__((reqd_work_group_size(LOCAL_SIZE, 1, 1)))\nvoid filter2D(__global TYPE *src, const unsigned int srcStepBytes, const int4 srcRC,\n__global TYPE *dst, const unsigned int dstStepBytes, const int4 dstRC,\n#ifdef BORDER_CONSTANT\nSCALAR_TYPE borderValue,\n#endif\n__constant FPTYPE* kernelData\n)\n{\nconst struct RectCoords srcCoords = {srcRC.s0, srcRC.s1, srcRC.s2, srcRC.s3};\nstruct RectCoords dstCoords = {dstRC.s0, dstRC.s1, dstRC.s2, dstRC.s3};\nconst int local_id = get_local_id(0);\nconst int x = local_id + (LOCAL_SIZE - (KERNEL_SIZE_X - 1)) * get_group_id(0) - ANCHOR_X;\nconst int y = get_global_id(1) * BLOCK_SIZE_Y;\nINTERMEDIATE_TYPE data[KERNEL_SIZE_Y];\n__local INTERMEDIATE_TYPE sumOfCols[LOCAL_SIZE];\nint2 srcPos = (int2)(srcCoords.x1 + x, srcCoords.y1 + y - ANCHOR_Y);\nint2 pos = (int2)(dstCoords.x1 + x, dstCoords.y1 + y);\n__global TYPE* dstPtr = (__global TYPE*)((__global char*)dst + pos.x * sizeof(TYPE) + pos.y * dstStepBytes);\nbool writeResult = (local_id >= ANCHOR_X && local_id < LOCAL_SIZE - (KERNEL_SIZE_X - 1 - ANCHOR_X) &&\npos.x >= dstCoords.x1 && pos.x < dstCoords.x2);\n#if BLOCK_SIZE_Y > 1\nbool readAllpixels = true;\nint sy_index = 0;\ndstCoords.y2 = min(dstCoords.y2, pos.y + BLOCK_SIZE_Y);\nfor (;\npos.y < dstCoords.y2;\npos.y++,\ndstPtr = (__global TYPE*)((__global char*)dstPtr + dstStepBytes))\n#endif\n{\nASSERT(pos.y < dstCoords.y2);\nfor (\n#if BLOCK_SIZE_Y > 1\nint sy = readAllpixels ? 0 : -1; sy < (readAllpixels ? KERNEL_SIZE_Y : 0);\n#else\nint sy = 0, sy_index = 0; sy < KERNEL_SIZE_Y;\n#endif\nsy++, srcPos.y++)\n{\ndata[sy + sy_index] = readSrcPixel(srcPos, src, srcStepBytes, srcCoords\n#ifdef BORDER_CONSTANT\n, borderValue\n#endif\n);\n}\nINTERMEDIATE_TYPE total_sum = 0;\nfor (int sx = 0; sx < KERNEL_SIZE_X; sx++)\n{\n{\n__constant FPTYPE* k = &kernelData[KERNEL_SIZE_Y2_ALIGNED * sx\n#if BLOCK_SIZE_Y > 1\n+ KERNEL_SIZE_Y - sy_index\n#endif\n];\nINTERMEDIATE_TYPE tmp_sum = 0;\nfor (int sy = 0; sy < KERNEL_SIZE_Y; sy++)\n{\ntmp_sum += data[sy] * k[sy];\n}\nsumOfCols[local_id] = tmp_sum;\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nint id = local_id + sx - ANCHOR_X;\nif (id >= 0 && id < LOCAL_SIZE)\ntotal_sum += sumOfCols[id];\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif (writeResult)\n{\nASSERT(pos.y >= dstCoords.y1 && pos.y < dstCoords.y2);\n*dstPtr = CONVERT_TO_TYPE(total_sum);\n}\n#if BLOCK_SIZE_Y > 1\nreadAllpixels = false;\n#if BLOCK_SIZE_Y > KERNEL_SIZE_Y\nsy_index = (sy_index + 1 <= KERNEL_SIZE_Y) ? sy_index + 1 : 1;\n#else\nsy_index++;\n#endif\n#endif\n}\n}\n", "ca32031fbf7bad598b8468e60df95be6", "filtering_boxFilter", "#ifdef BORDER_REPLICATE\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n#endif\n#ifdef BORDER_REFLECT\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n#endif\n#ifdef BORDER_REFLECT_101\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n#endif\n#ifdef BORDER_WRAP\n#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n#endif\n#ifdef EXTRA_EXTRAPOLATION\n#ifdef BORDER_CONSTANT\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n{ \\\nx = max(min(x, maxX - 1), minX); \\\ny = max(min(y, maxY - 1), minY); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n{ \\\nif (x < minX) \\\nx -= ((x - maxX + 1) / maxX) * maxX; \\\nif (x >= maxX) \\\nx %= maxX; \\\nif (y < minY) \\\ny -= ((y - maxY + 1) / maxY) * maxY; \\\nif (y >= maxY) \\\ny %= maxY; \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n#define EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, delta) \\\n{ \\\nif (maxX - minX == 1) \\\nx = minX; \\\nelse \\\ndo \\\n{ \\\nif (x < minX) \\\nx = -(x - minX) - 1 + delta; \\\nelse \\\nx = maxX - 1 - (x - maxX) - delta; \\\n} \\\nwhile (x >= maxX || x < minX); \\\n\\\nif (maxY - minY == 1) \\\ny = minY; \\\nelse \\\ndo \\\n{ \\\nif (y < minY) \\\ny = -(y - minY) - 1 + delta; \\\nelse \\\ny = maxY - 1 - (y - maxY) - delta; \\\n} \\\nwhile (y >= maxY || y < minY); \\\n}\n#ifdef BORDER_REFLECT\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 0)\n#elif defined(BORDER_REFLECT_101)\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 1)\n#endif\n#else\n#error No extrapolation method\n#endif\n#else\n#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n{ \\\nint _row = y - minY, _col = x - minX; \\\n_row = ADDR_H(_row, 0, maxY - minY); \\\n_row = ADDR_B(_row, maxY - minY, _row); \\\ny = _row + minY; \\\n\\\n_col = ADDR_L(_col, 0, maxX - minX); \\\n_col = ADDR_R(_col, maxX - minX, _col); \\\nx = _col + minX; \\\n}\n#endif\n#if USE_DOUBLE\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define FPTYPE double\n#define CONVERT_TO_FPTYPE CAT(convert_double, VEC_SIZE)\n#else\n#define FPTYPE float\n#define CONVERT_TO_FPTYPE CAT(convert_float, VEC_SIZE)\n#endif\n#if DATA_DEPTH == 0\n#define BASE_TYPE uchar\n#elif DATA_DEPTH == 1\n#define BASE_TYPE char\n#elif DATA_DEPTH == 2\n#define BASE_TYPE ushort\n#elif DATA_DEPTH == 3\n#define BASE_TYPE short\n#elif DATA_DEPTH == 4\n#define BASE_TYPE int\n#elif DATA_DEPTH == 5\n#define BASE_TYPE float\n#elif DATA_DEPTH == 6\n#define BASE_TYPE double\n#else\n#error data_depth\n#endif\n#define __CAT(x, y) x##y\n#define CAT(x, y) __CAT(x, y)\n#define uchar1 uchar\n#define char1 char\n#define ushort1 ushort\n#define short1 short\n#define int1 int\n#define float1 float\n#define double1 double\n#define convert_uchar1_sat_rte convert_uchar_sat_rte\n#define convert_char1_sat_rte convert_char_sat_rte\n#define convert_ushort1_sat_rte convert_ushort_sat_rte\n#define convert_short1_sat_rte convert_short_sat_rte\n#define convert_int1_sat_rte convert_int_sat_rte\n#define convert_float1\n#define convert_double1\n#if DATA_DEPTH == 5 || DATA_DEPTH == 6\n#define CONVERT_TO_TYPE CAT(CAT(convert_, BASE_TYPE), VEC_SIZE)\n#else\n#define CONVERT_TO_TYPE CAT(CAT(CAT(convert_, BASE_TYPE), VEC_SIZE), _sat_rte)\n#endif\n#define VEC_SIZE DATA_CHAN\n#define VEC_TYPE CAT(BASE_TYPE, VEC_SIZE)\n#define TYPE VEC_TYPE\n#define SCALAR_TYPE CAT(FPTYPE, VEC_SIZE)\n#define INTERMEDIATE_TYPE CAT(FPTYPE, VEC_SIZE)\nstruct RectCoords\n{\nint x1, y1, x2, y2;\n};\n#ifdef DEBUG\n#define DEBUG_ONLY(x) x\n#define ASSERT(condition) do { if (!(condition)) { printf(\"BUG in boxFilter kernel (global=%d,%d): \" #condition \"\\n\", get_global_id(0), get_global_id(1)); } } while (0)\n#else\n#define DEBUG_ONLY(x)\n#define ASSERT(condition)\n#endif\nINTERMEDIATE_TYPE readSrcPixel(int2 pos, __global TYPE *src, const unsigned int srcStepBytes, const struct RectCoords srcCoords\n#ifdef BORDER_CONSTANT\n, SCALAR_TYPE borderValue\n#endif\n)\n{\n#ifdef BORDER_ISOLATED\nif(pos.x >= srcCoords.x1 && pos.y >= srcCoords.y1 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n#else\nif(pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n#endif\n{\n__global TYPE* ptr = (__global TYPE*)((__global char*)src + pos.x * sizeof(TYPE) + pos.y * srcStepBytes);\nreturn CONVERT_TO_FPTYPE(*ptr);\n}\nelse\n{\n#ifdef BORDER_CONSTANT\nreturn borderValue;\n#else\nint selected_col = pos.x;\nint selected_row = pos.y;\nEXTRAPOLATE(selected_col, selected_row,\n#ifdef BORDER_ISOLATED\nsrcCoords.x1, srcCoords.y1,\n#else\n0, 0,\n#endif\nsrcCoords.x2, srcCoords.y2\n);\npos = (int2)(selected_col, selected_row);\nif(pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n{\n__global TYPE* ptr = (__global TYPE*)((__global char*)src + pos.x * sizeof(TYPE) + pos.y * srcStepBytes);\nreturn CONVERT_TO_FPTYPE(*ptr);\n}\nelse\n{\nDEBUG_ONLY(printf(\"BUG in boxFilter kernel\\n\"));\nreturn (FPTYPE)(0.0f);\n}\n#endif\n}\n}\n__kernel\n__attribute__((reqd_work_group_size(LOCAL_SIZE, 1, 1)))\nvoid boxFilter(__global TYPE *src, const unsigned int srcStepBytes, const int4 srcRC,\n__global TYPE *dst, const unsigned int dstStepBytes, const int4 dstRC,\n#ifdef BORDER_CONSTANT\nSCALAR_TYPE borderValue,\n#endif\nFPTYPE alpha\n)\n{\nconst struct RectCoords srcCoords = {srcRC.s0, srcRC.s1, srcRC.s2, srcRC.s3};\nconst struct RectCoords dstCoords = {dstRC.s0, dstRC.s1, dstRC.s2, dstRC.s3};\nconst int x = get_local_id(0) + (LOCAL_SIZE - (KERNEL_SIZE_X - 1)) * get_group_id(0) - ANCHOR_X;\nconst int y = get_global_id(1) * BLOCK_SIZE_Y;\nconst int local_id = get_local_id(0);\nINTERMEDIATE_TYPE data[KERNEL_SIZE_Y];\n__local INTERMEDIATE_TYPE sumOfCols[LOCAL_SIZE];\nint2 srcPos = (int2)(srcCoords.x1 + x, srcCoords.y1 + y - ANCHOR_Y);\nfor(int sy = 0; sy < KERNEL_SIZE_Y; sy++, srcPos.y++)\n{\ndata[sy] = readSrcPixel(srcPos, src, srcStepBytes, srcCoords\n#ifdef BORDER_CONSTANT\n, borderValue\n#endif\n);\n}\nINTERMEDIATE_TYPE tmp_sum = 0;\nfor(int sy = 0; sy < KERNEL_SIZE_Y; sy++)\n{\ntmp_sum += (data[sy]);\n}\nsumOfCols[local_id] = tmp_sum;\nbarrier(CLK_LOCAL_MEM_FENCE);\nint2 pos = (int2)(dstCoords.x1 + x, dstCoords.y1 + y);\n__global TYPE* dstPtr = (__global TYPE*)((__global char*)dst + pos.x * sizeof(TYPE) + pos.y * dstStepBytes);\nint sy_index = 0;\nint stepsY = min(dstCoords.y2 - pos.y, BLOCK_SIZE_Y);\nASSERT(stepsY > 0);\nfor (; ;)\n{\nASSERT(pos.y < dstCoords.y2);\nif(local_id >= ANCHOR_X && local_id < LOCAL_SIZE - (KERNEL_SIZE_X - 1 - ANCHOR_X) &&\npos.x >= dstCoords.x1 && pos.x < dstCoords.x2)\n{\nASSERT(pos.y >= dstCoords.y1 && pos.y < dstCoords.y2);\nINTERMEDIATE_TYPE total_sum = 0;\n#pragma unroll\nfor (int sx = 0; sx < KERNEL_SIZE_X; sx++)\n{\ntotal_sum += sumOfCols[local_id + sx - ANCHOR_X];\n}\n*dstPtr = CONVERT_TO_TYPE(((INTERMEDIATE_TYPE)alpha) * total_sum);\n}\n#if BLOCK_SIZE_Y == 1\nbreak;\n#else\nif (--stepsY == 0)\nbreak;\nbarrier(CLK_LOCAL_MEM_FENCE);\ntmp_sum = sumOfCols[local_id];\ntmp_sum -= data[sy_index];\ndata[sy_index] = readSrcPixel(srcPos, src, srcStepBytes, srcCoords\n#ifdef BORDER_CONSTANT\n, borderValue\n#endif\n);\nsrcPos.y++;\ntmp_sum += data[sy_index];\nsumOfCols[local_id] = tmp_sum;\nsy_index = (sy_index + 1 < KERNEL_SIZE_Y) ? sy_index + 1 : 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nDEBUG_ONLY(pos.y++);\ndstPtr = (__global TYPE*)((__global char*)dstPtr + dstStepBytes);\n#endif\n}\n}\n", "4886fb0eca8474fbd9c13bc03089baf2", "filtering_adaptive_bilateral", "#ifdef BORDER_CONSTANT\n#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nx = max(min(x, maxV - 1), 0); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nif (x < 0) \\\nx -= ((x - maxV + 1) / maxV) * maxV; \\\nif (x >= maxV) \\\nx %= maxV; \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n#define EXTRAPOLATE_(x, maxV, delta) \\\n{ \\\nif (maxV == 1) \\\nx = 0; \\\nelse \\\ndo \\\n{ \\\nif ( x < 0 ) \\\nx = -x - 1 + delta; \\\nelse \\\nx = maxV - 1 - (x - maxV) - delta; \\\n} \\\nwhile (x >= maxV || x < 0); \\\n}\n#ifdef BORDER_REFLECT\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 0)\n#else\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 1)\n#endif\n#else\n#error No extrapolation method\n#endif\n__kernel void\nadaptiveBilateralFilter_C4_D0(\n__global const uchar4 * restrict src,\n__global uchar4 *dst,\nfloat alpha,\nint src_offset,\nint src_whole_rows,\nint src_whole_cols,\nint src_step,\nint dst_offset,\nint dst_rows,\nint dst_cols,\nint dst_step,\n__global const float* lut,\nint lut_step)\n{\nint col = get_local_id(0);\nconst int gX = get_group_id(0);\nconst int gY = get_group_id(1);\nint src_x_off = (src_offset % src_step) >> 2;\nint src_y_off = src_offset / src_step;\nint dst_x_off = (dst_offset % dst_step) >> 2;\nint dst_y_off = dst_offset / dst_step;\nint startX = gX * (THREADS-ksX+1) - anX + src_x_off;\nint startY = (gY * (1+EXTRA)) - anY + src_y_off;\nint dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\nint dst_startY = (gY * (1+EXTRA)) + dst_y_off;\nint posX = dst_startX - dst_x_off + col;\nint posY = (gY * (1+EXTRA))  ;\n__local uchar4 data[ksY+EXTRA][THREADS];\nfloat4 tmp_sum[1+EXTRA];\nfor(int tmpint = 0; tmpint < 1+EXTRA; tmpint++)\ntmp_sum[tmpint] = (float4)(0,0,0,0);\n#ifdef BORDER_CONSTANT\nbool con;\nuchar4 ss;\nfor(int j = 0;  j < ksY+EXTRA; j++)\n{\ncon = (startX+col >= 0 && startX+col < src_whole_cols && startY+j >= 0 && startY+j < src_whole_rows);\nint cur_col = clamp(startX + col, 0, src_whole_cols);\nif (con)\nss = src[(startY+j)*(src_step>>2) + cur_col];\ndata[j][col] = con ? ss : (uchar4)0;\n}\n#else\nfor(int j= 0; j < ksY+EXTRA; j++)\n{\nint selected_row = startY+j, selected_col = startX+col;\nEXTRAPOLATE(selected_row, src_whole_rows)\nEXTRAPOLATE(selected_col, src_whole_cols)\ndata[j][col] = src[selected_row * (src_step>>2) + selected_col];\n}\n#endif\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat4 var[1+EXTRA];\n#if VAR_PER_CHANNEL\nfloat4 weight;\nfloat4 totalWeight = (float4)(0,0,0,0);\n#else\nfloat weight;\nfloat totalWeight = 0;\n#endif\nint4 currValCenter;\nint4 currWRTCenter;\nint4 sumVal = 0;\nint4 sumValSqr = 0;\nif(col < (THREADS-(ksX-1)))\n{\nint4 currVal;\nint howManyAll = (2*anX+1)*(ksY);\nint startLMj;\nint endLMj ;\nfor(int extraCnt = 0; extraCnt <=EXTRA; extraCnt++)\n{\n#if CALCVAR\nstartLMj = extraCnt;\nendLMj =  ksY+extraCnt-1;\nsumVal = (int4)0;\nsumValSqr= (int4)0;\nfor(int j = startLMj; j < endLMj; j++)\nfor(int i=-anX; i<=anX; i++)\n{\ncurrVal = convert_int4(data[j][col+anX+i]);\nsumVal += currVal;\nsumValSqr += mul24(currVal, currVal);\n}\nvar[extraCnt] = clamp( convert_float4( ( (sumValSqr * howManyAll)- mul24(sumVal , sumVal) ) ) /  ( (float)(howManyAll*howManyAll) ), (float4)(0.1f, 0.1f, 0.1f, 0.1f), (float4)(MAX_VAR_VAL, MAX_VAR_VAL, MAX_VAR_VAL, MAX_VAR_VAL)) ;\n#else\nvar[extraCnt] = (float4)(MAX_VAR_VAL, MAX_VAR_VAL, MAX_VAR_VAL, MAX_VAR_VAL);\n#endif\n}\nfor(int extraCnt = 0; extraCnt <= EXTRA; extraCnt++)\n{\nstartLMj = extraCnt;\nendLMj =  extraCnt + ksY;\ncurrValCenter = convert_int4( data[ (startLMj + endLMj)/2][col+anX] );\nfor(int j = startLMj, lut_j = 0; j < endLMj; j++, lut_j++)\n{\nfor(int i=-anX; i<=anX; i++)\n{\n#if FIXED_WEIGHT\n#if VAR_PER_CHANNEL\nweight.x = 1.0f;\nweight.y = 1.0f;\nweight.z = 1.0f;\nweight.w = 1.0f;\n#else\nweight = 1.0f;\n#endif\n#else\ncurrVal = convert_int4(data[j][col+anX+i]);\ncurrWRTCenter = currVal-currValCenter;\n#if ABF_GAUSSIAN\n#if VAR_PER_CHANNEL\nweight = exp( (float4)(-0.5f, -0.5f, -0.5f, -0.5f) * convert_float4(currWRTCenter * currWRTCenter) / var[extraCnt] )*\n(float4)(lut[lut_j*lut_step+anX+i]);\n#else\nweight = exp( -0.5f * (mul24(currWRTCenter.x, currWRTCenter.x) + mul24(currWRTCenter.y, currWRTCenter.y) +\nmul24(currWRTCenter.z, currWRTCenter.z) ) / (var[extraCnt].x+var[extraCnt].y+var[extraCnt].z) ) * lut[lut_j*lut_step+anX+i];\n#endif\n#else\n#if VAR_PER_CHANNEL\nweight = var[extraCnt] / (var[extraCnt] + convert_float4(currWRTCenter * currWRTCenter)) *\n(float4)(lut[lut_j*lut_step+anX+i]);\n#else\nweight = ((float)lut[lut_j*lut_step+anX+i]) /(1.0f+( mul24(currWRTCenter.x, currWRTCenter.x) + mul24(currWRTCenter.y, currWRTCenter.y) +\nmul24(currWRTCenter.z, currWRTCenter.z))/(var[extraCnt].x+var[extraCnt].y+var[extraCnt].z));\n#endif\n#endif\n#endif\ntmp_sum[extraCnt] += convert_float4(data[j][col+anX+i]) * weight;\ntotalWeight += weight;\n}\n}\nif(posX >= 0 && posX < dst_cols && (posY+extraCnt) >= 0 && (posY+extraCnt) < dst_rows)\ndst[(dst_startY+extraCnt) * (dst_step>>2)+ dst_startX + col] = convert_uchar4_rtz( (tmp_sum[extraCnt] / (float4)totalWeight) + (float4)0.5f);\n#if VAR_PER_CHANNEL\ntotalWeight = (float4)(0,0,0,0);\n#else\ntotalWeight = 0.0f;\n#endif\n}\n}\n}\n__kernel void\nadaptiveBilateralFilter_C1_D0(\n__global const uchar * restrict src,\n__global uchar *dst,\nfloat alpha,\nint src_offset,\nint src_whole_rows,\nint src_whole_cols,\nint src_step,\nint dst_offset,\nint dst_rows,\nint dst_cols,\nint dst_step,\n__global const float * lut,\nint lut_step)\n{\nint col = get_local_id(0);\nconst int gX = get_group_id(0);\nconst int gY = get_group_id(1);\nint src_x_off = (src_offset % src_step);\nint src_y_off = src_offset / src_step;\nint dst_x_off = (dst_offset % dst_step);\nint dst_y_off = dst_offset / dst_step;\nint startX = gX * (THREADS-ksX+1) - anX + src_x_off;\nint startY = (gY * (1+EXTRA)) - anY + src_y_off;\nint dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\nint dst_startY = (gY * (1+EXTRA)) + dst_y_off;\nint posX = dst_startX - dst_x_off + col;\nint posY = (gY * (1+EXTRA))  ;\n__local uchar data[ksY+EXTRA][THREADS];\nfloat tmp_sum[1+EXTRA];\nfor(int tmpint = 0; tmpint < 1+EXTRA; tmpint++)\n{\ntmp_sum[tmpint] = (float)(0);\n}\n#ifdef BORDER_CONSTANT\nbool con;\nuchar ss;\nfor(int j = 0;  j < ksY+EXTRA; j++)\n{\ncon = (startX+col >= 0 && startX+col < src_whole_cols && startY+j >= 0 && startY+j < src_whole_rows);\nint cur_col = clamp(startX + col, 0, src_whole_cols);\nif(con)\n{\nss = src[(startY+j)*(src_step) + cur_col];\n}\ndata[j][col] = con ? ss : 0;\n}\n#else\nfor(int j= 0; j < ksY+EXTRA; j++)\n{\nint selected_row = startY+j, selected_col = startX+col;\nEXTRAPOLATE(selected_row, src_whole_rows)\nEXTRAPOLATE(selected_col, src_whole_cols)\ndata[j][col] = src[selected_row * (src_step) + selected_col];\n}\n#endif\nbarrier(CLK_LOCAL_MEM_FENCE);\nfloat var[1+EXTRA];\nfloat weight;\nfloat totalWeight = 0;\nint currValCenter;\nint currWRTCenter;\nint sumVal = 0;\nint sumValSqr = 0;\nif(col < (THREADS-(ksX-1)))\n{\nint currVal;\nint howManyAll = (2*anX+1)*(ksY);\nint startLMj;\nint endLMj;\nfor(int extraCnt=0; extraCnt<=EXTRA; extraCnt++)\n{\n#if CALCVAR\nstartLMj = extraCnt;\nendLMj =  ksY+extraCnt-1;\nsumVal = 0;\nsumValSqr =0;\nfor(int j = startLMj; j < endLMj; j++)\n{\nfor(int i=-anX; i<=anX; i++)\n{\ncurrVal  = (uint)(data[j][col+anX+i])  ;\nsumVal += currVal;\nsumValSqr += mul24(currVal, currVal);\n}\n}\nvar[extraCnt] =  clamp((float)( ( (sumValSqr * howManyAll)- mul24(sumVal , sumVal) ) ) /  ( (float)(howManyAll*howManyAll) ) , 0.1f, (float)(MAX_VAR_VAL) );\n#else\nvar[extraCnt] = (float)(MAX_VAR_VAL);\n#endif\n}\nfor(int extraCnt = 0; extraCnt <= EXTRA; extraCnt++)\n{\nstartLMj = extraCnt;\nendLMj =  extraCnt + ksY;\ncurrValCenter = (int)( data[ (startLMj + endLMj)/2][col+anX] );\nfor(int j = startLMj, lut_j = 0; j < endLMj; j++, lut_j++)\n{\nfor(int i=-anX; i<=anX; i++)\n{\n#if FIXED_WEIGHT\nweight = 1.0f;\n#else\ncurrVal  = (int)(data[j][col+anX+i])  ;\ncurrWRTCenter = currVal-currValCenter;\n#if ABF_GAUSSIAN\nweight = exp( -0.5f * (float)mul24(currWRTCenter,currWRTCenter)/var[extraCnt]) * lut[lut_j*lut_step+anX+i] ;\n#else\nweight = var[extraCnt] / (var[extraCnt] + (float)mul24(currWRTCenter,currWRTCenter)) * lut[lut_j*lut_step+anX+i] ;\n#endif\n#endif\ntmp_sum[extraCnt] += (float)(data[j][col+anX+i] * weight);\ntotalWeight += weight;\n}\n}\nif(posX >= 0 && posX < dst_cols && (posY+extraCnt) >= 0 && (posY+extraCnt) < dst_rows)\n{\ndst[(dst_startY+extraCnt) * (dst_step)+ dst_startX + col] = convert_uchar_rtz(tmp_sum[extraCnt]/totalWeight+0.5f);\n}\ntotalWeight = 0;\n}\n}\n}\n", "9bf8fa5a50a63ee945172dc0f70760f2", "filter_sep_row", "#define READ_TIMES_ROW ((2*(RADIUSX+LSIZE0)-1)/LSIZE0)\n#define READ_TIMES_COL ((2*(RADIUSY+LSIZE1)-1)/LSIZE1)\n#define RADIUS 1\n#if CN ==1\n#define ALIGN (((RADIUS)+3)>>2<<2)\n#elif CN==2\n#define ALIGN (((RADIUS)+1)>>1<<1)\n#elif CN==3\n#define ALIGN (((RADIUS)+3)>>2<<2)\n#elif CN==4\n#define ALIGN (RADIUS)\n#endif\n#ifdef BORDER_CONSTANT\n#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n#elif defined BORDER_REPLICATE\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nx = max(min(x, maxV - 1), 0); \\\n}\n#elif defined BORDER_WRAP\n#define EXTRAPOLATE(x, maxV) \\\n{ \\\nif (x < 0) \\\nx -= ((x - maxV + 1) / maxV) * maxV; \\\nif (x >= maxV) \\\nx %= maxV; \\\n}\n#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n#define EXTRAPOLATE_(x, maxV, delta) \\\n{ \\\nif (maxV == 1) \\\nx = 0; \\\nelse \\\ndo \\\n{ \\\nif ( x < 0 ) \\\nx = -x - 1 + delta; \\\nelse \\\nx = maxV - 1 - (x - maxV) - delta; \\\n} \\\nwhile (x >= maxV || x < 0); \\\n}\n#ifdef BORDER_REFLECT\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 0)\n#else\n#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 1)\n#endif\n#else\n#error No extrapolation method\n#endif\n__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C1_D0\n(__global uchar * restrict src,\n__global float * dst,\nint dst_cols, int dst_rows,\nint src_whole_cols, int src_whole_rows,\nint src_step_in_pixel,\nint src_offset_x, int src_offset_y,\nint dst_step_in_pixel, int radiusy,\n__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n{\nint x = get_global_id(0)<<2;\nint y = get_global_id(1);\nint l_x = get_local_id(0);\nint l_y = get_local_id(1);\nint start_x = x+src_offset_x - RADIUSX & 0xfffffffc;\nint offset = src_offset_x - RADIUSX & 3;\nint start_y = y + src_offset_y - radiusy;\nint start_addr = mad24(start_y, src_step_in_pixel, start_x);\nint i;\nfloat4 sum;\nuchar4 temp[READ_TIMES_ROW];\n__local uchar4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n#ifdef BORDER_CONSTANT\nint end_addr = mad24(src_whole_rows - 1, src_step_in_pixel, src_whole_cols);\nfor (i = 0; i < READ_TIMES_ROW; i++)\n{\nint current_addr = start_addr+i*LSIZE0*4;\ncurrent_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\ntemp[i] = *(__global uchar4*)&src[current_addr];\n}\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\ntemp[i].x = ELEM(start_x+i*LSIZE0*4,0,src_whole_cols,0,temp[i].x);\ntemp[i].y = ELEM(start_x+i*LSIZE0*4+1,0,src_whole_cols,0,temp[i].y);\ntemp[i].z = ELEM(start_x+i*LSIZE0*4+2,0,src_whole_cols,0,temp[i].z);\ntemp[i].w = ELEM(start_x+i*LSIZE0*4+3,0,src_whole_cols,0,temp[i].w);\ntemp[i]   = ELEM(start_y,0,src_whole_rows,(uchar4)0,temp[i]);\n}\n#else\nint not_all_in_range = (start_x<0) | (start_x + READ_TIMES_ROW*LSIZE0*4+4>src_whole_cols)| (start_y<0) | (start_y >= src_whole_rows);\nint4 index[READ_TIMES_ROW];\nint4 addr;\nint s_y;\nif (not_all_in_range)\n{\nfor (i = 0; i < READ_TIMES_ROW; i++)\n{\nindex[i] = (int4)(start_x+i*LSIZE0*4) + (int4)(0, 1, 2, 3);\nEXTRAPOLATE(index[i].x, src_whole_cols);\nEXTRAPOLATE(index[i].y, src_whole_cols);\nEXTRAPOLATE(index[i].z, src_whole_cols);\nEXTRAPOLATE(index[i].w, src_whole_cols);\n}\ns_y = start_y;\nEXTRAPOLATE(s_y, src_whole_rows);\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\naddr = mad24((int4)s_y,(int4)src_step_in_pixel,index[i]);\ntemp[i].x = src[addr.x];\ntemp[i].y = src[addr.y];\ntemp[i].z = src[addr.z];\ntemp[i].w = src[addr.w];\n}\n}\nelse\n{\nfor (i = 0; i<READ_TIMES_ROW; i++)\ntemp[i] = *(__global uchar4*)&src[start_addr+i*LSIZE0*4];\n}\n#endif\nfor (i = 0; i<READ_TIMES_ROW; i++)\nLDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum =convert_float4(vload4(0,(__local uchar*)&LDS_DAT[l_y][l_x]+RADIUSX+offset))*mat_kernel[RADIUSX];\nfor (i=1; i<=RADIUSX; i++)\n{\ntemp[0] = vload4(0, (__local uchar*)&LDS_DAT[l_y][l_x] + RADIUSX + offset - i);\ntemp[1] = vload4(0, (__local uchar*)&LDS_DAT[l_y][l_x] + RADIUSX + offset + i);\nsum += convert_float4(temp[0]) * mat_kernel[RADIUSX-i] + convert_float4(temp[1]) * mat_kernel[RADIUSX+i];\n}\nstart_addr = mad24(y,dst_step_in_pixel,x);\nif ((x+3<dst_cols) & (y<dst_rows))\n*(__global float4*)&dst[start_addr] = sum;\nelse if ((x+2<dst_cols) && (y<dst_rows))\n{\ndst[start_addr] = sum.x;\ndst[start_addr+1] = sum.y;\ndst[start_addr+2] = sum.z;\n}\nelse if ((x+1<dst_cols) && (y<dst_rows))\n{\ndst[start_addr] = sum.x;\ndst[start_addr+1] = sum.y;\n}\nelse if (x<dst_cols && y<dst_rows)\ndst[start_addr] = sum.x;\n}\n__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C4_D0\n(__global uchar4 * restrict src,\n__global float4 * dst,\nint dst_cols, int dst_rows,\nint src_whole_cols, int src_whole_rows,\nint src_step_in_pixel,\nint src_offset_x, int src_offset_y,\nint dst_step_in_pixel, int radiusy,\n__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nint l_x = get_local_id(0);\nint l_y = get_local_id(1);\nint start_x = x+src_offset_x-RADIUSX;\nint start_y = y+src_offset_y-radiusy;\nint start_addr = mad24(start_y,src_step_in_pixel,start_x);\nint i;\nfloat4 sum;\nuchar4 temp[READ_TIMES_ROW];\n__local uchar4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n#ifdef BORDER_CONSTANT\nint end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\nint current_addr = start_addr+i*LSIZE0;\ncurrent_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\ntemp[i] = src[current_addr];\n}\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\ntemp[i]= ELEM(start_x+i*LSIZE0,0,src_whole_cols,(uchar4)0,temp[i]);\ntemp[i]= ELEM(start_y,0,src_whole_rows,(uchar4)0,temp[i]);\n}\n#else\nint index[READ_TIMES_ROW];\nint s_x,s_y;\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\ns_x = start_x+i*LSIZE0;\nEXTRAPOLATE(s_x, src_whole_cols);\ns_y = start_y;\nEXTRAPOLATE(s_y, src_whole_rows);\nindex[i]=mad24(s_y,src_step_in_pixel,s_x);\n}\nfor (i = 0; i<READ_TIMES_ROW; i++)\ntemp[i] = src[index[i]];\n#endif\nfor (i = 0; i<READ_TIMES_ROW; i++)\nLDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum =convert_float4(LDS_DAT[l_y][l_x+RADIUSX])*mat_kernel[RADIUSX];\nfor (i=1; i<=RADIUSX; i++)\n{\ntemp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\ntemp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\nsum += convert_float4(temp[0])*mat_kernel[RADIUSX-i]+convert_float4(temp[1])*mat_kernel[RADIUSX+i];\n}\nif (x<dst_cols && y<dst_rows)\n{\nstart_addr = mad24(y,dst_step_in_pixel,x);\ndst[start_addr] = sum;\n}\n}\n__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C1_D5\n(__global float * restrict src,\n__global float * dst,\nint dst_cols, int dst_rows,\nint src_whole_cols, int src_whole_rows,\nint src_step_in_pixel,\nint src_offset_x, int src_offset_y,\nint dst_step_in_pixel, int radiusy,\n__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nint l_x = get_local_id(0);\nint l_y = get_local_id(1);\nint start_x = x+src_offset_x-RADIUSX;\nint start_y = y+src_offset_y-radiusy;\nint start_addr = mad24(start_y,src_step_in_pixel,start_x);\nint i;\nfloat sum;\nfloat temp[READ_TIMES_ROW];\n__local float LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n#ifdef BORDER_CONSTANT\nint end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\nint current_addr = start_addr+i*LSIZE0;\ncurrent_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\ntemp[i] = src[current_addr];\n}\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\ntemp[i]= ELEM(start_x+i*LSIZE0,0,src_whole_cols,(float)0,temp[i]);\ntemp[i]= ELEM(start_y,0,src_whole_rows,(float)0,temp[i]);\n}\n#else\nint index[READ_TIMES_ROW];\nint s_x,s_y;\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\ns_x = start_x + i*LSIZE0, s_y = start_y;\nEXTRAPOLATE(s_x, src_whole_cols);\nEXTRAPOLATE(s_y, src_whole_rows);\nindex[i]=mad24(s_y, src_step_in_pixel, s_x);\n}\nfor (i = 0; i<READ_TIMES_ROW; i++)\ntemp[i] = src[index[i]];\n#endif\nfor (i = 0; i<READ_TIMES_ROW; i++)\nLDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum =LDS_DAT[l_y][l_x+RADIUSX]*mat_kernel[RADIUSX];\nfor (i=1; i<=RADIUSX; i++)\n{\ntemp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\ntemp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\nsum += temp[0]*mat_kernel[RADIUSX-i]+temp[1]*mat_kernel[RADIUSX+i];\n}\nif (x<dst_cols && y<dst_rows)\n{\nstart_addr = mad24(y,dst_step_in_pixel,x);\ndst[start_addr] = sum;\n}\n}\n__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C4_D5\n(__global float4 * restrict src,\n__global float4 * dst,\nint dst_cols, int dst_rows,\nint src_whole_cols, int src_whole_rows,\nint src_step_in_pixel,\nint src_offset_x, int src_offset_y,\nint dst_step_in_pixel, int radiusy,\n__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nint l_x = get_local_id(0);\nint l_y = get_local_id(1);\nint start_x = x+src_offset_x-RADIUSX;\nint start_y = y+src_offset_y-radiusy;\nint start_addr = mad24(start_y,src_step_in_pixel,start_x);\nint i;\nfloat4 sum;\nfloat4 temp[READ_TIMES_ROW];\n__local float4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n#ifdef BORDER_CONSTANT\nint end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\nint current_addr = start_addr+i*LSIZE0;\ncurrent_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\ntemp[i] = src[current_addr];\n}\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\ntemp[i]= ELEM(start_x+i*LSIZE0,0,src_whole_cols,(float4)0,temp[i]);\ntemp[i]= ELEM(start_y,0,src_whole_rows,(float4)0,temp[i]);\n}\n#else\nint index[READ_TIMES_ROW];\nint s_x,s_y;\nfor (i = 0; i<READ_TIMES_ROW; i++)\n{\ns_x = start_x + i*LSIZE0, s_y = start_y;\nEXTRAPOLATE(s_x, src_whole_cols);\nEXTRAPOLATE(s_y, src_whole_rows);\nindex[i]=mad24(s_y,src_step_in_pixel,s_x);\n}\nfor (i = 0; i<READ_TIMES_ROW; i++)\ntemp[i] = src[index[i]];\n#endif\nfor (i = 0; i<READ_TIMES_ROW; i++)\nLDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum =LDS_DAT[l_y][l_x+RADIUSX]*mat_kernel[RADIUSX];\nfor (i=1; i<=RADIUSX; i++)\n{\ntemp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\ntemp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\nsum += temp[0]*mat_kernel[RADIUSX-i]+temp[1]*mat_kernel[RADIUSX+i];\n}\nif (x<dst_cols && y<dst_rows)\n{\nstart_addr = mad24(y,dst_step_in_pixel,x);\ndst[start_addr] = sum;\n}\n}\n", "f8d165185422bdb2670abb440bc50225", "filter_sep_col", "#define READ_TIMES_COL ((2*(RADIUSY+LSIZE1)-1)/LSIZE1)\n#define RADIUS 1\n#if CN ==1\n#define ALIGN (((RADIUS)+3)>>2<<2)\n#elif CN==2\n#define ALIGN (((RADIUS)+1)>>1<<1)\n#elif CN==3\n#define ALIGN (((RADIUS)+3)>>2<<2)\n#elif CN==4\n#define ALIGN (RADIUS)\n#define READ_TIMES_ROW ((2*(RADIUS+LSIZE0)-1)/LSIZE0)\n#endif\n__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void col_filter\n(__global const GENTYPE_SRC * restrict src,\n__global GENTYPE_DST * dst,\nconst int dst_cols,\nconst int dst_rows,\nconst int src_whole_cols,\nconst int src_whole_rows,\nconst int src_step_in_pixel,\nconst int dst_step_in_pixel,\nconst int dst_offset_in_pixel,\n__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSY+1)))))\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nint l_x = get_local_id(0);\nint l_y = get_local_id(1);\nint start_addr = mad24(y, src_step_in_pixel, x);\nint end_addr = mad24(src_whole_rows - 1, src_step_in_pixel, src_whole_cols);\nint i;\nGENTYPE_SRC sum, temp[READ_TIMES_COL];\n__local GENTYPE_SRC LDS_DAT[LSIZE1 * READ_TIMES_COL][LSIZE0 + 1];\nfor(i = 0;i<READ_TIMES_COL;i++)\n{\nint current_addr = start_addr+i*LSIZE1*src_step_in_pixel;\ncurrent_addr = current_addr < end_addr ? current_addr : 0;\ntemp[i] = src[current_addr];\n}\nfor(i = 0;i<READ_TIMES_COL;i++)\n{\nLDS_DAT[l_y+i*LSIZE1][l_x] = temp[i];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nsum = LDS_DAT[l_y+RADIUSY][l_x]*mat_kernel[RADIUSY];\nfor(i=1;i<=RADIUSY;i++)\n{\ntemp[0]=LDS_DAT[l_y+RADIUSY-i][l_x];\ntemp[1]=LDS_DAT[l_y+RADIUSY+i][l_x];\nsum += temp[0] * mat_kernel[RADIUSY-i]+temp[1] * mat_kernel[RADIUSY+i];\n}\nif((x<dst_cols) & (y<dst_rows))\n{\nstart_addr = mad24(y,dst_step_in_pixel,x+dst_offset_in_pixel);\ndst[start_addr] = convert_to_DST(sum);\n}\n}\n", "06a58fab4710a0c1f63d1a16efbeddf8", "cvt_color", "#ifndef hscale\n#define hscale 0\n#endif\n#ifndef hrange\n#define hrange 0\n#endif\n#ifdef DEPTH_0\n#define DATA_TYPE uchar\n#define VECTOR2 uchar2\n#define VECTOR4 uchar4\n#define VECTOR8 uchar8\n#define VECTOR16 uchar16\n#define COEFF_TYPE int\n#define MAX_NUM  255\n#define HALF_MAX 128\n#define SAT_CAST(num) convert_uchar_sat_rte(num)\n#define SAT_CAST2(num) convert_uchar2_sat(num)\n#define SAT_CAST4(num) convert_uchar4_sat(num)\n#endif\n#ifdef DEPTH_2\n#define DATA_TYPE ushort\n#define VECTOR2 ushort2\n#define VECTOR4 ushort4\n#define VECTOR8 ushort8\n#define VECTOR16 ushort16\n#define COEFF_TYPE int\n#define MAX_NUM  65535\n#define HALF_MAX 32768\n#define SAT_CAST(num) convert_ushort_sat_rte(num)\n#define SAT_CAST2(num) convert_ushort2_sat(num)\n#define SAT_CAST4(num) convert_ushort4_sat(num)\n#endif\n#ifdef DEPTH_5\n#define DATA_TYPE float\n#define VECTOR2 float2\n#define VECTOR4 float4\n#define VECTOR8 float8\n#define VECTOR16 float16\n#define COEFF_TYPE float\n#define MAX_NUM  1.0f\n#define HALF_MAX 0.5f\n#define SAT_CAST(num) (num)\n#endif\n#ifndef bidx\n#define bidx 0\n#endif\n#ifndef pixels_per_work_item\n#define pixels_per_work_item 1\n#endif\n#define CV_DESCALE(x, n) (((x) + (1 << ((n)-1))) >> (n))\nenum\n{\nyuv_shift  = 14,\nxyz_shift  = 12,\nhsv_shift  = 12,\nR2Y        = 4899,\nG2Y        = 9617,\nB2Y        = 1868,\nBLOCK_SIZE = 256\n};\n__constant float c_RGB2GrayCoeffs_f[3]  = { 0.114f, 0.587f, 0.299f };\n__constant int   c_RGB2GrayCoeffs_i[3]  = { B2Y, G2Y, R2Y };\n__kernel void RGB2Gray(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0) * pixels_per_work_item;\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nint src_idx = mad24(y, src_step, src_offset + (x << 2));\nint dst_idx = mad24(y, dst_step, dst_offset + x);\n#ifndef INTEL_DEVICE\n#ifdef DEPTH_5\ndst[dst_idx] = src[src_idx + bidx] * 0.114f + src[src_idx + 1] * 0.587f + src[src_idx + (bidx^2)] * 0.299f;\n#else\ndst[dst_idx] = (DATA_TYPE)CV_DESCALE((src[src_idx + bidx] * B2Y + src[src_idx + 1] * G2Y + src[src_idx + (bidx^2)] * R2Y), yuv_shift);\n#endif\n#else\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#ifdef DEPTH_5\n__constant float * coeffs = c_RGB2GrayCoeffs_f;\n#else\n__constant int * coeffs = c_RGB2GrayCoeffs_i;\n#endif\n#if (1 == pixels_per_work_item)\n{\n#ifdef DEPTH_5\n*dst_ptr = src_ptr[bidx] * coeffs[0] + src_ptr[1] * coeffs[1] + src_ptr[(bidx^2)] *coeffs[2];\n#else\n*dst_ptr = (DATA_TYPE)CV_DESCALE((src_ptr[bidx] * coeffs[0] + src_ptr[1] * coeffs[1] + src_ptr[(bidx^2)] * coeffs[2]), yuv_shift);\n#endif\n}\n#elif (2 == pixels_per_work_item)\n{\nconst VECTOR8 r0 = vload8(0, src_ptr);\n#ifdef DEPTH_5\nconst float2 c0 = r0.s04;\nconst float2 c1 = r0.s15;\nconst float2 c2 = r0.s26;\nconst float2 Y = c0 * coeffs[bidx] + c1 * coeffs[1] + c2 * coeffs[bidx^2];\n#else\nconst int2 c0 = convert_int2(r0.s04);\nconst int2 c1 = convert_int2(r0.s15);\nconst int2 c2 = convert_int2(r0.s26);\nconst int2 yi = CV_DESCALE(c0 * coeffs[bidx] + c1 * coeffs[1] + c2 * coeffs[bidx^2], yuv_shift);\nconst VECTOR2 Y = SAT_CAST2(yi);\n#endif\nvstore2(Y, 0, dst_ptr);\n}\n#elif (4 == pixels_per_work_item)\n{\n#ifndef DEPTH_5\nconst VECTOR16 r0 = vload16(0, src_ptr);\nconst int4 c0 = convert_int4(r0.s048c);\nconst int4 c1 = convert_int4(r0.s159d);\nconst int4 c2 = convert_int4(r0.s26ae);\nconst int4 Y = CV_DESCALE(c0 * coeffs[bidx] + c1 * coeffs[1] + c2 * coeffs[bidx^2], yuv_shift);\nvstore4(SAT_CAST4(Y), 0, dst_ptr);\n#endif\n}\n#endif\n#endif\n}\n}\n__kernel void Gray2RGB(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + (x << 2));\nDATA_TYPE val = src[src_idx];\ndst[dst_idx] = val;\ndst[dst_idx + 1] = val;\ndst[dst_idx + 2] = val;\n#if dcn == 4\ndst[dst_idx + 3] = MAX_NUM;\n#endif\n}\n}\n__constant float c_RGB2YUVCoeffs_f[5]  = { 0.114f, 0.587f, 0.299f, 0.492f, 0.877f };\n__constant int   c_RGB2YUVCoeffs_i[5]  = { B2Y, G2Y, R2Y, 8061, 14369 };\n__kernel void RGB2YUV(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0) * pixels_per_work_item;\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#ifdef DEPTH_5\n__constant float * coeffs = c_RGB2YUVCoeffs_f;\n#else\n__constant int * coeffs = c_RGB2YUVCoeffs_i;\nconst int delta = HALF_MAX * (1 << yuv_shift);\n#endif\n#if (1 == pixels_per_work_item)\n{\nconst DATA_TYPE rgb[] = {src_ptr[0], src_ptr[1], src_ptr[2]};\n#ifdef DEPTH_5\nfloat Y = rgb[0] * coeffs[bidx^2] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx];\nfloat U = (rgb[bidx^2] - Y) * coeffs[3] + HALF_MAX;\nfloat V = (rgb[bidx] - Y) * coeffs[4] + HALF_MAX;\n#else\nint Y = CV_DESCALE(rgb[0] * coeffs[bidx^2] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx], yuv_shift);\nint U = CV_DESCALE((rgb[bidx^2] - Y) * coeffs[3] + delta, yuv_shift);\nint V = CV_DESCALE((rgb[bidx] - Y) * coeffs[4] + delta, yuv_shift);\n#endif\ndst_ptr[0] = SAT_CAST( Y );\ndst_ptr[1] = SAT_CAST( U );\ndst_ptr[2] = SAT_CAST( V );\n}\n#elif (2 == pixels_per_work_item)\n{\nconst VECTOR8 r0 = vload8(0, src_ptr);\n#ifdef DEPTH_5\nconst float2 c0 = r0.s04;\nconst float2 c1 = r0.s15;\nconst float2 c2 = r0.s26;\nconst float2 Y = (bidx == 0) ? (c0 * coeffs[2] + c1 * coeffs[1] + c2 * coeffs[0]) : (c0 * coeffs[0] + c1 * coeffs[1] + c2 * coeffs[2]);\nconst float2 U = (bidx == 0) ? ((c2 - Y) * coeffs[3] + HALF_MAX) : ((c0 - Y) * coeffs[3] + HALF_MAX);\nconst float2 V = (bidx == 0) ? ((c0 - Y) * coeffs[4] + HALF_MAX) : ((c2 - Y) * coeffs[4] + HALF_MAX);\n#else\nconst int2 c0 = convert_int2(r0.s04);\nconst int2 c1 = convert_int2(r0.s15);\nconst int2 c2 = convert_int2(r0.s26);\nconst int2 yi = (bidx == 0) ? CV_DESCALE(c0 * coeffs[2] + c1 * coeffs[1] + c2 * coeffs[0], yuv_shift) : CV_DESCALE(c0 * coeffs[0] + c1 * coeffs[1] + c2 * coeffs[2], yuv_shift);\nconst int2 ui = (bidx == 0) ? CV_DESCALE((c2 - yi) * coeffs[3] + delta, yuv_shift) : CV_DESCALE((c0 - yi) * coeffs[3] + delta, yuv_shift);\nconst int2 vi = (bidx == 0) ? CV_DESCALE((c0 - yi) * coeffs[4] + delta, yuv_shift) : CV_DESCALE((c2 - yi) * coeffs[4] + delta, yuv_shift);\nconst VECTOR2 Y = SAT_CAST2(yi);\nconst VECTOR2 U = SAT_CAST2(ui);\nconst VECTOR2 V = SAT_CAST2(vi);\n#endif\nvstore8((VECTOR8)(Y.s0, U.s0, V.s0, 0, Y.s1, U.s1, V.s1, 0), 0, dst_ptr);\n}\n#elif (4 == pixels_per_work_item)\n{\n#ifndef DEPTH_5\nconst VECTOR16 r0 = vload16(0, src_ptr);\nconst int4 c0 = convert_int4(r0.s048c);\nconst int4 c1 = convert_int4(r0.s159d);\nconst int4 c2 = convert_int4(r0.s26ae);\nconst int4 yi = (bidx == 0) ? CV_DESCALE(c0 * coeffs[2] + c1 * coeffs[1] + c2 * coeffs[0], yuv_shift) : CV_DESCALE(c0 * coeffs[0] + c1 * coeffs[1] + c2 * coeffs[2], yuv_shift);\nconst int4 ui = (bidx == 0) ? CV_DESCALE((c2 - yi) * coeffs[3] + delta, yuv_shift) : CV_DESCALE((c0 - yi) * coeffs[3] + delta, yuv_shift);\nconst int4 vi = (bidx == 0) ? CV_DESCALE((c0 - yi) * coeffs[4] + delta, yuv_shift) : CV_DESCALE((c2 - yi) * coeffs[4] + delta, yuv_shift);\nconst VECTOR4 Y = SAT_CAST4(yi);\nconst VECTOR4 U = SAT_CAST4(ui);\nconst VECTOR4 V = SAT_CAST4(vi);\nvstore16((VECTOR16)(Y.s0, U.s0, V.s0, 0, Y.s1, U.s1, V.s1, 0, Y.s2, U.s2, V.s2, 0, Y.s3, U.s3, V.s3, 0), 0, dst_ptr);\n#endif\n}\n#endif\n}\n}\n__constant float c_YUV2RGBCoeffs_f[5] = { 2.032f, -0.395f, -0.581f, 1.140f };\n__constant int   c_YUV2RGBCoeffs_i[5] = { 33292, -6472, -9519, 18678 };\n__kernel void YUV2RGB(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0) * pixels_per_work_item;\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#ifdef DEPTH_5\n__constant float * coeffs = c_YUV2RGBCoeffs_f;\n#else\n__constant int * coeffs = c_YUV2RGBCoeffs_i;\n#endif\n#if (1 == pixels_per_work_item)\n{\nconst DATA_TYPE yuv[] = {src_ptr[0], src_ptr[1], src_ptr[2]};\n#ifdef DEPTH_5\nfloat B = yuv[0] + (yuv[2] - HALF_MAX) * coeffs[3];\nfloat G = yuv[0] + (yuv[2] - HALF_MAX) * coeffs[2] + (yuv[1] - HALF_MAX) * coeffs[1];\nfloat R = yuv[0] + (yuv[1] - HALF_MAX) * coeffs[0];\n#else\nint B = yuv[0] + CV_DESCALE((yuv[2] - HALF_MAX) * coeffs[3], yuv_shift);\nint G = yuv[0] + CV_DESCALE((yuv[2] - HALF_MAX) * coeffs[2] + (yuv[1] - HALF_MAX) * coeffs[1], yuv_shift);\nint R = yuv[0] + CV_DESCALE((yuv[1] - HALF_MAX) * coeffs[0], yuv_shift);\n#endif\ndst_ptr[bidx]     = SAT_CAST( B );\ndst_ptr[1]        = SAT_CAST( G );\ndst_ptr[(bidx^2)] = SAT_CAST( R );\n#if dcn == 4\ndst_ptr[3]         = MAX_NUM;\n#endif\n}\n#elif (2 == pixels_per_work_item)\n{\nconst VECTOR8 r0 = vload8(0, src_ptr);\n#ifdef DEPTH_5\nconst float2 Y = r0.s04;\nconst float2 U = r0.s15;\nconst float2 V = r0.s26;\nconst float2 c0 = (bidx == 0) ? (Y + (V - HALF_MAX) * coeffs[3]) : (Y + (U - HALF_MAX) * coeffs[0]);\nconst float2 c1 = Y + (V - HALF_MAX) * coeffs[2] + (U - HALF_MAX) * coeffs[1];\nconst float2 c2 = (bidx == 0) ? (Y + (U - HALF_MAX) * coeffs[0]) : (Y + (V - HALF_MAX) * coeffs[3]);\n#else\nconst int2 Y = convert_int2(r0.s04);\nconst int2 U = convert_int2(r0.s15);\nconst int2 V = convert_int2(r0.s26);\nconst int2 c0i = (bidx == 0) ? (Y + CV_DESCALE((V - HALF_MAX) * coeffs[3], yuv_shift)) : (Y + CV_DESCALE((U - HALF_MAX) * coeffs[0], yuv_shift));\nconst int2 c1i = Y + CV_DESCALE((V - HALF_MAX) * coeffs[2] + (U - HALF_MAX) * coeffs[1], yuv_shift);\nconst int2 c2i = (bidx == 0) ? (Y + CV_DESCALE((U - HALF_MAX) * coeffs[0], yuv_shift)) : (Y + CV_DESCALE((V - HALF_MAX) * coeffs[3], yuv_shift));\nconst VECTOR2 c0 = SAT_CAST2(c0i);\nconst VECTOR2 c1 = SAT_CAST2(c1i);\nconst VECTOR2 c2 = SAT_CAST2(c2i);\n#endif\n#if dcn == 4\nvstore8((VECTOR8)(c0.s0, c1.s0, c2.s0, MAX_NUM, c0.s1, c1.s1, c2.s1, MAX_NUM), 0, dst_ptr);\n#else\nvstore8((VECTOR8)(c0.s0, c1.s0, c2.s0, 0, c0.s1, c1.s1, c2.s1, 0), 0, dst_ptr);\n#endif\n}\n#elif (4 == pixels_per_work_item)\n{\n#ifndef DEPTH_5\nconst VECTOR16 r0 = vload16(0, src_ptr);\nconst int4 Y = convert_int4(r0.s048c);\nconst int4 U = convert_int4(r0.s159d);\nconst int4 V = convert_int4(r0.s26ae);\nconst int4 c0i = (bidx == 0) ? (Y + CV_DESCALE((V - HALF_MAX) * coeffs[3], yuv_shift)) : (Y + CV_DESCALE((U - HALF_MAX) * coeffs[0], yuv_shift));\nconst int4 c1i = Y + CV_DESCALE((V - HALF_MAX) * coeffs[2] + (U - HALF_MAX) * coeffs[1], yuv_shift);\nconst int4 c2i = (bidx == 0) ? (Y + CV_DESCALE((U - HALF_MAX) * coeffs[0], yuv_shift)) : (Y + CV_DESCALE((V - HALF_MAX) * coeffs[3], yuv_shift));\nconst VECTOR4 c0 = SAT_CAST4(c0i);\nconst VECTOR4 c1 = SAT_CAST4(c1i);\nconst VECTOR4 c2 = SAT_CAST4(c2i);\n#if dcn == 4\nvstore16((VECTOR16)(c0.s0, c1.s0, c2.s0, MAX_NUM, c0.s1, c1.s1, c2.s1, MAX_NUM, c0.s2, c1.s2, c2.s2, MAX_NUM, c0.s3, c1.s3, c2.s3, MAX_NUM), 0, dst_ptr);\n#else\nvstore16((VECTOR16)(c0.s0, c1.s0, c2.s0, 0, c0.s1, c1.s1, c2.s1, 0, c0.s2, c1.s2, c2.s2, 0, c0.s3, c1.s3, c2.s3, 0), 0, dst_ptr);\n#endif\n#endif\n}\n#endif\n}\n}\n__constant int ITUR_BT_601_CY = 1220542;\n__constant int ITUR_BT_601_CUB = 2116026;\n__constant int ITUR_BT_601_CUG = 409993;\n__constant int ITUR_BT_601_CVG = 852492;\n__constant int ITUR_BT_601_CVR = 1673527;\n__constant int ITUR_BT_601_SHIFT = 20;\n__kernel void YUV2RGBA_NV12(int cols, int rows, int src_step, int dst_step,\n__global const uchar* src, __global uchar* dst,\nint src_offset, int dst_offset)\n{\nconst int x = get_global_id(0);\nconst int y = get_global_id(1);\nif (y < rows / 2 && x < cols / 2 )\n{\n__global const uchar* ysrc = src + mad24(y << 1, src_step, (x << 1) + src_offset);\n__global const uchar* usrc = src + mad24(rows + y, src_step, (x << 1) + src_offset);\n__global uchar*       dst1 = dst + mad24(y << 1, dst_step, (x << 3) + dst_offset);\n__global uchar*       dst2 = dst + mad24((y << 1) + 1, dst_step, (x << 3) + dst_offset);\nint Y1 = ysrc[0];\nint Y2 = ysrc[1];\nint Y3 = ysrc[src_step];\nint Y4 = ysrc[src_step + 1];\nint U  = usrc[0] - 128;\nint V  = usrc[1] - 128;\nint ruv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CVR * V;\nint guv = (1 << (ITUR_BT_601_SHIFT - 1)) - ITUR_BT_601_CVG * V - ITUR_BT_601_CUG * U;\nint buv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CUB * U;\nY1 = max(0, Y1 - 16) * ITUR_BT_601_CY;\ndst1[2 - bidx]     = convert_uchar_sat((Y1 + ruv) >> ITUR_BT_601_SHIFT);\ndst1[1]        = convert_uchar_sat((Y1 + guv) >> ITUR_BT_601_SHIFT);\ndst1[bidx] = convert_uchar_sat((Y1 + buv) >> ITUR_BT_601_SHIFT);\ndst1[3]        = 255;\nY2 = max(0, Y2 - 16) * ITUR_BT_601_CY;\ndst1[6 - bidx] = convert_uchar_sat((Y2 + ruv) >> ITUR_BT_601_SHIFT);\ndst1[5]        = convert_uchar_sat((Y2 + guv) >> ITUR_BT_601_SHIFT);\ndst1[4 + bidx] = convert_uchar_sat((Y2 + buv) >> ITUR_BT_601_SHIFT);\ndst1[7]        = 255;\nY3 = max(0, Y3 - 16) * ITUR_BT_601_CY;\ndst2[2 - bidx]     = convert_uchar_sat((Y3 + ruv) >> ITUR_BT_601_SHIFT);\ndst2[1]        = convert_uchar_sat((Y3 + guv) >> ITUR_BT_601_SHIFT);\ndst2[bidx] = convert_uchar_sat((Y3 + buv) >> ITUR_BT_601_SHIFT);\ndst2[3]        = 255;\nY4 = max(0, Y4 - 16) * ITUR_BT_601_CY;\ndst2[6 - bidx] = convert_uchar_sat((Y4 + ruv) >> ITUR_BT_601_SHIFT);\ndst2[5]        = convert_uchar_sat((Y4 + guv) >> ITUR_BT_601_SHIFT);\ndst2[4 + bidx] = convert_uchar_sat((Y4 + buv) >> ITUR_BT_601_SHIFT);\ndst2[7]        = 255;\n}\n}\n__constant float c_RGB2YCrCbCoeffs_f[5] = {0.299f, 0.587f, 0.114f, 0.713f, 0.564f};\n__constant int   c_RGB2YCrCbCoeffs_i[5] = {R2Y, G2Y, B2Y, 11682, 9241};\n__kernel void RGB2YCrCb(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0) * pixels_per_work_item;\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#ifdef DEPTH_5\n__constant float * coeffs = c_RGB2YCrCbCoeffs_f;\n#else\n__constant int * coeffs = c_RGB2YCrCbCoeffs_i;\nconst int delta = HALF_MAX * (1 << yuv_shift);\n#endif\n#if (1 == pixels_per_work_item)\n{\nconst DATA_TYPE rgb[] = {src_ptr[0], src_ptr[1], src_ptr[2]};\n#ifdef DEPTH_5\nfloat Y  = rgb[0] * coeffs[bidx^2] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx];\nfloat Cr = (rgb[bidx^2] - Y) * coeffs[3] + HALF_MAX;\nfloat Cb = (rgb[bidx] - Y) * coeffs[4] + HALF_MAX;\n#else\nint Y =  CV_DESCALE(rgb[0] * coeffs[bidx^2] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx], yuv_shift);\nint Cr = CV_DESCALE((rgb[bidx^2] - Y) * coeffs[3] + delta, yuv_shift);\nint Cb = CV_DESCALE((rgb[bidx] - Y) * coeffs[4] + delta, yuv_shift);\n#endif\ndst_ptr[0] = SAT_CAST( Y );\ndst_ptr[1] = SAT_CAST( Cr );\ndst_ptr[2] = SAT_CAST( Cb );\n}\n#elif (2 == pixels_per_work_item)\n{\nconst VECTOR8 r0 = vload8(0, src_ptr);\n#ifdef DEPTH_5\nconst float2 c0 = r0.s04;\nconst float2 c1 = r0.s15;\nconst float2 c2 = r0.s26;\nconst float2 Y  = (bidx == 0) ? (c0 * coeffs[2] + c1 * coeffs[1] + c2 * coeffs[0]) : (c0 * coeffs[0] + c1 * coeffs[1] + c2 * coeffs[2]);\nconst float2 Cr = (bidx == 0) ? ((c2 - Y) * coeffs[3] + HALF_MAX) : ((c0 - Y) * coeffs[3] + HALF_MAX);\nconst float2 Cb = (bidx == 0) ? ((c0 - Y) * coeffs[4] + HALF_MAX) : ((c2 - Y) * coeffs[4] + HALF_MAX);\n#else\nconst int2 c0 = convert_int2(r0.s04);\nconst int2 c1 = convert_int2(r0.s15);\nconst int2 c2 = convert_int2(r0.s26);\nconst int2 yi = (bidx == 0) ? CV_DESCALE(c0 * coeffs[2] + c1 * coeffs[1] + c2 * coeffs[0], yuv_shift) : CV_DESCALE(c0 * coeffs[0] + c1 * coeffs[1] + c2 * coeffs[2], yuv_shift);\nconst int2 ui = (bidx == 0) ? CV_DESCALE((c2 - yi) * coeffs[3] + delta, yuv_shift) : CV_DESCALE((c0 - yi) * coeffs[3] + delta, yuv_shift);\nconst int2 vi = (bidx == 0) ? CV_DESCALE((c0 - yi) * coeffs[4] + delta, yuv_shift) : CV_DESCALE((c2 - yi) * coeffs[4] + delta, yuv_shift);\nconst VECTOR2 Y  = SAT_CAST2(yi);\nconst VECTOR2 Cr = SAT_CAST2(ui);\nconst VECTOR2 Cb = SAT_CAST2(vi);\n#endif\nvstore8((VECTOR8)(Y.s0, Cr.s0, Cb.s0, 0, Y.s1, Cr.s1, Cb.s1, 0), 0, dst_ptr);\n}\n#elif (4 == pixels_per_work_item)\n{\n#ifndef DEPTH_5\nconst VECTOR16 r0 = vload16(0, src_ptr);\nconst int4 c0 = convert_int4(r0.s048c);\nconst int4 c1 = convert_int4(r0.s159d);\nconst int4 c2 = convert_int4(r0.s26ae);\nconst int4 yi = (bidx == 0) ? CV_DESCALE(c0 * coeffs[2] + c1 * coeffs[1] + c2 * coeffs[0], yuv_shift) : CV_DESCALE(c0 * coeffs[0] + c1 * coeffs[1] + c2 * coeffs[2], yuv_shift);\nconst int4 ui = (bidx == 0) ? CV_DESCALE((c2 - yi) * coeffs[3] + delta, yuv_shift) : CV_DESCALE((c0 - yi) * coeffs[3] + delta, yuv_shift);\nconst int4 vi = (bidx == 0) ? CV_DESCALE((c0 - yi) * coeffs[4] + delta, yuv_shift) : CV_DESCALE((c2 - yi) * coeffs[4] + delta, yuv_shift);\nconst VECTOR4 Y  = SAT_CAST4(yi);\nconst VECTOR4 Cr = SAT_CAST4(ui);\nconst VECTOR4 Cb = SAT_CAST4(vi);\nvstore16((VECTOR16)(Y.s0, Cr.s0, Cb.s0, 0, Y.s1, Cr.s1, Cb.s1, 0, Y.s2, Cr.s2, Cb.s2, 0, Y.s3, Cr.s3, Cb.s3, 0), 0, dst_ptr);\n#endif\n}\n#endif\n}\n}\n__constant float c_YCrCb2RGBCoeffs_f[4] = { 1.403f, -0.714f, -0.344f, 1.773f };\n__constant int   c_YCrCb2RGBCoeffs_i[4] = { 22987, -11698, -5636, 29049 };\n__kernel void YCrCb2RGB(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0) * pixels_per_work_item;\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#ifdef DEPTH_5\n__constant float * coeffs = c_YCrCb2RGBCoeffs_f;\n#else\n__constant int * coeffs = c_YCrCb2RGBCoeffs_i;\n#endif\n#if (1 == pixels_per_work_item)\n{\nconst DATA_TYPE ycrcb[] = {src_ptr[0], src_ptr[1], src_ptr[2]};\n#ifdef DEPTH_5\nfloat B = ycrcb[0] + (ycrcb[2] - HALF_MAX) * coeffs[3];\nfloat G = ycrcb[0] + (ycrcb[2] - HALF_MAX) * coeffs[2] + (ycrcb[1] - HALF_MAX) * coeffs[1];\nfloat R = ycrcb[0] + (ycrcb[1] - HALF_MAX) * coeffs[0];\n#else\nint B = ycrcb[0] + CV_DESCALE((ycrcb[2] - HALF_MAX) * coeffs[3], yuv_shift);\nint G = ycrcb[0] + CV_DESCALE((ycrcb[2] - HALF_MAX) * coeffs[2] + (ycrcb[1] - HALF_MAX) * coeffs[1], yuv_shift);\nint R = ycrcb[0] + CV_DESCALE((ycrcb[1] - HALF_MAX) * coeffs[0], yuv_shift);\n#endif\ndst_ptr[bidx]     = SAT_CAST( B );\ndst_ptr[1]        = SAT_CAST( G );\ndst_ptr[(bidx^2)] = SAT_CAST( R );\n#if dcn == 4\ndst_ptr[3]         = MAX_NUM;\n#endif\n}\n#elif (2 == pixels_per_work_item)\n{\nconst VECTOR8 r0 = vload8(0, src_ptr);\n#ifdef DEPTH_5\nconst float2 Y  = r0.s04;\nconst float2 Cr = r0.s15;\nconst float2 Cb = r0.s26;\nconst float2 c0 = (bidx == 0) ? (Y + (Cb - HALF_MAX) * coeffs[3]) : (Y + (Cr - HALF_MAX) * coeffs[0]);\nconst float2 c1 = Y + (Cb - HALF_MAX) * coeffs[2] + (Cr - HALF_MAX) * coeffs[1];\nconst float2 c2 = (bidx == 0) ? (Y + (Cr - HALF_MAX) * coeffs[0]) : (Y + (Cb - HALF_MAX) * coeffs[3]);\n#else\nconst int2 Y  = convert_int2(r0.s04);\nconst int2 Cr = convert_int2(r0.s15);\nconst int2 Cb = convert_int2(r0.s26);\nconst int2 c0i = (bidx == 0) ? (Y + CV_DESCALE((Cb - HALF_MAX) * coeffs[3], yuv_shift)) : (Y + CV_DESCALE((Cr - HALF_MAX) * coeffs[0], yuv_shift));\nconst int2 c1i = Y + CV_DESCALE((Cb - HALF_MAX) * coeffs[2] + (Cr - HALF_MAX) * coeffs[1], yuv_shift);\nconst int2 c2i = (bidx == 0) ? (Y + CV_DESCALE((Cr - HALF_MAX) * coeffs[0], yuv_shift)) : (Y + CV_DESCALE((Cb - HALF_MAX) * coeffs[3], yuv_shift));\nconst VECTOR2 c0 = SAT_CAST2(c0i);\nconst VECTOR2 c1 = SAT_CAST2(c1i);\nconst VECTOR2 c2 = SAT_CAST2(c2i);\n#endif\n#if dcn == 4\nvstore8((VECTOR8)(c0.s0, c1.s0, c2.s0, MAX_NUM, c0.s1, c1.s1, c2.s1, MAX_NUM), 0, dst_ptr);\n#else\nvstore8((VECTOR8)(c0.s0, c1.s0, c2.s0, 0, c0.s1, c1.s1, c2.s1, 0), 0, dst_ptr);\n#endif\n}\n#elif (4 == pixels_per_work_item)\n{\n#ifndef DEPTH_5\nconst VECTOR16 r0 = vload16(0, src_ptr);\nconst int4 Y  = convert_int4(r0.s048c);\nconst int4 Cr = convert_int4(r0.s159d);\nconst int4 Cb = convert_int4(r0.s26ae);\nconst int4 c0i = (bidx == 0) ? (Y + CV_DESCALE((Cb - HALF_MAX) * coeffs[3], yuv_shift)) : (Y + CV_DESCALE((Cr - HALF_MAX) * coeffs[0], yuv_shift));\nconst int4 c1i = Y + CV_DESCALE((Cb - HALF_MAX) * coeffs[2] + (Cr - HALF_MAX) * coeffs[1], yuv_shift);\nconst int4 c2i = (bidx == 0) ? (Y + CV_DESCALE((Cr - HALF_MAX) * coeffs[0], yuv_shift)) : (Y + CV_DESCALE((Cb - HALF_MAX) * coeffs[3], yuv_shift));\nconst VECTOR4 c0 = SAT_CAST4(c0i);\nconst VECTOR4 c1 = SAT_CAST4(c1i);\nconst VECTOR4 c2 = SAT_CAST4(c2i);\n#if dcn == 4\nvstore16((VECTOR16)(c0.s0, c1.s0, c2.s0, MAX_NUM, c0.s1, c1.s1, c2.s1, MAX_NUM, c0.s2, c1.s2, c2.s2, MAX_NUM, c0.s3, c1.s3, c2.s3, MAX_NUM), 0, dst_ptr);\n#else\nvstore16((VECTOR16)(c0.s0, c1.s0, c2.s0, 0, c0.s1, c1.s1, c2.s1, 0, c0.s2, c1.s2, c2.s2, 0, c0.s3, c1.s3, c2.s3, 0), 0, dst_ptr);\n#endif\n#endif\n}\n#endif\n}\n}\n__kernel void RGB2XYZ(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset, __constant COEFF_TYPE * coeffs)\n{\nint dx = get_global_id(0) * pixels_per_work_item;\nint dy = get_global_id(1);\nif (dy < rows && dx < cols)\n{\ndx <<= 2;\nint src_idx = mad24(dy, src_step, src_offset + dx);\nint dst_idx = mad24(dy, dst_step, dst_offset + dx);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#if (1 == pixels_per_work_item)\n{\nDATA_TYPE R = src_ptr[0], G = src_ptr[1], B = src_ptr[2];\n#ifdef DEPTH_5\nfloat X = R * coeffs[0] + G * coeffs[1] + B * coeffs[2];\nfloat Y = R * coeffs[3] + G * coeffs[4] + B * coeffs[5];\nfloat Z = R * coeffs[6] + G * coeffs[7] + B * coeffs[8];\n#else\nint X = CV_DESCALE(R * coeffs[0] + G * coeffs[1] + B * coeffs[2], xyz_shift);\nint Y = CV_DESCALE(R * coeffs[3] + G * coeffs[4] + B * coeffs[5], xyz_shift);\nint Z = CV_DESCALE(R * coeffs[6] + G * coeffs[7] + B * coeffs[8], xyz_shift);\n#endif\ndst_ptr[0] = SAT_CAST( X );\ndst_ptr[1] = SAT_CAST( Y );\ndst_ptr[2] = SAT_CAST( Z );\n}\n#elif (2 == pixels_per_work_item)\n{\nconst VECTOR8 r0 = vload8(0, src_ptr);\n#ifdef DEPTH_5\nconst float2 R = r0.s04;\nconst float2 G = r0.s15;\nconst float2 B = r0.s26;\nconst float2 X = R * coeffs[0] + G * coeffs[1] + B * coeffs[2];\nconst float2 Y = R * coeffs[3] + G * coeffs[4] + B * coeffs[5];\nconst float2 Z = R * coeffs[6] + G * coeffs[7] + B * coeffs[8];\n#else\nconst int2 R = convert_int2(r0.s04);\nconst int2 G = convert_int2(r0.s15);\nconst int2 B = convert_int2(r0.s26);\nconst int2 xi = CV_DESCALE(R * coeffs[0] + G * coeffs[1] + B * coeffs[2], xyz_shift);\nconst int2 yi = CV_DESCALE(R * coeffs[3] + G * coeffs[4] + B * coeffs[5], xyz_shift);\nconst int2 zi = CV_DESCALE(R * coeffs[6] + G * coeffs[7] + B * coeffs[8], xyz_shift);\nconst VECTOR2 X = SAT_CAST2(xi);\nconst VECTOR2 Y = SAT_CAST2(yi);\nconst VECTOR2 Z = SAT_CAST2(zi);\n#endif\nvstore8((VECTOR8)(X.s0, Y.s0, Z.s0, 0, X.s1, Y.s1, Z.s1, 0), 0, dst_ptr);\n}\n#elif (4 == pixels_per_work_item)\n{\n#ifndef DEPTH_5\nconst VECTOR16 r0 = vload16(0, src_ptr);\nconst int4 R = convert_int4(r0.s048c);\nconst int4 G = convert_int4(r0.s159d);\nconst int4 B = convert_int4(r0.s26ae);\nconst int4 xi = CV_DESCALE(R * coeffs[0] + G * coeffs[1] + B * coeffs[2], xyz_shift);\nconst int4 yi = CV_DESCALE(R * coeffs[3] + G * coeffs[4] + B * coeffs[5], xyz_shift);\nconst int4 zi = CV_DESCALE(R * coeffs[6] + G * coeffs[7] + B * coeffs[8], xyz_shift);\nconst VECTOR4 X = SAT_CAST4(xi);\nconst VECTOR4 Y = SAT_CAST4(yi);\nconst VECTOR4 Z = SAT_CAST4(zi);\nvstore16((VECTOR16)(X.s0, Y.s0, Z.s0, 0, X.s1, Y.s1, Z.s1, 0, X.s2, Y.s2, Z.s2, 0, X.s3, Y.s3, Z.s3, 0), 0, dst_ptr);\n#endif\n}\n#endif\n}\n}\n__kernel void XYZ2RGB(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE* src, __global DATA_TYPE* dst,\nint src_offset, int dst_offset, __constant COEFF_TYPE * coeffs)\n{\nint dx = get_global_id(0) * pixels_per_work_item;\nint dy = get_global_id(1);\nif (dy < rows && dx < cols)\n{\ndx <<= 2;\nint src_idx = mad24(dy, src_step, src_offset + dx);\nint dst_idx = mad24(dy, dst_step, dst_offset + dx);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#if (1 == pixels_per_work_item)\n{\nconst DATA_TYPE X = src_ptr[0], Y = src_ptr[1], Z = src_ptr[2];\n#ifdef DEPTH_5\nfloat B = X * coeffs[0] + Y * coeffs[1] + Z * coeffs[2];\nfloat G = X * coeffs[3] + Y * coeffs[4] + Z * coeffs[5];\nfloat R = X * coeffs[6] + Y * coeffs[7] + Z * coeffs[8];\n#else\nint B = CV_DESCALE(X * coeffs[0] + Y * coeffs[1] + Z * coeffs[2], xyz_shift);\nint G = CV_DESCALE(X * coeffs[3] + Y * coeffs[4] + Z * coeffs[5], xyz_shift);\nint R = CV_DESCALE(X * coeffs[6] + Y * coeffs[7] + Z * coeffs[8], xyz_shift);\n#endif\ndst_ptr[0] = SAT_CAST( B );\ndst_ptr[1] = SAT_CAST( G );\ndst_ptr[2] = SAT_CAST( R );\n#if dcn == 4\ndst_ptr[3] = MAX_NUM;\n#endif\n}\n#elif (2 == pixels_per_work_item)\n{\nconst VECTOR8 r0 = vload8(0, src_ptr);\n#ifdef DEPTH_5\nconst float2 X = r0.s04;\nconst float2 Y = r0.s15;\nconst float2 Z = r0.s26;\nfloat2 B = X * coeffs[0] + Y * coeffs[1] + Z * coeffs[2];\nfloat2 G = X * coeffs[3] + Y * coeffs[4] + Z * coeffs[5];\nfloat2 R = X * coeffs[6] + Y * coeffs[7] + Z * coeffs[8];\n#else\nconst int2 xi = convert_int2(r0.s04);\nconst int2 yi = convert_int2(r0.s15);\nconst int2 zi = convert_int2(r0.s26);\nconst int2 bi = CV_DESCALE(xi * coeffs[0] + yi * coeffs[1] + zi * coeffs[2], xyz_shift);\nconst int2 gi = CV_DESCALE(xi * coeffs[3] + yi * coeffs[4] + zi * coeffs[5], xyz_shift);\nconst int2 ri = CV_DESCALE(xi * coeffs[6] + yi * coeffs[7] + zi * coeffs[8], xyz_shift);\nconst VECTOR2 R = SAT_CAST2(ri);\nconst VECTOR2 G = SAT_CAST2(gi);\nconst VECTOR2 B = SAT_CAST2(bi);\n#endif\n#if dcn == 4\nvstore8((VECTOR8)(B.s0, G.s0, R.s0, MAX_NUM, B.s1, G.s1, R.s1, MAX_NUM), 0, dst_ptr);\n#else\nvstore8((VECTOR8)(B.s0, G.s0, R.s0, 0, B.s1, G.s1, R.s1, 0), 0, dst_ptr);\n#endif\n}\n#elif (4 == pixels_per_work_item)\n{\n#ifndef DEPTH_5\nconst VECTOR16 r0 = vload16(0, src_ptr);\nconst int4 xi = convert_int4(r0.s048c);\nconst int4 yi = convert_int4(r0.s159d);\nconst int4 zi = convert_int4(r0.s26ae);\nconst int4 bi = CV_DESCALE(xi * coeffs[0] + yi * coeffs[1] + zi * coeffs[2], xyz_shift);\nconst int4 gi = CV_DESCALE(xi * coeffs[3] + yi * coeffs[4] + zi * coeffs[5], xyz_shift);\nconst int4 ri = CV_DESCALE(xi * coeffs[6] + yi * coeffs[7] + zi * coeffs[8], xyz_shift);\nconst VECTOR4 R = SAT_CAST4(ri);\nconst VECTOR4 G = SAT_CAST4(gi);\nconst VECTOR4 B = SAT_CAST4(bi);\n#if dcn == 4\nvstore16((VECTOR16)(B.s0, G.s0, R.s0, MAX_NUM, B.s1, G.s1, R.s1, MAX_NUM, B.s2, G.s2, R.s2, MAX_NUM, B.s3, G.s3, R.s3, MAX_NUM), 0, dst_ptr);\n#else\nvstore16((VECTOR16)(B.s0, G.s0, R.s0, 0, B.s1, G.s1, R.s1, 0, B.s2, G.s2, R.s2, 0, B.s3, G.s3, R.s3, 0), 0, dst_ptr);\n#endif\n#endif\n}\n#endif\n}\n}\n__kernel void RGB(int cols, int rows, int src_step, int dst_step,\n__global const DATA_TYPE * src, __global DATA_TYPE * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\n#ifndef INTEL_DEVICE\n#ifdef REVERSE\ndst[dst_idx] = src[src_idx + 2];\ndst[dst_idx + 1] = src[src_idx + 1];\ndst[dst_idx + 2] = src[src_idx];\n#elif defined ORDER\ndst[dst_idx] = src[src_idx];\ndst[dst_idx + 1] = src[src_idx + 1];\ndst[dst_idx + 2] = src[src_idx + 2];\n#endif\n#if dcn == 4\n#if scn == 3\ndst[dst_idx + 3] = MAX_NUM;\n#else\ndst[dst_idx + 3] = src[src_idx + 3];\n#endif\n#endif\n#else\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\nconst VECTOR4 r0 = vload4(0, src_ptr);\n#ifdef REVERSE\nif (3 == dcn)\n{\nvstore4((VECTOR4)(r0.s210, 0), 0, dst_ptr);\n}\nelse if (3 == scn)\n{\nvstore4((VECTOR4)(r0.s210, MAX_NUM), 0, dst_ptr);\n}\nelse {\nvstore4((VECTOR4)(r0.s2103), 0, dst_ptr);\n}\n#elif defined ORDER\nif (3 == dcn)\n{\nvstore4((VECTOR4)(r0.s012, 0), 0, dst_ptr);\n}\nelse if (3 == scn)\n{\nvstore4((VECTOR4)(r0.s012, MAX_NUM), 0, dst_ptr);\n}\nelse {\nvstore4(r0, 0, dst_ptr);\n}\n#endif\n#endif\n}\n}\n__kernel void RGB5x52RGB(int cols, int rows, int src_step, int dst_step,\n__global const ushort * src, __global uchar * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + (x << 2));\nushort t = src[src_idx];\n#if greenbits == 6\ndst[dst_idx + bidx] = (uchar)(t << 3);\ndst[dst_idx + 1] = (uchar)((t >> 3) & ~3);\ndst[dst_idx + (bidx^2)] = (uchar)((t >> 8) & ~7);\n#else\ndst[dst_idx + bidx] = (uchar)(t << 3);\ndst[dst_idx + 1] = (uchar)((t >> 2) & ~7);\ndst[dst_idx + (bidx^2)] = (uchar)((t >> 7) & ~7);\n#endif\n#if dcn == 4\n#if greenbits == 6\ndst[dst_idx + 3] = 255;\n#else\ndst[dst_idx + 3] = t & 0x8000 ? 255 : 0;\n#endif\n#endif\n}\n}\n__kernel void RGB2RGB5x5(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global ushort * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nint src_idx = mad24(y, src_step, src_offset + (x << 2));\nint dst_idx = mad24(y, dst_step, dst_offset + x);\n#if greenbits == 6\ndst[dst_idx] = (ushort)((src[src_idx + bidx] >> 3)|((src[src_idx + 1]&~3) << 3)|((src[src_idx + (bidx^2)]&~7) << 8));\n#elif scn == 3\ndst[dst_idx] = (ushort)((src[src_idx + bidx] >> 3)|((src[src_idx + 1]&~7) << 2)|((src[src_idx + (bidx^2)]&~7) << 7));\n#else\ndst[dst_idx] = (ushort)((src[src_idx + bidx] >> 3)|((src[src_idx + 1]&~7) << 2)|\n((src[src_idx + (bidx^2)]&~7) << 7)|(src[src_idx + 3] ? 0x8000 : 0));\n#endif\n}\n}\n__kernel void BGR5x52Gray(int cols, int rows, int src_step, int dst_step,\n__global const ushort * src, __global uchar * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nint t = src[src_idx];\n#if greenbits == 6\ndst[dst_idx] = (uchar)CV_DESCALE(((t << 3) & 0xf8)*B2Y +\n((t >> 3) & 0xfc)*G2Y +\n((t >> 8) & 0xf8)*R2Y, yuv_shift);\n#else\ndst[dst_idx] = (uchar)CV_DESCALE(((t << 3) & 0xf8)*B2Y +\n((t >> 2) & 0xf8)*G2Y +\n((t >> 7) & 0xf8)*R2Y, yuv_shift);\n#endif\n}\n}\n__kernel void Gray2BGR5x5(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global ushort * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nint t = src[src_idx];\n#if greenbits == 6\ndst[dst_idx] = (ushort)((t >> 3) | ((t & ~3) << 3) | ((t & ~7) << 8));\n#else\nt >>= 3;\ndst[dst_idx] = (ushort)(t|(t << 5)|(t << 10));\n#endif\n}\n}\n__constant int sector_data[][3] = { {1, 3, 0}, { 1, 0, 2 }, { 3, 0, 1 }, { 0, 2, 1 }, { 0, 1, 3 }, { 2, 1, 0 } };\n#ifdef DEPTH_0\n__kernel void RGB2HSV(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global uchar * dst,\nint src_offset, int dst_offset,\n__constant int * sdiv_table, __constant int * hdiv_table)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nint b = src[src_idx + bidx], g = src[src_idx + 1], r = src[src_idx + (bidx^2)];\nint h, s, v = b;\nint vmin = b, diff;\nint vr, vg;\nv = max( v, g );\nv = max( v, r );\nvmin = min( vmin, g );\nvmin = min( vmin, r );\ndiff = v - vmin;\nvr = v == r ? -1 : 0;\nvg = v == g ? -1 : 0;\ns = (diff * sdiv_table[v] + (1 << (hsv_shift-1))) >> hsv_shift;\nh = (vr & (g - b)) +\n(~vr & ((vg & (b - r + 2 * diff)) + ((~vg) & (r - g + 4 * diff))));\nh = (h * hdiv_table[diff] + (1 << (hsv_shift-1))) >> hsv_shift;\nh += h < 0 ? hrange : 0;\ndst[dst_idx] = convert_uchar_sat_rte(h);\ndst[dst_idx + 1] = (uchar)s;\ndst[dst_idx + 2] = (uchar)v;\n}\n}\n__kernel void HSV2RGB(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global uchar * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nfloat h = src[src_idx], s = src[src_idx + 1]*(1/255.f), v = src[src_idx + 2]*(1/255.f);\nfloat b, g, r;\nif (s != 0)\n{\nfloat tab[4];\nint sector;\nh *= hscale;\nif( h < 0 )\ndo h += 6; while( h < 0 );\nelse if( h >= 6 )\ndo h -= 6; while( h >= 6 );\nsector = convert_int_sat_rtn(h);\nh -= sector;\nif( (unsigned)sector >= 6u )\n{\nsector = 0;\nh = 0.f;\n}\ntab[0] = v;\ntab[1] = v*(1.f - s);\ntab[2] = v*(1.f - s*h);\ntab[3] = v*(1.f - s*(1.f - h));\nb = tab[sector_data[sector][0]];\ng = tab[sector_data[sector][1]];\nr = tab[sector_data[sector][2]];\n}\nelse\nb = g = r = v;\ndst[dst_idx + bidx] = convert_uchar_sat_rte(b*255.f);\ndst[dst_idx + 1] = convert_uchar_sat_rte(g*255.f);\ndst[dst_idx + (bidx^2)] = convert_uchar_sat_rte(r*255.f);\n#if dcn == 4\ndst[dst_idx + 3] = MAX_NUM;\n#endif\n}\n}\n#elif defined DEPTH_5\n__kernel void RGB2HSV(int cols, int rows, int src_step, int dst_step,\n__global const float * src, __global float * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nfloat b = src[src_idx + bidx], g = src[src_idx + 1], r = src[src_idx + (bidx^2)];\nfloat h, s, v;\nfloat vmin, diff;\nv = vmin = r;\nif( v < g ) v = g;\nif( v < b ) v = b;\nif( vmin > g ) vmin = g;\nif( vmin > b ) vmin = b;\ndiff = v - vmin;\ns = diff/(float)(fabs(v) + FLT_EPSILON);\ndiff = (float)(60./(diff + FLT_EPSILON));\nif( v == r )\nh = (g - b)*diff;\nelse if( v == g )\nh = (b - r)*diff + 120.f;\nelse\nh = (r - g)*diff + 240.f;\nif( h < 0 ) h += 360.f;\ndst[dst_idx] = h*hscale;\ndst[dst_idx + 1] = s;\ndst[dst_idx + 2] = v;\n}\n}\n__kernel void HSV2RGB(int cols, int rows, int src_step, int dst_step,\n__global const float * src, __global float * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nfloat h = src[src_idx], s = src[src_idx + 1], v = src[src_idx + 2];\nfloat b, g, r;\nif (s != 0)\n{\nfloat tab[4];\nint sector;\nh *= hscale;\nif(h < 0)\ndo h += 6; while (h < 0);\nelse if (h >= 6)\ndo h -= 6; while (h >= 6);\nsector = convert_int_sat_rtn(h);\nh -= sector;\nif ((unsigned)sector >= 6u)\n{\nsector = 0;\nh = 0.f;\n}\ntab[0] = v;\ntab[1] = v*(1.f - s);\ntab[2] = v*(1.f - s*h);\ntab[3] = v*(1.f - s*(1.f - h));\nb = tab[sector_data[sector][0]];\ng = tab[sector_data[sector][1]];\nr = tab[sector_data[sector][2]];\n}\nelse\nb = g = r = v;\ndst[dst_idx + bidx] = b;\ndst[dst_idx + 1] = g;\ndst[dst_idx + (bidx^2)] = r;\n#if dcn == 4\ndst[dst_idx + 3] = MAX_NUM;\n#endif\n}\n}\n#endif\n#ifdef DEPTH_0\n__kernel void RGB2HLS(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global uchar * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nfloat b = src[src_idx + bidx]*(1/255.f), g = src[src_idx + 1]*(1/255.f), r = src[src_idx + (bidx^2)]*(1/255.f);\nfloat h = 0.f, s = 0.f, l;\nfloat vmin, vmax, diff;\nvmax = vmin = r;\nif (vmax < g) vmax = g;\nif (vmax < b) vmax = b;\nif (vmin > g) vmin = g;\nif (vmin > b) vmin = b;\ndiff = vmax - vmin;\nl = (vmax + vmin)*0.5f;\nif (diff > FLT_EPSILON)\n{\ns = l < 0.5f ? diff/(vmax + vmin) : diff/(2 - vmax - vmin);\ndiff = 60.f/diff;\nif( vmax == r )\nh = (g - b)*diff;\nelse if( vmax == g )\nh = (b - r)*diff + 120.f;\nelse\nh = (r - g)*diff + 240.f;\nif( h < 0.f ) h += 360.f;\n}\ndst[dst_idx] = convert_uchar_sat_rte(h*hscale);\ndst[dst_idx + 1] = convert_uchar_sat_rte(l*255.f);\ndst[dst_idx + 2] = convert_uchar_sat_rte(s*255.f);\n}\n}\n__kernel void HLS2RGB(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global uchar * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nfloat h = src[src_idx], l = src[src_idx + 1]*(1.f/255.f), s = src[src_idx + 2]*(1.f/255.f);\nfloat b, g, r;\nif (s != 0)\n{\nfloat tab[4];\nfloat p2 = l <= 0.5f ? l*(1 + s) : l + s - l*s;\nfloat p1 = 2*l - p2;\nh *= hscale;\nif( h < 0 )\ndo h += 6; while( h < 0 );\nelse if( h >= 6 )\ndo h -= 6; while( h >= 6 );\nint sector = convert_int_sat_rtn(h);\nh -= sector;\ntab[0] = p2;\ntab[1] = p1;\ntab[2] = p1 + (p2 - p1)*(1-h);\ntab[3] = p1 + (p2 - p1)*h;\nb = tab[sector_data[sector][0]];\ng = tab[sector_data[sector][1]];\nr = tab[sector_data[sector][2]];\n}\nelse\nb = g = r = l;\ndst[dst_idx + bidx] = convert_uchar_sat_rte(b*255.f);\ndst[dst_idx + 1] = convert_uchar_sat_rte(g*255.f);\ndst[dst_idx + (bidx^2)] = convert_uchar_sat_rte(r*255.f);\n#if dcn == 4\ndst[dst_idx + 3] = MAX_NUM;\n#endif\n}\n}\n#elif defined DEPTH_5\n__kernel void RGB2HLS(int cols, int rows, int src_step, int dst_step,\n__global const float * src, __global float * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nfloat b = src[src_idx + bidx], g = src[src_idx + 1], r = src[src_idx + (bidx^2)];\nfloat h = 0.f, s = 0.f, l;\nfloat vmin, vmax, diff;\nvmax = vmin = r;\nif (vmax < g) vmax = g;\nif (vmax < b) vmax = b;\nif (vmin > g) vmin = g;\nif (vmin > b) vmin = b;\ndiff = vmax - vmin;\nl = (vmax + vmin)*0.5f;\nif (diff > FLT_EPSILON)\n{\ns = l < 0.5f ? diff/(vmax + vmin) : diff/(2 - vmax - vmin);\ndiff = 60.f/diff;\nif( vmax == r )\nh = (g - b)*diff;\nelse if( vmax == g )\nh = (b - r)*diff + 120.f;\nelse\nh = (r - g)*diff + 240.f;\nif( h < 0.f ) h += 360.f;\n}\ndst[dst_idx] = h*hscale;\ndst[dst_idx + 1] = l;\ndst[dst_idx + 2] = s;\n}\n}\n__kernel void HLS2RGB(int cols, int rows, int src_step, int dst_step,\n__global const float * src, __global float * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nfloat h = src[src_idx], l = src[src_idx + 1], s = src[src_idx + 2];\nfloat b, g, r;\nif (s != 0)\n{\nfloat tab[4];\nint sector;\nfloat p2 = l <= 0.5f ? l*(1 + s) : l + s - l*s;\nfloat p1 = 2*l - p2;\nh *= hscale;\nif( h < 0 )\ndo h += 6; while( h < 0 );\nelse if( h >= 6 )\ndo h -= 6; while( h >= 6 );\nsector = convert_int_sat_rtn(h);\nh -= sector;\ntab[0] = p2;\ntab[1] = p1;\ntab[2] = p1 + (p2 - p1)*(1-h);\ntab[3] = p1 + (p2 - p1)*h;\nb = tab[sector_data[sector][0]];\ng = tab[sector_data[sector][1]];\nr = tab[sector_data[sector][2]];\n}\nelse\nb = g = r = l;\ndst[dst_idx + bidx] = b;\ndst[dst_idx + 1] = g;\ndst[dst_idx + (bidx^2)] = r;\n#if dcn == 4\ndst[dst_idx + 3] = MAX_NUM;\n#endif\n}\n}\n#endif\n#ifdef DEPTH_0\n__kernel void RGBA2mRGBA(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global uchar * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0) * pixels_per_work_item;\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#if (1 == pixels_per_work_item)\n{\nconst uchar4 r0 = vload4(0, src_ptr);\ndst_ptr[0] = (r0.s0 * r0.s3 + HALF_MAX) / MAX_NUM;\ndst_ptr[1] = (r0.s1 * r0.s3 + HALF_MAX) / MAX_NUM;\ndst_ptr[2] = (r0.s2 * r0.s3 + HALF_MAX) / MAX_NUM;\ndst_ptr[3] = r0.s3;\n}\n#elif (2 == pixels_per_work_item)\n{\nconst uchar8 r0 = vload8(0, src_ptr);\nconst int2 v0 = convert_int2(r0.s04);\nconst int2 v1 = convert_int2(r0.s15);\nconst int2 v2 = convert_int2(r0.s26);\nconst int2 v3 = convert_int2(r0.s37);\nconst int2 ri = (v0 * v3 + HALF_MAX) / MAX_NUM;\nconst int2 gi = (v1 * v3 + HALF_MAX) / MAX_NUM;\nconst int2 bi = (v2 * v3 + HALF_MAX) / MAX_NUM;\nconst uchar2 r = convert_uchar2(ri);\nconst uchar2 g = convert_uchar2(gi);\nconst uchar2 b = convert_uchar2(bi);\nvstore8((uchar8)(r.s0, g.s0, b.s0, v3.s0, r.s1, g.s1, b.s1, v3.s1), 0, dst_ptr);\n}\n#elif (4 == pixels_per_work_item)\n{\nconst uchar16 r0 = vload16(0, src_ptr);\nconst int4 v0 = convert_int4(r0.s048c);\nconst int4 v1 = convert_int4(r0.s159d);\nconst int4 v2 = convert_int4(r0.s26ae);\nconst int4 v3 = convert_int4(r0.s37bf);\nconst int4 ri = (v0 * v3 + HALF_MAX) / MAX_NUM;\nconst int4 gi = (v1 * v3 + HALF_MAX) / MAX_NUM;\nconst int4 bi = (v2 * v3 + HALF_MAX) / MAX_NUM;\nconst uchar4 r = convert_uchar4(ri);\nconst uchar4 g = convert_uchar4(gi);\nconst uchar4 b = convert_uchar4(bi);\nvstore16((uchar16)(r.s0, g.s0, b.s0, v3.s0, r.s1, g.s1, b.s1, v3.s1, r.s2, g.s2, b.s2, v3.s2, r.s3, g.s3, b.s3, v3.s3), 0, dst_ptr);\n}\n#endif\n}\n}\n__kernel void mRGBA2RGBA(int cols, int rows, int src_step, int dst_step,\n__global const uchar * src, __global uchar * dst,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0) * pixels_per_work_item;\nint y = get_global_id(1);\nif (y < rows && x < cols)\n{\nx <<= 2;\nint src_idx = mad24(y, src_step, src_offset + x);\nint dst_idx = mad24(y, dst_step, dst_offset + x);\nglobal DATA_TYPE *src_ptr = (global DATA_TYPE *)(src + src_idx);\nglobal DATA_TYPE *dst_ptr = (global DATA_TYPE *)(dst + dst_idx);\n#if (1 == pixels_per_work_item)\n{\nconst uchar4 r0 = vload4(0, src_ptr);\nconst uchar v3_half = r0.s3 / 2;\nconst uchar r = (r0.s3 == 0) ? 0 : (r0.s0 * MAX_NUM + v3_half) / r0.s3;\nconst uchar g = (r0.s3 == 0) ? 0 : (r0.s1 * MAX_NUM + v3_half) / r0.s3;\nconst uchar b = (r0.s3 == 0) ? 0 : (r0.s2 * MAX_NUM + v3_half) / r0.s3;\nvstore4((uchar4)(r, g, b, r0.s3), 0, dst_ptr);\n}\n#elif (2 == pixels_per_work_item)\n{\nconst uchar8 r0 = vload8(0, src_ptr);\nconst int2 v0 = convert_int2(r0.s04);\nconst int2 v1 = convert_int2(r0.s15);\nconst int2 v2 = convert_int2(r0.s26);\nconst int2 v3 = convert_int2(r0.s37);\nconst int2 v3_half = v3 / 2;\nconst int2 ri = (v3 == 0) ? 0 : (v0 * MAX_NUM + v3_half) / v3;\nconst int2 gi = (v3 == 0) ? 0 : (v1 * MAX_NUM + v3_half) / v3;\nconst int2 bi = (v3 == 0) ? 0 : (v2 * MAX_NUM + v3_half) / v3;\nconst uchar2 r = convert_uchar2(ri);\nconst uchar2 g = convert_uchar2(gi);\nconst uchar2 b = convert_uchar2(bi);\nvstore8((uchar8)(r.s0, g.s0, b.s0, v3.s0, r.s1, g.s1, b.s1, v3.s1), 0, dst_ptr);\n}\n#elif (4 == pixels_per_work_item)\n{\nconst uchar16 r0 = vload16(0, src_ptr);\nconst int4 v0 = convert_int4(r0.s048c);\nconst int4 v1 = convert_int4(r0.s159d);\nconst int4 v2 = convert_int4(r0.s26ae);\nconst int4 v3 = convert_int4(r0.s37bf);\nconst int4 v3_half = v3 / 2;\nconst int4 ri = (v3 == 0) ? 0 : (v0 * MAX_NUM + v3_half) / v3;\nconst int4 gi = (v3 == 0) ? 0 : (v1 * MAX_NUM + v3_half) / v3;\nconst int4 bi = (v3 == 0) ? 0 : (v2 * MAX_NUM + v3_half) / v3;\nconst uchar4 r = convert_uchar4(ri);\nconst uchar4 g = convert_uchar4(gi);\nconst uchar4 b = convert_uchar4(bi);\nvstore16((uchar16)(r.s0, g.s0, b.s0, v3.s0, r.s1, g.s1, b.s1, v3.s1, r.s2, g.s2, b.s2, v3.s2, r.s3, g.s3, b.s3, v3.s3), 0, dst_ptr);\n}\n#endif\n}\n}\n#endif\n", "d8989aadab81f92a35b32db9740d9b62", "convertC3C4", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void convertC3C4(__global const GENTYPE4 * restrict src, __global GENTYPE4 *dst,\nint cols, int rows,\nint dstStep_in_piexl, int pixel_end)\n{\nint id = get_global_id(0);\nint3 pixelid = (int3)(mul24(id,3),mad24(id,3,1),mad24(id,3,2));\npixelid = clamp(pixelid,0,pixel_end);\nGENTYPE4 pixel0, pixel1, pixel2, outpix0,outpix1,outpix2,outpix3;\npixel0 = src[pixelid.x];\npixel1 = src[pixelid.y];\npixel2 = src[pixelid.z];\noutpix0 = (GENTYPE4)(pixel0.x,pixel0.y,pixel0.z,0);\noutpix1 = (GENTYPE4)(pixel0.w,pixel1.x,pixel1.y,0);\noutpix2 = (GENTYPE4)(pixel1.z,pixel1.w,pixel2.x,0);\noutpix3 = (GENTYPE4)(pixel2.y,pixel2.z,pixel2.w,0);\nint4 outy = (id<<2)/cols;\nint4 outx = (id<<2)%cols;\noutx += (int4)(0, 1, 2, 3);\nouty = select(outy, outy+1, outx>=cols);\noutx = select(outx, outx-cols, outx>=cols);\nouty = select(outy, outy + 1, outx >= cols);\noutx = select(outx, outx-cols, outx >= cols);\nouty = select(outy, outy + 1, outx >= cols);\noutx = select(outx, outx-cols, outx >= cols);\nint4 addr = mad24(outy,(int4)dstStep_in_piexl,outx);\nif(outx.w<cols && outy.w<rows)\n{\ndst[addr.x] = outpix0;\ndst[addr.y] = outpix1;\ndst[addr.z] = outpix2;\ndst[addr.w] = outpix3;\n}\nelse if(outx.z<cols && outy.z<rows)\n{\ndst[addr.x] = outpix0;\ndst[addr.y] = outpix1;\ndst[addr.z] = outpix2;\n}\nelse if(outx.y<cols && outy.y<rows)\n{\ndst[addr.x] = outpix0;\ndst[addr.y] = outpix1;\n}\nelse if(outx.x<cols && outy.x<rows)\ndst[addr.x] = outpix0;\n}\n__kernel void convertC4C3(__global const GENTYPE4 * restrict src, __global GENTYPE4 *dst,\nint cols, int rows,\nint srcStep_in_pixel, int pixel_end)\n{\nint id = get_global_id(0)<<2;\nint y = id / cols;\nint x = id % cols;\nint4 x4 = (int4)(x,x+1,x+2,x+3);\nint4 y4 = select((int4)y,(int4)(y+1),x4>=(int4)cols);\nx4 = select(x4,x4-(int4)cols,x4>=(int4)cols);\ny4 = select(y4, y4 + 1,x4>=(int4)cols);\nx4 = select(x4, x4 - (int4)cols,x4>=(int4)cols);\ny4 = select(y4, y4 + 1,x4>=(int4)cols);\nx4 = select(x4, x4-(int4)cols,x4>=(int4)cols);\ny4=clamp(y4,(int4)0,(int4)(rows-1));\nint4 addr = mad24(y4, (int4)srcStep_in_pixel, x4);\nGENTYPE4 pixel0,pixel1,pixel2,pixel3, outpixel1, outpixel2;\npixel0 = src[addr.x];\npixel1 = src[addr.y];\npixel2 = src[addr.z];\npixel3 = src[addr.w];\npixel0.w = pixel1.x;\noutpixel1.x = pixel1.y;\noutpixel1.y = pixel1.z;\noutpixel1.z = pixel2.x;\noutpixel1.w = pixel2.y;\noutpixel2.x = pixel2.z;\noutpixel2.y = pixel3.x;\noutpixel2.z = pixel3.y;\noutpixel2.w = pixel3.z;\nint4 outaddr = mul24(id>>2 , 3);\noutaddr.y++;\noutaddr.z+=2;\nif(outaddr.z <= pixel_end)\n{\ndst[outaddr.x] = pixel0;\ndst[outaddr.y] = outpixel1;\ndst[outaddr.z] = outpixel2;\n}\nelse if(outaddr.y <= pixel_end)\n{\ndst[outaddr.x] = pixel0;\ndst[outaddr.y] = outpixel1;\n}\nelse if(outaddr.x <= pixel_end)\ndst[outaddr.x] = pixel0;\n}\n", "bb9cf383213d95e505f8677a285ee329", "build_warps", "__kernel void buildWarpPlaneMaps(__global float * xmap, __global float * ymap,\n__constant float * KRT,\nint tl_u, int tl_v,\nint cols, int rows,\nint xmap_step, int ymap_step,\nint xmap_offset, int ymap_offset,\nfloat scale)\n{\nint du = get_global_id(0);\nint dv = get_global_id(1);\n__constant float * ck_rinv = KRT;\n__constant float * ct      = KRT + 9;\nif (du < cols && dv < rows)\n{\nint xmap_index = mad24(dv, xmap_step, xmap_offset + du);\nint ymap_index = mad24(dv, ymap_step, ymap_offset + du);\nfloat u = tl_u + du;\nfloat v = tl_v + dv;\nfloat x, y;\nfloat x_ = u / scale - ct[0];\nfloat y_ = v / scale - ct[1];\nfloat z;\nx = ck_rinv[0] * x_ + ck_rinv[1] * y_ + ck_rinv[2] * (1 - ct[2]);\ny = ck_rinv[3] * x_ + ck_rinv[4] * y_ + ck_rinv[5] * (1 - ct[2]);\nz = ck_rinv[6] * x_ + ck_rinv[7] * y_ + ck_rinv[8] * (1 - ct[2]);\nx /= z;\ny /= z;\nxmap[xmap_index] = x;\nymap[ymap_index] = y;\n}\n}\n__kernel void buildWarpCylindricalMaps(__global float * xmap, __global float * ymap,\n__constant float * ck_rinv,\nint tl_u, int tl_v,\nint cols, int rows,\nint xmap_step, int ymap_step,\nint xmap_offset, int ymap_offset,\nfloat scale)\n{\nint du = get_global_id(0);\nint dv = get_global_id(1);\nif (du < cols && dv < rows)\n{\nint xmap_index = mad24(dv, xmap_step, xmap_offset + du);\nint ymap_index = mad24(dv, ymap_step, ymap_offset + du);\nfloat u = tl_u + du;\nfloat v = tl_v + dv;\nfloat x, y;\nu /= scale;\nfloat x_ = sin(u);\nfloat y_ = v / scale;\nfloat z_ = cos(u);\nfloat z;\nx = ck_rinv[0] * x_ + ck_rinv[1] * y_ + ck_rinv[2] * z_;\ny = ck_rinv[3] * x_ + ck_rinv[4] * y_ + ck_rinv[5] * z_;\nz = ck_rinv[6] * x_ + ck_rinv[7] * y_ + ck_rinv[8] * z_;\nif (z > 0) { x /= z; y /= z; }\nelse x = y = -1;\nxmap[xmap_index] = x;\nymap[ymap_index] = y;\n}\n}\n__kernel void buildWarpSphericalMaps(__global float * xmap, __global float * ymap,\n__constant float * ck_rinv,\nint tl_u, int tl_v,\nint cols, int rows,\nint xmap_step, int ymap_step,\nint xmap_offset, int ymap_offset,\nfloat scale)\n{\nint du = get_global_id(0);\nint dv = get_global_id(1);\nif (du < cols && dv < rows)\n{\nint xmap_index = mad24(dv, xmap_step, xmap_offset + du);\nint ymap_index = mad24(dv, ymap_step, ymap_offset + du);\nfloat u = tl_u + du;\nfloat v = tl_v + dv;\nfloat x, y;\nv /= scale;\nu /= scale;\nfloat sinv = sin(v);\nfloat x_ = sinv * sin(u);\nfloat y_ = - cos(v);\nfloat z_ = sinv * cos(u);\nfloat z;\nx = ck_rinv[0] * x_ + ck_rinv[1] * y_ + ck_rinv[2] * z_;\ny = ck_rinv[3] * x_ + ck_rinv[4] * y_ + ck_rinv[5] * z_;\nz = ck_rinv[6] * x_ + ck_rinv[7] * y_ + ck_rinv[8] * z_;\nif (z > 0) { x /= z; y /= z; }\nelse x = y = -1;\nxmap[xmap_index] = x;\nymap[ymap_index] = y;\n}\n}\n__kernel void buildWarpAffineMaps(__global float * xmap, __global float * ymap,\n__constant float * c_warpMat,\nint cols, int rows,\nint xmap_step, int ymap_step,\nint xmap_offset, int ymap_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint xmap_index = mad24(y, xmap_step, x + xmap_offset);\nint ymap_index = mad24(y, ymap_step, x + ymap_offset);\nfloat xcoo = c_warpMat[0] * x + c_warpMat[1] * y + c_warpMat[2];\nfloat ycoo = c_warpMat[3] * x + c_warpMat[4] * y + c_warpMat[5];\nxmap[xmap_index] = xcoo;\nymap[ymap_index] = ycoo;\n}\n}\n__kernel void buildWarpPerspectiveMaps(__global float * xmap, __global float * ymap,\n__constant float * c_warpMat,\nint cols, int rows,\nint xmap_step, int ymap_step,\nint xmap_offset, int ymap_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint xmap_index = mad24(y, xmap_step, x + xmap_offset);\nint ymap_index = mad24(y, ymap_step, x + ymap_offset);\nfloat coeff = 1.0f / (c_warpMat[6] * x + c_warpMat[7] * y + c_warpMat[8]);\nfloat xcoo = coeff * (c_warpMat[0] * x + c_warpMat[1] * y + c_warpMat[2]);\nfloat ycoo = coeff * (c_warpMat[3] * x + c_warpMat[4] * y + c_warpMat[5]);\nxmap[xmap_index] = xcoo;\nymap[ymap_index] = ycoo;\n}\n}\n", "67d1271eae72e28991ae6632b3b9bd1f", "brute_force_match", "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n#define MAX_FLOAT 3.40282e+038f\n#ifndef T\n#define T float\n#endif\n#ifndef BLOCK_SIZE\n#define BLOCK_SIZE 16\n#endif\n#ifndef MAX_DESC_LEN\n#define MAX_DESC_LEN 64\n#endif\n#ifndef DIST_TYPE\n#define DIST_TYPE 0\n#endif\n#if   (DIST_TYPE == 0)\n#   ifdef T_FLOAT\n#       define DIST(x, y) fabs((x) - (y))\ntypedef float value_type;\ntypedef float result_type;\n#   else\n#       define DIST(x, y) abs((x) - (y))\ntypedef int value_type;\ntypedef int result_type;\n#   endif\n#define DIST_RES(x) (x)\n#elif (DIST_TYPE == 1)\n#define DIST(x, y) (((x) - (y)) * ((x) - (y)))\ntypedef float value_type;\ntypedef float result_type;\n#define DIST_RES(x) sqrt(x)\n#elif (DIST_TYPE == 2)\nint bit1Count(int v)\n{\nv = v - ((v >> 1) & 0x55555555);\nv = (v & 0x33333333) + ((v >> 2) & 0x33333333);\nreturn ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\n}\n#define DIST(x, y) bit1Count( (x) ^ (y) )\ntypedef int value_type;\ntypedef int result_type;\n#define DIST_RES(x) (x)\n#endif\nresult_type reduce_block(\n__local value_type *s_query,\n__local value_type *s_train,\nint lidx,\nint lidy\n)\n{\nresult_type result = 0;\n#pragma unroll\nfor (int j = 0 ; j < BLOCK_SIZE ; j++)\n{\nresult += DIST(\ns_query[lidy * BLOCK_SIZE + j],\ns_train[j * BLOCK_SIZE + lidx]);\n}\nreturn DIST_RES(result);\n}\nresult_type reduce_block_match(\n__local value_type *s_query,\n__local value_type *s_train,\nint lidx,\nint lidy\n)\n{\nresult_type result = 0;\n#pragma unroll\nfor (int j = 0 ; j < BLOCK_SIZE ; j++)\n{\nresult += DIST(\ns_query[lidy * BLOCK_SIZE + j],\ns_train[j * BLOCK_SIZE + lidx]);\n}\nreturn (result);\n}\nresult_type reduce_multi_block(\n__local value_type *s_query,\n__local value_type *s_train,\nint block_index,\nint lidx,\nint lidy\n)\n{\nresult_type result = 0;\n#pragma unroll\nfor (int j = 0 ; j < BLOCK_SIZE ; j++)\n{\nresult += DIST(\ns_query[lidy * MAX_DESC_LEN + block_index * BLOCK_SIZE + j],\ns_train[j * BLOCK_SIZE + lidx]);\n}\nreturn result;\n}\n__kernel void BruteForceMatch_UnrollMatch(\n__global T *query,\n__global T *train,\n__global int *bestTrainIdx,\n__global float *bestDistance,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint step\n)\n{\nconst int lidx = get_local_id(0);\nconst int lidy = get_local_id(1);\nconst int groupidx = get_group_id(0);\n__local value_type *s_query = (__local value_type *)sharebuffer;\n__local value_type *s_train = (__local value_type *)sharebuffer + BLOCK_SIZE * MAX_DESC_LEN;\nint queryIdx = groupidx * BLOCK_SIZE + lidy;\n#pragma unroll\nfor (int i = 0 ;  i <  MAX_DESC_LEN / BLOCK_SIZE; i ++)\n{\nint loadx = lidx + i * BLOCK_SIZE;\ns_query[lidy * MAX_DESC_LEN + loadx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(T)) + loadx] : 0;\n}\nfloat myBestDistance = MAX_FLOAT;\nint myBestTrainIdx = -1;\nfor (int t = 0, endt = (train_rows + BLOCK_SIZE - 1) / BLOCK_SIZE; t < endt; t++)\n{\nresult_type result = 0;\n#pragma unroll\nfor (int i = 0 ; i < MAX_DESC_LEN / BLOCK_SIZE ; i++)\n{\nconst int loadx = lidx + i * BLOCK_SIZE;\ns_train[lidx * BLOCK_SIZE + lidy] = loadx < train_cols ? train[min(t * BLOCK_SIZE + lidy, train_rows - 1) * (step / sizeof(T)) + loadx] : 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nresult += reduce_multi_block(s_query, s_train, i, lidx, lidy);\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nresult = DIST_RES(result);\nint trainIdx = t * BLOCK_SIZE + lidx;\nif (queryIdx < query_rows && trainIdx < train_rows && result < myBestDistance)\n{\nmyBestDistance = result;\nmyBestTrainIdx = trainIdx;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n__local float *s_distance = (__local float*)(sharebuffer);\n__local int* s_trainIdx = (__local int *)(sharebuffer + BLOCK_SIZE * BLOCK_SIZE);\ns_distance += lidy * BLOCK_SIZE;\ns_trainIdx += lidy * BLOCK_SIZE;\ns_distance[lidx] = myBestDistance;\ns_trainIdx[lidx] = myBestTrainIdx;\nbarrier(CLK_LOCAL_MEM_FENCE);\n#pragma unroll\nfor (int k = 0 ; k < BLOCK_SIZE; k++)\n{\nif (myBestDistance > s_distance[k])\n{\nmyBestDistance = s_distance[k];\nmyBestTrainIdx = s_trainIdx[k];\n}\n}\nif (queryIdx < query_rows && lidx == 0)\n{\nbestTrainIdx[queryIdx] = myBestTrainIdx;\nbestDistance[queryIdx] = myBestDistance;\n}\n}\n__kernel void BruteForceMatch_Match(\n__global T *query,\n__global T *train,\n__global int *bestTrainIdx,\n__global float *bestDistance,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint step\n)\n{\nconst int lidx = get_local_id(0);\nconst int lidy = get_local_id(1);\nconst int groupidx = get_group_id(0);\nconst int queryIdx = groupidx * BLOCK_SIZE + lidy;\nfloat myBestDistance = MAX_FLOAT;\nint myBestTrainIdx = -1;\n__local value_type *s_query = (__local value_type *)sharebuffer;\n__local value_type *s_train = (__local value_type *)sharebuffer + BLOCK_SIZE * BLOCK_SIZE;\nfor (int t = 0 ;  t < (train_rows + BLOCK_SIZE - 1) / BLOCK_SIZE ; t++)\n{\nresult_type result = 0;\nfor (int i = 0 ; i < (query_cols + BLOCK_SIZE - 1) / BLOCK_SIZE ; i++)\n{\nconst int loadx = lidx + i * BLOCK_SIZE;\ns_query[lidy * BLOCK_SIZE + lidx] = 0;\ns_train[lidx * BLOCK_SIZE + lidy] = 0;\nif (loadx < query_cols)\n{\ns_query[lidy * BLOCK_SIZE + lidx] = query[min(queryIdx, query_rows - 1) * (step / sizeof(T)) + loadx];\ns_train[lidx * BLOCK_SIZE + lidy] = train[min(t * BLOCK_SIZE + lidy, train_rows - 1) * (step / sizeof(T)) + loadx];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nresult += reduce_block_match(s_query, s_train, lidx, lidy);\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nresult = DIST_RES(result);\nconst int trainIdx = t * BLOCK_SIZE + lidx;\nif (queryIdx < query_rows && trainIdx < train_rows && result < myBestDistance )\n{\nmyBestDistance = result;\nmyBestTrainIdx = trainIdx;\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n__local float *s_distance = (__local float *)sharebuffer;\n__local int *s_trainIdx = (__local int *)(sharebuffer + BLOCK_SIZE * BLOCK_SIZE);\ns_distance += lidy * BLOCK_SIZE;\ns_trainIdx += lidy * BLOCK_SIZE;\ns_distance[lidx] = myBestDistance;\ns_trainIdx[lidx] = myBestTrainIdx;\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int k = 0 ; k < BLOCK_SIZE; k++)\n{\nif (myBestDistance > s_distance[k])\n{\nmyBestDistance = s_distance[k];\nmyBestTrainIdx = s_trainIdx[k];\n}\n}\nif (queryIdx < query_rows && lidx == 0)\n{\nbestTrainIdx[queryIdx] = myBestTrainIdx;\nbestDistance[queryIdx] = myBestDistance;\n}\n}\n__kernel void BruteForceMatch_RadiusUnrollMatch(\n__global T *query,\n__global T *train,\nfloat maxDistance,\n__global int *bestTrainIdx,\n__global float *bestDistance,\n__global int *nMatches,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint bestTrainIdx_cols,\nint step,\nint ostep\n)\n{\nconst int lidx = get_local_id(0);\nconst int lidy = get_local_id(1);\nconst int groupidx = get_group_id(0);\nconst int groupidy = get_group_id(1);\nconst int queryIdx = groupidy * BLOCK_SIZE + lidy;\nconst int trainIdx = groupidx * BLOCK_SIZE + lidx;\n__local value_type *s_query = (__local value_type *)sharebuffer;\n__local value_type *s_train = (__local value_type *)sharebuffer + BLOCK_SIZE * BLOCK_SIZE;\nresult_type result = 0;\nfor (int i = 0 ; i < MAX_DESC_LEN / BLOCK_SIZE ; ++i)\n{\nconst int loadx = lidx + i * BLOCK_SIZE;\ns_query[lidy * BLOCK_SIZE + lidx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(T)) + loadx] : 0;\ns_train[lidx * BLOCK_SIZE + lidy] = loadx < query_cols ? train[min(groupidx * BLOCK_SIZE + lidy, train_rows - 1)  * (step / sizeof(T)) + loadx] : 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nresult += reduce_block(s_query, s_train, lidx, lidy);\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif (queryIdx < query_rows && trainIdx < train_rows &&\nconvert_float(result) < maxDistance)\n{\nint ind = atom_inc(nMatches + queryIdx);\nif(ind < bestTrainIdx_cols)\n{\nbestTrainIdx[queryIdx * (ostep / sizeof(int)) + ind] = trainIdx;\nbestDistance[queryIdx * (ostep / sizeof(float)) + ind] = result;\n}\n}\n}\n__kernel void BruteForceMatch_RadiusMatch(\n__global T *query,\n__global T *train,\nfloat maxDistance,\n__global int *bestTrainIdx,\n__global float *bestDistance,\n__global int *nMatches,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint bestTrainIdx_cols,\nint step,\nint ostep\n)\n{\nconst int lidx = get_local_id(0);\nconst int lidy = get_local_id(1);\nconst int groupidx = get_group_id(0);\nconst int groupidy = get_group_id(1);\nconst int queryIdx = groupidy * BLOCK_SIZE + lidy;\nconst int trainIdx = groupidx * BLOCK_SIZE + lidx;\n__local value_type *s_query = (__local value_type *)sharebuffer;\n__local value_type *s_train = (__local value_type *)sharebuffer + BLOCK_SIZE * BLOCK_SIZE;\nresult_type result = 0;\nfor (int i = 0 ; i < (query_cols + BLOCK_SIZE - 1) / BLOCK_SIZE ; ++i)\n{\nconst int loadx = lidx + i * BLOCK_SIZE;\ns_query[lidy * BLOCK_SIZE + lidx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(T)) + loadx] : 0;\ns_train[lidx * BLOCK_SIZE + lidy] = loadx < query_cols ? train[min(groupidx * BLOCK_SIZE + lidy, train_rows - 1)  * (step / sizeof(T)) + loadx] : 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nresult += reduce_block(s_query, s_train, lidx, lidy);\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif (queryIdx < query_rows && trainIdx < train_rows &&\nconvert_float(result) < maxDistance)\n{\nint ind = atom_inc(nMatches + queryIdx);\nif(ind < bestTrainIdx_cols)\n{\nbestTrainIdx[queryIdx * (ostep / sizeof(int)) + ind] = trainIdx;\nbestDistance[queryIdx * (ostep / sizeof(float)) + ind] = result;\n}\n}\n}\n__kernel void BruteForceMatch_knnUnrollMatch(\n__global T *query,\n__global T *train,\n__global int2 *bestTrainIdx,\n__global float2 *bestDistance,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint step\n)\n{\nconst int lidx = get_local_id(0);\nconst int lidy = get_local_id(1);\nconst int groupidx = get_group_id(0);\nconst int queryIdx = groupidx * BLOCK_SIZE + lidy;\n__local value_type *s_query = (__local value_type *)sharebuffer;\n__local value_type *s_train = (__local value_type *)sharebuffer + BLOCK_SIZE * MAX_DESC_LEN;\nfor (int i = 0 ;  i <  MAX_DESC_LEN / BLOCK_SIZE; i ++)\n{\nint loadx = lidx + i * BLOCK_SIZE;\ns_query[lidy * MAX_DESC_LEN + loadx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(T)) + loadx] : 0;\n}\nfloat myBestDistance1 = MAX_FLOAT;\nfloat myBestDistance2 = MAX_FLOAT;\nint myBestTrainIdx1 = -1;\nint myBestTrainIdx2 = -1;\nfor (int t = 0 ; t < (train_rows + BLOCK_SIZE - 1) / BLOCK_SIZE ; t++)\n{\nresult_type result = 0;\nfor (int i = 0 ; i < MAX_DESC_LEN / BLOCK_SIZE ; i++)\n{\nconst int loadx = lidx + i * BLOCK_SIZE;\ns_train[lidx * BLOCK_SIZE + lidy] = loadx < train_cols ? train[min(t * BLOCK_SIZE + lidy, train_rows - 1) * (step / sizeof(T)) + loadx] : 0;\nbarrier(CLK_LOCAL_MEM_FENCE);\nresult += reduce_multi_block(s_query, s_train, i, lidx, lidy);\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nresult = DIST_RES(result);\nconst int trainIdx = t * BLOCK_SIZE + lidx;\nif (queryIdx < query_rows && trainIdx < train_rows)\n{\nif (result < myBestDistance1)\n{\nmyBestDistance2 = myBestDistance1;\nmyBestTrainIdx2 = myBestTrainIdx1;\nmyBestDistance1 = result;\nmyBestTrainIdx1 = trainIdx;\n}\nelse if (result < myBestDistance2)\n{\nmyBestDistance2 = result;\nmyBestTrainIdx2 = trainIdx;\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n__local float *s_distance = (local float *)sharebuffer;\n__local int *s_trainIdx = (local int *)(sharebuffer + BLOCK_SIZE * BLOCK_SIZE);\ns_distance += lidy * BLOCK_SIZE;\ns_trainIdx += lidy * BLOCK_SIZE;\ns_distance[lidx] = myBestDistance1;\ns_trainIdx[lidx] = myBestTrainIdx1;\nfloat bestDistance1 = MAX_FLOAT;\nfloat bestDistance2 = MAX_FLOAT;\nint bestTrainIdx1 = -1;\nint bestTrainIdx2 = -1;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lidx == 0)\n{\nfor (int i = 0 ; i < BLOCK_SIZE ; i++)\n{\nfloat val = s_distance[i];\nif (val < bestDistance1)\n{\nbestDistance2 = bestDistance1;\nbestTrainIdx2 = bestTrainIdx1;\nbestDistance1 = val;\nbestTrainIdx1 = s_trainIdx[i];\n}\nelse if (val < bestDistance2)\n{\nbestDistance2 = val;\nbestTrainIdx2 = s_trainIdx[i];\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\ns_distance[lidx] = myBestDistance2;\ns_trainIdx[lidx] = myBestTrainIdx2;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lidx == 0)\n{\nfor (int i = 0 ; i < BLOCK_SIZE ; i++)\n{\nfloat val = s_distance[i];\nif (val < bestDistance2)\n{\nbestDistance2 = val;\nbestTrainIdx2 = s_trainIdx[i];\n}\n}\n}\nmyBestDistance1 = bestDistance1;\nmyBestDistance2 = bestDistance2;\nmyBestTrainIdx1 = bestTrainIdx1;\nmyBestTrainIdx2 = bestTrainIdx2;\nif (queryIdx < query_rows && lidx == 0)\n{\nbestTrainIdx[queryIdx] = (int2)(myBestTrainIdx1, myBestTrainIdx2);\nbestDistance[queryIdx] = (float2)(myBestDistance1, myBestDistance2);\n}\n}\n__kernel void BruteForceMatch_knnMatch(\n__global T *query,\n__global T *train,\n__global int2 *bestTrainIdx,\n__global float2 *bestDistance,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint step\n)\n{\nconst int lidx = get_local_id(0);\nconst int lidy = get_local_id(1);\nconst int groupidx = get_group_id(0);\nconst int queryIdx = groupidx * BLOCK_SIZE + lidy;\n__local value_type *s_query = (__local value_type *)sharebuffer;\n__local value_type *s_train = (__local value_type *)sharebuffer + BLOCK_SIZE * BLOCK_SIZE;\nfloat myBestDistance1 = MAX_FLOAT;\nfloat myBestDistance2 = MAX_FLOAT;\nint myBestTrainIdx1 = -1;\nint myBestTrainIdx2 = -1;\nfor (int  t = 0 ; t < (train_rows + BLOCK_SIZE - 1) / BLOCK_SIZE ; t++)\n{\nresult_type result = 0.0f;\nfor (int i = 0 ; i < (query_cols + BLOCK_SIZE -1) / BLOCK_SIZE ; i++)\n{\nconst int loadx = lidx + i * BLOCK_SIZE;\ns_query[lidy * BLOCK_SIZE + lidx] = 0;\ns_train[lidx * BLOCK_SIZE + lidy] = 0;\nif (loadx < query_cols)\n{\ns_query[lidy * BLOCK_SIZE + lidx] = query[min(queryIdx, query_rows - 1) * (step / sizeof(T)) + loadx];\ns_train[lidx * BLOCK_SIZE + lidy] = train[min(t * BLOCK_SIZE + lidy, train_rows - 1) * (step / sizeof(T)) + loadx];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nresult += reduce_block_match(s_query, s_train, lidx, lidy);\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nresult = DIST_RES(result);\nconst int trainIdx = t * BLOCK_SIZE + lidx;\nif (queryIdx < query_rows && trainIdx < train_rows )\n{\nif (result < myBestDistance1)\n{\nmyBestDistance2 = myBestDistance1;\nmyBestTrainIdx2 = myBestTrainIdx1;\nmyBestDistance1 = result;\nmyBestTrainIdx1 = trainIdx;\n}\nelse if (result < myBestDistance2)\n{\nmyBestDistance2 = result;\nmyBestTrainIdx2 = trainIdx;\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n__local float *s_distance = (__local float *)sharebuffer;\n__local int *s_trainIdx = (__local int *)(sharebuffer + BLOCK_SIZE * BLOCK_SIZE);\ns_distance += lidy * BLOCK_SIZE;\ns_trainIdx += lidy * BLOCK_SIZE;\ns_distance[lidx] = myBestDistance1;\ns_trainIdx[lidx] = myBestTrainIdx1;\nfloat bestDistance1 = MAX_FLOAT;\nfloat bestDistance2 = MAX_FLOAT;\nint bestTrainIdx1 = -1;\nint bestTrainIdx2 = -1;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lidx == 0)\n{\nfor (int i = 0 ; i < BLOCK_SIZE ; i++)\n{\nfloat val = s_distance[i];\nif (val < bestDistance1)\n{\nbestDistance2 = bestDistance1;\nbestTrainIdx2 = bestTrainIdx1;\nbestDistance1 = val;\nbestTrainIdx1 = s_trainIdx[i];\n}\nelse if (val < bestDistance2)\n{\nbestDistance2 = val;\nbestTrainIdx2 = s_trainIdx[i];\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\ns_distance[lidx] = myBestDistance2;\ns_trainIdx[lidx] = myBestTrainIdx2;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lidx == 0)\n{\nfor (int i = 0 ; i < BLOCK_SIZE ; i++)\n{\nfloat val = s_distance[i];\nif (val < bestDistance2)\n{\nbestDistance2 = val;\nbestTrainIdx2 = s_trainIdx[i];\n}\n}\n}\nmyBestDistance1 = bestDistance1;\nmyBestDistance2 = bestDistance2;\nmyBestTrainIdx1 = bestTrainIdx1;\nmyBestTrainIdx2 = bestTrainIdx2;\nif (queryIdx < query_rows && lidx == 0)\n{\nbestTrainIdx[queryIdx] = (int2)(myBestTrainIdx1, myBestTrainIdx2);\nbestDistance[queryIdx] = (float2)(myBestDistance1, myBestDistance2);\n}\n}\nkernel void BruteForceMatch_calcDistanceUnrolled(\n__global T *query,\n__global T *train,\n__global float *allDist,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint step)\n{\n}\nkernel void BruteForceMatch_calcDistance(\n__global T *query,\n__global T *train,\n__global float *allDist,\n__local float *sharebuffer,\nint query_rows,\nint query_cols,\nint train_rows,\nint train_cols,\nint step)\n{\n}\nkernel void BruteForceMatch_findBestMatch(\n__global float *allDist,\n__global int *bestTrainIdx,\n__global float *bestDistance,\nint k\n)\n{\n}\n", "14abdacaf283cc25bdb9a58eb651a26b", "blend_linear", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void blendLinear(__global const T * src1, int src1_offset, int src1_step,\n__global const T * src2, int src2_offset, int src2_step,\n__global const float * weight1, int weight1_offset, int weight1_step,\n__global const float * weight2, int weight2_offset, int weight2_step,\n__global T * dst, int dst_offset, int dst_step,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, src1_offset + x);\nint src2_index = mad24(y, src2_step, src2_offset + x);\nint weight1_index = mad24(y, weight1_step, weight1_offset + x);\nint weight2_index = mad24(y, weight2_step, weight2_offset + x);\nint dst_index = mad24(y, dst_step, dst_offset + x);\nFT w1 = (FT)(weight1[weight1_index]), w2 = (FT)(weight2[weight2_index]);\nFT den = w1 + w2 + (FT)(1e-5f);\nFT num = w1 * convertToFT(src1[src1_index]) + w2 * convertToFT(src2[src2_index]);\ndst[dst_index] = convertToT(num / den);\n}\n}\n", "282ca434c43357705cd20966671a57ef", "bgfg_mog", "#if defined (CN1)\n#define T_FRAME uchar\n#define T_MEAN_VAR float\n#define CONVERT_TYPE convert_uchar_sat\n#define F_ZERO (0.0f)\nfloat cvt(uchar val)\n{\nreturn val;\n}\nfloat sqr(float val)\n{\nreturn val * val;\n}\nfloat sum(float val)\n{\nreturn val;\n}\nfloat clamp1(float var, float learningRate, float diff, float minVar)\n{\nreturn fmax(var + learningRate * (diff * diff - var), minVar);\n}\n#else\n#define T_FRAME uchar4\n#define T_MEAN_VAR float4\n#define CONVERT_TYPE convert_uchar4_sat\n#define F_ZERO (0.0f, 0.0f, 0.0f, 0.0f)\nfloat4 cvt(const uchar4 val)\n{\nfloat4 result;\nresult.x = val.x;\nresult.y = val.y;\nresult.z = val.z;\nresult.w = val.w;\nreturn result;\n}\nfloat sqr(const float4 val)\n{\nreturn val.x * val.x + val.y * val.y + val.z * val.z;\n}\nfloat sum(const float4 val)\n{\nreturn (val.x + val.y + val.z);\n}\nvoid swap4(__global float4* ptr, int x, int y, int k, int rows, int ptr_step)\n{\nfloat4 val = ptr[(k * rows + y) * ptr_step + x];\nptr[(k * rows + y) * ptr_step + x] = ptr[((k + 1) * rows + y) * ptr_step + x];\nptr[((k + 1) * rows + y) * ptr_step + x] = val;\n}\nfloat4 clamp1(const float4 var, float learningRate, const float4 diff, float minVar)\n{\nfloat4 result;\nresult.x = fmax(var.x + learningRate * (diff.x * diff.x - var.x), minVar);\nresult.y = fmax(var.y + learningRate * (diff.y * diff.y - var.y), minVar);\nresult.z = fmax(var.z + learningRate * (diff.z * diff.z - var.z), minVar);\nresult.w = 0.0f;\nreturn result;\n}\n#endif\ntypedef struct\n{\nfloat c_Tb;\nfloat c_TB;\nfloat c_Tg;\nfloat c_varInit;\nfloat c_varMin;\nfloat c_varMax;\nfloat c_tau;\nuchar c_shadowVal;\n} con_srtuct_t;\nvoid swap(__global float* ptr, int x, int y, int k, int rows, int ptr_step)\n{\nfloat val = ptr[(k * rows + y) * ptr_step + x];\nptr[(k * rows + y) * ptr_step + x] = ptr[((k + 1) * rows + y) * ptr_step + x];\nptr[((k + 1) * rows + y) * ptr_step + x] = val;\n}\n__kernel void mog_withoutLearning_kernel(__global T_FRAME* frame, __global uchar* fgmask,\n__global float* weight, __global T_MEAN_VAR* mean, __global T_MEAN_VAR* var,\nint frame_row, int frame_col, int frame_step, int fgmask_step,\nint weight_step, int mean_step, int var_step,\nfloat varThreshold, float backgroundRatio, int fgmask_offset_x,\nint fgmask_offset_y, int frame_offset_x, int frame_offset_y)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < frame_col && y < frame_row)\n{\nT_MEAN_VAR pix = cvt(frame[(y + frame_offset_y) * frame_step + (x + frame_offset_x)]);\nint kHit = -1;\nint kForeground = -1;\nfor (int k = 0; k < (NMIXTURES); ++k)\n{\nif (weight[(k * frame_row + y) * weight_step + x] < 1.192092896e-07f)\nbreak;\nT_MEAN_VAR mu = mean[(k * frame_row + y) * mean_step + x];\nT_MEAN_VAR _var = var[(k * frame_row + y) + var_step + x];\nT_MEAN_VAR diff = pix - mu;\nif (sqr(diff) < varThreshold * sum(_var))\n{\nkHit = k;\nbreak;\n}\n}\nif (kHit >= 0)\n{\nfloat wsum = 0.0f;\nfor (int k = 0; k < (NMIXTURES); ++k)\n{\nwsum += weight[(k * frame_row + y) * weight_step + x];\nif (wsum > backgroundRatio)\n{\nkForeground = k + 1;\nbreak;\n}\n}\n}\nif(kHit < 0 || kHit >= kForeground)\nfgmask[(y + fgmask_offset_y) * fgmask_step + (x + fgmask_offset_x)] = (uchar) (-1);\nelse\nfgmask[(y + fgmask_offset_y) * fgmask_step + (x + fgmask_offset_x)] = (uchar) (0);\n}\n}\n__kernel void mog_withLearning_kernel(__global T_FRAME* frame, __global int* fgmask,\n__global float* weight, __global float* sortKey, __global T_MEAN_VAR* mean,\n__global T_MEAN_VAR* var, int frame_row, int frame_col, int frame_step, int fgmask_step,\nint weight_step, int sortKey_step, int mean_step, int var_step,\nfloat varThreshold, float backgroundRatio, float learningRate, float minVar,\nint fgmask_offset_x, int fgmask_offset_y, int frame_offset_x, int frame_offset_y)\n{\nconst float w0 = 0.05f;\nconst float sk0 = w0 / 30.0f;\nconst float var0 = 900.f;\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x >= frame_col || y >= frame_row) return;\nfloat wsum = 0.0f;\nint kHit = -1;\nint kForeground = -1;\nint k = 0;\nT_MEAN_VAR pix = cvt(frame[(y + frame_offset_y) * frame_step + (x + frame_offset_x)]);\nfor (; k < (NMIXTURES); ++k)\n{\nfloat w = weight[(k * frame_row + y) * weight_step + x];\nwsum += w;\nif (w < 1.192092896e-07f)\nbreak;\nT_MEAN_VAR mu = mean[(k * frame_row + y) * mean_step + x];\nT_MEAN_VAR _var = var[(k * frame_row + y) * var_step + x];\nfloat sortKey_prev, weight_prev;\nT_MEAN_VAR mean_prev, var_prev;\nif (sqr(pix - mu) < varThreshold * sum(_var))\n{\nwsum -= w;\nfloat dw = learningRate * (1.0f - w);\n_var = clamp1(_var, learningRate, pix - mu, minVar);\nsortKey_prev = w / sqr(sum(_var));\nsortKey[(k * frame_row + y) * sortKey_step + x] = sortKey_prev;\nweight_prev = w + dw;\nweight[(k * frame_row + y) * weight_step + x] = weight_prev;\nmean_prev = mu + learningRate * (pix - mu);\nmean[(k * frame_row + y) * mean_step + x] = mean_prev;\nvar_prev = _var;\nvar[(k * frame_row + y) * var_step + x] = var_prev;\n}\nint k1 = k - 1;\nif (k1 >= 0 && sqr(pix - mu) < varThreshold * sum(_var))\n{\nfloat sortKey_next = sortKey[(k1 * frame_row + y) * sortKey_step + x];\nfloat weight_next = weight[(k1 * frame_row + y) * weight_step + x];\nT_MEAN_VAR mean_next = mean[(k1 * frame_row + y) * mean_step + x];\nT_MEAN_VAR var_next = var[(k1 * frame_row + y) * var_step + x];\nfor (; sortKey_next < sortKey_prev && k1 >= 0; --k1)\n{\nsortKey[(k1 * frame_row + y) * sortKey_step + x] = sortKey_prev;\nsortKey[((k1 + 1) * frame_row + y) * sortKey_step + x] = sortKey_next;\nweight[(k1 * frame_row + y) * weight_step + x] = weight_prev;\nweight[((k1 + 1) * frame_row + y) * weight_step + x] = weight_next;\nmean[(k1 * frame_row + y) * mean_step + x] = mean_prev;\nmean[((k1 + 1) * frame_row + y) * mean_step + x] = mean_next;\nvar[(k1 * frame_row + y) * var_step + x] = var_prev;\nvar[((k1 + 1) * frame_row + y) * var_step + x] = var_next;\nsortKey_prev = sortKey_next;\nsortKey_next = k1 > 0 ? sortKey[((k1 - 1) * frame_row + y) * sortKey_step + x] : 0.0f;\nweight_prev = weight_next;\nweight_next = k1 > 0 ? weight[((k1 - 1) * frame_row + y) * weight_step + x] : 0.0f;\nmean_prev = mean_next;\nmean_next = k1 > 0 ? mean[((k1 - 1) * frame_row + y) * mean_step + x] : (T_MEAN_VAR)F_ZERO;\nvar_prev = var_next;\nvar_next = k1 > 0 ? var[((k1 - 1) * frame_row + y) * var_step + x] : (T_MEAN_VAR)F_ZERO;\n}\n}\nkHit = k1 + 1;\nbreak;\n}\nif (kHit < 0)\n{\nkHit = k = k < ((NMIXTURES) - 1) ? k : ((NMIXTURES) - 1);\nwsum += w0 - weight[(k * frame_row + y) * weight_step + x];\nweight[(k * frame_row + y) * weight_step + x] = w0;\nmean[(k * frame_row + y) * mean_step + x] = pix;\n#if defined (CN1)\nvar[(k * frame_row + y) * var_step + x] = (T_MEAN_VAR)(var0);\n#else\nvar[(k * frame_row + y) * var_step + x] = (T_MEAN_VAR)(var0, var0, var0, var0);\n#endif\nsortKey[(k * frame_row + y) * sortKey_step + x] = sk0;\n}\nelse\n{\nfor( ; k < (NMIXTURES); k++)\nwsum += weight[(k * frame_row + y) * weight_step + x];\n}\nfloat wscale = 1.0f / wsum;\nwsum = 0;\nfor (k = 0; k < (NMIXTURES); ++k)\n{\nfloat w = weight[(k * frame_row + y) * weight_step + x];\nw *= wscale;\nwsum += w;\nweight[(k * frame_row + y) * weight_step + x] = w;\nsortKey[(k * frame_row + y) * sortKey_step + x] *= wscale;\nkForeground = select(kForeground, k + 1, wsum > backgroundRatio && kForeground < 0);\n}\nfgmask[(y + fgmask_offset_y) * fgmask_step + (x + fgmask_offset_x)] = (uchar)(-(kHit >= kForeground));\n}\n__kernel void getBackgroundImage_kernel(__global float* weight, __global T_MEAN_VAR* mean, __global T_FRAME* dst,\nint dst_row, int dst_col, int weight_step, int mean_step, int dst_step,\nfloat backgroundRatio)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < dst_col && y < dst_row)\n{\nT_MEAN_VAR meanVal = (T_MEAN_VAR)F_ZERO;\nfloat totalWeight = 0.0f;\nfor (int mode = 0; mode < (NMIXTURES); ++mode)\n{\nfloat _weight = weight[(mode * dst_row + y) * weight_step + x];\nT_MEAN_VAR _mean = mean[(mode * dst_row + y) * mean_step + x];\nmeanVal = meanVal + _weight * _mean;\ntotalWeight += _weight;\nif(totalWeight > backgroundRatio)\nbreak;\n}\nmeanVal = meanVal * (1.f / totalWeight);\ndst[y * dst_step + x] = CONVERT_TYPE(meanVal);\n}\n}\n__kernel void mog2_kernel(__global T_FRAME * frame, __global int* fgmask, __global float* weight, __global T_MEAN_VAR * mean,\n__global int* modesUsed, __global float* variance, int frame_row, int frame_col, int frame_step,\nint fgmask_step, int weight_step, int mean_step, int modesUsed_step, int var_step, float alphaT, float alpha1, float prune,\nint detectShadows_flag, int fgmask_offset_x, int fgmask_offset_y, int frame_offset_x, int frame_offset_y, __constant con_srtuct_t* constants)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < frame_col && y < frame_row)\n{\nT_MEAN_VAR pix = cvt(frame[(y + frame_offset_y) * frame_step + x + frame_offset_x]);\nbool background = false;\nbool fitsPDF = false;\nint nmodes = modesUsed[y * modesUsed_step + x];\nint nNewModes = nmodes;\nfloat totalWeight = 0.0f;\nfor (int mode = 0; mode < nmodes; ++mode)\n{\nfloat _weight = alpha1 * weight[(mode * frame_row + y) * weight_step + x] + prune;\nint swap_count = 0;\nif (!fitsPDF)\n{\nfloat var = variance[(mode * frame_row + y) * var_step + x];\nT_MEAN_VAR _mean = mean[(mode * frame_row + y) * mean_step + x];\nT_MEAN_VAR diff = _mean - pix;\nfloat dist2 = sqr(diff);\nif (totalWeight < constants -> c_TB && dist2 < constants -> c_Tb * var)\nbackground = true;\nif (dist2 < constants -> c_Tg * var)\n{\nfitsPDF = true;\n_weight += alphaT;\nfloat k = alphaT / _weight;\nmean[(mode * frame_row + y) * mean_step + x] = _mean - k * diff;\nfloat varnew = var + k * (dist2 - var);\nvarnew = fmax(varnew, constants -> c_varMin);\nvarnew = fmin(varnew, constants -> c_varMax);\nvariance[(mode * frame_row + y) * var_step + x] = varnew;\nfor (int i = mode; i > 0; --i)\n{\nif (_weight < weight[((i - 1) * frame_row + y) * weight_step + x])\nbreak;\nswap_count++;\nswap(weight, x, y, i - 1, frame_row, weight_step);\nswap(variance, x, y, i - 1, frame_row, var_step);\n#if defined (CN1)\nswap(mean, x, y, i - 1, frame_row, mean_step);\n#else\nswap4(mean, x, y, i - 1, frame_row, mean_step);\n#endif\n}\n}\n}\nif (_weight < -prune)\n{\n_weight = 0.0f;\nnmodes--;\n}\nweight[((mode - swap_count) * frame_row + y) * weight_step + x] = _weight;\ntotalWeight += _weight;\n}\ntotalWeight = 1.f / totalWeight;\nfor (int mode = 0; mode < nmodes; ++mode)\nweight[(mode * frame_row + y) * weight_step + x] *= totalWeight;\nnmodes = nNewModes;\nif (!fitsPDF)\n{\nint mode = nmodes == (NMIXTURES) ? (NMIXTURES) - 1 : nmodes++;\nif (nmodes == 1)\nweight[(mode * frame_row + y) * weight_step + x] = 1.f;\nelse\n{\nweight[(mode * frame_row + y) * weight_step + x] = alphaT;\nfor (int i = 0; i < nmodes - 1; ++i)\nweight[(i * frame_row + y) * weight_step + x] *= alpha1;\n}\nmean[(mode * frame_row + y) * mean_step + x] = pix;\nvariance[(mode * frame_row + y) * var_step + x] = constants -> c_varInit;\nfor (int i = nmodes - 1; i > 0; --i)\n{\nif (alphaT < weight[((i - 1) * frame_row + y) * weight_step + x])\nbreak;\nswap(weight, x, y, i - 1, frame_row, weight_step);\nswap(variance, x, y, i - 1, frame_row, var_step);\n#if defined (CN1)\nswap(mean, x, y, i - 1, frame_row, mean_step);\n#else\nswap4(mean, x, y, i - 1, frame_row, mean_step);\n#endif\n}\n}\nmodesUsed[y * modesUsed_step + x] = nmodes;\nbool isShadow = false;\nif (detectShadows_flag && !background)\n{\nfloat tWeight = 0.0f;\nfor (int mode = 0; mode < nmodes; ++mode)\n{\nT_MEAN_VAR _mean = mean[(mode * frame_row + y) * mean_step + x];\nT_MEAN_VAR pix_mean = pix * _mean;\nfloat numerator = sum(pix_mean);\nfloat denominator = sqr(_mean);\nif (denominator == 0)\nbreak;\nif (numerator <= denominator && numerator >= constants -> c_tau * denominator)\n{\nfloat a = numerator / denominator;\nT_MEAN_VAR dD = a * _mean - pix;\nif (sqr(dD) < constants -> c_Tb * variance[(mode * frame_row + y) * var_step + x] * a * a)\n{\nisShadow = true;\nbreak;\n}\n}\ntWeight += weight[(mode * frame_row + y) * weight_step + x];\nif (tWeight > constants -> c_TB)\nbreak;\n}\n}\nfgmask[(y + fgmask_offset_y) * fgmask_step + x + fgmask_offset_x] = background ? 0 : isShadow ? constants -> c_shadowVal : 255;\n}\n}\n__kernel void getBackgroundImage2_kernel(__global int* modesUsed, __global float* weight, __global T_MEAN_VAR* mean,\n__global T_FRAME* dst, float c_TB, int modesUsed_row, int modesUsed_col, int modesUsed_step, int weight_step,\nint mean_step, int dst_step, int dst_x, int dst_y)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < modesUsed_col && y < modesUsed_row)\n{\nint nmodes = modesUsed[y * modesUsed_step + x];\nT_MEAN_VAR meanVal = (T_MEAN_VAR)F_ZERO;\nfloat totalWeight = 0.0f;\nfor (int mode = 0; mode < nmodes; ++mode)\n{\nfloat _weight = weight[(mode * modesUsed_row + y) * weight_step + x];\nT_MEAN_VAR _mean = mean[(mode * modesUsed_row + y) * mean_step + x];\nmeanVal = meanVal + _weight * _mean;\ntotalWeight += _weight;\nif(totalWeight > c_TB)\nbreak;\n}\nmeanVal = meanVal * (1.f / totalWeight);\ndst[(y + dst_y) * dst_step + x + dst_x] = CONVERT_TYPE(meanVal);\n}\n}\n", "7fd1eedde22b5fad55ba5eb9cac67955", "arithm_transpose", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#define TILE_DIM      32\n#define BLOCK_ROWS    8\n#define LDS_STEP      TILE_DIM\n__kernel void transpose(__global const T* src, __global T* dst,\nint src_cols, int src_rows,\nint src_step, int dst_step,\nint src_offset, int dst_offset)\n{\nint gp_x = get_group_id(0),   gp_y = get_group_id(1);\nint gs_x = get_num_groups(0), gs_y = get_num_groups(1);\nint groupId_x, groupId_y;\nif(src_rows == src_cols)\n{\ngroupId_y = gp_x;\ngroupId_x = (gp_x + gp_y) % gs_x;\n}\nelse\n{\nint bid = gp_x + gs_x * gp_y;\ngroupId_y =  bid % gs_y;\ngroupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n}\nint lx = get_local_id(0);\nint ly = get_local_id(1);\nint x = groupId_x * TILE_DIM + lx;\nint y = groupId_y * TILE_DIM + ly;\nint x_index = groupId_y * TILE_DIM + lx;\nint y_index = groupId_x * TILE_DIM + ly;\n__local T title[TILE_DIM * LDS_STEP];\nif (x < src_cols && y < src_rows)\n{\nint index_src = mad24(y, src_step, x);\nfor(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n{\nif (y + i < src_rows)\n{\ntitle[(ly + i) * LDS_STEP + lx] = src[src_offset + index_src];\nindex_src = mad24(BLOCK_ROWS, src_step, index_src);\n}\n}\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (x_index < src_rows && y_index < src_cols)\n{\nint index_dst = mad24(y_index, dst_step, x_index);\nfor(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n{\nif ((y_index + i) < src_cols)\n{\ndst[dst_offset + index_dst] = title[lx * LDS_STEP + ly + i];\nindex_dst +=  dst_step * BLOCK_ROWS;\n}\n}\n}\n}\n__kernel void transpose_inplace(__global T* src, __global T* dst,\nint src_cols, int src_rows,\nint src_step, int dst_step,\nint src_offset, int dst_offset)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (y < src_rows && x < y)\n{\nint srcIdx = mad24(y, src_step, src_offset + x);\nint dstIdx = mad24(x, dst_step, dst_offset + y);\nT tmp = dst[dstIdx];\ndst[dstIdx] = src[srcIdx];\nsrc[srcIdx] = tmp;\n}\n}\n", "bd4ecb4b23c96b7c71399c6faa7a71f4", "arithm_sum", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#if FUNC_SUM\n#define FUNC(a, b) b += a;\n#elif FUNC_ABS_SUM\n#define FUNC(a, b) b += a >= (dstT)(0) ? a : -a;\n#elif FUNC_SQR_SUM\n#define FUNC(a, b) b += a * a;\n#else\n#error No sum function\n#endif\n__kernel void arithm_op_sum(__global srcT * src, int src_step, int src_offset, int src_cols,\nint total, int groupnum, __global dstT * dst)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint id = get_global_id(0);\n__local dstT localmem_sum[128];\ndstT sum = (dstT)(0), temp;\nfor (int grainSize = groupnum << 8; id < total; id += grainSize)\n{\ntemp = convertToDstT(src[mad24(id / src_cols, src_step, id % src_cols + src_offset)]);\nFUNC(temp, sum);\n}\nif (lid > 127)\nlocalmem_sum[lid - 128] = sum;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lid < 128)\nlocalmem_sum[lid] = sum + localmem_sum[lid];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int lsize = 64; lsize > 0; lsize >>= 1)\n{\nif (lid < lsize)\n{\nint lid2 = lsize + lid;\nlocalmem_sum[lid] = localmem_sum[lid] + localmem_sum[lid2];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif (lid == 0)\ndst[gid] = localmem_sum[0];\n}\n", "6183a9be49fc10d3d55fa959093a607f", "arithm_setidentity", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void setIdentity(__global T * src, int src_step, int src_offset,\nint cols, int rows, __global const T * scalar)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src_index = mad24(y, src_step, src_offset + x);\nif (x == y)\nsrc[src_index] = *scalar;\nelse\nsrc[src_index] = 0;\n}\n}\n", "bc19dcbca5a8d384082c7d000b806e1b", "arithm_pow", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void arithm_pow(__global VT * src, int src_step, int src_offset,\n__global VT * dst, int dst_step, int dst_offset,\nint rows, int cols, T p)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src_index = mad24(y, src_step, x + src_offset);\nint dst_index = mad24(y, dst_step, x + dst_offset);\nVT src_data = src[src_index];\nVT tmp = src_data > (VT)0 ? (VT)exp(p * log(src_data)) : (src_data == (VT)0 ? (VT)0 : (VT)exp(p * log(fabs(src_data))));\ndst[dst_index] = tmp;\n}\n}\n", "a79b90c5a25fec8fe4d5af644308c7c5", "arithm_polarToCart", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define CV_PI M_PI\n#else\n#define CV_PI M_PI_F\n#endif\n__kernel void arithm_polarToCart_mag_D5 (__global float *src1, int src1_step, int src1_offset,\n__global float *src2, int src2_step, int src2_offset,\n__global float *dst1, int dst1_step, int dst1_offset,\n__global float *dst2, int dst2_step, int dst2_offset,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst1_index = mad24(y, dst1_step, x + dst1_offset);\nint dst2_index = mad24(y, dst2_step, x + dst2_offset);\nfloat x = src1[src1_index];\nfloat y = src2[src2_index];\n#ifdef DEGREE\nfloat ascale = CV_PI/180.0f;\nfloat alpha = y * ascale;\n#else\nfloat alpha = y;\n#endif\nfloat a = cos(alpha) * x;\nfloat b = sin(alpha) * x;\ndst1[dst1_index] = a;\ndst2[dst2_index] = b;\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void arithm_polarToCart_mag_D6 (__global double *src1, int src1_step, int src1_offset,\n__global double *src2, int src2_step, int src2_offset,\n__global double *dst1, int dst1_step, int dst1_offset,\n__global double *dst2, int dst2_step, int dst2_offset,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst1_index = mad24(y, dst1_step, x + dst1_offset);\nint dst2_index = mad24(y, dst2_step, x + dst2_offset);\ndouble x = src1[src1_index];\ndouble y = src2[src2_index];\n#ifdef DEGREE\nfloat ascale = CV_PI/180.0;\nfloat alpha = y * ascale;\n#else\nfloat alpha = y;\n#endif\ndouble a = cos(alpha) * x;\ndouble b = sin(alpha) * x;\ndst1[dst1_index] = a;\ndst2[dst2_index] = b;\n}\n}\n#endif\n__kernel void arithm_polarToCart_D5 (__global float *src,  int src_step,  int src_offset,\n__global float *dst1, int dst1_step, int dst1_offset,\n__global float *dst2, int dst2_step, int dst2_offset,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src_index  = mad24(y, src_step,  x + src_offset);\nint dst1_index = mad24(y, dst1_step, x + dst1_offset);\nint dst2_index = mad24(y, dst2_step, x + dst2_offset);\nfloat y = src[src_index];\n#ifdef DEGREE\nfloat ascale = CV_PI/180.0f;\nfloat alpha = y * ascale;\n#else\nfloat alpha = y;\n#endif\nfloat a = cos(alpha);\nfloat b = sin(alpha);\ndst1[dst1_index] = a;\ndst2[dst2_index] = b;\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void arithm_polarToCart_D6 (__global float *src,  int src_step,  int src_offset,\n__global float *dst1, int dst1_step, int dst1_offset,\n__global float *dst2, int dst2_step, int dst2_offset,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src_index  = mad24(y, src_step,  x + src_offset);\nint dst1_index = mad24(y, dst1_step, x + dst1_offset);\nint dst2_index = mad24(y, dst2_step, x + dst2_offset);\ndouble y = src[src_index];\n#ifdef DEGREE\nfloat ascale = CV_PI/180.0f;\nfloat alpha = y * ascale;\n#else\nfloat alpha = y;\n#endif\ndouble a = cos(alpha);\ndouble b = sin(alpha);\ndst1[dst1_index] = a;\ndst2[dst2_index] = b;\n}\n}\n#endif\n", "3b9f767242239556823d43460957858f", "arithm_phase", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define CV_PI M_PI\n#define CV_2PI (2 * CV_PI)\n#else\n#define CV_PI M_PI_F\n#define CV_2PI (2 * CV_PI)\n#endif\n__kernel void arithm_phase_inradians_D5(__global float *src1, int src1_step1, int src1_offset1,\n__global float *src2, int src2_step1, int src2_offset1,\n__global float *dst,  int dst_step1,  int dst_offset1,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step1, x + src1_offset1);\nint src2_index = mad24(y, src2_step1, x + src2_offset1);\nint dst_index  = mad24(y, dst_step1, x + dst_offset1);\nfloat data1 = src1[src1_index];\nfloat data2 = src2[src2_index];\nfloat tmp = atan2(data2, data1);\nif (tmp < 0)\ntmp += CV_2PI;\ndst[dst_index] = tmp;\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void arithm_phase_inradians_D6(__global double *src1, int src1_step1, int src1_offset1,\n__global double *src2, int src2_step1, int src2_offset1,\n__global double *dst,  int dst_step1,  int dst_offset1,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step1, x + src1_offset1);\nint src2_index = mad24(y, src2_step1, x + src2_offset1);\nint dst_index  = mad24(y, dst_step1, x + dst_offset1);\ndouble data1 = src1[src1_index];\ndouble data2 = src2[src2_index];\ndouble tmp = atan2(data2, data1);\nif (tmp < 0)\ntmp += CV_2PI;\ndst[dst_index] = tmp;\n}\n}\n#endif\n__kernel void arithm_phase_indegrees_D5(__global float *src1, int src1_step1, int src1_offset1,\n__global float *src2, int src2_step1, int src2_offset1,\n__global float *dst,  int dst_step1,  int dst_offset1,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step1, x + src1_offset1);\nint src2_index = mad24(y, src2_step1, x + src2_offset1);\nint dst_index  = mad24(y, dst_step1, x + dst_offset1);\nfloat data1 = src1[src1_index];\nfloat data2 = src2[src2_index];\nfloat tmp = atan2(data2, data1);\ntmp = 180 * tmp / CV_PI;\nif (tmp < 0)\ntmp += 360;\ndst[dst_index] = tmp;\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void arithm_phase_indegrees_D6 (__global double *src1, int src1_step1, int src1_offset1,\n__global double *src2, int src2_step1, int src2_offset1,\n__global double *dst,  int dst_step1,  int dst_offset1,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step1, x + src1_offset1);\nint src2_index = mad24(y, src2_step1, x + src2_offset1);\nint dst_index  = mad24(y, dst_step1, x + dst_offset1);\ndouble data1 = src1[src1_index];\ndouble data2 = src2[src2_index];\ndouble tmp = atan2(data2, data1);\ntmp = 180 * tmp / CV_PI;\nif (tmp < 0)\ntmp += 360;\ndst[dst_index] = tmp;\n}\n}\n#endif\n", "74e75b6750558dabe4856b6557b6ae41", "arithm_nonzero", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void arithm_op_nonzero(__global srcT * src, int src_step, int src_offset, int src_cols,\nint total, int groupnum, __global dstT * dst)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint  id = get_global_id(0);\n__local dstT localmem_nonzero[128];\ndstT nonzero = (dstT)(0);\nfor (int grain = groupnum << 8; id < total; id += grain)\nnonzero += convertToDstT(src[mad24(id / src_cols, src_step, id % src_cols + src_offset)] == (srcT)(0)) ? (dstT)(0) : (dstT)(1);\nif (lid > 127)\nlocalmem_nonzero[lid - 128] = nonzero;\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lid < 128)\nlocalmem_nonzero[lid] = nonzero + localmem_nonzero[lid];\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int lsize = 64; lsize > 0; lsize >>= 1)\n{\nif (lid < lsize)\n{\nint lid2 = lsize + lid;\nlocalmem_nonzero[lid] = localmem_nonzero[lid] + localmem_nonzero[lid2];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif (lid == 0)\ndst[gid] = localmem_nonzero[0];\n}\n", "650573f3600f3c0f0a6a87ab3d29e803", "arithm_minMaxLoc_mask", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define RES_TYPE double4\n#define CONVERT_RES_TYPE convert_double4\n#else\n#define RES_TYPE float4\n#define CONVERT_RES_TYPE convert_float4\n#endif\n#if defined (DEPTH_0)\n#define TYPE uchar\n#define VEC_TYPE uchar4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_uchar4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL 0\n#define MAX_VAL 255\n#endif\n#if defined (DEPTH_1)\n#define TYPE char\n#define VEC_TYPE char4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_char4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL -128\n#define MAX_VAL 127\n#endif\n#if defined (DEPTH_2)\n#define TYPE ushort\n#define VEC_TYPE ushort4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_ushort4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL 0\n#define MAX_VAL 65535\n#endif\n#if defined (DEPTH_3)\n#define TYPE short\n#define VEC_TYPE short4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_short4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL -32768\n#define MAX_VAL 32767\n#endif\n#if defined (DEPTH_4)\n#define TYPE int\n#define VEC_TYPE int4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_int4\n#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n#define MIN_VAL INT_MIN\n#define MAX_VAL INT_MAX\n#endif\n#if defined (DEPTH_5)\n#define TYPE float\n#define VEC_TYPE float4\n#define VEC_TYPE_LOC float4\n#define CONVERT_TYPE convert_float4\n#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n#define MIN_VAL (-FLT_MAX)\n#define MAX_VAL FLT_MAX\n#endif\n#if defined (DEPTH_6)\n#define TYPE double\n#define VEC_TYPE double4\n#define VEC_TYPE_LOC double4\n#define CONVERT_TYPE convert_double4\n#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n#define MIN_VAL (-DBL_MAX)\n#define MAX_VAL DBL_MAX\n#endif\n#if defined (REPEAT_E0)\n#define repeat_e(a) a=a;\n#endif\n#if defined (REPEAT_E1)\n#define repeat_e(a) a.s3 = a.s2;\n#endif\n#if defined (REPEAT_E2)\n#define repeat_e(a) a.s3 = a.s1;a.s2 = a.s1;\n#endif\n#if defined (REPEAT_E3)\n#define repeat_e(a) a.s3 = a.s0;a.s2 = a.s0;a.s1 = a.s0;\n#endif\n#if defined (REPEAT_E0)\n#define repeat_me(a) a = a;\n#endif\n#if defined (REPEAT_E1)\n#define repeat_me(a) a.s3 = 0;\n#endif\n#if defined (REPEAT_E2)\n#define repeat_me(a) a.s3 = 0;a.s2 = 0;\n#endif\n#if defined (REPEAT_E3)\n#define repeat_me(a) a.s3 = 0;a.s2 = 0;a.s1 = 0;\n#endif\n__kernel void arithm_op_minMaxLoc_mask (int cols,int invalid_cols,int offset,int elemnum,int groupnum,__global TYPE *src,\nint minvalid_cols,int moffset,__global uchar *mask,__global RES_TYPE  *dst)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint  id = get_global_id(0);\nint idx = id + (id / cols) * invalid_cols;\nint midx = id + (id / cols) * minvalid_cols;\n__local VEC_TYPE lm_max[128],lm_min[128];\nVEC_TYPE minval, maxval, temp, m_temp, zeroVal = (VEC_TYPE)(0);\n__local VEC_TYPE_LOC lm_maxloc[128], lm_minloc[128];\nVEC_TYPE_LOC minloc, maxloc, temploc, negative = -1, one = 1, zero = 0;\nif(id < elemnum)\n{\ntemp = vload4(idx, &src[offset]);\nm_temp = CONVERT_TYPE(vload4(midx,&mask[moffset]));\nint idx_c = (idx << 2) + offset;\ntemploc = (VEC_TYPE_LOC)(idx_c,idx_c+1,idx_c+2,idx_c+3);\nif (id % cols == cols - 1)\n{\nrepeat_me(m_temp);\nrepeat_e(temploc);\n}\nminval = m_temp != zeroVal ? temp : (VEC_TYPE)MAX_VAL;\nmaxval = m_temp != zeroVal ? temp : (VEC_TYPE)MIN_VAL;\nminloc = CONDITION_FUNC(m_temp != zeroVal, temploc , negative);\nmaxloc = minloc;\n}\nelse\n{\nminval = MAX_VAL;\nmaxval = MIN_VAL;\nminloc = negative;\nmaxloc = negative;\n}\nfor(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n{\nidx = id + (id / cols) * invalid_cols;\nmidx = id + (id / cols) * minvalid_cols;\ntemp = vload4(idx, &src[offset]);\nm_temp = CONVERT_TYPE(vload4(midx,&mask[moffset]));\nint idx_c = (idx << 2) + offset;\ntemploc = (VEC_TYPE_LOC)(idx_c,idx_c+1,idx_c+2,idx_c+3);\nif (id % cols == cols - 1)\n{\nrepeat_me(m_temp);\nrepeat_e(temploc);\n}\nminval = min(minval, m_temp != zeroVal ? temp : minval);\nmaxval = max(maxval, m_temp != zeroVal ? temp : maxval);\nminloc = CONDITION_FUNC(minval == temp && m_temp != zeroVal, temploc , minloc);\nmaxloc = CONDITION_FUNC(maxval == temp && m_temp != zeroVal, temploc , maxloc);\n}\nif(lid > 127)\n{\nlm_min[lid - 128] = minval;\nlm_max[lid - 128] = maxval;\nlm_minloc[lid - 128] = minloc;\nlm_maxloc[lid - 128] = maxloc;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif(lid < 128)\n{\nlm_min[lid] = min(minval, lm_min[lid]);\nlm_max[lid] = max(maxval, lm_max[lid]);\nVEC_TYPE con_min = CONVERT_TYPE(minloc != negative ? one : zero);\nVEC_TYPE con_max = CONVERT_TYPE(maxloc != negative ? one : zero);\nVEC_TYPE lmMinVal = lm_min[lid], lmMaxVal = lm_max[lid];\nlm_minloc[lid] = CONDITION_FUNC(lmMinVal == minval && con_min != zeroVal, minloc , lm_minloc[lid]);\nlm_maxloc[lid] = CONDITION_FUNC(lmMaxVal == maxval && con_max != zeroVal, maxloc , lm_maxloc[lid]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor(int lsize = 64; lsize > 0; lsize >>= 1)\n{\nif(lid < lsize)\n{\nint lid2 = lsize + lid;\nlm_min[lid] = min(lm_min[lid], lm_min[lid2]);\nlm_max[lid] = max(lm_max[lid], lm_max[lid2]);\nVEC_TYPE con_min = CONVERT_TYPE(lm_minloc[lid2] != negative ? one : zero);\nVEC_TYPE con_max = CONVERT_TYPE(lm_maxloc[lid2] != negative ? one : zero);\nVEC_TYPE lmMinVal1 = lm_min[lid], lmMinVal2 = lm_min[lid2];\nVEC_TYPE lmMaxVal1 = lm_max[lid], lmMaxVal2 = lm_max[lid2];\nlm_minloc[lid] = CONDITION_FUNC(lmMinVal1 == lmMinVal2 && con_min != zeroVal, lm_minloc[lid2] , lm_minloc[lid]);\nlm_maxloc[lid] = CONDITION_FUNC(lmMaxVal1 == lmMaxVal2 && con_max != zeroVal, lm_maxloc[lid2] , lm_maxloc[lid]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif( lid == 0)\n{\ndst[gid] = CONVERT_RES_TYPE(lm_min[0]);\ndst[gid + groupnum] = CONVERT_RES_TYPE(lm_max[0]);\ndst[gid + 2 * groupnum] = CONVERT_RES_TYPE(lm_minloc[0]);\ndst[gid + 3 * groupnum] = CONVERT_RES_TYPE(lm_maxloc[0]);\n}\n}\n", "a2ac711cf5b963637b561e0c868b7f04", "arithm_minMaxLoc", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define RES_TYPE double4\n#define CONVERT_RES_TYPE convert_double4\n#else\n#define RES_TYPE float4\n#define CONVERT_RES_TYPE convert_float4\n#endif\n#if defined (DEPTH_0)\n#define VEC_TYPE uchar4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_uchar4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL 0\n#define MAX_VAL 255\n#endif\n#if defined (DEPTH_1)\n#define VEC_TYPE char4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_char4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL -128\n#define MAX_VAL 127\n#endif\n#if defined (DEPTH_2)\n#define VEC_TYPE ushort4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_ushort4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL 0\n#define MAX_VAL 65535\n#endif\n#if defined (DEPTH_3)\n#define VEC_TYPE short4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_short4\n#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n#define MIN_VAL -32768\n#define MAX_VAL 32767\n#endif\n#if defined (DEPTH_4)\n#define VEC_TYPE int4\n#define VEC_TYPE_LOC int4\n#define CONVERT_TYPE convert_int4\n#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n#define MIN_VAL INT_MIN\n#define MAX_VAL INT_MAX\n#endif\n#if defined (DEPTH_5)\n#define VEC_TYPE float4\n#define VEC_TYPE_LOC float4\n#define CONVERT_TYPE convert_float4\n#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n#define MIN_VAL (-FLT_MAX)\n#define MAX_VAL FLT_MAX\n#endif\n#if defined (DEPTH_6)\n#define VEC_TYPE double4\n#define VEC_TYPE_LOC double4\n#define CONVERT_TYPE convert_double4\n#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n#define MIN_VAL (-DBL_MAX)\n#define MAX_VAL DBL_MAX\n#endif\n#if defined (REPEAT_S0)\n#define repeat_s(a) a=a;\n#endif\n#if defined (REPEAT_S1)\n#define repeat_s(a) a.s0 = a.s1;\n#endif\n#if defined (REPEAT_S2)\n#define repeat_s(a) a.s0 = a.s2;a.s1 = a.s2;\n#endif\n#if defined (REPEAT_S3)\n#define repeat_s(a) a.s0 = a.s3;a.s1 = a.s3;a.s2 = a.s3;\n#endif\n#if defined (REPEAT_E0)\n#define repeat_e(a) a=a;\n#endif\n#if defined (REPEAT_E1)\n#define repeat_e(a) a.s3 = a.s2;\n#endif\n#if defined (REPEAT_E2)\n#define repeat_e(a) a.s3 = a.s1;a.s2 = a.s1;\n#endif\n#if defined (REPEAT_E3)\n#define repeat_e(a) a.s3 = a.s0;a.s2 = a.s0;a.s1 = a.s0;\n#endif\n__kernel void arithm_op_minMaxLoc(int cols, int invalid_cols, int offset, int elemnum, int groupnum,\n__global VEC_TYPE *src, __global RES_TYPE *dst)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint  id = get_global_id(0);\nint idx = offset + id + (id / cols) * invalid_cols;\n__local VEC_TYPE localmem_max[128], localmem_min[128];\nVEC_TYPE minval, maxval, temp;\n__local VEC_TYPE_LOC localmem_maxloc[128], localmem_minloc[128];\nVEC_TYPE_LOC minloc, maxloc, temploc, negative = -1;\nint idx_c;\nif (id < elemnum)\n{\ntemp = src[idx];\nidx_c = idx << 2;\ntemploc = (VEC_TYPE_LOC)(idx_c, idx_c + 1, idx_c + 2, idx_c + 3);\nif (id % cols == 0 )\n{\nrepeat_s(temp);\nrepeat_s(temploc);\n}\nif (id % cols == cols - 1)\n{\nrepeat_e(temp);\nrepeat_e(temploc);\n}\nminval = temp;\nmaxval = temp;\nminloc = temploc;\nmaxloc = temploc;\n}\nelse\n{\nminval = MAX_VAL;\nmaxval = MIN_VAL;\nminloc = negative;\nmaxloc = negative;\n}\nint grainSize = (groupnum << 8);\nfor (id = id + grainSize; id < elemnum; id = id + grainSize)\n{\nidx = offset + id + (id / cols) * invalid_cols;\ntemp = src[idx];\nidx_c = idx << 2;\ntemploc = (VEC_TYPE_LOC)(idx_c, idx_c+1, idx_c+2, idx_c+3);\nif (id % cols == 0 )\n{\nrepeat_s(temp);\nrepeat_s(temploc);\n}\nif (id % cols == cols - 1)\n{\nrepeat_e(temp);\nrepeat_e(temploc);\n}\nminval = min(minval, temp);\nmaxval = max(maxval, temp);\nminloc = CONDITION_FUNC(minval == temp, temploc, minloc);\nmaxloc = CONDITION_FUNC(maxval == temp, temploc, maxloc);\n}\nif (lid > 127)\n{\nlocalmem_min[lid - 128] = minval;\nlocalmem_max[lid - 128] = maxval;\nlocalmem_minloc[lid - 128] = minloc;\nlocalmem_maxloc[lid - 128] = maxloc;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lid < 128)\n{\nlocalmem_min[lid] = min(minval,localmem_min[lid]);\nlocalmem_max[lid] = max(maxval,localmem_max[lid]);\nVEC_TYPE minVal = localmem_min[lid], maxVal = localmem_max[lid];\nlocalmem_minloc[lid] = CONDITION_FUNC(minVal == minval, minloc, localmem_minloc[lid]);\nlocalmem_maxloc[lid] = CONDITION_FUNC(maxVal == maxval, maxloc, localmem_maxloc[lid]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int lsize = 64; lsize > 0; lsize >>= 1)\n{\nif (lid < lsize)\n{\nint lid2 = lsize + lid;\nlocalmem_min[lid] = min(localmem_min[lid], localmem_min[lid2]);\nlocalmem_max[lid] = max(localmem_max[lid], localmem_max[lid2]);\nVEC_TYPE min1 = localmem_min[lid], min2 = localmem_min[lid2];\nlocalmem_minloc[lid] = CONDITION_FUNC(min1 == min2, localmem_minloc[lid2], localmem_minloc[lid]);\nVEC_TYPE max1 = localmem_max[lid], max2 = localmem_max[lid2];\nlocalmem_maxloc[lid] = CONDITION_FUNC(max1 == max2, localmem_maxloc[lid2], localmem_maxloc[lid]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif ( lid == 0)\n{\ndst[gid] = CONVERT_RES_TYPE(localmem_min[0]);\ndst[gid + groupnum] = CONVERT_RES_TYPE(localmem_max[0]);\ndst[gid + 2 * groupnum] = CONVERT_RES_TYPE(localmem_minloc[0]);\ndst[gid + 3 * groupnum] = CONVERT_RES_TYPE(localmem_maxloc[0]);\n}\n}\n", "a59ab29ff6ebd4dcab6304a7547f4cf3", "arithm_minMax", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#ifdef DEPTH_5\n#define MIN_VAL (-FLT_MAX)\n#define MAX_VAL FLT_MAX\n#elif defined DEPTH_6\n#define MIN_VAL (-DBL_MAX)\n#define MAX_VAL DBL_MAX\n#endif\n__kernel void arithm_op_minMax(__global const T * src, int src_step, int src_offset, int src_rows, int src_cols,\nint total, int groupnum, __global T * dst\n#ifdef WITH_MASK\n, __global const uchar * mask, int mask_step, int mask_offset\n#endif\n)\n{\nint lid = get_local_id(0);\nint gid = get_group_id(0);\nint id = get_global_id(0);\n__local T localmem_max[128], localmem_min[128];\nT minval = (T)(MAX_VAL), maxval = (T)(MIN_VAL), temp;\nint y, x;\nfor (int grainSize = groupnum << 8; id < total; id += grainSize)\n{\ny = id / src_cols;\nx = id % src_cols;\n#ifdef WITH_MASK\nif (mask[mad24(y, mask_step, x + mask_offset)])\n#endif\n{\ntemp = src[mad24(y, src_step, x + src_offset)];\nminval = min(minval, temp);\nmaxval = max(maxval, temp);\n}\n}\nif (lid > 127)\n{\nlocalmem_min[lid - 128] = minval;\nlocalmem_max[lid - 128] = maxval;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nif (lid < 128)\n{\nlocalmem_min[lid] = min(minval, localmem_min[lid]);\nlocalmem_max[lid] = max(maxval, localmem_max[lid]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\nfor (int lsize = 64; lsize > 0; lsize >>= 1)\n{\nif (lid < lsize)\n{\nint lid2 = lsize + lid;\nlocalmem_min[lid] = min(localmem_min[lid], localmem_min[lid2]);\nlocalmem_max[lid] = max(localmem_max[lid], localmem_max[lid2]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n}\nif (lid == 0)\n{\ndst[gid] = localmem_min[0];\ndst[gid + groupnum] = localmem_max[0];\n}\n}\n", "d62572e14800b115334df5c2e2937529", "arithm_magnitude", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void arithm_magnitude(__global T *src1, int src1_step, int src1_offset,\n__global T *src2, int src2_step, int src2_offset,\n__global T *dst,  int dst_step,  int dst_offset,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst_index  = mad24(y, dst_step,  x + dst_offset);\nT data1 = src1[src1_index];\nT data2 = src2[src2_index];\nT tmp = hypot(data1, data2);\ndst[dst_index] = tmp;\n}\n}\n", "1e7ac19c4313a240ab431d2249537d09", "arithm_log", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void arithm_log_C1(__global srcT *src, __global srcT *dst,\nint cols1, int rows,\nint srcOffset1, int dstOffset1,\nint srcStep1, int dstStep1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < cols1 && y < rows)\n{\nint srcIdx = mad24(y, srcStep1, x + srcOffset1);\nint dstIdx = mad24(y, dstStep1, x + dstOffset1);\ndst[dstIdx] = log(src[srcIdx]);\n}\n}\n__kernel void arithm_log_C2(__global srcT *src, __global srcT *dst,\nint cols1, int rows,\nint srcOffset1, int dstOffset1,\nint srcStep1, int dstStep1)\n{\nint x1 = get_global_id(0) << 1;\nint y = get_global_id(1);\nif(x1 < cols1 && y < rows)\n{\nint srcIdx = mad24(y, srcStep1, x1 + srcOffset1);\nint dstIdx = mad24(y, dstStep1, x1 + dstOffset1);\ndst[dstIdx] =                      log(src[srcIdx]);\ndst[dstIdx + 1] = x1 + 1 < cols1 ? log(src[srcIdx + 1]) : dst[dstIdx + 1];\n}\n}\n__kernel void arithm_log_C4(__global srcT *src, __global srcT *dst,\nint cols1, int rows,\nint srcOffset1, int dstOffset1,\nint srcStep1, int dstStep1)\n{\nint x1 = get_global_id(0) << 2;\nint y = get_global_id(1);\nif(x1 < cols1 && y < rows)\n{\nint srcIdx = mad24(y, srcStep1, x1 + srcOffset1);\nint dstIdx = mad24(y, dstStep1, x1 + dstOffset1);\ndst[dstIdx] =                      log(src[srcIdx]);\ndst[dstIdx + 1] = x1 + 1 < cols1 ? log(src[srcIdx + 1]) : dst[dstIdx + 1];\ndst[dstIdx + 2] = x1 + 2 < cols1 ? log(src[srcIdx + 2]) : dst[dstIdx + 2];\ndst[dstIdx + 3] = x1 + 3 < cols1 ? log(src[srcIdx + 3]) : dst[dstIdx + 3];\n}\n}\n", "576799ef2a4fec6719bfe812cfbeb270", "arithm_flip", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void arithm_flip_rows(__global T * src, int src_step, int src_offset,\n__global T * dst, int dst_step, int dst_offset,\nint rows, int cols, int thread_rows, int thread_cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < thread_rows)\n{\nint src_index_0 = mad24(y,            src_step, x + src_offset);\nint src_index_1 = mad24(rows - y - 1, src_step, x + src_offset);\nint dst_index_0 = mad24(y,            dst_step, x + dst_offset);\nint dst_index_1 = mad24(rows - y - 1, dst_step, x + dst_offset);\nT data0 = src[src_index_0], data1 = src[src_index_1];\ndst[dst_index_0] = data1;\ndst[dst_index_1] = data0;\n}\n}\n__kernel void arithm_flip_rows_cols(__global T * src, int src_step, int src_offset,\n__global T * dst, int dst_step, int dst_offset,\nint rows, int cols, int thread_rows, int thread_cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < thread_rows)\n{\nint src_index_0 = mad24(y,            src_step, x            + src_offset);\nint dst_index_0 = mad24(rows - y - 1, dst_step, cols - x - 1 + dst_offset);\nint src_index_1 = mad24(rows - y - 1, src_step, cols - x - 1 + src_offset);\nint dst_index_1 = mad24(y,            dst_step, x            + dst_offset);\nT data0 = src[src_index_0], data1 = src[src_index_1];\ndst[dst_index_0] = data0;\ndst[dst_index_1] = data1;\n}\n}\n__kernel void arithm_flip_cols(__global T * src, int src_step, int src_offset,\n__global T * dst, int dst_step, int dst_offset,\nint rows, int cols, int thread_rows, int thread_cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < thread_cols && y < rows)\n{\nint src_index_0 = mad24(y, src_step, x            + src_offset);\nint dst_index_0 = mad24(y, dst_step, cols - x - 1 + dst_offset);\nint src_index_1 = mad24(y, src_step, cols - x - 1 + src_offset);\nint dst_index_1 = mad24(y, dst_step, x            + dst_offset);\nT data0 = src[src_index_0], data1 = src[src_index_1];\ndst[dst_index_1] = data1;\ndst[dst_index_0] = data0;\n}\n}\n", "1a13aef3910e62cabcd190131cc9fe56", "arithm_exp", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void arithm_exp_C1(__global srcT *src, __global srcT *dst,\nint cols1, int rows,\nint srcOffset1, int dstOffset1,\nint srcStep1, int dstStep1)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < cols1 && y < rows)\n{\nint srcIdx = mad24(y, srcStep1, x + srcOffset1);\nint dstIdx = mad24(y, dstStep1, x + dstOffset1);\ndst[dstIdx] = exp(src[srcIdx]);\n}\n}\n__kernel void arithm_exp_C2(__global srcT *src, __global srcT *dst,\nint cols1, int rows,\nint srcOffset1, int dstOffset1,\nint srcStep1, int dstStep1)\n{\nint x1 = get_global_id(0) << 1;\nint y = get_global_id(1);\nif(x1 < cols1 && y < rows)\n{\nint srcIdx = mad24(y, srcStep1, x1 + srcOffset1);\nint dstIdx = mad24(y, dstStep1, x1 + dstOffset1);\ndst[dstIdx] =                      exp(src[srcIdx]);\ndst[dstIdx + 1] = x1 + 1 < cols1 ? exp(src[srcIdx + 1]) : dst[dstIdx + 1];\n}\n}\n__kernel void arithm_exp_C4(__global srcT *src, __global srcT *dst,\nint cols1, int rows,\nint srcOffset1, int dstOffset1,\nint srcStep1, int dstStep1)\n{\nint x1 = get_global_id(0) << 2;\nint y = get_global_id(1);\nif(x1 < cols1 && y < rows)\n{\nint srcIdx = mad24(y, srcStep1, x1 + srcOffset1);\nint dstIdx = mad24(y, dstStep1, x1 + dstOffset1);\ndst[dstIdx] =                      exp(src[srcIdx]);\ndst[dstIdx + 1] = x1 + 1 < cols1 ? exp(src[srcIdx + 1]) : dst[dstIdx + 1];\ndst[dstIdx + 2] = x1 + 2 < cols1 ? exp(src[srcIdx + 2]) : dst[dstIdx + 2];\ndst[dstIdx + 3] = x1 + 3 < cols1 ? exp(src[srcIdx + 3]) : dst[dstIdx + 3];\n}\n}\n", "606622bd16248ee57812ed0da18de6f8", "arithm_compare", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void arithm_compare(__global T * src1, int src1_step1, int src1_offset1,\n__global T * src2, int src2_step1, int src2_offset1,\n__global uchar * dst, int dst_step1, int dst_offset1,\nint cols1, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols1 && y < rows)\n{\nint src1_index = mad24(y, src1_step1, x + src1_offset1);\nint src2_index = mad24(y, src2_step1, x + src2_offset1);\nint dst_index = mad24(y, dst_step1, x + dst_offset1);\ndst[dst_index] = convert_uchar(src1[src1_index] Operation src2[src2_index] ? 255 : 0);\n}\n}\n", "3bf172a1e9d43fc31ca2a20d4c48b567", "arithm_cartToPolar", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#define CV_PI M_PI\n#else\n#define CV_PI M_PI_F\n#endif\n__kernel void arithm_cartToPolar_D5 (__global float *src1, int src1_step, int src1_offset,\n__global float *src2, int src2_step, int src2_offset,\n__global float *dst1, int dst1_step, int dst1_offset,\n__global float *dst2, int dst2_step, int dst2_offset,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst1_index = mad24(y, dst1_step, x + dst1_offset);\nint dst2_index = mad24(y, dst2_step, x + dst2_offset);\nfloat x = src1[src1_index];\nfloat y = src2[src2_index];\nfloat x2 = x * x;\nfloat y2 = y * y;\nfloat magnitude = sqrt(x2 + y2);\nfloat tmp = y >= 0 ? 0 : CV_PI*2;\ntmp = x < 0 ? CV_PI : tmp;\nfloat tmp1 = y >= 0 ? CV_PI*0.5f : CV_PI*1.5f;\nfloat cartToPolar = y2 <= x2 ? x*y/(x2 + 0.28f*y2 + FLT_EPSILON) + tmp :\ntmp1 - x*y/(y2 + 0.28f*x2 + FLT_EPSILON);\n#ifdef DEGREE\ncartToPolar *= (180/CV_PI);\n#endif\ndst1[dst1_index] = magnitude;\ndst2[dst2_index] = cartToPolar;\n}\n}\n#if defined (DOUBLE_SUPPORT)\n__kernel void arithm_cartToPolar_D6 (__global double *src1, int src1_step, int src1_offset,\n__global double *src2, int src2_step, int src2_offset,\n__global double *dst1, int dst1_step, int dst1_offset,\n__global double *dst2, int dst2_step, int dst2_offset,\nint rows, int cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst1_index = mad24(y, dst1_step, x + dst1_offset);\nint dst2_index = mad24(y, dst2_step, x + dst2_offset);\ndouble x = src1[src1_index];\ndouble y = src2[src2_index];\ndouble x2 = x * x;\ndouble y2 = y * y;\ndouble magnitude = sqrt(x2 + y2);\nfloat tmp = y >= 0 ? 0 : CV_PI*2;\ntmp = x < 0 ? CV_PI : tmp;\nfloat tmp1 = y >= 0 ? CV_PI*0.5 : CV_PI*1.5;\ndouble cartToPolar = y2 <= x2 ? x*y/(x2 + 0.28f*y2 + DBL_EPSILON)  + tmp :\ntmp1 - x*y/(y2 + 0.28f*x2 + DBL_EPSILON);\n#ifdef DEGREE\ncartToPolar *= (180/CV_PI);\n#endif\ndst1[dst1_index] = magnitude;\ndst2[dst2_index] = cartToPolar;\n}\n}\n#endif\n", "a43471e45195c432df267f55f46bba02", "arithm_bitwise", "__kernel void arithm_bitwise(__global uchar * src1ptr, int src1_step, int src1_offset,\n#ifdef OP_BINARY\n__global uchar * src2ptr, int src2_step, int src2_offset,\n#elif defined HAVE_SCALAR\nT scalar,\n#endif\n#ifdef HAVE_MASK\n__global uchar * mask, int mask_step, int mask_offset,\n#endif\n__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < dst_cols && y < dst_rows)\n{\n#ifdef HAVE_MASK\nmask += mad24(y, mask_step, x + mask_offset);\nif (mask[0])\n#endif\n{\nint src1_index = mad24(y, src1_step, mad24(x, (int)sizeof(T), src1_offset));\n#ifdef OP_BINARY\nint src2_index = mad24(y, src2_step, mad24(x, (int)sizeof(T), src2_offset));\n#endif\nint dst_index = mad24(y, dst_step, mad24(x, (int)sizeof(T), dst_offset));\n__global const T * src1 = (__global const T *)(src1ptr + src1_index);\n#ifdef OP_BINARY\n__global const T * src2 = (__global const T *)(src2ptr + src2_index);\n#endif\n__global T * dst = (__global T *)(dstptr + dst_index);\n#ifdef OP_BINARY\ndst[0] = src1[0] Operation src2[0];\n#elif defined HAVE_SCALAR\ndst[0] = src1[0] Operation scalar;\n#else\ndst[0] = Operation src1[0];\n#endif\n}\n}\n}\n", "7dfc3e052a5289cb3de59d38f374d10d", "arithm_add_scalar_mask", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#if defined (FUNC_ADD)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) + scalar);\n#endif\n#if defined (FUNC_SUB)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) - scalar);\n#endif\n#if defined (FUNC_MUL)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) * scalar);\n#endif\n#if defined (FUNC_DIV)\n#define EXPRESSION T zero = (T)(0); \\\ndst[dst_index] = src2[src2_index] == zero ? zero : \\\nconvertToT(convertToWT(src1[src1_index]) / scalar[0]);\n#endif\n__kernel void arithm_binary_op_scalar_mask(__global T *src1, int src1_step, int src1_offset,\nWT scalar,\n__global uchar *mask, int mask_step, int mask_offset,\n__global T *dst,  int dst_step,  int dst_offset,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint mask_index = mad24(y, mask_step, x + mask_offset);\nif (mask[mask_index])\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint dst_index = mad24(y, dst_step, dst_offset + x);\nEXPRESSION\n}\n}\n}\n", "8288be1429ee6b66e7cf0c2a3afa9028", "arithm_add_scalar", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#if defined (FUNC_ADD)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) + scalar);\n#endif\n#if defined (FUNC_SUB)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) - scalar);\n#endif\n#if defined (FUNC_MUL)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) * scalar);\n#endif\n#if defined (FUNC_DIV)\n#define EXPRESSION T zero = (T)(0); \\\ndst[dst_index] = src1[src1_index] == zero ? zero : convertToT(scalar / convertToWT(src1[src1_index]));\n#endif\n#if defined (FUNC_ABS)\n#define EXPRESSION \\\nT value = src1[src1_index] > (T)(0) ? src1[src1_index] : -src1[src1_index]; \\\ndst[dst_index] = value;\n#endif\n#if defined (FUNC_ABS_DIFF)\n#define EXPRESSION WT value = convertToWT(src1[src1_index]) - scalar; \\\nvalue = value > (WT)(0) ? value : -value; \\\ndst[dst_index] = convertToT(value);\n#endif\n__kernel void arithm_binary_op_scalar (__global T *src1, int src1_step, int src1_offset,\nWT scalar,\n__global T *dst,  int dst_step,  int dst_offset,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint dst_index = mad24(y, dst_step, x + dst_offset);\nEXPRESSION\n}\n}\n", "247f201b03d2ae30ab341fefb9d8bf9f", "arithm_add_mask", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#if defined (FUNC_ADD)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) + convertToWT(src2[src2_index]));\n#endif\n#if defined (FUNC_SUB)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) - convertToWT(src2[src2_index]));\n#endif\n#if defined (FUNC_MUL)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) * convertToWT(src2[src2_index]));\n#endif\n#if defined (FUNC_DIV)\n#define EXPRESSION T zero = (T)(0); \\\ndst[dst_index] = src2[src2_index] == zero ? zero : \\\nconvertToT(convertToWT(src1[src1_index]) / convertToWT(src2[src2_index]));\n#endif\n__kernel void arithm_binary_op_mat_mask(__global T * src1, int src1_step, int src1_offset,\n__global T * src2, int src2_step, int src2_offset,\n__global uchar * mask, int mask_step, int mask_offset,\n__global T * dst, int dst_step, int dst_offset,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint mask_index = mad24(y, mask_step, x + mask_offset);\nif (mask[mask_index])\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst_index  = mad24(y, dst_step, dst_offset + x);\nEXPRESSION\n}\n}\n}\n", "6f293dea131291749c2be083eafe6839", "arithm_addWeighted", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void addWeighted(__global T * src1, int src1_step1, int src1_offset1,\n__global T * src2, int src2_step1, int src2_offset1,\n__global T * dst, int dst_step1, int dst_offset1,\nWT alpha, WT beta, WT gama,\nint cols1, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols1 && y < rows)\n{\nint src1_index = mad24(y, src1_step1, x + src1_offset1);\nint src2_index = mad24(y, src2_step1, x + src2_offset1);\nint dst_index = mad24(y, dst_step1, x + dst_offset1);\ndst[dst_index] = convertToT(src1[src1_index]*alpha + src2[src2_index]*beta + gama);\n}\n}\n", "8ef56ec47d035ad8ba7181337797571e", "arithm_add", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#if defined (FUNC_ADD)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) + convertToWT(src2[src2_index]));\n#endif\n#if defined (FUNC_SUB)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) - convertToWT(src2[src2_index]));\n#endif\n#if defined (FUNC_MUL)\n#if defined (HAVE_SCALAR)\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) * scalar * convertToWT(src2[src2_index]));\n#else\n#define EXPRESSION dst[dst_index] = convertToT(convertToWT(src1[src1_index]) * convertToWT(src2[src2_index]));\n#endif\n#endif\n#if defined (FUNC_DIV)\n#if defined (HAVE_SCALAR)\n#define EXPRESSION T zero = (T)(0); \\\ndst[dst_index] = src2[src2_index] == zero ? zero : \\\nconvertToT(convertToWT(src1[src1_index]) * scalar / convertToWT(src2[src2_index]));\n#else\n#define EXPRESSION T zero = (T)(0); \\\ndst[dst_index] = src2[src2_index] == zero ? zero : \\\nconvertToT(convertToWT(src1[src1_index]) / convertToWT(src2[src2_index]));\n#endif\n#endif\n#if defined (FUNC_ABS_DIFF)\n#define EXPRESSION WT value = convertToWT(src1[src1_index]) - convertToWT(src2[src2_index]); \\\nvalue = value > (WT)(0) ? value : -value; \\\ndst[dst_index] = convertToT(value);\n#endif\n#if defined (FUNC_MIN)\n#define EXPRESSION dst[dst_index] = min( src1[src1_index], src2[src2_index] );\n#endif\n#if defined (FUNC_MAX)\n#define EXPRESSION dst[dst_index] = max( src1[src1_index], src2[src2_index] );\n#endif\n#ifndef HAVE_SCALAR\n__kernel void arithm_binary_op_mat(__global T *src1, int src1_step, int src1_offset,\n__global T *src2, int src2_step, int src2_offset,\n__global T *dst, int dst_step, int dst_offset,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst_index  = mad24(y, dst_step, x + dst_offset);\nEXPRESSION\n}\n}\n#else\n__kernel void arithm_binary_op_mat_scalar(__global T *src1, int src1_step, int src1_offset,\n__global T *src2, int src2_step, int src2_offset,\nWT scalar,\n__global T *dst, int dst_step,  int dst_offset,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst_index = mad24(y, dst_step, x + dst_offset);\nEXPRESSION\n}\n}\n#endif\n", "6fd43f6cf03580fec25aef52bea680a2", "arithm_absdiff_nonsaturate", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n#ifdef BINARY\n__kernel void arithm_absdiff_nonsaturate_binary(__global srcT *src1, int src1_step, int src1_offset,\n__global srcT *src2, int src2_step, int src2_offset,\n__global dstT *dst, int dst_step, int dst_offset,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint src2_index = mad24(y, src2_step, x + src2_offset);\nint dst_index  = mad24(y, dst_step, x + dst_offset);\n#ifdef INTEL_DEVICE\nif(src1_index >= 0 && src2_index >= 0)\n#endif\n{\ndstT t0 = convertToDstT(src1[src1_index]);\ndstT t1 = convertToDstT(src2[src2_index]);\ndstT t2 = t0 - t1;\ndst[dst_index] = t2 >= (dstT)(0) ? t2 : -t2;\n}\n}\n}\n#else\n__kernel void arithm_absdiff_nonsaturate(__global srcT *src1, int src1_step, int src1_offset,\n__global dstT *dst, int dst_step, int dst_offset,\nint cols, int rows)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif (x < cols && y < rows)\n{\nint src1_index = mad24(y, src1_step, x + src1_offset);\nint dst_index  = mad24(y, dst_step, x + dst_offset);\n#ifdef INTEL_DEVICE\nif(src1_index >= 0)\n#endif\n{\ndstT t0 = convertToDstT(src1[src1_index]);\ndst[dst_index] = t0 >= (dstT)(0) ? t0 : -t0;\n}\n}\n}\n#endif\n", "3f15259dde8b84d419a8748dead572f0", "arithm_LUT", "#ifdef DOUBLE_SUPPORT\n#ifdef cl_amd_fp64\n#pragma OPENCL EXTENSION cl_amd_fp64:enable\n#elif defined (cl_khr_fp64)\n#pragma OPENCL EXTENSION cl_khr_fp64:enable\n#endif\n#endif\n__kernel void LUT_C1( __global const srcT * src, __global const dstT *lut,\n__global dstT *dst,\nint cols1, int rows,\nint src_offset1,\nint lut_offset1,\nint dst_offset1,\nint src_step1, int dst_step1)\n{\nint x1 = get_global_id(0);\nint y = get_global_id(1);\nif (x1 < cols1 && y < rows)\n{\nint src_index = mad24(y, src_step1, src_offset1 + x1);\nint dst_index = mad24(y, dst_step1, dst_offset1 + x1);\ndst[dst_index] = lut[lut_offset1 + src[src_index]];\n}\n}\n__kernel void LUT_C2( __global const srcT * src, __global const dstT *lut,\n__global dstT *dst,\nint cols1, int rows,\nint src_offset1,\nint lut_offset1,\nint dst_offset1,\nint src_step1, int dst_step1)\n{\nint x1 = get_global_id(0) << 1;\nint y = get_global_id(1);\nif (x1 < cols1 && y < rows)\n{\nint src_index = mad24(y, src_step1, src_offset1 + x1);\nint dst_index = mad24(y, dst_step1, dst_offset1 + x1);\ndst[dst_index    ] =                  lut[lut_offset1 + (src[src_index    ] << 1)    ];\ndst[dst_index + 1] = x1 + 1 < cols1 ? lut[lut_offset1 + (src[src_index + 1] << 1) + 1] : dst[dst_index + 1];\n}\n}\n__kernel void LUT_C4( __global const srcT * src, __global const dstT *lut,\n__global dstT *dst,\nint cols1, int rows,\nint src_offset1,\nint lut_offset1,\nint dst_offset1,\nint src_step1, int dst_step1)\n{\nint x1 = get_global_id(0) << 2;\nint y = get_global_id(1);\nif (x1 < cols1 && y < rows)\n{\nint src_index = mad24(y, src_step1, src_offset1 + x1);\nint dst_index = mad24(y, dst_step1, dst_offset1 + x1);\ndst[dst_index    ] =                  lut[lut_offset1 + (src[src_index    ] << 2)    ];\ndst[dst_index + 1] = x1 + 1 < cols1 ? lut[lut_offset1 + (src[src_index + 1] << 2) + 1] : dst[dst_index + 1];\ndst[dst_index + 2] = x1 + 2 < cols1 ? lut[lut_offset1 + (src[src_index + 2] << 2) + 2] : dst[dst_index + 2];\ndst[dst_index + 3] = x1 + 3 < cols1 ? lut[lut_offset1 + (src[src_index + 3] << 2) + 3] : dst[dst_index + 3];\n}\n}\n", "afd02da735fe96c1be560841a0616208", "sizes.size() == corners.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/util.cpp", "vector::_M_insert_aux", "vector::_M_fill_insert", "cv::Rect cv::detail::resultRoi(const std::vector<cv::Point_<int> >&, const std::vector<cv::Size_<int> >&)", "N2cv6detail19ExposureCompensatorE", "N2cv6detail18RotationWarperBaseINS0_18SphericalProjectorEEE", "N2cv6detail14RotationWarperE", "N2cv15SphericalWarperE", "N2cv13WarperCreatorE", "N2cv6detail9EstimatorE", "void cv::detail::RotationWarperBase<P>::warpBackward(const cv::Mat&, const cv::Mat&, const cv::Mat&, int, int, cv::Size, cv::Mat&) [with P = cv::detail::SphericalProjector, cv::Size = cv::Size_<int>]", "void cv::detail::BundleAdjusterBase::setRefinementMask(const cv::Mat&)", "src_br.x - src_tl.x + 1 == src.cols && src_br.y - src_tl.y + 1 == src.rows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/include/opencv2/stitching/detail/warpers_inl.hpp", "mask.type() == CV_8U && mask.size() == Size(3, 3)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/include/opencv2/stitching/detail/motion_estimators.hpp", "vector::_M_fill_insert", "vector::_M_insert_aux", "imgs.size() == imgs_.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/stitcher.cpp", "cv::Stitcher::Status cv::Stitcher::composePanorama(cv::InputArray, cv::OutputArray)", "N2cv6detail14FeaturesFinderE", "N2cv6detail15FeaturesMatcherE", "*N12_GLOBAL__N_114MatchPairsBodyE", "N2cv6detail18SurfFeaturesFinderE", "N2cv6detail17OrbFeaturesFinderE", "virtual void cv::detail::OrbFeaturesFinder::find(const cv::Mat&, cv::detail::ImageFeatures&)", "(image.type() == CV_8UC3) || (image.type() == CV_8UC1)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/matchers.cpp", "vector::reserve", "Feature2D.SURF", "OpenCV was built without SURF support", "hessianThreshold", "nOctaves", "nOctaveLayers", "features1.descriptors.type() == features2.descriptors.type()", "features2.descriptors.depth() == CV_8U || features2.descriptors.depth() == CV_32F", "vector::_M_insert_aux", "(image.type() == CV_8UC3) || (image.type() == CV_8UC4) || (image.type() == CV_8UC1)", "vector::_M_fill_insert", "mask.empty() || (mask.type() == CV_8U && mask.cols == num_images && mask.rows)", "virtual void (anonymous namespace)::CpuMatcher::match(const cv::detail::ImageFeatures&, const cv::detail::ImageFeatures&, cv::detail::MatchesInfo&)", "cv::detail::SurfFeaturesFinder::SurfFeaturesFinder(double, int, int, int, int)", "virtual void cv::detail::SurfFeaturesFinder::find(const cv::Mat&, cv::detail::ImageFeatures&)", "*N12_GLOBAL__N_110CpuMatcherE", "void cv::detail::FeaturesMatcher::operator()(const std::vector<cv::detail::ImageFeatures>&, std::vector<cv::detail::MatchesInfo>&, const cv::Mat&)", "N2cv6detail21BestOf2NearestMatcherE", "bool cv::detail::calibrateRotatingCamera(const std::vector<cv::Mat>&, cv::Mat&)", "void cv::detail::focalsFromHomography(const cv::Mat&, double&, double&, bool&, bool&)", "H.type() == CV_64F && H.size() == Size(3, 3)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/autocalib.cpp", "vector::_M_fill_insert", "vector::_M_insert_aux", "m >= 1", "Hs[i].size() == Size(3, 3) && Hs[i].type() == CV_64F", "N2cv6detail21NoExposureCompensatorE", "N2cv6detail21BlocksGainCompensatorE", "static cv::Ptr<cv::detail::ExposureCompensator> cv::detail::ExposureCompensator::createDefault(int)", "virtual void cv::detail::GainCompensator::feed(const std::vector<cv::Point_<int> >&, const std::vector<cv::Mat>&, const std::vector<std::pair<cv::Mat, unsigned char> >&)", "virtual void cv::detail::BlocksGainCompensator::feed(const std::vector<cv::Point_<int> >&, const std::vector<cv::Mat>&, const std::vector<std::pair<cv::Mat, unsigned char> >&)", "image.type() == CV_8UC3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/exposure_compensate.cpp", "unsupported exposure compensation method", "corners.size() == images.size() && images.size() == masks.size()", "vector::_M_fill_insert", "virtual void cv::detail::BlocksGainCompensator::apply(int, cv::Point, cv::Mat&, const cv::Mat&)", "N2cv6detail15GainCompensatorE", "N2cv6detail10SeamFinderE", "N2cv6detail22GraphCutSeamFinderBaseE", "N2cv6detail18GraphCutSeamFinderE", "void cv::detail::DpSeamFinder::computeGradients(const cv::Mat&, const cv::Mat&)", "N2cv6detail18PairwiseSeamFinderE", "void cv::detail::GraphCutSeamFinderGpu::setGraphWeightsColorGrad(const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&)", "bool GCGraph<TWeight>::inSourceSegment(int) [with TWeight = float]", "virtual void cv::detail::GraphCutSeamFinderGpu::findInPair(std::size_t, std::size_t, cv::Rect)", "void GCGraph<TWeight>::addTermWeights(int, TWeight, TWeight) [with TWeight = float]", "N2cv6detail12DpSeamFinderE", "N2cv6detail21GraphCutSeamFinderGpuE", "CUDA optimization is unavailable", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/seam_finders.cpp", "image1.channels() == 3 || image1.channels() == 4", "image2.channels() == 3 || image2.channels() == 4", "costFunction() == COLOR_GRAD", "states_[comp] & INTERS", "both images must have CV_32FC3(4) or CV_8UC3(4) type", "i>=0 && i<(int)vtcs.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/../../imgproc/src/gcgraph.hpp", "seam.front() == p1", "seam.back() == p2", "vector::reserve", "vector::_M_fill_insert", "states_[comp1] & INTERS", "vector::_M_insert_aux", "j>=0 && j<(int)vtcs.size()", "w>=0 && revw>=0", "i != j", "unsupported pixel similarity measure", "image1.size() == mask1.size()", "image2.size() == mask2.size()", "src[i].channels() == 3", "virtual void cv::detail::GraphCutSeamFinderGpu::find(const std::vector<cv::Mat>&, const std::vector<cv::Point_<int> >&, std::vector<cv::Mat>&)", "virtual void cv::detail::GraphCutSeamFinder::Impl::find(const std::vector<cv::Mat>&, const std::vector<cv::Point_<int> >&, std::vector<cv::Mat>&)", "virtual void cv::detail::GraphCutSeamFinder::Impl::findInPair(std::size_t, std::size_t, cv::Rect)", "void GCGraph<TWeight>::addEdges(int, int, TWeight, TWeight) [with TWeight = float]", "N2cv6detail17VoronoiSeamFinderE", "bool cv::detail::DpSeamFinder::estimateSeam(const cv::Mat&, const cv::Mat&, cv::Point, cv::Point, int, cv::Point, cv::Point, std::vector<cv::Point_<int> >&, bool&)", "void cv::detail::DpSeamFinder::process(const cv::Mat&, const cv::Mat&, cv::Point, cv::Point, cv::Mat&, cv::Mat&)", "N2cv6detail18GraphCutSeamFinder4ImplE", "void cv::detail::DpSeamFinder::computeCosts(const cv::Mat&, const cv::Mat&, cv::Point, cv::Point, int, cv::Mat_<float>&, cv::Mat_<float>&)", "void cv::detail::GraphCutSeamFinderGpu::setGraphWeightsColor(const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&, cv::Mat&)", "bool cv::detail::DpSeamFinder::getSeamTips(int, int, cv::Point&, cv::Point&)", "cv::detail::MultiBandBlender::MultiBandBlender(int, int, int)", "static cv::Ptr<cv::detail::Blender> cv::detail::Blender::createDefault(int, bool)", "N2cv6detail14FeatherBlenderE", "N2cv6detail7BlenderE", "void cv::detail::createWeightMap(const cv::Mat&, float, cv::Mat&)", "N2cv6detail16MultiBandBlenderE", "void cv::detail::normalizeUsingWeightMap(const cv::Mat&, cv::Mat&)", "img.type() == CV_16SC3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/blenders.cpp", "mask.type() == CV_8U", "src.type() == CV_16SC3", "weight.type() == CV_16SC1", "CUDA optimization is unavailable", "weight_type == CV_32F || weight_type == CV_16S", "unsupported blending method", "vector::_M_fill_insert", "img.type() == CV_16SC3 || img.type() == CV_8UC3", "void cv::detail::restoreImageFromLaplacePyrGpu(std::vector<cv::Mat>&)", "virtual void cv::detail::MultiBandBlender::feed(const cv::Mat&, const cv::Mat&, cv::Point)", "virtual void cv::detail::Blender::feed(const cv::Mat&, const cv::Mat&, cv::Point)", "virtual void cv::detail::FeatherBlender::feed(const cv::Mat&, const cv::Mat&, cv::Point)", "void cv::detail::createLaplacePyrGpu(const cv::Mat&, int, std::vector<cv::Mat>&)", "N2cv6detail18RotationWarperBaseINS0_26SphericalPortraitProjectorEEE", "N2cv6detail18RotationWarperBaseINS0_14PlaneProjectorEEE", "cv::Rect cv::detail::SphericalWarperGpu::buildMaps(cv::Size, const cv::Mat&, const cv::Mat&, cv::gpu::GpuMat&, cv::gpu::GpuMat&)", "cv::Point cv::detail::PlaneWarperGpu::warp(const cv::gpu::GpuMat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, int, int, cv::gpu::GpuMat&)", "void cv::detail::ProjectorBase::setCameraParams(const cv::Mat&, const cv::Mat&, const cv::Mat&)", "void cv::detail::RotationWarperBase<P>::warpBackward(const cv::Mat&, const cv::Mat&, const cv::Mat&, int, int, cv::Size, cv::Mat&) [with P = cv::detail::SphericalPortraitProjector, cv::Size = cv::Size_<int>]", "cv::Point cv::detail::CylindricalWarperGpu::warp(const cv::gpu::GpuMat&, const cv::Mat&, const cv::Mat&, int, int, cv::gpu::GpuMat&)", "void cv::detail::RotationWarperBase<P>::warpBackward(const cv::Mat&, const cv::Mat&, const cv::Mat&, int, int, cv::Size, cv::Mat&) [with P = cv::detail::PlaneProjector, cv::Size = cv::Size_<int>]", "N2cv6detail23SphericalPortraitWarperE", "N2cv6detail15SphericalWarperE", "CUDA optimization is unavailable", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/warpers.cpp", "K.size() == Size(3, 3) && K.type() == CV_32F", "R.size() == Size(3, 3) && R.type() == CV_32F", "(T.size() == Size(1, 3) || T.size() == Size(3, 1)) && T.type() == CV_32F", "src_br.x - src_tl.x + 1 == src.cols && src_br.y - src_tl.y + 1 == src.rows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/include/opencv2/stitching/detail/warpers_inl.hpp", "cv::Rect cv::detail::PlaneWarperGpu::buildMaps(cv::Size, const cv::Mat&, const cv::Mat&, const cv::Mat&, cv::gpu::GpuMat&, cv::gpu::GpuMat&)", "cv::Point cv::detail::SphericalWarperGpu::warp(const cv::gpu::GpuMat&, const cv::Mat&, const cv::Mat&, int, int, cv::gpu::GpuMat&)", "cv::Rect cv::detail::CylindricalWarperGpu::buildMaps(cv::Size, const cv::Mat&, const cv::Mat&, cv::gpu::GpuMat&, cv::gpu::GpuMat&)", "N2cv6detail11PlaneWarperE", "N2cv6detail17BundleAdjusterRayE", "void cv::detail::findMaxSpanningTree(int, const std::vector<cv::detail::MatchesInfo>&, cv::detail::Graph&, std::vector<int>&)", "N2cv6detail18BundleAdjusterBaseE", "N2cv6detail20BundleAdjusterReprojE", "N2cv6detail24HomographyBasedEstimatorE", "void cv::detail::waveCorrect(std::vector<cv::Mat>&, cv::detail::WaveCorrectKind)", "rvec.type() == CV_32F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/stitching/src/motion_estimators.cpp", "unsupported kind of wave correction", "graph matches_graph{\n", "basic_string::substr", "\" -- \"", "[label=\"Nm=", ", Ni=", ", C=", "\"];\n", "vector::_M_insert_aux", "centers.size() > 0 && centers.size() <= 2", "virtual void cv::detail::BundleAdjusterRay::setUpInitialCameraParams(const std::vector<cv::detail::CameraParams>&)", "virtual void cv::detail::BundleAdjusterReproj::setUpInitialCameraParams(const std::vector<cv::detail::CameraParams>&)", "N2cv8superres15SuperResolutionE", "cv::Ptr<cv::superres::SuperResolution> cv::superres::createSuperResolution_BTVL1_GPU()", "The called functionality is disabled for current build or platform", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/superres/src/btv_l1_gpu.cpp", "*N12_GLOBAL__N_114BTVL1_OCL_BaseE", "*N12_GLOBAL__N_19BTVL1_OCLE", "SuperResolution.BTVL1_OCL", "vector::_M_fill_insert", "Scale factor.", "scale", "Iteration count.", "iterations", "Asymptotic value of steepest descent method.", "Weight parameter to balance data term and smoothness term.", "lambda", "Parameter of spacial distribution in Bilateral-TV.", "alpha", "Kernel size of Bilateral-TV filter.", "btvKernelSize", "Gaussian blur kernel size.", "blurKernelSize", "Gaussian blur sigma.", "blurSigma", "Radius of the temporal search area.", "temporalAreaRadius", "Dense optical flow algorithm.", "opticalFlow", "vector::_M_insert_aux", "buildMotionMapsKernel", "upscaleKernel", "diffSignKernel", "calcBtvRegularizationKernel", "scale_ > 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/superres/src/btv_l1_ocl.cpp", "iterations_ > 0", "tau_ > 0.0", "alpha_ > 0.0", "btvKernelSize_ > 0 && btvKernelSize_ <= 16", "blurKernelSize_ > 0", "blurSigma_ >= 0.0", "src.channels() == 1 || src.channels() == 3 || src.channels() == 4", "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.wholecols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.wholerows", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ocl/include/opencv2/ocl/matrix_operations.hpp", "cv::ocl::oclMat::oclMat(const cv::ocl::oclMat&, const Rect&)", "void (anonymous namespace)::upscale(const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void (anonymous namespace)::BTVL1_OCL_Base::process(const std::vector<cv::ocl::oclMat>&, cv::ocl::oclMat&, const std::vector<std::pair<cv::ocl::oclMat, cv::ocl::oclMat> >&, const std::vector<std::pair<cv::ocl::oclMat, cv::ocl::oclMat> >&, int)", "*N12_GLOBAL__N_121BtvRegularizationBodyIN2cv7Point3_IfEEEE", "void (anonymous namespace)::upscale(const cv::Mat&, cv::Mat&, int)", "*N12_GLOBAL__N_15BTVL1E", "void (anonymous namespace)::BTVL1_Base::process(const std::vector<cv::Mat>&, cv::Mat&, const std::vector<cv::Mat>&, const std::vector<cv::Mat>&, int)", "SuperResolution.BTVL1", "Scale factor.", "scale", "Iteration count.", "iterations", "Asymptotic value of steepest descent method.", "Weight parameter to balance data term and smoothness term.", "lambda", "Parameter of spacial distribution in Bilateral-TV.", "alpha", "Kernel size of Bilateral-TV filter.", "btvKernelSize", "Gaussian blur kernel size.", "blurKernelSize", "Gaussian blur sigma.", "blurSigma", "Radius of the temporal search area.", "temporalAreaRadius", "Dense optical flow algorithm.", "opticalFlow", "vector::_M_fill_insert", "scale_ > 1", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/superres/src/btv_l1.cpp", "iterations_ > 0", "tau_ > 0.0", "alpha_ > 0.0", "btvKernelSize_ > 0", "blurKernelSize_ > 0", "blurSigma_ >= 0.0", "src.channels() == 1 || src.channels() == 3 || src.channels() == 4", "*N12_GLOBAL__N_121BtvRegularizationBodyIfEE", "*N12_GLOBAL__N_110BTVL1_BaseE", "N2cv8superres19DenseOpticalFlowExtE", "cv::Ptr<cv::superres::DenseOpticalFlowExt> cv::superres::createOptFlow_Brox_GPU()", "*N12_GLOBAL__N_113FarneBack_OCLE", "*N12_GLOBAL__N_18DualTVL1E", "cv::Ptr<cv::superres::DenseOpticalFlowExt> cv::superres::createOptFlow_DualTVL1_GPU()", "lambda", "theta", "nscales", "warps", "epsilon", "iterations", "useInitialFlow", "_frame1.type() == _frame0.type()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/superres/src/optical_flow.cpp", "_frame1.size() == _frame0.size()", "DenseOpticalFlowExt.Farneback", "DenseOpticalFlowExt.Simple", "DenseOpticalFlowExt.DualTVL1", "DenseOpticalFlowExt.PyrLK_OCL", "DenseOpticalFlowExt.DualTVL1_OCL", "DenseOpticalFlowExt.FarneBack_OCL", "pyrScale", "numLevels", "winSize", "numIters", "polyN", "polySigma", "flags", "layers", "averagingBlockSize", "maxFlow", "sigmaDist", "sigmaColor", "postProcessWindow", "sigmaDistFix", "sigmaColorFix", "occThr", "upscaleAveragingRadius", "upscaleSigmaDist", "upscaleSigmaColor", "speedUpThr", "frame1.type() == frame0.type()", "frame1.size() == frame0.size()", "The called functionality is disabled for current build or platform", "maxLevel", "*N12_GLOBAL__N_19FarnebackE", "*N12_GLOBAL__N_19PyrLK_OCLE", "cv::Ptr<cv::superres::DenseOpticalFlowExt> cv::superres::createOptFlow_PyrLK_GPU()", "*N12_GLOBAL__N_114oclOpticalFlowE", "*N12_GLOBAL__N_114CpuOpticalFlowE", "cv::Ptr<cv::superres::DenseOpticalFlowExt> cv::superres::createOptFlow_Farneback_GPU()", "*N12_GLOBAL__N_112DualTVL1_OCLE", "virtual void (anonymous namespace)::oclOpticalFlow::calc(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray)", "*N12_GLOBAL__N_16SimpleE", "virtual void (anonymous namespace)::CpuOpticalFlow::calc(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray)", "virtual void (anonymous namespace)::CameraFrameSource::reset()", "*N12_GLOBAL__N_116EmptyFrameSourceE", "*N12_GLOBAL__N_116VideoFrameSourceE", "vc_.isOpened()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/superres/src/frame_source.cpp", "The called functionality is disabled for current build or platform", "virtual void (anonymous namespace)::VideoFrameSource::reset()", "cv::Ptr<cv::superres::FrameSource> cv::superres::createFrameSource_Video_GPU(const string&)", "*N12_GLOBAL__N_117CameraFrameSourceE", "*N12_GLOBAL__N_118CaptureFrameSourceE", "N2cv8superres11FrameSourceE", "void (anonymous namespace)::convertToCn(cv::InputArray, cv::OutputArray, int)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/superres/src/input_array_utility.cpp", "cn == 1 || cn == 3 || cn == 4", "src.depth() <= CV_64F", "depth == CV_8U || depth == CV_32F", "The called functionality is disabled for current build or platform", "void (anonymous namespace)::convertToCn(const cv::ocl::oclMat&, cv::ocl::oclMat&, int)", "void (anonymous namespace)::convertToDepth(cv::InputArray, cv::OutputArray, int)", "superres_btvl1", "__kernel void buildMotionMapsKernel(__global float* forwardMotionX,\n__global float* forwardMotionY,\n__global float* backwardMotionX,\n__global float* backwardMotionY,\n__global float* forwardMapX,\n__global float* forwardMapY,\n__global float* backwardMapX,\n__global float* backwardMapY,\nint forwardMotionX_row,\nint forwardMotionX_col,\nint forwardMotionX_step,\nint forwardMotionY_step,\nint backwardMotionX_step,\nint backwardMotionY_step,\nint forwardMapX_step,\nint forwardMapY_step,\nint backwardMapX_step,\nint backwardMapY_step\n)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < forwardMotionX_col && y < forwardMotionX_row)\n{\nfloat fx = forwardMotionX[y * forwardMotionX_step + x];\nfloat fy = forwardMotionY[y * forwardMotionY_step + x];\nfloat bx = backwardMotionX[y * backwardMotionX_step + x];\nfloat by = backwardMotionY[y * backwardMotionY_step + x];\nforwardMapX[y * forwardMapX_step + x] = x + bx;\nforwardMapY[y * forwardMapY_step + x] = y + by;\nbackwardMapX[y * backwardMapX_step + x] = x + fx;\nbackwardMapY[y * backwardMapY_step + x] = y + fy;\n}\n}\n__kernel void upscaleKernel(__global float* src,\n__global float* dst,\nint src_step,\nint dst_step,\nint src_row,\nint src_col,\nint scale,\nint channels\n)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < src_col && y < src_row)\n{\nif(channels == 1)\n{\ndst[y * scale * dst_step + x * scale] = src[y * src_step + x];\n}\nelse\n{\nvstore4(vload4(0, src + y * channels * src_step + 4 * x), 0, dst + y * channels * scale * dst_step + 4 * x * scale);\n}\n}\n}\nfloat diffSign(float a, float b)\n{\nreturn a > b ? 1.0f : a < b ? -1.0f : 0.0f;\n}\nfloat4 diffSign4(float4 a, float4 b)\n{\nfloat4 pos;\npos.x = a.x > b.x ? 1.0f : a.x < b.x ? -1.0f : 0.0f;\npos.y = a.y > b.y ? 1.0f : a.y < b.y ? -1.0f : 0.0f;\npos.z = a.z > b.z ? 1.0f : a.z < b.z ? -1.0f : 0.0f;\npos.w = 0.0f;\nreturn pos;\n}\n__kernel void diffSignKernel(__global float* src1,\n__global float* src2,\n__global float* dst,\nint src1_row,\nint src1_col,\nint dst_step,\nint src1_step,\nint src2_step)\n{\nint x = get_global_id(0);\nint y = get_global_id(1);\nif(x < src1_col && y < src1_row)\n{\ndst[y * dst_step + x] = diffSign(src1[y * src1_step + x], src2[y * src2_step + x]);\n}\n}\n__kernel void calcBtvRegularizationKernel(__global float* src,\n__global float* dst,\nint src_step,\nint dst_step,\nint src_row,\nint src_col,\nint ksize,\nint channels,\n__constant float* c_btvRegWeights\n)\n{\nint x = get_global_id(0) + ksize;\nint y = get_global_id(1) + ksize;\nif ((y < src_row - ksize) && (x < src_col - ksize))\n{\nif(channels == 1)\n{\nconst float srcVal = src[y * src_step + x];\nfloat dstVal = 0.0f;\nfor (int m = 0, count = 0; m <= ksize; ++m)\n{\nfor (int l = ksize; l + m >= 0; --l, ++count)\n{\ndstVal = dstVal + c_btvRegWeights[count] * (diffSign(srcVal, src[(y + m) * src_step + (x + l)]) - diffSign(src[(y - m) * src_step + (x - l)], srcVal));\n}\n}\ndst[y * dst_step + x] = dstVal;\n}\nelse\n{\nfloat4 srcVal = vload4(0, src + y * src_step + 4 * x);\nfloat4 dstVal = 0.f;\nfor (int m = 0, count = 0; m <= ksize; ++m)\n{\nfor (int l = ksize; l + m >= 0; --l, ++count)\n{\nfloat4 src1;\nsrc1.x = src[(y + m) * src_step + 4 * (x + l) + 0];\nsrc1.y = src[(y + m) * src_step + 4 * (x + l) + 1];\nsrc1.z = src[(y + m) * src_step + 4 * (x + l) + 2];\nsrc1.w = src[(y + m) * src_step + 4 * (x + l) + 3];\nfloat4 src2;\nsrc2.x = src[(y - m) * src_step + 4 * (x - l) + 0];\nsrc2.y = src[(y - m) * src_step + 4 * (x - l) + 1];\nsrc2.z = src[(y - m) * src_step + 4 * (x - l) + 2];\nsrc2.w = src[(y - m) * src_step + 4 * (x - l) + 3];\ndstVal = dstVal + c_btvRegWeights[count] * (diffSign4(srcVal, src1) - diffSign4(src2, srcVal));\n}\n}\nvstore4(dstVal, 0, dst + y * dst_step + 4 * x);\n}\n}\n}\n", "30f28e5e4fff61c587f608005cd5fe53", "sub matrix", "whole matrix", "inverse", "direct", "gold", "actual", "diff", "(null)", "Matrices \"", "\" and \"", "\" have different sizes : \"", "] vs \"", "\" have different types : \"", "The max difference between matrices \"", "\" is ", " at (", ", which exceeds \"", "\", where \"", "\" at (", ") evaluates to ", "\" evaluates to ", "vector::reserve", "Incorrect device number - ", "Device ", "] is NOT compatible with current GPU module build", "KeyPoints size mistmach\n", "\" : ", "KeyPoints differ at ", "\" vs \"", "\" : \n", "pt : ", " vs ", "size : ", "angle : ", "response : ", "octave : ", "class_id : ", "[----------]\n[ GPU INFO ] \tRun on OS Linux x32.\n[----------]", "vector::_M_fill_insert", "BGR2BGRA", "BGRA2BGR", "BGR2RGBA", "RGBA2BGR", "BGR2RGB", "BGRA2RGBA", "BGR2GRAY", "RGB2GRAY", "GRAY2BGR", "GRAY2BGRA", "BGRA2GRAY", "RGBA2GRAY", "BGR2BGR565", "RGB2BGR565", "BGR5652BGR", "BGR5652RGB", "BGRA2BGR565", "RGBA2BGR565", "BGR5652BGRA", "BGR5652RGBA", "GRAY2BGR565", "BGR5652GRAY", "BGR2BGR555", "RGB2BGR555", "BGR5552BGR", "BGR5552RGB", "BGRA2BGR555", "RGBA2BGR555", "BGR5552BGRA", "BGR5552RGBA", "GRAY2BGR555", "BGR5552GRAY", "BGR2XYZ", "RGB2XYZ", "XYZ2BGR", "XYZ2RGB", "BGR2YCrCb", "RGB2YCrCb", "YCrCb2BGR", "YCrCb2RGB", "BGR2HSV", "RGB2HSV", "BGR2Lab", "RGB2Lab", "BayerBG2BGR", "BayerGB2BGR", "BayerRG2BGR", "BayerGR2BGR", "BGR2Luv", "RGB2Luv", "BGR2HLS", "RGB2HLS", "HSV2BGR", "HSV2RGB", "Lab2BGR", "Lab2RGB", "Luv2BGR", "Luv2RGB", "HLS2BGR", "HLS2RGB", "BayerBG2BGR_VNG", "BayerGB2BGR_VNG", "BayerRG2BGR_VNG", "BayerGR2BGR_VNG", "BGR2HSV_FULL", "RGB2HSV_FULL", "BGR2HLS_FULL", "RGB2HLS_FULL", "HSV2BGR_FULL", "HSV2RGB_FULL", "HLS2BGR_FULL", "HLS2RGB_FULL", "LBGR2Lab", "LRGB2Lab", "LBGR2Luv", "LRGB2Luv", "Lab2LBGR", "Lab2LRGB", "Luv2LBGR", "Luv2LRGB", "BGR2YUV", "RGB2YUV", "YUV2BGR", "YUV2RGB", "BayerBG2GRAY", "BayerGB2GRAY", "BayerRG2GRAY", "BayerGR2GRAY", "YUV2RGB_NV12", "YUV2BGR_NV12", "YUV2RGB_NV21", "YUV2BGR_NV21", "YUV2RGBA_NV12", "YUV2BGRA_NV12", "YUV2RGBA_NV21", "YUV2BGRA_NV21", "YUV2RGB_YV12", "YUV2BGR_YV12", "YUV2RGB_IYUV", "YUV2BGR_IYUV", "YUV2RGBA_YV12", "YUV2BGRA_YV12", "YUV2RGBA_IYUV", "YUV2BGRA_IYUV", "YUV2GRAY_420", "YUV2RGB_UYVY", "YUV2BGR_UYVY", "YUV2RGB_VYUY", "YUV2BGR_VYUY", "YUV2RGBA_UYVY", "YUV2BGRA_UYVY", "YUV2RGBA_VYUY", "YUV2BGRA_VYUY", "YUV2RGB_YUY2", "YUV2BGR_YUY2", "YUV2RGB_YVYU", "YUV2BGR_YVYU", "YUV2RGBA_YUY2", "YUV2BGRA_YUY2", "YUV2RGBA_YVYU", "YUV2BGRA_YVYU", "YUV2GRAY_UYVY", "YUV2GRAY_YUY2", "RGBA2mRGBA", "mRGBA2RGBA", "COLORCVT_MAX", "N6cvtest2TSE", "N6cvtest10BadArgTestE", "N6cvtest8BaseTestE", "void cvtest::fillGradient(cv::Mat&, int)", "unknown function", "OpenCV Error: %s (%s) in %s, file %s, line %d\n", "%s  (test case #%d): no expected exception was thrown\n", "%s (test case #%d): the error code %d is different from the expected %d\n", "%s  (test case #%d): unknown exception was thrown (the function has likely crashed)\n", "OPENCV_TEST_DATA_PATH", "%s%s%s/", "Generic/Unknown", "No test data", "Invalid test data", "cvError invoked", "Hardware/OS exception", "Invalid memory access", "Arithmetic exception", "Corrupted memblock (beginning)", "Corrupted memblock (end)", "Memory leak", "Invalid function output", "Unexpected output", "Bad accuracy", "Infinite loop(?)", "Incorrect handling of bad arguments", "OpenCV Error: %s (%s) in %s, file %s, line %d", "!img.empty() && img.depth() == CV_8U && ch <= 4", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ts/src/ts.cpp", "Succeeded", "%08x%08x", "\n-----------------------------------\n\tSUM: ", "\n-----------------------------------\n\tLOG: ", "\n-----------------------------------\n\tCONSOLE: ", "\n-----------------------------------\n", "Failed", "\n\tfailure reason: ", "\n\ttest case #", "\n\tseed: ", "N6cvtest9ArrayTestE", "vector::_M_fill_insert", "min_log_array_size", "max_log_array_size", "test_case_count", "%s array %d type=%sC%d, size=(%s)\n", "input", "input/output", "output", "ref input/output", "ref output", "temporary", "mask", "N7testing11EnvironmentE", "22PerfEarlyExitException", "N4perf8TestBase21PerfSkipTestExceptionE", "perf::performance_metrics& perf::TestBase::calcMetrics()", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = cv::Mat]", "static int64 perf::TestBase::_calibrate()", "*ZN4perf8TestBase10_calibrateEvE7_helper", "*N12_GLOBAL__N_115PerfEnvironmentE", "N4perf8TestBaseE", "cv::FileStorage& cv::operator<<(cv::FileStorage&, const _Tp&) [with _Tp = int]", "void perf::sort(std::vector<cv::KeyPoint>&, cv::InputOutputArray)", "Error in the syscall setaffinity: mask=%d=0x%x err=%d=0x%x", "No element name has been given", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/core/include/opencv2/core/operations.hpp", "Subsequent initialization of Regression utility is not allowed.", "OPENCV_TEST_DATA_PATH", "perf", "basic_string::substr", "_new", "Failed to open sanity data for reading: %s", "Could not open \"%s\" file for writing", "undefined", "basic_string::erase", "last", "rng1", "rng2", "kind", "type", "cv_implementation", "cv_num_threads", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ts/src/ts_perf.cpp", "Failed", "  Uninitialized input/output parameters are not allowed for performance tests", "Expected: PerfTestBody() doesn't throw an exception.\n  Actual: it throws cv::Exception:\n  ", "(null)", "Expected: PerfTestBody() doesn't throw an exception.\n  Actual: it throws std::exception:\n  ", "Expected: PerfTestBody() doesn't throw an exception.\n  Actual: it throws...", "cuda", "USRTYPE1", "expected.size()", "actual.size()", "  Bad path to test resource", "  Requested file \"", "\" does not exist.", "vector::reserve", "pts.size() == (size_t)desc.rows", "expect_min", "actual_min", " has unexpected minimal value", "expect_max", "actual_max", " has unexpected maximal value", "expect_cols", "actual.size.p[1]", " has unexpected number of columns", "expect_rows", "actual.size.p[0]", " has unexpected number of rows", "expect_last", "actual_last", " has unexpected value of the last element", "expect_rng1", "actual_rng1", " has unexpected value of the [", "] element", "expect_rng2", "actual_rng2", "Expected: (", ") <= (", "), actual: ", " vs ", "expected_kind", "array.kind()", "  Argument \"", "\" has unexpected kind", "expected_type", "array.type()", "\" has unexpected type", "expected_length", "(int)array.total()", "  Vector \"", "\" has unexpected length", "(size_t)26", "actual.total() * (size_t)actual.channels()", "]\" has unexpected number of elements", "%s[%d]", "actual.empty()", "false", "true", "  expected empty ", "] has unexpected size", " Expected: ", " Actual:", "  Absolute difference (=", ") between argument \"", "]\" and expected value is greater than ", "  Relative difference (", " of ", " allowed) between argument \"", " in ", " points", "array.total() * (size_t)array.channels()", "\" has unexpected number of elements", "Argument \"", "\" has unexpected size", "  Difference (=", ") between argument1 \"", "\" and expected value is greater than ", "  Can not check regression for CV_USRTYPE1 data type for ", "  No regression data for ", " argument", "-queryIdx", "-trainIdx", "-imgIdx", "-distance", "-size", "-angle", "-response", "-octave", "-class_id", "m.samples", ") >= (", "  stopTimer() is called before startTimer()/next()", "metrics.samples <= (unsigned int)currentIter", "custom_status", "skipped", "bytesIn", "bytesOut", "term", "samples", "outliers", "frequency", "%.0f", "median", "gmean", "gstddev", "%.6f", "mean", "stddev", "type      = %11s", "params    = %11s", "termination reason:  reached maximum number of iterations", "termination reason:  reached time limit", "termination reason:  aborted by the performance testing framework", "termination reason:  unhandled exception", "termination reason:  unknown", "bytesIn   =%11lu", "bytesOut  =%11lu", "samples   =%11u", "samples   =%11u of %u", "outliers  =%11u", "frequency =%11.0f", "min       =%11.0f = %.2fms", "median    =%11.0f = %.2fms", "gmean     =%11.0f = %.2fms", "gstddev   =%11.8f = %.2fms for 97%% dispersion interval", "mean      =%11.0f = %.2fms", "stddev    =%11.0f = %.2fms", "  next() is called before stopTimer()", "test_start", "%llu", "test_complete", "compensation < 0.01 * cv::getTickFrequency()", "Time compensation is %.0f", "{   |perf_max_outliers           |8        |percent of allowed outliers}{   |perf_min_samples            |10       |minimal required numer of samples}{   |perf_force_samples          |100      |force set maximum number of samples for all tests}{   |perf_seed                   |809564   |seed for random numbers generator}{   |perf_threads                |-1       |the number of worker threads, if parallel execution is enabled}{   |perf_write_sanity           |false    |create new records for sanity checks}{   |perf_verify_sanity          |false    |fail tests having no regression data for sanity checks}{   |perf_impl                   |", "|the implementation variant of functions under test}{   |perf_list_impls             |false    |list available implementation variants and exit}{   |perf_run_cpu                |false    |deprecated, equivalent to --perf_impl=plain}{   |perf_strategy               |default  |specifies performance measuring strategy: default, base or simple (weak restrictions)}{   |perf_time_limit             |6.0      |default time limit for a single test (in seconds)}{   |perf_affinity_mask          |0        |set affinity mask for the main thread}{   |perf_log_power_checkpoints  |         |additional xml logging for power measurement}{   |perf_max_deviation          |1.0      |}{h  |help                        |false    |print help info}", "help", "perf_run_cpu", "plain", "perf_impl", "perf_strategy", "default", "base", "simple", "No such strategy: %s\n", "perf_max_outliers", "perf_min_samples", "perf_max_deviation", "perf_seed", "perf_time_limit", "perf_force_samples", "perf_write_sanity", "perf_verify_sanity", "perf_threads", "perf_affinity_mask", "perf_log_power_checkpoints", "perf_list_impls", "Available implementation variants:", "No such implementation: %s\n", "[----------]\n[   INFO   ] \tImplementation variant: %s.\n[----------]\n", "  No time measurements was performed.\nstartTimer() and stopTimer() commands are required for performance tests.", "param_min_samples", "  Only a few samples are collected.\nPlease increase number of iterations or/and time limit to get reliable performance measurements.", "2 * sinh(m.gstddev * param_max_deviation)", ") > (", "  Test results are not reliable ((mean-sigma,mean+sigma) deviation interval is greater than measured time interval).", "m.outliers", "std::max((unsigned int)cvCeil(m.samples * param_max_outliers / 100.), 1u)", "  Test results are not reliable (too many outliers).", "    samples = %d, mean = %.2f, stddev = %.2f (%.1f%%)\n", "\tTest was skipped", "Succeeded", "Test was skipped", "The test has no sanity checks. There should be at least one check at the end of performance test.", "[ VALUE    ] \t%s\n", "[ TYPE     ] \t%s\n", "N7testing31TestPartResultReporterInterfaceE", "N7testing8internal27OsStackTraceGetterInterfaceE", "N7testing8internal16DeathTestFactoryE", "N7testing17TestEventListenerE", "N7testing8internal9DeathTestE", "N7testing22EmptyTestEventListenerE", "N7testing8internal11ThreadLocalIPNS_31TestPartResultReporterInterfaceEE11ValueHolderE", "N7testing8internal26ThreadLocalValueHolderBaseE", "N7testing8internal26GoogleTestFailureExceptionE", "N7testing8internal11ThreadLocalISt6vectorINS0_9TraceInfoESaIS3_EEE11ValueHolderE", "N7testing8internal17StreamingListenerE", "N7testing8internal17StreamingListener12SocketWriterE", "N7testing8internal17StreamingListener20AbstractSocketWriterE", "GTEST_SHARD_INDEX", "catch_exceptions", "N7testing8internal24HasNewFatalFailureHelperE", "N7testing8TestCaseE", "N7testing8internal16ForkingDeathTestE", "N7testing8internal24XmlUnitTestResultPrinterE", "death_test_use_fork", "*N7testing8internal12_GLOBAL__N_123ClassUniqueToAlwaysTrueE", "GetParam()", "stream_result_to", "death_test_style", "fast", "break_on_failure", "N7testing8internal27PrettyUnitTestResultPrinterE", "N7testing8internal18OsStackTraceGetterE", "filter", "GTEST_SHARD_STATUS_FILE", "random_seed", "*DeathTest:*DeathTest/*", "This program contains tests written using Google Test. You can use the\nfollowing command line flags to control its behavior:\n\nTest Selection:\n  @G--gtest_list_tests@D\n      List the names of all tests instead of running them. The name of\n      TEST(Foo, Bar) is \"Foo.Bar\".\n  @G--gtest_filter=@YPOSTIVE_PATTERNS[@G-@YNEGATIVE_PATTERNS]@D\n      Run only the tests whose name matches one of the positive patterns but\n      none of the negative patterns. '?' matches any single character; '*'\n      matches any substring; ':' separates two patterns.\n  @G--gtest_param_filter=@YPOSITIVE_PATTERNS[@G-@YNEGATIVE_PATTERNS]@D\n      Like @G--gtest_filter@D, but applies to the test's parameter. If a\n      test is not parameterized, its parameter is considered to be the\n      empty string.\n  @G--gtest_also_run_disabled_tests@D\n      Run all disabled tests too.\n\nTest Execution:\n  @G--gtest_repeat=@Y[COUNT]@D\n      Run the tests repeatedly; use a negative count to repeat forever.\n  @G--gtest_shuffle@D\n      Randomize tests' orders on every iteration.\n  @G--gtest_random_seed=@Y[NUMBER]@D\n      Random number seed to use for shuffling test orders (between 1 and\n      99999, or 0 to use a seed based on the current time).\n\nTest Output:\n  @G--gtest_color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n      Enable/disable colored output. The default is @Gauto@D.\n  -@G-gtest_print_time=0@D\n      Don't print the elapsed time of each test.\n  @G--gtest_output=xml@Y[@G:@YDIRECTORY_PATH@G/@Y|@G:@YFILE_PATH]@D\n      Generate an XML report in the given directory or with the given file\n      name. @YFILE_PATH@D defaults to @Gtest_details.xml@D.\n  @G--gtest_stream_result_to=@YHOST@G:@YPORT@D\n      Stream test results to the given server.\n\nAssertion Behavior:\n  @G--gtest_death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\n      Set the default death test style.\n  @G--gtest_break_on_failure@D\n      Turn assertion failures into debugger break-points.\n  @G--gtest_throw_on_failure@D\n      Turn assertion failures into C++ exceptions.\n  @G--gtest_catch_exceptions=0@D\n      Do not report exceptions as test failures. Instead, allow them\n      to crash the program or throw a pop-up (on Windows).\n\nExcept for @G--gtest_list_tests@D, you can alternatively set the corresponding\nenvironment variable of a flag (all letters in upper-case). For example, to\ndisable colored text output, you can either specify @G--gtest_color=no@D or set\nthe @GGTEST_COLOR@D environment variable to @Gno@D.\n\nFor more information, please read the Google Test documentation at\n@Ghttp://code.google.com/p/googletest/@D. If you find a bug in Google Test\n(not one in your own code or tests), please report it to\n@G<googletestframework@@googlegroups.com>@D.\n", "N7testing32ScopedFakeTestPartResultReporterE", "shuffle", "N7testing8internal13ExecDeathTestE", "N7testing8internal12UnitTestImplE", "N7testing8internal35DefaultGlobalTestPartResultReporterE", "N7testing8internal17TestEventRepeaterE", "internal_run_death_test", "stack_trace_depth", "TypeParam", ", where ", "%s = %s", " and ", "basic_string::_S_construct null not valid", "[  DEATH   ] ", "basic_string::substr", "event=TestProgramStart", "event=TestCaseStart&name=", "event=TestStart&name=", "gtest_", "%02X", "vector::_M_range_check", "auto", "TERM", "xterm", "xterm-color", "xterm-256color", "screen", "screen-256color", "linux", "cygwin", "true", "[----------] ", "Global test environment tear-down", "Global test environment set-up.", "[ RUN      ] ", "%s.%s", "XML output file may not be null\n", "<![CDATA[", "]]>]]&gt;<![CDATA[", "[  FAILED  ] ", "Could not write to the test shard status file \"%s\" specified by the %s environment variable.\n", "  # %s = ", "  %s", "gtest_internal_", "gtest-", "threadsafe", "/sdcard/gtest_captured_stream.XXXXXX", "-byte object <", " ... ", "Non-fatal failure", "Success", "Fatal failure", "\nInvalid index (%d) into TestPartResultArray.\n", "(null)", "WARNING: ", " is expected to be a 32-bit integer, but actually", " has value \"", " has value ", ", which overflows.\n", "The value of flag --", "The value of environment variable ", "Environment variable ", "The default value %s is used.\n", "Invalid environment variables: you have ", ", but have left ", " unset.\n", "Invalid environment variables: we require 0 <= ", ", but you have ", "C++ exception with description \"", "Unknown C++ exception", " thrown in ", "Value of: ", "\n  Actual: ", "\nExpected: ", "&lt;", "&gt;", "&amp;", "&apos;", "&quot;", "[       OK ] ", " (%s ms)\n", "test", "tests", "%s from %s", ", where %s = %s\n", "\nRepeating all tests (iteration %d) . . .\n\n", "Note: %s filter = %s\n", "Google Test", "Note: %s parameter filter = %s\n", "Note: This is test shard %d of %s.\n", "Note: Randomizing tests' orders with a seed of %d .\n", "[==========] ", "test case", "test cases", "Running %s from %s.\n", "TEST", "TESTS", "%s from %s ran.", " (%s ms total)", "[  PASSED  ] ", "%s.\n", "%s, listed below:\n", "\n%2d FAILED %s\n", "  YOU HAVE %d DISABLED %s\n\n", "%s from %s (%s ms total)\n\n", "[WARNING]", "[  INFO ]", "[ FATAL ]", "[ ERROR ]", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ts/include/opencv2/ts/ts_gtest.h", "pthread_mutex_destroy(&mutex_)", "failed with error ", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ts/src/ts_gtest.cpp", "Only one ", " capturer can exist at a time.", "stderr", "stdout", "pthread_mutex_init(&mutex_, NULL)", "Condition 1 <= seed && seed <= kMaxRandomSeed failed. ", "Invalid random seed ", " - must be in [1, ", "pthread_mutex_lock(&mutex_)", "pthread_mutex_unlock(&mutex_)", "Condition sockfd_ == -1 failed. ", "MakeConnection() can't be called when there is already a connection.", "stream_result_to: getaddrinfo() failed: ", "stream_result_to: failed to connect to ", "Condition range > 0 failed. ", "Cannot generate a number in the range [0, 0).", "Condition range <= kMaxRange failed. ", "Generation of a number in [0, ", ") was requested, ", "but this can only generate numbers in [0, ", "Condition sockfd_ != -1 failed. ", "CloseConnection() can be called only when there is a connection.", "Send() can be called only when there is a connection.", "stream_result_to: failed to stream to ", "Death test: ", "    Result: failed to die.\n", " Error msg:\n", "    Result: threw an exception.\n", "    Result: illegal return in test statement.\n", "    Result: died but not with expected error.\n", "  Expected: ", "Actual msg:\n", "    Result: died but not with expected exit code:\n", "            ", "Exited with exit status ", "Terminated by signal ", " (core dumped)", "DeathTest::Passed somehow called before conclusion of test", " is listed more than once.\n", " can be found in this test case.\n", "You forgot to list test ", "%s %s", "Test ", "No test named ", "Failure\n", "Unknown result type", "Attempted redefinition of test case ", "All tests in the same test case must use the same test fixture\n", "class.  However, in test case ", ", you tried\n", "to define a test using a fixture class different from the one\n", "used earlier. This can happen if the two fixture classes are\n", "from different namespaces and have the same name. You should\n", "probably rename one of the classes to put the tests into different\n", "test cases.", " (ignoring case)", "\nWhich is: ", "event=TestProgramEnd&passed=", "event=TestIterationStart&iteration=", "event=TestEnd&passed=", "&elapsed_time=", "event=TestCaseEnd&passed=", "event=TestIterationEnd&passed=", "event=TestPartResult&file=", "&line=", "&message=", "NULL", " pointing to ", " (no terminating NUL)", "(Invalid Unicode 0x", "not ", "  Actual: ", "Expected: ", "a substring of ", "Which is: ", "Expected: (", ") != (", ") (ignoring case), actual: \"", "\" vs \"", "), actual: \"", "The difference between ", " is ", ", which exceeds ", ", where\n", " evaluates to ", ", and\n", ") > (", "), actual: ", " vs ", ") >= (", ") < (", ") <= (", "pthread_key_delete(key_)", "Condition 0 <= begin && begin <= size failed. ", "Invalid shuffle range start ", ": must be in range [0, ", "Condition begin <= end && end <= size failed. ", "Invalid shuffle range finish ", ": must be in range [", "--help", "Condition sizeof(Integer) <= sizeof(parsed) failed. ", ", 0x", "gtest_streaming_protocol_version=1.0", "WARNING: unrecognized streaming target \"%s\" ignored.\n", "pthread_key_create(&key, &DeleteThreadLocalValue)", "WARNING: unrecognized output format \"%s\" ignored.\n", "Error while reading death test internal: ", "Death test child process reported ", "unexpected status byte (", "Read from death test child process failed: ", "CHECK failed: File ", ", line ", "posix::Close(read_fd())", " != -1", "waitpid(child_pid_, &status_value, 0)", "posix::Write(write_fd(), &status_ch, 1)", "read_fd_ == -1", "Cannot run a death test outside of a TEST or TEST_F construct", "Death test count (", ") somehow exceeded expected maximum (", "fast", "Unknown death test style \"", "\" encountered", "Death tests use fork(), which is unsafe particularly", " in a threaded context. For this test, ", "couldn't detect the number of threads.", "detected ", " threads.", "pipe(pipe_fd) != -1", "child_pid != -1", "close(pipe_fd[0])", "close(pipe_fd[1])", "Condition !original_working_dir_.IsEmpty() failed. ", "Failed to get the current working directory.", "Condition typeid(*base) == typeid(Derived) failed. ", "pthread_setspecific(key_, holder_base)", "fcntl(pipe_fd[1], F_SETFD, 0) != -1", "sigaction( SIGPROF, &ignore_sigprof_action, &saved_sigprof_action)", "close(args->close_fd)", "chdir(\"", "\") failed: ", "execve(", ", ...) in ", " failed: ", "sigaction(SIGPROF, &saved_sigprof_action, NULL)", "Bad --gtest_internal_run_death_test flag: ", " trace:", "^(%s)$", "is_valid_", "false", "Regular expression \"", "\" is not a valid POSIX Extended regular expression.", "Failed", "class, so mixing TEST_F and TEST in the same test case is\n", "illegal.  In test case ", "test ", " is defined using TEST_F but\n", " is defined using TEST.  You probably\n", "want to change the TEST to TEST_F or move it to another test\n", "case.", "you defined test ", " and test ", "using two different test fixture classes.  This can happen if\n", "the two classes are from different namespaces or translation\n", "units and have the same name.  You should probably rename one\n", "of the classes to put the tests into different test cases.", "SetUp()", "the test body", "TearDown()", "the test fixture's constructor", "the test fixture's destructor", "SetUpTestCase()", "TearDownTestCase()", "\nThis test program did NOT call ::testing::InitGoogleTest before calling RUN_ALL_TESTS().  Please fix it.", "TEST_PREMATURE_EXIT_FILE", "auxiliary test code (environments or event listeners)", "1 fatal failure", "1 non-fatal failure", " failures", "  Actual:\n", " containing \"", "testsuites", "testsuite", "testcase", "Condition false failed. ", "Unrecognized xml_element provided: ", "Condition std::find(allowed_names.begin(), allowed_names.end(), name) != allowed_names.end() failed. ", "Attribute ", " is not allowed for element <", "notrun", "    <testcase", "name", "value_param", "type_param", "status", "time", "classname", "      <failure message=\"", "\" type=\"\">", "</failure>\n", " />\n", "    </testcase>\n", "failures", "disabled", "errors", "  </", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", "timestamp", "random_seed", "AllTests", "Unable to open file \"%s\"\n", "Reserved key used in RecordProperty(): ", "and ", " are reserved by ", "also_run_disabled_tests", "break_on_failure", "catch_exceptions", "color", "filter", "param_filter", "output", "print_time", "repeat", "shuffle", "stack_trace_depth", "stream_result_to", "throw_on_failure", "death_test_style", "death_test_use_fork", "... Google Test internal frames ...", "param_filter", "N7testing8internal23DefaultDeathTestFactoryE", "test_detail.xml", "N7testing8UnitTestE", "output", "N7testing8internal15NoExecDeathTestE", "list_tests", "N7testing8internal38DefaultPerThreadTestPartResultReporterE", "DISABLED_*:*/DISABLED_*", "color", "unknown file", "throw_on_failure", "GTEST_TOTAL_SHARDS", "\nStack trace:\n", "repeat", "print_time", "N7testing8internal13DeathTestImplE", "N7testing4TestE", "also_run_disabled_tests", "void cvtest::erode(const cv::Mat&, cv::Mat&, const cv::Mat&, cv::Point, int, const Scalar&)", "void cvtest::compare_(const _Tp*, const _Tp*, uchar*, size_t, int) [with _Tp = int, uchar = unsigned char, size_t = unsigned int]", "bool cvtest::cmpUlps(const cv::Mat&, const cv::Mat&, int, double*, std::vector<int>*)", "void cvtest::filter2D(const cv::Mat&, cv::Mat&, int, const cv::Mat&, cv::Point, double, int, const Scalar&)", "void cvtest::compareS_(const _Tp*, _WTp, uchar*, size_t, int) [with _Tp = double, _WTp = double, uchar = unsigned char, size_t = unsigned int]", "void cvtest::compare_(const _Tp*, const _Tp*, uchar*, size_t, int) [with _Tp = short int, uchar = unsigned char, size_t = unsigned int]", "void cvtest::convertTo(const _Tp*, void*, int, size_t, double, double) [with _Tp = signed char, size_t = unsigned int]", "void cvtest::writeElems(std::ostream&, void const*, int, int, int)", "int cvtest::check(const cv::Mat&, double, double, std::vector<int>*)", "void cvtest::convertTo(const _Tp*, void*, int, size_t, double, double) [with _Tp = float, size_t = unsigned int]", "double cvtest::getMaxVal(int)", "void cvtest::compare_(const _Tp*, const _Tp*, uchar*, size_t, int) [with _Tp = float, uchar = unsigned char, size_t = unsigned int]", "void cvtest::convertTo(const _Tp*, void*, int, size_t, double, double) [with _Tp = double, size_t = unsigned int]", "void cvtest::convertTo(const _Tp*, void*, int, size_t, double, double) [with _Tp = int, size_t = unsigned int]", "void cvtest::convertTo(const _Tp*, void*, int, size_t, double, double) [with _Tp = unsigned char, size_t = unsigned int]", "void cvtest::transform(const cv::Mat&, cv::Mat&, const cv::Mat&, const cv::Mat&)", "int cvtest::borderInterpolate(int, int, int)", "int cvtest::randomType(cv::RNG&, int, int, int)", "double cvtest::norm(const cv::Mat&, int, const cv::Mat&)", "void cvtest::muldiv(const cv::Mat&, const cv::Mat&, cv::Mat&, double, char)", "double cvtest::crossCorr(const cv::Mat&, const cv::Mat&)", "void cvtest::insert(const cv::Mat&, cv::Mat&, int)", "cv::Mat cvtest::calcSobelKernel2D(int, int, int, int)", "void cvtest::compareS_(const _Tp*, _WTp, uchar*, size_t, int) [with _Tp = short unsigned int, _WTp = int, uchar = unsigned char, size_t = unsigned int]", "void cvtest::compare_(const _Tp*, const _Tp*, uchar*, size_t, int) [with _Tp = signed char, uchar = unsigned char, size_t = unsigned int]", "void cvtest::gemm(const cv::Mat&, const cv::Mat&, double, const cv::Mat&, double, cv::Mat&, int)", "int cvtest::cmpEps(const cv::Mat&, const cv::Mat&, double*, double, std::vector<int>*, bool)", "void cvtest::copy(const cv::Mat&, cv::Mat&, const cv::Mat&, bool)", "void cvtest::convertTo(const _Tp*, void*, int, size_t, double, double) [with _Tp = short int, size_t = unsigned int]", "void cvtest::compareS_(const _Tp*, _WTp, uchar*, size_t, int) [with _Tp = float, _WTp = double, uchar = unsigned char, size_t = unsigned int]", "cv::Mat cvtest::getSubArray(const cv::Mat&, int, std::vector<int>&, std::vector<int>&)", "void cvtest::logicOp(const cv::Mat&, const Scalar&, cv::Mat&, char)", "void cvtest::compare(const cv::Mat&, const cv::Mat&, cv::Mat&, int)", "void cvtest::compareS_(const _Tp*, _WTp, uchar*, size_t, int) [with _Tp = short int, _WTp = int, uchar = unsigned char, size_t = unsigned int]", "void cvtest::convertTo(const _Tp*, void*, int, size_t, double, double) [with _Tp = short unsigned int, size_t = unsigned int]", "void cvtest::compareS_(const _Tp*, _WTp, uchar*, size_t, int) [with _Tp = unsigned char, _WTp = int, uchar = unsigned char, size_t = unsigned int]", "int cvtest::normHamming(const uchar*, size_t, int)", "void cvtest::compareS_(const _Tp*, _WTp, uchar*, size_t, int) [with _Tp = signed char, _WTp = int, uchar = unsigned char, size_t = unsigned int]", "void cvtest::compare_(const _Tp*, const _Tp*, uchar*, size_t, int) [with _Tp = unsigned char, uchar = unsigned char, size_t = unsigned int]", "void cvtest::extract(const cv::Mat&, cv::Mat&, int)", "cv::Scalar cvtest::mean(const cv::Mat&, const cv::Mat&)", "void cvtest::compare(const cv::Mat&, double, cv::Mat&, int)", "void cvtest::compare_(const _Tp*, const _Tp*, uchar*, size_t, int) [with _Tp = short unsigned int, uchar = unsigned char, size_t = unsigned int]", "void cvtest::minMaxLoc(const cv::Mat&, double*, double*, std::vector<int>*, std::vector<int>*, const cv::Mat&)", "void cvtest::compare_(const _Tp*, const _Tp*, uchar*, size_t, int) [with _Tp = double, uchar = unsigned char, size_t = unsigned int]", "void cvtest::patchZeros(cv::Mat&, double)", "void cvtest::add(const cv::Mat&, double, const cv::Mat&, double, cv::Scalar, cv::Mat&, int, bool)", "std::ostream& cvtest::operator<<(std::ostream&, const cvtest::MatPart&)", "void cvtest::transpose(const cv::Mat&, cv::Mat&)", "void cvtest::compareS_(const _Tp*, _WTp, uchar*, size_t, int) [with _Tp = int, _WTp = int, uchar = unsigned char, size_t = unsigned int]", "double cvtest::norm(const cv::Mat&, const cv::Mat&, int, const cv::Mat&)", "void cvtest::logicOp(const cv::Mat&, const cv::Mat&, cv::Mat&, char)", "void cvtest::set(cv::Mat&, const Scalar&, const cv::Mat&)", "void cvtest::randUni(cv::RNG&, cv::Mat&, const Scalar&, const Scalar&)", "double cvtest::getMinVal(int)", "void cvtest::minmax(const cv::Mat&, double, cv::Mat&, char)", "void cvtest::dilate(const cv::Mat&, cv::Mat&, const cv::Mat&, cv::Point, int, const Scalar&)", "!m.loc || ((int)m.loc->size() == m.m->dims && m.m->dims <= 2)", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/ts/src/ts_func.cpp", "mask >= 0", "Unknown/unsupported border type", "src1.empty() || (src1.type() == src2.type() && src1.size == src2.size)", "src1.type() == src2.type() && src1.size == src2.size", "(typeMask & DEPTH_MASK_ALL) != 0", "val != -1", "!a.empty() || !b.empty()", "a.size == b.size", "planes[0].rows == 1", "src.size == mask.size && mask.type() == CV_8U", "dst.size == mask.size && mask.type() == CV_8U", "dst.size == src.size && src.depth() == dst.depth() && 0 <= coi && coi < dst.channels()", "0 <= coi && coi < src.channels()", "src.dims == 2", "src.depth() == CV_8U", "mask.empty() || (src.size == mask.size && mask.type() == CV_8U)", "normType == NORM_INF || normType == NORM_L1 || normType == NORM_L2", "temp.depth() == CV_8U", "mask.empty() || (src1.size == mask.size && mask.type() == CV_8U)", "src1.size == src2.size && src1.type() == src2.type()", "op == '&' || op == '|' || op == '^'", "op == '&' || op == '|' || op == '^' || op == '~'", "src1.type() == src2.type() && src1.channels() == 1 && src1.size == src2.size", "Unknown comparison operation", "src.channels() == 1", "a.type() == b.type() && a.dims == 2 && b.dims == 2 && cn <= 2", "c.dims == 2 && c.type() == a.type() && c_rows == a_rows && c_cols == b_cols", "scn <= 4 && dcn <= 4 && (mattype == CV_32F || mattype == CV_64F) && (!haveShift || (shift.type() == mattype && (shift.rows == 1 || shift.cols == 1)))", "mask.empty() || (mask.type() == CV_8U && mask.size == src.size)", "depth == CV_32F || depth == CV_64F", "<Empty>", "-dim (", "cv_version", "2.4.11", "OpenCV version: ", "Version control", "basic_string::substr", "cv_vcs_version", "OpenCV VCS version: ", "inner version", "cv_inner_vcs_version", "Inner VCS version: ", "cv_build_type", "release", "Build type: ", "cv_parallel_framework", "Parallel framework: ", "cv_cpu_features", "CPU features: ", "(null)", "vector::_M_insert_aux", "kernel.type() == CV_8U", "kernel.type() == CV_32F || kernel.type() == CV_64F", "vector::_M_fill_insert", "(_aperture_size == -1 || (_aperture_size >= 1 && _aperture_size % 2 == 1)) && dx >= 0 && dy >= 0 && dx + dy <= 3", "arr.type() == refarr.type() && arr.size == refarr.size", "%s: Too big difference (=%g)", "%s: Invalid output", "%s: Invalid reference output", "%s at element %d\n", "%s at (%s)\n", "d == (int)ofs.size()", "The reference and the actual output arrays have different type or size:\n", "too big relative difference (", ") between ", "' and '", "' at ", "void cvtest::minmax(const cv::Mat&, const cv::Mat&, cv::Mat&, char)", "N2cv9videostab13InpainterBaseE", "N2cv9videostab18InpaintingPipelineE", "Inpaint cv::videostab::FastMarchingMethod::run(const cv::Mat&, Inpaint) [with Inpaint = cv::videostab::MotionInpaintBody]", "void cv::videostab::completeFrameAccordingToFlow(const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&, float, cv::Mat&, cv::Mat&)", "cv::videostab::MotionInpainter::MotionInpainter()", "float cv::videostab::alignementError(const cv::Mat&, const cv::Mat&, const cv::Mat&, const cv::Mat&)", "Current implementation of MotionInpainter requires GPU", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/videostab/src/inpainting.cpp", "flowX.type() == CV_32F && flowX.size() == mask0.size()", "flowY.type() == CV_32F && flowY.size() == mask0.size()", "errors.type() == CV_32F && errors.size() == mask0.size()", "mask0.type() == CV_8U", "mask1.type() == CV_8U && mask1.size() == mask0.size()", "flowMask.type() == CV_8U", "flowX.type() == CV_32F && flowX.size() == flowMask.size()", "flowY.type() == CV_32F && flowY.size() == flowMask.size()", "frame1.type() == CV_8UC3 && frame1.size() == flowMask.size()", "mask1.type() == CV_8U && mask1.size() == flowMask.size()", "frame0.type() == CV_8UC3 && frame0.size() == flowMask.size()", "mask0.type() == CV_8U && mask0.size() == flowMask.size()", "mask.type() == CV_8U", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/videostab/include/opencv2/videostab/fast_marching_inl.hpp", "frame.type() == CV_8UC3", "mask.size() == frame.size() && mask.type() == CV_8U", "frame0.type() == CV_8UC3 && frame1.type() == CV_8UC3", "mask0.type() == CV_8U && mask0.size() == frame0.size()", "frame0.size() == frame1.size()", "M.size() == Size(3,3) && M.type() == CV_32F", "N2cv9videostab14ColorInpainterE", "Inpaint cv::videostab::FastMarchingMethod::run(const cv::Mat&, Inpaint) [with Inpaint = cv::videostab::ColorAverageInpaintBody]", "void cv::videostab::calcFlowMask(const cv::Mat&, const cv::Mat&, const cv::Mat&, float, const cv::Mat&, const cv::Mat&, cv::Mat&)", "N2cv9videostab21ColorAverageInpainterE", "N2cv9videostab25ConsistentMosaicInpainterE", "N2cv9videostab15MotionInpainterE", "virtual void cv::videostab::ConsistentMosaicInpainter::inpaint(int, cv::Mat&, cv::Mat&)", "N2cv9videostab12DeblurerBaseE", "virtual void cv::videostab::WeightingDeblurer::deblur(int, cv::Mat&)", "frame.type() == CV_8UC3", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/videostab/src/deblurring.cpp", "N2cv9videostab17WeightingDeblurerE", "N2cv9videostab22IGlobalMotionEstimatorE", "N2cv9videostab23ISparseOptFlowEstimatorE", "N2cv9videostab26PyrLkRobustMotionEstimatorE", "cv::Mat cv::videostab::estimateGlobalMotionLeastSquares(const std::vector<cv::Point_<float> >&, const std::vector<cv::Point_<float> >&, int, float*)", "points0.size() == points1.size()", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/videostab/src/global_motion.cpp", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::reserve", "cv::Mat cv::videostab::estimateGlobalMotionRobust(const std::vector<cv::Point_<float> >&, const std::vector<cv::Point_<float> >&, int, const cv::videostab::RansacParams&, float*, int*)", "vector::_M_fill_insert", "N2cv9videostab17IMotionStabilizerE", "N2cv9videostab16MotionFilterBaseE", "N2cv9videostab20GaussianMotionFilterE", "M.size() == Size(3,3) && M.type() == CV_32F", "/hdd2/buildbot/slaves/slave_ardbeg1/50-SDK/opencv/modules/videostab/src/motion_stabilizing.cpp", "vector::_M_fill_insert", "cv::Mat cv::videostab::ensureInclusionConstraint(const cv::Mat&, cv::Size, float)", "float cv::videostab::estimateOptimalTrimRatio(const cv::Mat&, cv::Size)", "N2cv9videostab25PyrLkOptFlowEstimatorBaseE", "N2cv9videostab27SparsePyrLkOptFlowEstimatorE", "N2cv9videostab4ILogE", "N2cv9videostab11LogToStdoutE", "N2cv9videostab12IFrameSourceE", "can't open file: ", "N2cv9videostab15VideoFileSourceE", "N2cv9videostab13NullInpainterE", "N2cv9videostab12NullDeblurerE", "N2cv9videostab15NullFrameSourceE", "N2cv9videostab7NullLogE", "N2cv9videostab14StabilizerBaseE", "N2cv9videostab17TwoPassStabilizerE", "vector::_M_fill_insert", "processing frames", "vector::_M_insert_aux", "first pass: estimating motions", "estimated trim ratio: %f\n", "N2cv9videostab17OnePassStabilizerE", "Bogus message code %d", "Sorry, there are legal restrictions on arithmetic coding", "ALIGN_TYPE is wrong, please fix", "MAX_ALLOC_CHUNK is wrong, please fix", "Bogus buffer control mode", "Invalid component ID %d in SOS", "Invalid crop request", "DCT coefficient out of range", "IDCT output block size %d not supported", "Bogus Huffman table definition", "Bogus input colorspace", "Bogus JPEG colorspace", "Bogus marker length", "Wrong JPEG library version: library is %d, caller expects %d", "Sampling factors too large for interleaved scan", "Invalid memory pool code %d", "Unsupported JPEG data precision %d", "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d", "Invalid progressive parameters at scan script entry %d", "Bogus sampling factors", "Invalid scan script at entry %d", "Improper call to JPEG library in state %d", "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u", "Bogus virtual array access", "Buffer passed to JPEG library is too small", "Suspension not allowed here", "CCIR601 sampling not implemented yet", "Too many color components: %d, max %d", "Unsupported color conversion request", "Bogus DAC index %d", "Bogus DAC value 0x%x", "Bogus DHT index %d", "Bogus DQT index %d", "Empty JPEG image (DNL not supported)", "Read from EMS failed", "Write to EMS failed", "Didn't expect more than one scan", "Input file read error", "Output file write error --- out of disk space?", "Fractional sampling not implemented yet", "Huffman code size table overflow", "Missing Huffman code table entry", "Maximum supported image dimension is %u pixels", "Empty input file", "Premature end of input file", "Cannot transcode due to multiple use of quantization table %d", "Scan script does not transmit all data", "Invalid color quantization mode change", "Not implemented yet", "Requested feature was omitted at compile time", "Backing store not supported", "Huffman table 0x%02x was not defined", "JPEG datastream contains no image", "Quantization table 0x%02x was not defined", "Not a JPEG file: starts with 0x%02x 0x%02x", "Insufficient memory (case %d)", "Cannot quantize more than %d color components", "Cannot quantize to fewer than %d colors", "Cannot quantize to more than %d colors", "Invalid JPEG file structure: two SOF markers", "Invalid JPEG file structure: missing SOS marker", "Unsupported JPEG process: SOF type 0x%02x", "Invalid JPEG file structure: two SOI markers", "Invalid JPEG file structure: SOS before SOF", "Failed to create temporary file %s", "Read failed on temporary file", "Seek failed on temporary file", "Write failed on temporary file --- out of disk space?", "Application transferred too few scanlines", "Unsupported marker type 0x%02x", "Virtual array controller messed up", "Image too wide for this implementation", "Read from XMS failed", "Write to XMS failed", "Copyright (C) 1998, Thomas G. Lane", "6b  27-Mar-1998", "Caution: quantization tables are too coarse for baseline JPEG", "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d", "Unknown APP0 marker (not JFIF), length %u", "Unknown APP14 marker (not Adobe), length %u", "Define Arithmetic Table 0x%02x: 0x%02x", "Define Huffman Table 0x%02x", "Define Quantization Table %d  precision %d", "Define Restart Interval %u", "Freed EMS handle %u", "Obtained EMS handle %u", "End Of Image", "        %3d %3d %3d %3d %3d %3d %3d %3d", "JFIF APP0 marker: version %d.%02d, density %dx%d  %d", "Warning: thumbnail image size does not match data length %u", "JFIF extension marker: type 0x%02x, length %u", "    with %d x %d thumbnail image", "Miscellaneous marker 0x%02x, length %u", "Unexpected marker 0x%02x", "        %4u %4u %4u %4u %4u %4u %4u %4u", "Quantizing to %d = %d*%d*%d colors", "Quantizing to %d colors", "Selected %d colors for quantization", "At marker 0x%02x, recovery action %d", "RST%d", "Smoothing not supported with nonstandard sampling ratios", "Start Of Frame 0x%02x: width=%u, height=%u, components=%d", "    Component %d: %dhx%dv q=%d", "Start of Image", "Start Of Scan: %d components", "    Component %d: dc=%d ac=%d", "  Ss=%d, Se=%d, Ah=%d, Al=%d", "Closed temporary file %s", "Opened temporary file %s", "JFIF extension marker: JPEG-compressed thumbnail image, length %u", "JFIF extension marker: palette thumbnail image, length %u", "JFIF extension marker: RGB thumbnail image, length %u", "Unrecognized component IDs %d %d %d, assuming YCbCr", "Freed XMS handle %u", "Obtained XMS handle %u", "Unknown Adobe color transform code %d", "Inconsistent progression sequence for component %d coefficient %d", "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x", "Corrupt JPEG data: premature end of data segment", "Corrupt JPEG data: bad Huffman code", "Warning: unknown JFIF revision number %d.%02d", "Premature end of JPEG file", "Corrupt JPEG data: found marker 0x%02x instead of RST%d", "Invalid SOS parameters for sequential JPEG", "Application transferred too many scanlines", "%ld%c", "cHRM White X", "cHRM White Y", "cHRM Red X", "cHRM Red Y", "cHRM Green X", "cHRM Green Y", "cHRM Blue X", "cHRM Blue Y", "cHRM Red Z", "Out of range gamma value ignored", "png_set_gAMA", "Invalid palette size, hIST allocation skipped", "Insufficient memory for hIST chunk data", "Invalid pCAL equation type", "Invalid format for pCAL parameter", "Insufficient memory for pCAL purpose", "Insufficient memory for pCAL units", "Insufficient memory for pCAL params", "Insufficient memory for pCAL parameter", "Invalid sCAL unit", "Invalid sCAL width", "Invalid sCAL height", "Memory allocation failed while processing sCAL", "Invalid sCAL width ignored", "Invalid sCAL height ignored", "Invalid palette length", "Insufficient memory to process iCCP chunk", "Insufficient memory to process iCCP profile", "text compression mode is out of range", "Insufficient memory to store text", "Ignoring invalid time value", "tRNS chunk has out-of-range samples for bit_depth", "No memory for sPLT palettes", "Out of memory while processing sPLT chunk", "Out of memory while processing unknown chunk", "MNG features are not allowed in a PNG datastream", "Writing zero-length unknown chunk", "Valid palette required for paletted images", "No IDATs written into file", "Wrote palette index exceeding num_palette", "png_write_info was never called before png_write_row", "internal write transform logic error", "zlib error", "Unknown row filter for method 0", "Can't add Up filter after starting", "Can't add Average filter after starting", "Can't add Paeth filter after starting", "Unknown custom filter method", "Unknown filter heuristic method", "Only compression windows <= 32k supported by PNG", "Only compression windows >= 256 supported by PNG", "Compression window is being reset to 512", "Only compression method 8 is supported by PNG", "Text compression window is being reset to 512", "Write Error", "Call to NULL write function", "Can't set both read_data_fn and write_data_fn in the same structure", "sCAL width", "sCAL height", "IDAT", "text", "1.2.3", "invalid zlib state", "zlib failed to initialize compressor (", ") version error", ") stream error", ") memory error", ") unknown error", "zstream already in use (internal error)", "Unknown compression type @1", "zlib error", "version", "stream", "memory", "unknown", "[no zlib message]", "zlib failed to reset compressor: @1(@2): @3", "Invalid zlib compression method or flags in non-IDAT chunk", "zstream not in use (internal error)", "Invalid bit depth for grayscale image", "Invalid bit depth for RGB image", "Invalid bit depth for paletted image", "Invalid bit depth for grayscale+alpha image", "Invalid bit depth for RGBA image", "Invalid image color type specified", "Invalid compression type specified", "Invalid filter type specified", "Invalid interlace type specified", "Invalid number of colors in palette", "Ignoring request to write a PLTE chunk in grayscale PNG", "Invalid zlib compression method or flags in IDAT", "Invalid sRGB rendering intent specified", "Invalid sBIT depth specified", "Invalid number of transparent colors specified", "Ignoring attempt to write tRNS chunk out-of-range for bit_depth", "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8", "Can't write tRNS with an alpha channel", "Invalid background palette index", "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8", "Ignoring attempt to write bKGD chunk out-of-range for bit_depth", "Invalid number of histogram entries specified", "zero length keyword", "Out of memory while procesing keyword", "invalid keyword character 0x@1", "trailing spaces removed from keyword", "leading spaces removed from keyword", "extra interior spaces removed from keyword", "Zero length keyword", "keyword length must be 1 - 79 characters", "Unknown compression type in iCCP chunk", "Embedded profile length in iCCP chunk is negative", "Embedded profile length too large in iCCP chunk", "Truncating profile to actual length in iCCP chunk", "Empty language field in iTXt chunk", "Unrecognized unit type for oFFs chunk", "Unrecognized equation type for pCAL chunk", "Can't write sCAL (buffer too small)", "Unrecognized unit type for pHYs chunk", "Invalid time specified for tIME chunk", "Read Error", "Call to NULL read function", "Can't set both read_data_fn and write_data_fn in the same structure", "Too many bytes for PNG signature", "Potential overflow in png_zalloc()", "Unknown freer parameter in png_data_freer", "Ignoring invalid time value", " +0000", "\nlibpng version 1.5.12 - July 11, 2012\nCopyright (c) 1998-2012 Glenn Randers-Pehrson\nCopyright (c) 1996-1997 Andreas Dilger\nCopyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n", "1.5.12", "Application built with libpng-", " but running with ", " libpng version 1.5.12 - July 11, 2012\n\n", "Image width is zero in IHDR", "Image height is zero in IHDR", "Image width exceeds user limit in IHDR", "Image height exceeds user limit in IHDR", "Invalid image width in IHDR", "Invalid image height in IHDR", "Width is too large for libpng to process pixels", "Invalid bit depth in IHDR", "Invalid color type in IHDR", "Invalid color type/bit depth combination in IHDR", "Unknown interlace method in IHDR", "Unknown compression method in IHDR", "MNG features are not allowed in a PNG datastream", "Unknown filter method in IHDR", "Invalid filter method in IHDR", "Invalid IHDR data", "ASCII conversion buffer too small", "fixed point overflow ignored", "extreme cHRM chunk cannot be converted to tristimulus values", "internal error in png_XYZ_from_xy", "Ignoring attempt to set negative chromaticity value", "Invalid cHRM white point", "Invalid cHRM red point", "Invalid cHRM green point", "Invalid cHRM blue point", "Ignoring attempt to set cHRM RGB triangle with zero area", "gamma table being rebuilt", "Out of Memory", "Can't discard critical data on CRC error", "Application must supply a known background gamma", "png_set_background", "output gamma out of expected range", "invalid alpha mode", "conflicting calls to set alpha mode and background", "gamma value", "invalid error action to rgb_to_gray", "ignoring out of range rgb_to_gray coefficients", "rgb to gray red coefficient", "rgb to gray green coefficient", "libpng does not support gamma+background+rgb_to_gray", "invalid background gamma type", "png_do_encode_alpha: unexpected call", "NULL row buffer", "Uninitialized row", "png_do_rgb_to_gray found nongray pixel", "png_do_quantize returned rowbytes=0", "0123456789ABCDEF", "libpng warning: %s", "123456789", "undefined", "libpng error: %s", "fixed point overflow in ", "1.2.3", "zlib memory error", "zlib stream error", "zlib version error", "Unknown zlib error", "Missing IHDR before IDAT", "Missing PLTE before IDAT", "Decompression error", "Invalid attempt to read row data", "Not enough image data", "Extra compressed data", "bad adaptive filter value", "sequential row overflow", "internal sequential row size calculation error", "Interlace handling should be turned on when using png_read_image", "Read palette index exceeding num_palette", "Too many IDATs found", "Image is too high to process with png_read_png()", "Buffer error in compressed datastream", "Data error in compressed datastream", "Incomplete compressed datastream", "PNG unsigned integer out of range", "Not a PNG file", "PNG file corrupted by ASCII conversion", "CRC error", "invalid chunklength", "Exceeded size limit while expanding chunk", "png_inflate logic error", "Not enough memory to decompress chunk", "Unknown compression type @1", "Out of place IHDR", "Invalid IHDR chunk", "Missing IHDR before PLTE", "Invalid PLTE after IDAT", "Duplicate PLTE chunk", "Ignoring PLTE chunk in grayscale PNG", "Invalid palette chunk", "Truncating incorrect tRNS chunk length", "Truncating incorrect info tRNS chunk length", "No image in file", "Incorrect IEND chunk length", "Missing IHDR before gAMA", "Invalid gAMA after IDAT", "Out of place gAMA chunk", "Duplicate gAMA chunk", "Incorrect gAMA chunk length", "Ignoring gAMA chunk with out of range gamma", "Ignoring incorrect gAMA value @1 when sRGB is also present", "Missing IHDR before sBIT", "Invalid sBIT after IDAT", "Out of place sBIT chunk", "Duplicate sBIT chunk", "Incorrect sBIT chunk length", "Missing IHDR before cHRM", "Invalid cHRM after IDAT", "Out of place cHRM chunk", "Duplicate cHRM chunk", "Incorrect cHRM chunk length", "Ignoring cHRM chunk with negative chromaticities", "Ignoring incorrect cHRM white(@1,@2) r(@3,@4)g(@5,@6)b(@7,@8) when sRGB is also present", "internal error handling cHRM coefficients", "internal error handling cHRM->XYZ", "Missing IHDR before sRGB", "Invalid sRGB after IDAT", "Out of place sRGB chunk", "Duplicate sRGB chunk", "Incorrect sRGB chunk length", "Unknown sRGB intent", "Ignoring incorrect cHRM value when sRGB is also present", "Missing IHDR before iCCP", "Invalid iCCP after IDAT", "Out of place iCCP chunk", "Duplicate iCCP chunk", "Malformed iCCP chunk", "Ignoring nonzero compression type in iCCP chunk", "Profile size field missing from iCCP chunk", "Ignoring iCCP chunk with declared size = @1 and actual length = @2", "No space in chunk cache for sPLT", "Missing IHDR before sPLT", "Invalid sPLT after IDAT", "malformed sPLT chunk", "sPLT chunk has bad length", "sPLT chunk too long", "sPLT chunk requires too much memory", "Missing IHDR before tRNS", "Invalid tRNS after IDAT", "Duplicate tRNS chunk", "Incorrect tRNS chunk length", "Missing PLTE before tRNS", "Zero length tRNS chunk", "tRNS chunk not allowed with alpha channel", "Missing IHDR before bKGD", "Invalid bKGD after IDAT", "Missing PLTE before bKGD", "Duplicate bKGD chunk", "Incorrect bKGD chunk length", "Incorrect bKGD chunk index value", "Missing IHDR before hIST", "Invalid hIST after IDAT", "Missing PLTE before hIST", "Duplicate hIST chunk", "Incorrect hIST chunk length", "Missing IHDR before pHYs", "Invalid pHYs after IDAT", "Duplicate pHYs chunk", "Incorrect pHYs chunk length", "Missing IHDR before oFFs", "Invalid oFFs after IDAT", "Duplicate oFFs chunk", "Incorrect oFFs chunk length", "Missing IHDR before pCAL", "Invalid pCAL after IDAT", "Duplicate pCAL chunk", "No memory for pCAL purpose", "Invalid pCAL data", "Invalid pCAL parameters for equation type", "Unrecognized equation type for pCAL chunk", "No memory for pCAL params", "Missing IHDR before sCAL", "Invalid sCAL after IDAT", "Duplicate sCAL chunk", "sCAL chunk too short", "Out of memory while processing sCAL chunk", "Invalid sCAL ignored: invalid unit", "Invalid sCAL chunk ignored: bad width format", "Invalid sCAL chunk ignored: non-positive width", "Invalid sCAL chunk ignored: bad height format", "Invalid sCAL chunk ignored: non-positive height", "Out of place tIME chunk", "Duplicate tIME chunk", "Incorrect tIME chunk length", "No space in chunk cache for tEXt", "Missing IHDR before tEXt", "No memory to process text chunk", "Not enough memory to process text chunk", "Insufficient memory to process text chunk", "No space in chunk cache for zTXt", "Missing IHDR before zTXt", "Out of memory processing zTXt chunk", "Truncated zTXt chunk", "Unknown compression type in zTXt chunk", "Not enough memory to process zTXt chunk", "Insufficient memory to store zTXt chunk", "No space in chunk cache for iTXt", "Missing IHDR before iTXt", "No memory to process iTXt chunk", "Truncated iTXt chunk", "Unknown iTXt compression type or method", "Malformed iTXt chunk", "Not enough memory to process iTXt chunk", "Insufficient memory to store iTXt chunk", "No space in chunk cache for unknown chunk", "unknown critical chunk", "error in user chunk", "invalid chunk type", "internal row logic error", "internal row size calculation error", "internal row width error", "invalid user transform pixel depth", "Decompression Error", "Not enough image data", "Extra compressed data", "Extra compression data", "Row has too many bytes to allocate in memory", "Tag ", "TIFFUnlinkDirectory", "TIFFAdvanceDirectory", "_TIFFVSetField", "Error fetching directory count", "Error fetching directory link", "Sanity check on directory count failed", "%s: Error fetching directory count", "%s: Error fetching directory link", "pseudo-", "_TIFFVGetField", "%s: Invalid %stag \"%s\" (not supported by codec)", "DotRange", "Unknown", "Nonstandard tile width %d, convert file", "Nonstandard tile length %d, convert file", "%s: Sorry, cannot nest SubIFDs", "TIFFSetField", "%s: Invalid InkNames value; expecting %d names, found %d", "%s: Failed to allocate space for list of custom values", "%s: Bad field type %d for \"%s\"", "%s: Null count for \"%s\" (type %d, writecount %d, passcount %d)", "custom tag binary object", "%s: Bad value %u for \"%s\" tag", "%s: Unknown %stag %u", "%s: Cannot modify tag \"%s\" while writing", "Can not unlink directory in read-only file", "Directory %d does not exist", "Error writing directory link", "TIFFMergeFieldInfo", "_TIFFMergeFields", "for fields array", "TRUE", "FALSE", "%s: \n", "field[%2d] %5lu, %2d, %2d, %d, %2d, %5s, %5s, %s\n", "Failed to allocate fields array", "Tag ", "_TIFFSetupFields", "Setting up field info failed", "TIFFFieldWithTag", "Internal error, unknown tag 0x%x", "TIFFFieldWithName", "Internal error, unknown tag %s", "Tag %d", "SubfileType", "OldSubfileType", "ImageWidth", "ImageLength", "BitsPerSample", "Compression", "PhotometricInterpretation", "Threshholding", "CellWidth", "CellLength", "FillOrder", "DocumentName", "ImageDescription", "Make", "Model", "StripOffsets", "Orientation", "SamplesPerPixel", "RowsPerStrip", "StripByteCounts", "MinSampleValue", "MaxSampleValue", "XResolution", "YResolution", "PlanarConfiguration", "PageName", "XPosition", "YPosition", "FreeOffsets", "FreeByteCounts", "GrayResponseUnit", "GrayResponseCurve", "ResolutionUnit", "PageNumber", "ColorResponseUnit", "TransferFunction", "Software", "DateTime", "Artist", "HostComputer", "WhitePoint", "PrimaryChromaticities", "ColorMap", "HalftoneHints", "TileWidth", "TileLength", "TileOffsets", "TileByteCounts", "SubIFD", "InkSet", "InkNames", "NumberOfInks", "DotRange", "TargetPrinter", "ExtraSamples", "SampleFormat", "SMinSampleValue", "SMaxSampleValue", "ClipPath", "XClipPathUnits", "YClipPathUnits", "YCbCrCoefficients", "YCbCrSubsampling", "YCbCrPositioning", "ReferenceBlackWhite", "XMLPacket", "Matteing", "DataType", "ImageDepth", "TileDepth", "ImageFullWidth", "ImageFullLength", "TextureFormat", "TextureWrapModes", "FieldOfViewCotangent", "MatrixWorldToScreen", "MatrixWorldToCamera", "Copyright", "RichTIFFIPTC", "Photoshop", "EXIFIFDOffset", "ICC Profile", "GPSIFDOffset", "FaxRecvParams", "FaxSubAddress", "FaxRecvTime", "FaxDcs", "StoNits", "InteroperabilityIFDOffset", "DNGVersion", "DNGBackwardVersion", "UniqueCameraModel", "LocalizedCameraModel", "CFAPlaneColor", "CFALayout", "LinearizationTable", "BlackLevelRepeatDim", "BlackLevel", "BlackLevelDeltaH", "BlackLevelDeltaV", "WhiteLevel", "DefaultScale", "BestQualityScale", "DefaultCropOrigin", "DefaultCropSize", "ColorMatrix1", "ColorMatrix2", "CameraCalibration1", "CameraCalibration2", "ReductionMatrix1", "ReductionMatrix2", "AnalogBalance", "AsShotNeutral", "AsShotWhiteXY", "BaselineExposure", "BaselineNoise", "BaselineSharpness", "BayerGreenSplit", "LinearResponseLimit", "CameraSerialNumber", "LensInfo", "ChromaBlurRadius", "AntiAliasStrength", "ShadowScale", "DNGPrivateData", "MakerNoteSafety", "CalibrationIlluminant1", "CalibrationIlluminant2", "RawDataUniqueID", "OriginalRawFileName", "OriginalRawFileData", "ActiveArea", "MaskedAreas", "AsShotICCProfile", "AsShotPreProfileMatrix", "CurrentICCProfile", "CurrentPreProfileMatrix", "PerSample", "ExposureTime", "FNumber", "ExposureProgram", "SpectralSensitivity", "ISOSpeedRatings", "OptoelectricConversionFactor", "ExifVersion", "DateTimeOriginal", "DateTimeDigitized", "ComponentsConfiguration", "CompressedBitsPerPixel", "ShutterSpeedValue", "ApertureValue", "BrightnessValue", "ExposureBiasValue", "MaxApertureValue", "SubjectDistance", "MeteringMode", "LightSource", "Flash", "FocalLength", "SubjectArea", "MakerNote", "UserComment", "SubSecTime", "SubSecTimeOriginal", "SubSecTimeDigitized", "FlashpixVersion", "ColorSpace", "PixelXDimension", "PixelYDimension", "RelatedSoundFile", "FlashEnergy", "SpatialFrequencyResponse", "FocalPlaneXResolution", "FocalPlaneYResolution", "FocalPlaneResolutionUnit", "SubjectLocation", "ExposureIndex", "SensingMethod", "FileSource", "SceneType", "CFAPattern", "CustomRendered", "ExposureMode", "WhiteBalance", "DigitalZoomRatio", "FocalLengthIn35mmFilm", "SceneCaptureType", "GainControl", "Contrast", "Saturation", "Sharpness", "DeviceSettingDescription", "SubjectDistanceRange", "ImageUniqueID", "for fields array", "TIFFFetchNormalTag", "MissingRequired", "TIFFReadDirectoryCheckOrder", "EstimateStripByteCounts", "TIFFFetchDirectory", "Incorrect count for \"%s\"", "Incompatible type for \"%s\"", "IO error during reading of \"%s\"", "Incorrect value for \"%s\"", "Cannot handle different values per sample for \"%s\"", "Sanity check on size of \"%s\" value failed", "Out of memory reading of \"%s\"", "Incorrect count for \"%s\"; tag ignored", "Incompatible type for \"%s\"; tag ignored", "IO error during reading of \"%s\"; tag ignored", "Incorrect value for \"%s\"; tag ignored", "Cannot handle different values per sample for \"%s\"; tag ignored", "Sanity check on size of \"%s\" value failed; tag ignored", "Out of memory reading of \"%s\"; tag ignored", "%s: Seek error accessing TIFF directory", "%s: Can not read TIFF directory count", "Sanity check on directory count failed, this is probably not a valid IFD offset", "to read TIFF directory", "%.100s: Can not read TIFF directory", "Can not read TIFF directory count", "Sanity check on directory count failed, zero tag directories not supported", "Can not read TIFF directory", "ReadDirEntryArray", "unknown tagname", "for strip array", "TIFFFetchNormalTag", "No definition found for tag %d", "ASCII value for tag \"%s\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations", "ASCII value for tag \"%s\" does not end in null byte", "Failed to read custom directory at offset %llu", "Invalid TIFF directory; tags are not sorted in ascending order", "Unknown field with tag %d (0x%x) encountered", "Registering anonymous field with tag %d (0x%x) failed", "Wrong data type %d for \"%s\"; tag ignored", "incorrect count for field \"%s\" (%llu, expecting %u); tag ignored", "incorrect count for field \"%s\" (%llu, expecting %u); tag trimmed", "SubjectDistance", "for \"StripByteCounts\" array", "Cannot determine size of unknown tag type %d", "tiles", "strips", "TileOffsets", "StripOffsets", "for IFD list", "Failed to read directory at offset %llu", "Compression", "Planarconfig tag value assumed incorrect, assuming data is contig instead of chunky", "TIFF directory is missing required \"%s\" field", "ImageLength", "Cannot handle zero number of %s", "Photometric tag is missing, assuming data is YCbCr", "Photometric tag value assumed incorrect, assuming data is YCbCr instead of RGB", "BitsPerSample tag is missing, assuming 8 bits per sample", "SamplesPerPixel tag is missing, assuming correct SamplesPerPixel value is 3", "SamplesPerPixel tag is missing, applying correct SamplesPerPixel value of 3", "Colormap", "StripByteCounts", "TIFF directory is missing required \"StripByteCounts\" field, calculating from imagelength", "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength", "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength", "for chopped \"StripByteCounts\" array", "for chopped \"StripOffsets\" array", "Cannot handle zero scanline size", "Cannot handle zero tile size", "Cannot handle zero strip size", "TIFFFetchStripThing", "TIFFReadDirectory", "TIFFFetchSubjectDistance", "TIFFReadCustomDirectory", "BuildMapUaToAa", "BuildMapBitdepth16To8", "Out of memory", "No space for YCbCr->RGB conversion state", "No space for photometric conversion table", "No space for B&W mapping table", "No space for Palette mapping table", "Assuming 8-bit colormap", "No space for strip buffer", "Integer overflow in %s", "gtStripSeparate", "No space for tile buffer", "gtTileSeparate", "Sorry, requested compression method is not configured", "Sorry, can not handle images with %d-bit samples", "Missing needed %s tag", "Sorry, can not handle contiguous data with %s=%d, and %s=%d and Bits/Sample=%d", "Samples/pixel", "Sorry, can not handle RGB image with %s=%d", "Color channels", "Sorry, can not handle separated image with %s=%d", "InkSet", "Sorry, LogL data must have %s=%d", "Compression", "Sorry, LogLuv data must have %s=%d or %d", "Sorry, can not handle LogLuv images with %s=%d", "Planarconfiguration", "Sorry, can not handle image with %s=%d", "Missing required \"Colormap\" tag", "Out of memory for colormap copy", "No space for CIE L*a*b*->RGB conversion state.", "Failed to initialize CIE L*a*b*->RGB conversion state.", "Sorry, can not handle image", "No \"get\" routine setup", "No \"put\" routine setupl; probably can not handle image format", "Can't use TIFFReadRGBAStrip() with tiled file.", "Row passed to TIFFReadRGBAStrip() must be first in a strip.", "Can't use TIFFReadRGBATile() with stripped file.", "Row/col passed to TIFFReadRGBATile() must be topleft corner of a tile.", "initCIELabConversion", "PhotometricInterpretation", "TIFFClientOpen", "\"%s\": Bad mode", "%s: Out of memory (TIFF structure)", "One of the client procedures is NULL pointer.", "Cannot read TIFF header", "Error writing TIFF header", "Not a TIFF or MDI file, bad magic number %d (0x%x)", "Not a TIFF file, bad version number %d (0x%x)", "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)", "Not a TIFF file, bad BigTIFF unused %d (0x%x)", "TIFFFillStrip", "TIFFReadRawTile", "TIFFFillTile", "TIFFReadRawStrip", "TIFFReadBufferSetup", "TIFFFillStripPartial", "Seek error at row %lu, col %lu, tile %lu", "Read error at row %lu, col %lu; got %llu bytes, expected %llu", "Read error at row %lu, col %lu, tile %lu; got %llu bytes, expected %llu", "Seek error at scanline %lu, strip %lu", "Read error at scanline %lu; got %llu bytes, expected %llu", "Read error at scanline %lu, strip %lu; got %llu bytes, expected %llu", "File not open for reading", "Can not read scanlines from a tiled image", "%lu: Strip out of range, max %lu", "Compression scheme does not support access to raw uncompressed data", "%llu: Invalid strip byte count, strip %lu", "Integer overflow", "Can not read tiles from a stripped image", "%lu: Tile out of range, max %lu", "No space for data buffer at scanline %lu", "%llu: Invalid tile byte count, tile %lu", "Data buffer too small to hold tile %lu", "Invalid strip byte count %llu, strip %lu", "Read error on strip %lu; got %llu bytes, expected %llu", "Data buffer too small to hold strip %lu", "%lu: Row out of range, max %lu", "%lu: Sample out of range, max %lu", "TIFFReadEncodedStrip", "TIFFReadEncodedTile", "TIFFScanlineSize64", "TIFFVStripSize64", "TIFFRasterScanlineSize64", "TIFFScanlineSize", "TIFFVStripSize", "TIFFRawStripSize64", "TIFFRawStripSize", "TIFFRasterScanlineSize", "%lu: Sample out of range, max %lu", "TIFFNumberOfStrips", "%llu: Invalid strip byte count, strip %lu", "Integer overflow", "Invalid YCbCr subsampling", "Invalid td_samplesperpixel value", "Invalid YCbCr subsampling (%dx%d)", "Integer arithmetic overflow", "TIFFStripSize", "TIFFComputeStrip", "%lu: Col out of range, max %lu", "%lu: Row out of range, max %lu", "%lu: Depth out of range, max %lu", "%lu: Sample out of range, max %lu", "TIFFNumberOfTiles", "TIFFTileRowSize", "Integer overflow", "Invalid YCbCr subsampling (%dx%d)", "TIFFVTileSize64", "TIFFVTileSize", "TIFFTileSize", "TIFFWriteScanline", "TIFFWriteBufferSetup", "TIFFWriteEncodedStrip", "TIFFWriteRawStrip", "TIFFAppendToStrip", "TIFFWriteEncodedTile", "Seek error at scanline %lu", "Maximum TIFF file size exceeded", "Write error at scanline %lu", "No space to expand strip arrays", "Can not write tiles to a stripped image", "Can not write scanlines to a tiled image", "tile", "strip", "File not open for writing", "Must set \"ImageWidth\" before writing data", "Must set \"PlanarConfiguration\" before writing data", "No space for %s arrays", "Tile %lu out of range, max %lu", "Can not grow image by strips when using separate planes", "No space for output buffer", "Can not change \"ImageLength\" when using separate planes", "%lu: Sample out of range, max %lu", "TIFFWriteRawTile", "%s: ", "Warning, ", "%s: %s", "%s: Cannot open", "TIFFOpen", "Integer overflow in %s", "Failed to allocate memory for %s (%ld elements of %ld bytes each)", "No space for \"TransferFunction\" tag", "Compression algorithm does not support random access", "%s %s decoding is not implemented", "scanline", "Compression scheme %u %s decoding is not implemented", "%s %s encoding is not implemented", "strip", "Compression scheme %u %s encoding is not implemented", "tile", "TIFFRegisterCODEC", "No space to register compression scheme %s", "TIFFUnRegisterCODEC", "Cannot remove compression scheme %s; not registered", "TIFFWriteDirectoryTagSubifd", "TIFFWriteDirectorySec", "TIFFWriteDirectoryTagCheckedRationalArray", "TIFFWriteDirectoryTagData", "TIFFWriteDirectoryTagColormap", "TIFFResetField", "TIFFWriteDirectoryTagIfdIfd8Array", "TIFFWriteDirectoryTagSampleformatArray", "TIFFWriteDirectoryTagCheckedSrationalArray", "TIFFLinkDirectory", "Maximum TIFF file size exceeded", "IO error writing tag data", "Out of memory", "Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.", "Error post-encoding before directory write", "Error flushing data before directory write", "Error writing SubIFD directory link", "Error writing TIFF header", "Error fetching directory count", "Error fetching directory link", "Error writing directory link", "Sanity check on tag count failed, likely corrupt TIFF", "IO error writing directory", "Error updating TIFF header", "Memory mapped files not currently supported for this operation.", "Attempt to reset field on directory not already on disk.", "%s: Seek error accessing TIFF directory", "%s: Can not read TIFF directory count", "%s: Can not read TIFF directory entry.", "%s: Could not find tag %d.", "for field buffer.", "Value exceeds 32bit range of output type.", "%s: Can not write TIFF directory entry.", "TIFFWriteDirectoryTagTransferfunction", "TIFFRewriteDirectory", "TIFFWriteDirectoryTagShortPerSample", "TIFFWriteDirectoryTagLongLong8Array", "%s compression support is not configured", "None", "PackBits", "ThunderScan", "NeXT", "JPEG", "Old-style JPEG", "CCITT RLE", "CCITT RLE/W", "CCITT Group 3", "CCITT Group 4", "ISO JBIG", "Deflate", "AdobeDeflate", "PixarLog", "SGILog", "SGILog24", "LZMA", "DumpModeDecode", "Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes", "Fax3DecodeRLE", "Fax3Decode1D", "Fax3Encode", "Fax3Decode2D", "Fractional scanlines cannot be written", "Bits/sample must be 1 for Group 3/4 encoding/decoding", "Row pixels integer overflow (rowpixels %u)", "for Group 3/4 run arrays", "No space for Group 3/4 reference line", "  Group 4 Options:", "%suncompressed data", "  Group 3 Options:", "%s2-d encoding", "%sEOL padding", " (%lu = 0x%lx)\n", "  Fax Data:", " clean", " receiver regenerated", " uncorrected errors", " (%u = 0x%x)\n", "  Bad Fax Lines: %lu\n", "  Consecutive Bad Fax Lines: %lu\n", "InitCCITTFax3", "Merging common CCITT Fax codec-specific tags failed", "No space for state block", "tile", "strip", "Premature EOL", "Line length mismatch", "Fractional scanlines cannot be read", "Bad code word at line %u of %s %u (x %u)", "Premature EOF at line %u of %s %u (x %u)", "%s at line %u of %s %u (got %u, expected %u)", "Uncompressed data (not supported) at line %u of %s %u (x %u)", "TIFFInitCCITTFax3", "Merging CCITT Fax 3 codec-specific tags failed", "TIFFInitCCITTFax4", "Merging CCITT Fax 4 codec-specific tags failed", "Group3Options", "FaxMode", "FaxFillFunc", "BadFaxLines", "CleanFaxData", "ConsecutiveBadFaxLines", "Group4Options", "InitCCITTFax3", "Fax4Encode", "Fax4Decode", "Fax3SetupState", "LogL16Decode", "LogLuvSetupEncode", "LogLuvInitState", "LogLuvDecode24", "TIFFInitSGILog", "Not enough data at row %lu (short %llu pixels)", "SGILog compression cannot handle non-contiguous data", "No support for converting user data format to LogLuv", "No space for SGILog translation buffer", "No support for converting user data format to LogL", "Y, L", "XYZ, Luv", "Inappropriate photometric interpretation %d for SGILog compression; %s", "must be either LogLUV or LogL", "SGILog compression supported only for %s, or raw data", "Unknown data format %d for LogLuv compression", "Unknown encoding %d for LogLuv compression", "Merging SGILog codec-specific tags failed", "%s: No space for LogLuv state block", "SGILogDataFmt", "SGILogEncode", "LogLuvSetupDecode", "LogLuvVSetField", "LogL16InitState", "LogLuvDecode32", "LZWSetupEncode", "LZWDecodeCompat", "LZWPreDecode", "LZWDecode: Strip %d not terminated with EOI code", "LZWDecode: Corrupted LZW table at scanline %d", "Corrupted LZW table at scanline %d", "Wrong length of decoded string: data probably corrupted at scanline %d", "Bogus encoding, loop in the code table; scanline %d", "Not enough data at scanline %d (short %llu bytes)", "Old-style LZW codes, convert file", "No space for LZW state block", "No space for LZW code table", "No space for LZW hash table", "LZWDecode", "LZWSetupDecode", "Fractional scanlines cannot be read", "Not enough data for scanline %ld", "NeXTDecode", "Discarding %lu bytes to avoid buffer overrun", "Not enough data for scanline %lu", "PackBitsDecode", "PixarLogVSetField", "PixarLogPreEncode", "PixarLogEncode", "PixarLogSetupEncode", "PixarLogSetupDecode", "ZLib error: %s", "%d bit input not supported in PixarLog", "ZLib cannot deal with buffers this size", "Encoder error: %s", "PixarLog compression can't handle %d bit linear encodings", "1.2.3", "Decoding error at scanline %lu, %s", "Not enough data at scanline %lu (short %llu bytes)", "stride %lu is not a multiple of sample count, %lu, data truncated.", "Unsupported bits/sample: %d", "PixarLog compression can't handle bits depth/data format combination (depth: %d)", "Merging PixarLog codec-specific tags failed", "No space for PixarLog state block", "PixarLogPreDecode", "PixarLogDecode", "TIFFInitPixarLog", "PixarLogPostEncode", "PredictorSetup", "Horizontal differencing \"Predictor\" not supported with %d-bit samples", "Floating point \"Predictor\" not supported with %d data format", "\"Predictor\" value %d not supported", "Out of memory allocating %zd byte temp buffer.", "  Predictor: ", "none ", "horizontal differencing ", "floating point predictor ", "%u (0x%x)\n", "TIFFPredictorInit", "Merging Predictor codec-specific tags failed", "Predictor", "PredictorEncodeTile", "ThunderDecodeRow", "Not enough", "Too much", "Fractional scanlines cannot be read", "%s data at scanline %lu (%llu != %llu)", "Wrong bitspersample value (%d), Thunder decoder only supports 4bits per sample.", "ZIPPostEncode", "TIFFInitZIP", "ZIPSetupDecode", "ZIPVSetField", "ZIPPreDecode", "Encoder error: %s", "ZLib error: %s", "1.2.3", "Decoding error at scanline %lu, %s", "Not enough data at scanline %lu (short %llu bytes)", "ZLib cannot deal with buffers this size", "Merging Deflate codec-specific tags failed", "No space for ZIP state block", "ZIPSetupEncode", "ZIPPreEncode", "ZIPDecode", "ZIPEncode", "JPEG-2000 JP2 File Format Syntax (ISO/IEC 15444-1)", "JPEG-2000 Code Stream Syntax (ISO/IEC 15444-1)", "prec=%d, sgnd=%d, cmpttype=%d\n", " f(%d,%d)=%ld", "error: cannot get box\n", "error: expecting signature box\n", "incorrect magic number\n", "expecting file type box\n", "box type %s\n", "error: no code stream found\n", "error: cannot decode code stream\n", "error: missing IHDR box\n", "warning: number of components mismatch\n", "error: no components\n", "warning: component data type mismatch\n", "error: unsupported compression type\n", "warning: superfluous BPCC box\n", "error: no COLR box\n", "ICC Profile CS %08x\n", "warning: missing PCLR box or superfluous CMAP box\n", "warning: missing CMAP box or superfluous PCLR box\n", "error: invalid component number in CMAP box\n", "error: invalid CMAP LUT index\n", "error: no memory\n", "channo=%d; type=%d; assoc=%d\n", "numchans = %d\n", "cmptno=%d; map=%d; pcol=%d\n", "numents=%d; numchans=%d\n", "LUT[%d][%d]=%d\n", "method=%d; pri=%d; approx=%d\n", "csid=%d\n", "JP2 box: ", "type=%c%s%c (0x%08x); length=%d\n", "warning: cannot handle large 64-bit box length\n", "cannot copy box data\n", "cannot parse box data\n", "Unknown", "FTYP", "JP2H", "IHDR", "BPCC", "COLR", "PCLR", "CMAP", "CDEF", "RESC", "RESD", "JP2C", "JP2I", "UUID", "UINF", "ULST", "%s/tmp.XXXXXXXXXX", "/tmp/", "%08x:", " %02x", "warning: ignoring unknown marker segment\n", "jpc_dec_decodecblks failed\n", "warning: possibly corrupt code stream\n", "write component failed\n", "invalid component number in QCC marker segment\n", "invalid component number in RGN marker segment\n", "invalid component number in COC marker segment\n", "warning: ignoring invalid option %s\n", "cannot get marker segment\n", "unexpected marker segment type\n", "RESOLUTION LEVEL %d\n", "xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\n", "BAND %d\n", "CODE BLOCK GROUP %d\n", "CODE BLOCK %d\n", "jpc_dec_decodepkts failed\n", "warning: ignoring trailing garbage (%lu bytes)\n", "read error\n", "warning: not enough tile data (%lu bytes)\n", "invalid tile number in SOT marker segment\n", "maxlyrs", "maxpkts", "debug", "cannot write SOC marker\n", "cannot write SIZ marker\n", "Creator: JasPer Version %s", "cannot write COM marker\n", "cannot write COD marker\n", "start=%d end=%d type=%d term=%d lyrno=%d firstchar=%02x size=%ld pos=%ld\n", "lyrno = %02d\n", "lyrno=%02d cmptno=%02d rlvlno=%02d bandno=%02d prcno=%02d cblkno=%03d passno=%03d\n", "min rdslope = %f max rdslope = %f\n", "maxlen=%08ld actuallen=%08ld thresh=%f\n", "warning: empty layer generated\n", "success %d goodthresh %f\n", "  tcmpt %5d %5d %5d %5d\n", "    rlvl %5d %5d %5d %5d\n", "      band %5d %5d %5d %5d\n", "        prc %5d %5d %5d %5d (%5d %5d)\n", "         cblk %5d %5d %5d %5d\n", "unsupported image type\n", "ignoring invalid mode %s\n", "ignoring invalid progression order %s\n", "ignoring bad rate specifier %s\n", "warning: invalid intermediate layer rates specifier ignored (%s)\n", "warning: ignoring invalid option %s\n", "warning: overriding imgareatlx value\n", "warning: overriding imgareatly value\n", "warning: color space apparently not RGB\n", "invalid tile width %lu\n", "invalid tile height %lu\n", "invalid tile grid offset (%lu, %lu)\n", "cannot use real mode for lossless coding\n", "invalid precinct width\n", "invalid precinct height\n", "invalid code block width %d\n", "invalid code block height %d\n", "code block size too large\n", "too many layers\n", "must be at least one resolution level\n", "invalid number of guard bits\n", "warning: specified rate is unreasonably large (%lu > %lu)\n", "intermediate layer rates must increase monotonically\n", "warning: intermediate layer rates must be less than overall rate\n", "error: too few guard bits (need at least %d)\n", "cannot open tmp file\n", "cannot write SOT marker\n", "cannot write SOD marker\n", "dotile failed\n", "cannot write EOI marker\n", "invalid JP encoder options\n", "real", "lrcp", "rlcp", "rpcl", "pcrl", "cprl", "debug", "imgareatlx", "imgareatly", "tilegrdtlx", "tilegrdtly", "tilewidth", "tileheight", "prcwidth", "prcheight", "cblkwidth", "cblkheight", "mode", "nomct", "numrlvls", "lazy", "termall", "segsym", "vcausal", "pterm", "resetprob", "numgbits", "rate", "ilyrrates", "_jp2overhead", "1.900.1", "%s\n_jp2overhead=%lu\n", "%d %d", "%d %d\n", "%s%4ld", "%02x ", "hoff[%d] = %d; voff[%d] = %d\n", "seqno = %d;\n", "po[%d] = %d; ", "cs[%d] = %d; ce[%d] = %d; ", "rs[%d] = %d; re[%d] = %d; ", "le[%d] = %d\n", "compno = %d; qntsty = %d; numguard = %d; numstepsizes = %d\n", "expn[%d] = 0x%04x; mant[%d] = 0x%04x;\n", "qntsty = %d; numguard = %d; numstepsizes = %d\n", "compno = %d; roisty = %d; roishift = %d\n", "compno = %d; csty = 0x%02x; numdlvls = %d;\n", "cblkwidthval = %d; cblkheightval = %d; cblksty = 0x%02x; qmfbid = %d;\n", "caps = 0x%02x;\n", "width = %d; height = %d; xoff = %d; yoff = %d;\n", "tilewidth = %d; tileheight = %d; tilexoff = %d; tileyoff = %d;\n", "prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; vsamp[%d] = %d\n", "tileno = %d; len = %d; partno = %d; numparts = %d\n", "csty = 0x%02x;\n", "numdlvls = %d; qmfbid = %d; mctrans = %d\n", "prg = %d; numlyrs = %d;\n", "cblkwidthval = %d; cblkheightval = %d; cblksty = 0x%02x;\n", "prcwidth[%d] = %d, prcheight[%d] = %d\n", "regid = %d;\n", "data = ", "ind=%d; len = %d;\n", "data =\n", "type = 0x%04x (%s);", " len = %d;", "warning: trailing garbage in marker segment (%ld bytes)\n", "UNKNOWN", "warning: corrupt code stream\n", "warning: bad segmentation symbol\n", "coding pass failed passtype=%d segtype=%d\n", "warning: bad termination pattern detected\n", "%04x:", " %02x", "warning: stopping decode prematurely as requested\n", "packet offset=%08ld prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n", "missing SOP marker segment\n", "alignment failed\n", "hdrlen=%lu bodylen=%lu \n", "cannot get (EPH) marker segment\n", "missing EPH marker segment\n", "packet body offset=%06ld\n", "string = \"%s\"\n", "ascii = \"%s\"\n", "uclangcode = %d; uclen = %d\n", "sccode = %d\n", "maclen = %d\n", "(%f, %f, %f)\n", "number of entires = %d\n", "gamma = %f\n", "entry[%d] = %f\n", "numinchans=%d, numoutchans=%d, clutlen=%d\n", "e[%d][%d]=%f ", "numintabents=%d, numouttabents=%d\n", "cannot get header\n", "cannot get tab table\n", "refcnt = %d; type = 0x%08x %s\n", "numattrs=%d\n", "---\n", "attrno=%d; attrname=\"%s\"(0x%08x); attrtype=\"%s\"(0x%08x)\n", "node %p, parent %p, value %d, lower %d, known %d\n", "AREG = %08x, CREG = %08x, CTREG = %d\n", "IND = %02d, MPS = %d, QEVAL = %04x\n", "MQDEC A = %08lx, C = %08lx, CT=%08lx, ", "CTX = %d, ", "IND %d, MPS %d, QEVAL %x\n", "N3Iex7TypeExcE", "N3Imf14TypedAttributeINS_9LineOrderEEE", "N3Imf14TypedAttributeIN5Imath4Vec2IfEEEE", "N3Imf14TypedAttributeIfEE", "N3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IiEEEEEE", "N3Imf14TypedAttributeINS_11ChannelListEEE", "N3Iex6ArgExcE", "N3Imf14TypedAttributeINS_15TileDescriptionEEE", "N3Imf14TypedAttributeINS_12PreviewImageEEE", "N3Iex8InputExcE", "N3Imf14TypedAttributeIN5Imath4Vec3IiEEEE", "N3Imf14TypedAttributeIN5Imath4Vec3IfEEEE", "N3Imf14TypedAttributeIN5Imath4Vec3IdEEEE", "N3Imf14TypedAttributeIN5Imath4Vec2IiEEEE", "N3Imf14TypedAttributeIN5Imath4Vec2IdEEEE", "N3Imf14TypedAttributeINS_8TimeCodeEEE", "N3Imf14TypedAttributeISt6vectorISsSaISsEEEE", "N3Imf14TypedAttributeISsEE", "N3Imf14TypedAttributeINS_8RationalEEE", "N3Imf14TypedAttributeIN5Imath8Matrix44IfEEEE", "N3Imf14TypedAttributeIN5Imath8Matrix44IdEEEE", "N3Imf14TypedAttributeIN5Imath8Matrix33IfEEEE", "N3Imf14TypedAttributeIN5Imath8Matrix33IdEEEE", "N3Imf14TypedAttributeINS_7KeyCodeEEE", "N3Imf14TypedAttributeIiEE", "N3Imf14TypedAttributeINS_6EnvmapEEE", "N3Imf14TypedAttributeIdEE", "N3Imf14TypedAttributeINS_14ChromaticitiesEEE", "N3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IfEEEEEE", "Unexpected attribute type.", "preview", "Invalid ", ": it is more than ", " characters long.", "Cannot find image attribute \"", "displayWindow", "dataWindow", "pixelAspectRatio", "screenWindowCenter", "screenWindowWidth", "channels", "lineOrder", "compression", "tiles", "Invalid display window in image header.", "Invalid data window in image header.", "The width of the data window exceeds the maximum width of ", "pixels.", "Invalid pixel aspect ratio in image header.", "Invalid screen window width in image header.", "Tiled image has no tile description attribute.", "Invalid tile size in image header.", "The width of the tiles exceeds the maximum width of ", "Invalid level mode in image header.", "Invalid level rounding mode in image header.", "Invalid line order in image header.", "Unknown compression type in image header.", "Pixel type of \"", "\" image channel is invalid.", "The x subsampling factor for the \"", "\" channel is not 1.", "The y subsampling factor for the \"", "\" channel is invalid.", "The minimum x coordinate of the image's data window is not a multiple of the x subsampling factor of the \"", "\" channel.", "The minimum y coordinate of the image's data window is not a multiple of the y subsampling factor of the \"", "Number of pixels per row in the image's data window is not a multiple of the x subsampling factor of the \"", "Number of pixels per column in the image's data window is not a multiple of the y subsampling factor of the \"", "File is not an image file.", "Cannot read version ", " image files.  Current file format version is ", "The file format version number's flag field contains unrecognized flags.", "attribute name", "attribute type name", "Unexpected type for image attribute \"", "Image attribute name cannot be an empty string.", "Cannot assign a value of type \"", "\" to image attribute \"", "\" of type \"", "timecode", "N3Imf15OpaqueAttributeE", "Cannot copy the value of an image file attribute of type \"", "\" to an attribute of type \"", "compression", "stringvector", "Unexpected attribute type.", "chromaticities", "whiteLuminance", "adoptedNeutral", "renderingTransform", "lookModTransform", "xDensity", "owner", "comments", "capDate", "utcOffset", "longitude", "latitude", "altitude", "focus", "expTime", "aperture", "isoSpeed", "envmap", "keyCode", "timeCode", "wrapmodes", "framesPerSecond", "multiView", "worldToCamera", "worldToNDC", "N3Iex7MathExcE", "N5Imath13SingMatrixExcE", "double", "N3Iex11OverflowExcE", "N3Imf10CompressorE", "Integer multiplication overflow.", "box2i", "box2f", "Cannot set hours field in time code. New value is out of range.", "Cannot set minutes field in time code. New value is out of range.", "Cannot set seconds field in time code. New value is out of range.", "Cannot set frame field in time code. New value is out of range.", "Cannot extract binary group from time code user data.  Group number is out of range.", "Error decompressing data (input data are shorter than expected).", "Integer multiplication overflow.", "Integer addition overflow.", "Error decompressing data (input data are longer than expected).", "N3Imf13B44CompressorE", "tiledesc", "N3Iex5IoExcE", "N3Iex8LogicExcE", "N3Imf10OutputFileE", "N3Imf10OutputFile4DataE", "*N3Imf12_GLOBAL__N_114LineBufferTaskE", "Cannot determine current file position (%T).", "unrecognized exception", "No frame buffer specified as pixel data source.", "Tried to write more scan lines than specified by the data window.", "Failed to write pixel data to image file \"", "tiles", "Cannot copy pixels from image file \"", "\" to image file \"", "\". The input file is tiled, but the output file is not. Try using TiledOutputFile::copyPixels instead.", "\". The files have different data windows.", "Quick pixel copy from image file \"", "\" failed. The files have different line orders.", "\" failed. The files use different compression methods.", "\" failed.  The files have different channel lists.", "\" failed. \"", "\" already contains pixel data.", "Cannot update preview image pixels. File \"", "\" does not contain a preview image.", "preview", "Unexpected attribute type.", "Cannot update preview image pixels for file \"", "Cannot overwrite scan line ", ". The scan line has not yet been stored in file \"", "vector::_M_fill_insert", "Cannot open image file \"", "Pixel type of \"", "\" channel of output file \"", "\" is not compatible with the frame buffer's pixel type.", "X and/or y subsampling factors of \"", "\" are not compatible with the frame buffer's subsampling factors.", "chromaticities", "chlist", "Invalid ", "channel name", ": it is more than ", " characters long.", "N3Imf9AttributeE", "Cannot register image file attribute type \"", "\". The type has already been registered.", "Cannot create image file attribute of unknown type \"", "N3Imf9InputFileE", "N3Imf9InputFile4DataE", "Cannot read image file \"", "Tried to read scan line outside the image file's data window.", "Tried to read a raw scanline from a tiled image.", "Error reading pixel data from image file \"", "Tried to read a raw tile from a scanline-based image.", "Error reading tile data from image file \"", "Cannot get a TiledInputFile pointer from an InputFile that is not tiled.", "Unknown pixel data type.", "Error decompressing data (input data are shorter than expected).", "Integer addition overflow.", "Integer multiplication overflow.", "Data compression (zlib) failed.", "Data decompression (zlib) failed.", "Error decompressing data (input data are longer than expected).", "N3Imf15Pxr24CompressorE", "lineOrder", "Invalid key code film manufacturer code (must be between 0 and 99).", "Invalid key code film type (must be between 0 and 99).", "Invalid key code prefix (must be between 0 and 999999).", "Invalid key code count (must be between 0 and 9999).", "Invalid key code perforation offset (must be between 0 and 119).", "Invalid key code number of perforations per frame (must be between 1 and 15).", "Invalid key code number of perforations per count (must be between 20 and 120).", "keycode", "Cannot find image channel \"", "basic_string::erase", "Image channel name cannot be an empty string.", "float", "Data compression (zlib) failed.", "Data decompression (zlib) failed.", "Integer addition overflow.", "Integer multiplication overflow.", "N3Imf13ZipCompressorE", "preview", "N3Iex8ErrnoExcE", "N3Imf11StdOFStreamE", "N3Imf11StdOSStreamE", "Early end of file: read ", " out of ", " requested bytes.", "Unexpected end of file.", "File output failed.", "(string)", "N3Imf11StdIFStreamE", "Cannot find frame buffer slice \"", "Frame buffer slice name cannot be an empty string.", "m33f", "m33d", "m44f", "m44d", "Integer multiplication overflow.", "N3Iex9EdquotExcE", "N3Iex12EcanceledExcE", "N3Iex12EremoteioExcE", "N3Iex9EisnamExcE", "N3Iex10EnavailExcE", "N3Iex10EnotnamExcE", "N3Iex10EucleanExcE", "N3Iex9EstaleExcE", "N3Iex14EinprogressExcE", "N3Iex11EalreadyExcE", "N3Iex15EhostunreachExcE", "N3Iex12EhostdownExcE", "N3Iex15EconnrefusedExcE", "N3Iex12EtimedoutExcE", "N3Iex15EtoomanyrefsExcE", "N3Iex12EshutdownExcE", "N3Iex11EnotconnExcE", "N3Iex10EisconnExcE", "N3Iex10EnobufsExcE", "N3Iex13EconnresetExcE", "N3Iex15EconnabortedExcE", "N3Iex12EnetresetExcE", "N3Iex14EnetunreachExcE", "N3Iex11EnetdownExcE", "N3Iex16EaddrnotavailExcE", "N3Iex13EaddrinuseExcE", "N3Iex15EafnosupportExcE", "N3Iex15EpfnosupportExcE", "N3Iex13EopnotsuppExcE", "N3Iex18EsocktnosupportExcE", "N3Iex18EprotonosupportExcE", "N3Iex14EnoprotooptExcE", "N3Iex13EprototypeExcE", "N3Iex11EmsgsizeExcE", "N3Iex15EdestaddrreqExcE", "N3Iex11EnotsockExcE", "N3Iex9EusersExcE", "N3Iex12EnotemptyExcE", "N3Iex11EstrpipeExcE", "N3Iex11ErestartExcE", "N3Iex8EloopExcE", "N3Iex9EnosysExcE", "N3Iex9EilseqExcE", "N3Iex11ElibexecExcE", "N3Iex10ElibmaxExcE", "N3Iex10ElibscnExcE", "N3Iex10ElibbadExcE", "N3Iex10ElibaccExcE", "N3Iex10EremchgExcE", "N3Iex9EbadfdExcE", "N3Iex11EnotuniqExcE", "N3Iex12EoverflowExcE", "N3Iex15EnametoolongExcE", "N3Iex10EbadmsgExcE", "N3Iex12EmultihopExcE", "N3Iex9EprotoExcE", "N3Iex8EcommExcE", "N3Iex9EsrmntExcE", "N3Iex7EadvExcE", "N3Iex10EnolinkExcE", "N3Iex10EremoteExcE", "N3Iex9EnopkgExcE", "N3Iex9EnonetExcE", "N3Iex8EnosrExcE", "N3Iex8EtimeExcE", "N3Iex10EnodataExcE", "N3Iex9EnostrExcE", "N3Iex9EbfontExcE", "N3Iex10EbadsltExcE", "N3Iex10EbadrqcExcE", "N3Iex9EnoanoExcE", "N3Iex9ExfullExcE", "N3Iex8EbadrExcE", "N3Iex8EbadeExcE", "N3Iex9EnolckExcE", "N3Iex10EdeadlkExcE", "N3Iex9El2hltExcE", "N3Iex10EunatchExcE", "N3Iex9ElnrngExcE", "N3Iex9El3rstExcE", "N3Iex9El3hltExcE", "N3Iex11El2nsyncExcE", "N3Iex9EchrngExcE", "N3Iex8EidrmExcE", "N3Iex9EnomsgExcE", "N3Iex9ErangeExcE", "N3Iex7EdomExcE", "N3Iex8EpipeExcE", "N3Iex9EmlinkExcE", "N3Iex8ErofsExcE", "N3Iex9EspipeExcE", "N3Iex9EnospcExcE", "N3Iex8EfbigExcE", "N3Iex10EtxtbsyExcE", "N3Iex9EnottyExcE", "N3Iex9EmfileExcE", "N3Iex9EnfileExcE", "N3Iex9EinvalExcE", "N3Iex9EisdirExcE", "N3Iex10EnotdirExcE", "N3Iex9EnodevExcE", "N3Iex8ExdevExcE", "N3Iex9EexistExcE", "N3Iex8EbusyExcE", "N3Iex10EnotblkExcE", "N3Iex9EfaultExcE", "N3Iex9EaccesExcE", "N3Iex9EnomemExcE", "N3Iex9EagainExcE", "N3Iex9EchildExcE", "N3Iex8EbadfExcE", "N3Iex10EnoexecExcE", "N3Iex8E2bigExcE", "N3Iex8EnxioExcE", "N3Iex6EioExcE", "N3Iex8EintrExcE", "N3Iex8EsrchExcE", "N3Iex9EnoentExcE", "N3Iex8EpermExcE", "N3Iex7BaseExcE", "N9IlmThread9SemaphoreE", "Cannot initialize semaphore (%T).", "Post operation on semaphore failed (%T).", "Cannot read semaphore value (%T).", "N9IlmThread5MutexE", "Cannot initialize mutex (%T).", "Cannot lock mutex (%T).", "Cannot unlock mutex (%T).", "N9IlmThread4TaskE", "*N9IlmThread12_GLOBAL__N_112WorkerThreadE", "Attempt to set the number of threads in a thread pool to a negative value.", "N9IlmThread10ThreadPoolE", "N9IlmThread6ThreadE", "Cannot create new thread (%T).", "rational", "envmap", "N3Imf7OStreamE", "Attempt to perform a memory-mapped read on a file that is not memory mapped.", "N3Imf7IStreamE", "string", "Unknown pixel type.", "Unknown pixel data type.", "vector::_M_fill_insert", "*N3Imf12_GLOBAL__N_114LineBufferTaskE", "unrecognized exception", "Scan line ", " is missing.", "Unexpected data block y coordinate.", "Unexpected data block length.", "No frame buffer specified as pixel data destination.", "Tried to read scan line outside the image file's data window.", "Error reading pixel data from image file \"", "vector::_M_fill_insert", "X and/or y subsampling factors of \"", "\" channel of input file \"", "\" are not compatible with the frame buffer's subsampling factors.", "N3Imf17ScanLineInputFile4DataE", "N3Imf17ScanLineInputFileE", "N3Imf13PizCompressorE", "Integer multiplication overflow.", "Integer addition overflow.", "Error in header for PIZ-compressed data (invalid bitmap size).", "N3Imf14TiledInputFileE", "*N3Imf12_GLOBAL__N_114TileBufferTaskE", "N3Imf14TiledInputFile4DataE", "unrecognized exception", "Error calling numLevels() on image file \"", "\" (numLevels() is not defined for files with RIPMAP level mode).", "Error calling levelWidth() on image file \"", "Error calling levelHeight() on image file \"", "Error calling numXTiles() on image file \"", "\" (Argument is not in valid range).", "Error calling numYTiles() on image file \"", "Error calling dataWindowForLevel() on image file \"", "Arguments not in valid range.", "Error calling dataWindowForTile() on image file \"", "Tried to read a tile outside the image file's data window.", "Unexpected tile block length.", "Error reading pixel data from image file \"", "No frame buffer specified as pixel data destination.", "Tile (", ") is not a valid tile.", ") is missing.", "Unexpected tile x coordinate.", "Unexpected tile y coordinate.", "Unexpected tile x level number coordinate.", "Unexpected tile y level number coordinate.", "vector::_M_fill_insert", "X and/or y subsampling factors of \"", "\" channel of input file \"", "\" are not compatible with the frame buffer's subsampling factors.", "Expected a tiled file but the file is not tiled.", "Cannot open image file \"", "Data decoding (rle) failed.", "Integer multiplication overflow.", "N3Imf13RleCompressorE", "Cannot determine current file position (%T).", "Unknown LevelMode format.", "vector::_M_fill_insert", "Error in Huffman-encoded data (decoded data are shorter than expected).", "Error in Huffman-encoded data (unexpected end of code table data).", "Error in Huffman-encoded data (code table is longer than expected).", "Error in Huffman-encoded data (invalid code table entry).", "Error in Huffman-encoded data (decoded data are longer than expected).", "Error in Huffman-encoded data (invalid code).", "Error in Huffman-encoded data (invalid code table size).", "Error in header for Huffman-encoded data (invalid number of bits).", "Argument not in valid range.", "Unknown LevelMode format.", "OpenCV::camera", "CameraActivity::onFrameBuffer - empty callback", "CameraWrapperConnector::setProperty error: wrong pointer to camera object", "CameraWrapperConnector::getProperty error: wrong pointer to camera object", "calling (*pGetPropertyC)(%p, %d)", "CameraWrapperConnector::applyProperties error: wrong pointer to camera object", "CameraWrapperConnector::getSymbolFromLib ERROR: cannot get symbol of the function '%s' from the camera wrapper library, dlerror=\"%s\"", "org.opencv.lib_v24_armv7a", "org.opencv.engine", "/data/data/%s/lib/", "Trying package \"%s\" (\"%s\")", "Package not found", "Library name: %s", "Library base address: %p", "/proc/self/smaps", "Strange error: could not find path beginning in lin \"%s\"", "Libraries folder found: %s", "Could not find library path", "Could not read /proc/self/smaps", "Could not get library name and base address", "libnative_camera", "||%s", "Trying to find native camera in default OpenCV packages", "CameraWrapperConnector::connectToLib: folderPath=%s", "try to load library '%s'", "Loaded library '%s'", "CameraWrapperConnector::connectToLib ERROR: cannot dlopen camera wrapper library %s, dlerror=\"%s\"", "initCameraConnectC", "closeCameraConnectC", "getCameraPropertyC", "setCameraPropertyC", "applyCameraPropertiesC", "CameraWrapperConnector::connectToLib ERROR: cannot dlopen camera wrapper library", "CameraWrapperConnector::disconnect error: wrong pointer to camera object", "CameraWrapperConnector::connect error: wrong pointer to CameraActivity object", "CameraWrapperConnector::connectWrapper ERROR: the initializing function returned false", "14CameraActivity", "St10ctype_base", "St5ctypeIcE", "St5ctypeIwE", "St8ios_base", "NSt8ios_base7failureE", "N9__gnu_cxx24__concurrence_lock_errorE", "N9__gnu_cxx26__concurrence_unlock_errorE", "NSt6locale5facetE", "__gnu_cxx::__concurrence_lock_error", "__gnu_cxx::__concurrence_unlock_error", "locale::_S_normalize_category category not found", "locale::_Impl::_M_replace_facet", "St13runtime_error", "St12out_of_range", "St11logic_error", "St12length_error", "*N12_GLOBAL__N_122generic_error_categoryE", "St14error_category", "*N12_GLOBAL__N_121system_error_categoryE", "generic", "system", "POSIX", "space", "print", "cntrl", "upper", "lower", "alpha", "digit", "punct", "xdigit", "alnum", "graph", "true", "false", "locale::facet::_S_create_c_locale name not valid", "LC_CTYPE", "LC_NUMERIC", "LC_TIME", "LC_COLLATE", "LC_MONETARY", "LC_MESSAGES", "St14basic_ifstreamIcSt11char_traitsIcEE", "St13basic_fstreamIcSt11char_traitsIcEE", "St13basic_filebufIcSt11char_traitsIcEE", "St14basic_ofstreamIcSt11char_traitsIcEE", "basic_filebuf::xsgetn error reading the file", "basic_filebuf::underflow codecvt::max_length() is not valid", "basic_filebuf::underflow incomplete character in file", "basic_filebuf::underflow invalid byte sequence in file", "basic_filebuf::underflow error reading the file", "basic_filebuf::_M_convert_to_external conversion error", "St9basic_iosIwSt11char_traitsIwEE", "St9basic_iosIcSt11char_traitsIcEE", "basic_ios::clear", "St13basic_istreamIwSt11char_traitsIwEE", "St9time_base", "St12codecvt_base", "St13messages_base", "St10money_base", "St7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St9money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St16__numpunct_cacheIcE", "St11__timepunctIcE", "St9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St18__moneypunct_cacheIcLb1EE", "St7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St8messagesIcE", "St8numpunctIcE", "St10moneypunctIcLb0EE", "St8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St7collateIcE", "St10moneypunctIcLb1EE", "St18__moneypunct_cacheIcLb0EE", "St17__timepunct_cacheIcE", "POSIX", "basic_string::erase", "%.*Lf", "%m/%d/%y", "%H:%M", "%H:%M:%S", "St23__codecvt_abstract_baseIcc9mbstate_tE", "N9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE", "N9__gnu_cxx18stdio_sync_filebufIcSt11char_traitsIcEEE", "St13basic_ostreamIwSt11char_traitsIwEE", "St19basic_ostringstreamIcSt11char_traitsIcESaIcEE", "St18basic_stringstreamIcSt11char_traitsIcESaIcEE", "St15basic_stringbufIcSt11char_traitsIcESaIcEE", "St15basic_streambufIwSt11char_traitsIwEE", "St15basic_streambufIcSt11char_traitsIcEE", "basic_string::at", "basic_string::copy", "basic_string::compare", "basic_string::_S_create", "basic_string::assign", "basic_string::_M_replace_aux", "basic_string::replace", "basic_string::insert", "basic_string::erase", "basic_string::append", "basic_string::resize", "basic_string::_S_construct null not valid", "basic_string::basic_string", "basic_string::substr", "St10moneypunctIwLb0EE", "St10moneypunctIwLb1EE", "POSIX", "basic_string::erase", "%.*Lf", "%m/%d/%y", "%H:%M", "%H:%M:%S", "St18__moneypunct_cacheIwLb0EE", "St9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7collateIwE", "St17__timepunct_cacheIwE", "St7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St18__moneypunct_cacheIwLb1EE", "St23__codecvt_abstract_baseIwc9mbstate_tE", "St8messagesIwE", "St16__numpunct_cacheIwE", "St21__ctype_abstract_baseIwE", "St11__timepunctIwE", "St8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St8numpunctIwE", "St8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "basic_string::at", "basic_string::copy", "basic_string::compare", "basic_string::_S_create", "basic_string::assign", "basic_string::_M_replace_aux", "basic_string::replace", "basic_string::insert", "basic_string::erase", "basic_string::append", "basic_string::resize", "basic_string::_S_construct null not valid", "basic_string::basic_string", "basic_string::substr", "std::bad_alloc", "St9bad_alloc", "St8bad_cast", "std::bad_cast", "std::bad_typeid", "St10bad_typeid", "N10__cxxabiv117__class_type_infoE", "N10__cxxabiv115__forced_unwindE", "N10__cxxabiv119__foreign_exceptionE", "std::exception", "std::bad_exception", "St9exception", "St13bad_exception", "N10__cxxabiv116__enum_type_infoE", "PKDs", "PKDi", "PKDf", "PKDd", "PKDe", "PKDn", "N10__cxxabiv123__fundamental_type_infoE", "N9__gnu_cxx24__concurrence_wait_errorE", "N9__gnu_cxx29__concurrence_broadcast_errorE", "__gnu_cxx::__concurrence_lock_error", "__gnu_cxx::__concurrence_unlock_error", "__gnu_cxx::__concurrence_broadcast_error", "__gnu_cxx::__concurrence_wait_error", "N10__cxxabiv119__pointer_type_infoE", "pure virtual method called\n", "N10__cxxabiv120__si_class_type_infoE", "St9type_info", "N10__cxxabiv121__vmi_class_type_infoE", "St7codecvtIwc9mbstate_tE", "St7codecvtIcc9mbstate_tE", "-+xX0123456789abcdefABCDEF", "-0123456789", "AKST", "%m/%d/%y", "%H:%M:%S", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "January", "February", "March", "April", "June", "July", "August", "September", "October", "November", "December", "N10__cxxabiv117__pbase_type_infoE", "terminate called recursively\n", "terminate called after throwing an instance of '", "terminate called without an active exception\n", "  what():  ", "_GLOBAL_", "(anonymous namespace)", "string literal", "JArray", "vtable for ", "VTT for ", "construction vtable for ", "-in-", "typeinfo for ", "typeinfo name for ", "typeinfo fn for ", "non-virtual thunk to ", "virtual thunk to ", "covariant return thunk to ", "java Class for ", "guard variable for ", "reference temporary for ", "hidden alias for ", "_Sat ", "_Accum", "_Fract", "operator", "operator ", "false", "true", "java resource ", "decltype (", "{parm#", "global constructors keyed to ", "global destructors keyed to ", "{lambda(", "{unnamed type#", " [clone ", " restrict", " volatile", " const", "complex ", "imaginary ", " __vector(", "{default arg#", "signed char", "bool", "boolean", "char", "byte", "double", "long double", "float", "__float128", "unsigned char", "unsigned int", "unsigned", "long", "unsigned long", "__int128", "unsigned __int128", "short", "unsigned short", "void", "wchar_t", "long long", "unsigned long long", "decimal32", "decimal64", "decimal128", "half", "char16_t", "char32_t", "decltype(nullptr)", "std::allocator", "allocator", "std::basic_string", "basic_string", "std::string", "std::basic_string<char, std::char_traits<char>, std::allocator<char> >", "std::istream", "std::basic_istream<char, std::char_traits<char> >", "basic_istream", "std::ostream", "std::basic_ostream<char, std::char_traits<char> >", "basic_ostream", "std::iostream", "std::basic_iostream<char, std::char_traits<char> >", "basic_iostream", "delete[]", "delete", "new[]", "sizeof ", "alignof "], "stringidentifiers": ["std::exception", "cv::Exception", "vector::_M_insert_aux", "vector::reserve", "std::exception", "cv::Exception", "pixels", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "Dynamic", "Pyramid", "Grid", "FAST", "STAR", "SIFT", "SURF", "MSER", "GFTT", "HARRIS", "SimpleBlob", "Dense", "BRISK", "FlannBased", "BruteForce", "Opponent", "BRIEF", "FREAK", "ONEWAY", "FERN", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "std::exception", "cv::Exception", "integer", "short", "boolean", "double", "string", "cv::Mat", "algorithm", "float", "name", "vector::_M_fill_insert", "N2cv9AlgorithmE", "N2cv16TLSDataContainerE", "N2cv9ExceptionE", "OPENCV_TEMP_PATH", "status", "error", "Backtrace", "vector::_M_fill_insert", "cxcore", "basic_string::substr", "N2cv11FileStorageE", "ucwsifdr", "unnamed", "ucwsifdr", "width", "height", "origin", "layout", "interleaved", "data", "sizes", "rows", "cols", "flags", "vertex_dt", "edge_dt", "vertex_count", "edge_count", "oriented", "header_dt", "header_user_data", "vertices", "edges", "count", "curve", "closed", "hole", "untyped", "rect", "color", "type_id", "apos", "quot", "float", "sequences", "level", "vector::_M_insert_aux", "planar", "recursive", "false", "False", "FALSE", "opencv_storage", "N2cv16BatchDistInvokerE", "N2cv17MatOp_InitializerE", "N2cv11MatOp_AddExE", "N2cv11MatOp_SolveE", "N2cv5MatOpE", "N2cv9MatOp_BinE", "N2cv9MatOp_CmpE", "N2cv12MatOp_InvertE", "N2cv10MatOp_GEMME", "N2cv7MatOp_TE", "N2cv14MatOp_IdentityE", "MXVNTMRMPNOPOSPURVTVVU", "PTRMRV", "NUSMSTRVPVOTOS", "MXRMPNOPOSPURVSVUUVSVPUNSMRM", "MWUNSMQMONOOPPTRUSUUSVQVOU", "MXOMOSPURVSVUUVSVM", "MXOVQVOROPPNRMSMUNVPVRTVVV", "LXVPUNTMRMPNOONQNSOUPVRVTUUT", "LXVPUNTMRMPNOONQNSOUPVRVTUUSRS", "PUTMQV", "OVUMSSRUQVPVOUOT", "LXRMPNOONQNSOUPVRVTUUTVRVPUNTMRM", "MWVNTMRMPNPPQQTRUSUUSVPVNU", "LXPMNSNUOVRVTUUSWM", "MWQMWMNVTV", "MWNLVX", "MWNVVV", "PVRMUQ", "MWMMOKQKTMVMWK", "MWUQSPRPPQOSPURVSVUU", "MWOSUSTQRPPQOSPURVTV", "MWRPPQOSPURVTUUSTQRP", "NWUQTPQPPQPRQSTSUTUUTVQVPU", "MWOPUPOVUV", "MXVPUSTURVPUOSPQRPTQUUVV", "MWOTQVSVTUTSSRPQRQTPUOUNTMRMQNPPOTNY", "MWTNSMRMQNQORPTQUSTURVPUOSPQRP", "LXNQOPPPQQQURVSVTUUSVPVNUMTMSNSPTRUSWT", "OVRPQSQURVSVTU", "MWOSPURVTUUSTQRPPQOSNY", "MXVPRPPQOSPURVTUUSTQRP", "KXMQNPOPPQPUQVSVTUUSVP", "MXPPOQOSPURVSVUUVSVQUPTPSQRSQY", "MWQMOSPURVTUUSTQRPPQOS", "MWUQSPRPPQOSPURVTV", "MWOSTSURUQSPRPPQOSPURVTV", "OTSMQSQURVSV", "NVTQSPQPPQPRQSRSSTSURVPVOU", "MWNPOPPQPROTOUPVRVTUURUP", "MWUSTQRPPQOSPURVTUUSUPTNRMQM", "MWUQSPQPOQOSPTRUSVSWRXQX", "MWUNORUV", "MWONUROV", "OUTKQKQYTY", "OUPKSKSYPY", "OUTKSLRNROSQQRSSRURVSXTY", "OUPKQLRNROQQSRQSRURVQXPY", "MWRMPNOPOSPURVTUUSUPTNRM", "MWPORMRV", "MWONQMSMUNUPTROVUV", "MWTMRMPNOPOSPURVTUUSTQRPPQOS", "MWUPTRRSPROPPNRMTNUPUSTURVPV", "PURURVSVSURU", "PUSVRVRUSUSWRY", "PTRMRQ", "NVQMPNPPQQSQTPTNSMQM", "MWVLNX", "OUTKRNQQQSRVTY", "OUPKRNSQSSRVPY", "PTRKRY", "LXNRVR", "PURQRRSRSQRQ", "PUSMRORQSQSPRP", "PUSNRNRMSMSORQ", "LXVRURTSSURVOVNUNSORRQSPSNRMPMONOPQSSUUVVV", "LYRQQPOPNQNSOTQTRSSQTPVPWQWSVTTTSSRQ", "NVRFRM", "KYQFOGNINKOMQNSNUMVKVIUGSFQF", "NVRBRb", "MWRQQRRSSRRQ", "MWSFRGQIQKRLSKRJ", "MWRHQGRFSGSIRKQL", "MWWRWQVOUNSMQMONNOMQMR", "MWMRMSNUOVQWSWUVVUWSWR", "LXLPNRQSSSVRXP", "RURUTTURTPRO", "RVRRUPVNVLUKTK", "NRRROPNNNLOKPK", "KYKRYR", "MWMWWM", "MWMMWW", "KYRJYNKVRZ", "JZJRNKVYZR", "KYKVKNYVYN", "JZLXJPZTXL", "KYQKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK", "LXLLLXXXXLLL", "KYRJKVYVRJ", "JZRIPOJOOSMYRUWYUSZOTORI", "LXPLPPLPLTPTPXTXTTXTXPTPTLPL", "QSRQQRRSSRRQ", "PTQPPQPSQTSTTSTQSPQP", "NVQNOONQNSOUQVSVUUVSVQUOSNQN", "MWQMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM", "NVRVQWRXSWRV", "MWQKPLPNQOSOTNTLSKQK", "NVRQQRRSSRRQ", "JZWLMRWX", "JZMLWRMX", "NVSLRMQLRKSLSNQP", "NVSKQMQORPSORNQO", "NVQLRMSLRKQLQNSP", "NVQKSMSORPQORNSO", "JZWMQMONNOMQMSNUOVQWWW", "JZMMMSNUOVQWSWUVVUWSWM", "JZMMSMUNVOWQWSVUUVSWMW", "JZMWMQNOONQMSMUNVOWQWW", "KYUBNRUb", "KYOBVROb", "MWRHSGRFQGQIRKSL", "MWQFRGSISKRLQKRJ", "MXVFTHSJSKTLUKTJ", "MXUHTGUFVGVHUJSL", "KZSFQGPIPKQMSNUNWMXKXIWGUFSF", "N2cv9FormatterE", "N2cv12CSVFormatterE", "N2cv14NumpyFormatterE", "N2cv15PythonFormatterE", "N2cv15MatlabFormatterE", "PYTHON", "NUMPY", "MATLAB", "uint8", "int8", "uint16", "int16", "int32", "float32", "float64", "uint64", "basic_string::erase", "false", "true", "GRAY", "BGRA", "N2cv16ParallelLoopBodyE", "vector::reserve", "vector::_M_insert_aux", "vector::_M_insert_aux", "vector::_M_fill_insert", "N2cv22KMeansDistanceComputerE", "N2cv24KMeansPPDistanceComputerE", "N2cv11_InputArrayE", "N2cv12_OutputArrayE", "ranges", "vector::_M_fill_insert", "N7cvflann7anyimpl12bad_any_castE", "N7cvflann17flann_algorithm_tE", "N7cvflann5IndexINS_11HammingLUT2EEE", "N7cvflann7NNIndexINS_11HammingLUT2EEE", "N7cvflann21RadiusUniqueResultSetIiEE", "N7cvflann15UniqueResultSetIiEE", "N7cvflann9ResultSetIiEE", "N7cvflann18KNNUniqueResultSetIiEE", "N7cvflann14FLANNExceptionE", "N7cvflann8LshIndexINS_11HammingLUT2EEE", "N7cvflann27HierarchicalClusteringIndexINS_11HammingLUT2EEE", "N7cvflann20flann_centers_init_tE", "N7cvflann5IndexINS_2L2IfEEEE", "N7cvflann7NNIndexINS_2L2IfEEEE", "N7cvflann21RadiusUniqueResultSetIfEE", "N7cvflann15UniqueResultSetIfEE", "N7cvflann9ResultSetIfEE", "N7cvflann18KNNUniqueResultSetIfEE", "N7cvflann11LinearIndexINS_2L2IfEEEE", "N7cvflann17KDTreeSingleIndexINS_2L2IfEEEE", "N7cvflann18KNNSimpleResultSetIfEE", "N7cvflann11KDTreeIndexINS_2L2IfEEEE", "N7cvflann11KMeansIndexINS_2L2IfEEEE", "N7cvflann14CompositeIndexINS_2L2IfEEEE", "N7cvflann14AutotunedIndexINS_2L2IfEEEE", "N7cvflann12KNNResultSetIfEE", "N7cvflann27HierarchicalClusteringIndexINS_2L2IfEEEE", "N7cvflann8LshIndexINS_2L2IfEEEE", "N7cvflann5IndexINS_2L1IfEEEE", "N7cvflann7NNIndexINS_2L1IfEEEE", "N7cvflann11LinearIndexINS_2L1IfEEEE", "N7cvflann17KDTreeSingleIndexINS_2L1IfEEEE", "N7cvflann11KDTreeIndexINS_2L1IfEEEE", "N7cvflann11KMeansIndexINS_2L1IfEEEE", "N7cvflann14CompositeIndexINS_2L1IfEEEE", "N7cvflann14AutotunedIndexINS_2L1IfEEEE", "N7cvflann27HierarchicalClusteringIndexINS_2L1IfEEEE", "N7cvflann8LshIndexINS_2L1IfEEEE", "N7cvflann7anyimpl16small_any_policyIPPNS_11KDTreeIndexINS_2L2IfEEE4NodeEEE", "N7cvflann7anyimpl21typed_base_any_policyIPPNS_11KDTreeIndexINS_2L2IfEEE4NodeEEE", "PPN7cvflann11KDTreeIndexINS_2L2IfEEE4NodeE", "PN7cvflann11KDTreeIndexINS_2L2IfEEE4NodeE", "N7cvflann11KDTreeIndexINS_2L2IfEEE4NodeE", "N7cvflann7anyimpl14big_any_policyIdEE", "N7cvflann7anyimpl21typed_base_any_policyIdEE", "N7cvflann7anyimpl14big_any_policyISsEE", "N7cvflann7anyimpl21typed_base_any_policyISsEE", "N7cvflann7anyimpl16small_any_policyIjEE", "N7cvflann7anyimpl21typed_base_any_policyIjEE", "N7cvflann7anyimpl14big_any_policyINS_20flann_centers_init_tEEE", "N7cvflann7anyimpl21typed_base_any_policyINS_20flann_centers_init_tEEE", "N7cvflann7anyimpl14big_any_policyINS_17flann_algorithm_tEEE", "N7cvflann7anyimpl21typed_base_any_policyINS_17flann_algorithm_tEEE", "N7cvflann7anyimpl16small_any_policyIbEE", "N7cvflann7anyimpl21typed_base_any_policyIbEE", "N7cvflann7anyimpl16small_any_policyIfEE", "N7cvflann7anyimpl21typed_base_any_policyIfEE", "N7cvflann7anyimpl16small_any_policyIiEE", "N7cvflann7anyimpl21typed_base_any_policyIiEE", "N7cvflann7anyimpl16small_any_policyIPKcEE", "N7cvflann7anyimpl21typed_base_any_policyIPKcEE", "N7cvflann7anyimpl14big_any_policyINS0_9empty_anyEEE", "N7cvflann7anyimpl21typed_base_any_policyINS0_9empty_anyEEE", "N7cvflann7anyimpl9empty_anyE", "N7cvflann7anyimpl15base_any_policyE", "N7cvflann7anyimpl16small_any_policyIPPNS_11KDTreeIndexINS_2L1IfEEE4NodeEEE", "PPN7cvflann11KDTreeIndexINS_2L1IfEEE4NodeE", "PN7cvflann11KDTreeIndexINS_2L1IfEEE4NodeE", "N7cvflann11KDTreeIndexINS_2L1IfEEE4NodeE", "N7cvflann7anyimpl21typed_base_any_policyIPPNS_11KDTreeIndexINS_2L1IfEEE4NodeEEE", "FLANN_INDEX", "vector::_M_insert_aux", "vector::_M_fill_insert", "algorithm", "checks", "sorted", "filename", "table_number", "key_size", "multi_probe_level", "branching", "centers_init", "trees", "leaf_size", "iterations", "cb_index", "target_precision", "build_weight", "memory_weight", "sample_fraction", "leaf_max_size", "reorder", "vector::reserve", "N2cv5flann5IndexE", "N2cv18ResizeArea_InvokerIddEE", "N2cv22resizeAreaFast_InvokerIddNS_19ResizeAreaFastNoVecIddEEEE", "N2cv22resizeAreaFast_InvokerIffNS_19ResizeAreaFastNoVecIffEEEE", "N2cv22resizeAreaFast_InvokerIsfNS_17ResizeAreaFastVecIsEEEE", "N2cv22resizeAreaFast_InvokerItfNS_17ResizeAreaFastVecItEEEE", "N2cv22resizeAreaFast_InvokerIhiNS_17ResizeAreaFastVecIhEEEE", "N2cv18ResizeArea_InvokerIffEE", "N2cv18ResizeArea_InvokerIsfEE", "N2cv18ResizeArea_InvokerItfEE", "N2cv18ResizeArea_InvokerIhfEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIddfEENS_12VResizeCubicIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIfffEENS_12VResizeCubicIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIsffEENS_12VResizeCubicIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicItffEENS_12VResizeCubicItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_12HResizeCubicIhisEENS_12VResizeCubicIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IddfEENS_15VResizeLanczos4IddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IfffEENS_15VResizeLanczos4IfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IsffEENS_15VResizeLanczos4IsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4ItffEENS_15VResizeLanczos4ItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_15HResizeLanczos4IhisEENS_15VResizeLanczos4IhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIddfLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIddfNS_4CastIddEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIfffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIfffNS_4CastIffEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIsffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearIsffNS_4CastIfsEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearItffLi1ENS_12HResizeNoVecEEENS_13VResizeLinearItffNS_4CastIftEENS_12VResizeNoVecEEEEE", "N2cv21resizeGeneric_InvokerINS_13HResizeLinearIhisLi2048ENS_12HResizeNoVecEEENS_13VResizeLinearIhisNS_11FixedPtCastIihLi22EEENS_12VResizeNoVecEEEEE", "N2cv15resizeNNInvokerE", "N2cv12RemapInvokerE", "N2cv17warpAffineInvokerE", "N2cv22warpPerspectiveInvokerE", "vector::_M_fill_insert", "N2cv16GeneralizedHoughE", "vector::reserve", "vector::_M_fill_insert", "minDist", "levels", "votesThreshold", "minScale", "maxScale", "scaleStep", "minAngle", "maxAngle", "angleStep", "maxSize", "angleEpsilon", "angleThresh", "scaleThresh", "posThresh", "N2cv6RowSumIddEE", "N2cv6RowSumIfdEE", "N2cv6RowSumIsdEE", "N2cv6RowSumIiiEE", "N2cv6RowSumIsiEE", "N2cv6RowSumItdEE", "N2cv6RowSumItiEE", "N2cv6RowSumIhdEE", "N2cv6RowSumIhiEE", "N2cv9ColumnSumIddEE", "N2cv9ColumnSumIidEE", "N2cv9ColumnSumIdfEE", "N2cv9ColumnSumIifEE", "N2cv9ColumnSumIiiEE", "N2cv9ColumnSumIdsEE", "N2cv9ColumnSumIisEE", "N2cv9ColumnSumIdtEE", "N2cv9ColumnSumIitEE", "N2cv9ColumnSumIdhEE", "N2cv9ColumnSumIihEE", "N2cv26BilateralFilter_8u_InvokerE", "N2cv27BilateralFilter_32f_InvokerE", "N2cv34adaptiveBilateralFilter_8u_InvokerE", "vector::_M_fill_insert", "vector::_M_fill_insert", "N2cv14MorphRowFilterINS_5MaxOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MaxOpIhEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIdEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIfEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIsEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpItEENS_13MorphRowNoVecEEE", "N2cv14MorphRowFilterINS_5MinOpIhEENS_13MorphRowNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MaxOpIhEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIdEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIfEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIsEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpItEENS_16MorphColumnNoVecEEE", "N2cv17MorphColumnFilterINS_5MinOpIhEENS_16MorphColumnNoVecEEE", "N2cv11MorphFilterINS_5MinOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MinOpIdEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIhEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpItEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIsEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIfEENS_10MorphNoVecEEE", "N2cv11MorphFilterINS_5MaxOpIdEENS_10MorphNoVecEEE", "N2cv16MorphologyRunnerE", "vector::_M_fill_insert", "N2cv12DTRowInvokerE", "N2cv15DTColumnInvokerE", "vector::reserve", "vector::_M_insert_aux", "vector::_M_fill_insert", "type", "is_uniform", "have_ranges", "bins", "thresh", "vector::_M_fill_insert", "N2cv5CLAHEE", "CLAHE", "clipLimit", "tilesX", "tilesY", "N2cv15ThresholdRunnerE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_7RGB2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_10RGB2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_10RGB5x52RGBEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIhEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayItEEEE", "N2cv20CvtColorLoop_InvokerINS_8RGB2GrayIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB5x52GrayEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIhEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBItEEEE", "N2cv20CvtColorLoop_InvokerINS_8Gray2RGBIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11Gray2RGB5x5EEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11RGB2YCrCb_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_11YCrCb2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2XYZ_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iIhEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_iItEEEE", "N2cv20CvtColorLoop_InvokerINS_9XYZ2RGB_fIfEEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HSV_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2HLS_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HSV2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9HLS2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Lab_fEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_bEEE", "N2cv20CvtColorLoop_InvokerINS_9RGB2Luv_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9Lab2RGB_fEEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_bEEE", "N2cv20CvtColorLoop_InvokerINS_9Luv2RGB_fEEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi0ELi1EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi0EEE", "N2cv22YUV420sp2RGB888InvokerILi2ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi0ELi1EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi0EEE", "N2cv24YUV420sp2RGBA8888InvokerILi2ELi1EEE", "N2cv21YUV420p2RGB888InvokerILi0EEE", "N2cv21YUV420p2RGB888InvokerILi2EEE", "N2cv23YUV420p2RGBA8888InvokerILi0EEE", "N2cv23YUV420p2RGBA8888InvokerILi2EEE", "N2cv22RGB888toYUV420pInvokerILi0EEE", "N2cv22RGB888toYUV420pInvokerILi2EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi0ELi1ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi0ELi1EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi0EEE", "N2cv21YUV422toRGB888InvokerILi2ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi0ELi1ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi0ELi1EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi0EEE", "N2cv23YUV422toRGBA8888InvokerILi2ELi1ELi1EEE", "N2cv20CvtColorLoop_InvokerINS_10RGBA2mRGBAIhEEEE", "N2cv20CvtColorLoop_InvokerINS_10mRGBA2RGBAIhEEEE", "vector::_M_fill_insert", "N2cv9RowFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIhiNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv18SymmRowSmallFilterIffNS_17SymmRowSmallNoVecEEE", "N2cv9RowFilterIhiNS_8RowNoVecEEE", "N2cv9RowFilterIhfNS_8RowNoVecEEE", "N2cv9RowFilterIhdNS_8RowNoVecEEE", "N2cv9RowFilterItfNS_8RowNoVecEEE", "N2cv9RowFilterItdNS_8RowNoVecEEE", "N2cv9RowFilterIsfNS_8RowNoVecEEE", "N2cv9RowFilterIsdNS_8RowNoVecEEE", "N2cv9RowFilterIffNS_8RowNoVecEEE", "N2cv9RowFilterIfdNS_8RowNoVecEEE", "N2cv9RowFilterIddNS_8RowNoVecEEE", "N2cv12ColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv21SymmColumnSmallFilterINS_13FixedPtCastExIihEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIisEENS_20SymmColumnSmallNoVecEEE", "N2cv12ColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv21SymmColumnSmallFilterINS_4CastIffEENS_20SymmColumnSmallNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdhEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIftEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdtEENS_11ColumnNoVecEEE", "N2cv12ColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIisEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIfsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIdsEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIffEENS_11ColumnNoVecEEE", "N2cv16SymmColumnFilterINS_4CastIddEENS_11ColumnNoVecEEE", "N2cv8Filter2DIhNS_4CastIfhEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIhNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIftEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DItNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIfsEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIsNS_4CastIddEENS_11FilterNoVecEEE", "N2cv8Filter2DIfNS_4CastIffEENS_11FilterNoVecEEE", "N2cv8Filter2DIdNS_4CastIddEENS_11FilterNoVecEEE", "vector::_M_fill_insert", "N2cv10BaseFilterE", "N2cv13BaseRowFilterE", "N2cv16BaseColumnFilterE", "N2cv12FilterEngineE", "vector::_M_fill_insert", "N2cv11VideoWriterE", "vector::_M_fill_insert", "code", "cvNamedWindow", "cvDestroyWindow", "cvDestroyAllWindows", "cvShowImage", "cvResizeWindow", "cvMoveWindow", "cvCreateTrackbar", "cvCreateTrackbar2", "cvSetMouseCallback", "cvGetTrackbarPos", "cvSetTrackbarPos", "cvSetTrackbarMax", "cvGetWindowHandle", "cvGetWindowName", "cvWaitKey", "cvInitSystem", "cvStartWindowThread", "cvAddText", "cvDisplayStatusBar", "cvStartLoop", "cvStopLoop", "cvSaveWindowParameters", "cvCreateButton", "OpenCV::camera", "yuv420sp", "yvu420sp", "N2cv10BmpDecoderE", "N2cv10BmpEncoderE", "N2cv11JpegEncoderE", "N2cv11JpegDecoderE", "vector::_M_fill_insert", "N2cv10PxMEncoderE", "N2cv10PxMDecoderE", "N2cv10PngEncoderE", "N2cv10PngDecoderE", "decoder", "vector::_M_fill_insert", "N2cv16BaseImageEncoderE", "N2cv16BaseImageDecoderE", "N2cv11TiffEncoderE", "N2cv11TiffDecoderE", "N2cv16SunRasterDecoderE", "N2cv16SunRasterEncoderE", "N2cv13Jpeg2KDecoderE", "N2cv13Jpeg2KEncoderE", "N2cv10ExrEncoderE", "N2cv10ExrDecoderE", "N2cv12WMByteStreamE", "N2cv11RBaseStreamE", "N2cv11WBaseStreamE", "N2cv12RLByteStreamE", "N2cv12WLByteStreamE", "vector::_M_fill_insert", "N2cv12RMByteStreamE", "thresholdStep", "minThreshold", "maxThreshold", "minRepeatability", "minDistBetweenBlobs", "filterByColor", "blobColor", "filterByArea", "minArea", "maxArea", "filterByCircularity", "minCircularity", "maxCircularity", "filterByInertia", "minInertiaRatio", "maxInertiaRatio", "filterByConvexity", "minConvexity", "maxConvexity", "N2cv18SimpleBlobDetectorE", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_fill_insert", "N2cv15AdjusterAdapterE", "SURF", "hessianThreshold", "FAST", "STAR", "N2cv29DynamicAdaptedFeatureDetectorE", "N2cv12StarAdjusterE", "N2cv12FastAdjusterE", "N2cv12SurfAdjusterE", "N2cv23VectorDescriptorMatcherE", "N2cv17DescriptorMatcherE", "N2cv17FlannBasedMatcherE", "N2cv17DescriptorMatcher20DescriptorCollectionE", "N2cv9BFMatcherE", "N2cv24GenericDescriptorMatcherE", "indexParams", "name", "type", "value", "typename", "searchParams", "vector::reserve", "FlannBased", "BruteForce", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_range_insert", "N2cv19DescriptorExtractorE", "vector::reserve", "Opponent", "basic_string::substr", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_range_insert", "N2cv32OpponentColorDescriptorExtractorE", "N2cv26GridAdaptedFeatureDetectorE", "vector::reserve", "Grid", "basic_string::substr", "Pyramid", "Dynamic", "HARRIS", "GFTT", "useHarrisDetector", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_range_insert", "N2cv15FeatureDetectorE", "N2cv29PyramidAdaptedFeatureDetectorE", "N2cv16BOWKMeansTrainerE", "vector::_M_fill_insert", "N2cv10BOWTrainerE", "N2cv25BOWImgDescriptorExtractorE", "N2cv5FREAKE", "bitset::set", "N2cv24BriefDescriptorExtractorE", "descriptorSize", "vector::reserve", "vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv9Feature2DE", "N2cv3ORBE", "vector::reserve", "vector::_M_insert_aux", "vector::_M_range_insert", "vector::_M_fill_insert", "N2cv20FastFeatureDetector2E", "N2cv19FastFeatureDetectorE", "N2cv12GFTTDetectorE", "threshold", "nonmaxSuppression", "type", "maxSize", "responseThreshold", "lineThresholdProjected", "lineThresholdBinarized", "suppressNonmaxSize", "delta", "minArea", "maxArea", "maxVariation", "minDiversity", "maxEvolution", "areaThreshold", "minMargin", "edgeBlurSize", "nfeatures", "qualityLevel", "minDistance", "useHarrisDetector", "initFeatureScale", "featureScaleLevels", "featureScaleMul", "initXyStep", "initImgBound", "varyXyStepWithScale", "varyImgBoundWithScale", "thres", "octaves", "bytes", "nFeatures", "scaleFactor", "nLevels", "firstLevel", "edgeThreshold", "patchSize", "WTA_K", "scoreType", "orientationNormalized", "scaleNormalized", "patternScale", "nbOctave", "thresholdStep", "minThreshold", "maxThreshold", "minRepeatability", "minDistBetweenBlobs", "filterByColor", "blobColor", "filterByArea", "filterByCircularity", "maxCircularity", "filterByInertia", "maxInertiaRatio", "filterByConvexity", "maxConvexity", "normType", "crossCheck", "detector", "maxTotalKeypoints", "gridRows", "gridCols", "N2cv4MSERE", "N2cv20DenseFeatureDetectorE", "N2cv12StarDetectorE", "N2cv5BRISKE", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_range_check", "vector::reserve", "vector::_M_insert_aux", "vector::_M_range_check", "vector::_M_fill_insert", "cvCheckChessboard", "N2cv10StereoSGBME", "vector::_M_fill_insert", "vector::_M_range_insert", "N2cv24FindStereoCorrespInvokerE", "N2cv17Affine3DEstimatorE", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::_M_insert_aux", "vector::_M_fill_insert", "CvStatModel::read", "CvStatModel::write", "my_stat_model", "layer_sizes", "input_scale", "output_scale", "inv_output_scale", "weights", "SIGMOID_SYM", "IDENTITY", "GAUSSIAN", "activation_function", "f_param1", "f_param2", "min_val", "max_val", "min_val1", "max_val1", "training_params", "train_method", "BACKPROP", "dw_scale", "moment_scale", "RPROP", "dw_plus", "dw_minus", "dw_min", "dw_max", "term_criteria", "epsilon", "iterations", "my_nn", "N2cv25ForestTreeBestSplitFinderE", "nclasses", "nsamples", "nactive_vars", "oob_error", "var_importance", "ntrees", "trees", "my_random_trees", "vector::_M_fill_insert", "var_count", "var_all", "var_idx", "cls_labels", "count", "productsum", "inv_eigen_values", "cov_rotate_mats", "my_nb", "N2cv2EME", "vector::_M_fill_insert", "means", "probs", "AbsoluteLoss", "SquaredLoss", "HuberLoss", "DevianceLoss", "loss_function", "ensemble_length", "shrinkage", "subsample_portion", "class_labels", "base_value", "class_count", "trees_", "my_boost_tree", "vector::_M_fill_insert", "best_tree_idx", "nodes", "depth", "sample_count", "value", "norm_class_idx", "complexity", "alpha", "node_risk", "tree_risk", "tree_error", "splits", "is_classifier", "var_all", "var_count", "ord_var_count", "cat_var_count", "training_params", "use_surrogates", "max_categories", "regression_accuracy", "max_depth", "min_sample_count", "cross_validation_folds", "use_1se_rule", "truncate_pruned_tree", "priors", "var_idx", "var_type", "cat_count", "cat_map", "not_in", "quality", "my_tree", "vector::_M_fill_insert", "N2cv20DTreeBestSplitFinderE", "var_all", "var_count", "class_count", "class_labels", "class_weights", "var_idx", "sv_total", "support_vectors", "decision_functions", "sv_count", "alpha", "index", "NU_SVC", "C_SVC", "ONE_CLASS", "EPS_SVR", "NU_SVR", "POLY", "LINEAR", "SIGMOID", "svm_type", "kernel", "type", "degree", "gamma", "coef0", "term_criteria", "epsilon", "iterations", "CvSVM::train", "CvSVM::train_auto", "CvSVM::get_default_grid", "my_svm", "optimize_linear", "trees", "RealAdaboost", "DiscreteAdaboost", "LogitBoost", "GentleAdaboost", "Gini", "Default", "Misclassification", "SquaredErr", "boosting_type", "splitting_criteria", "ntrees", "weight_trimming_rate", "my_boost_tree", "vector::_M_fill_insert", "nclusters", "covMatType", "maxIters", "epsilon", "weights", "means", "covs", "CvKNearest::train", "vector::_M_fill_insert", "N2cv17LatentSvmDetectorE", "vector::reserve", "basic_string::substr", "N2cv24CascadeClassifierInvokerE", "N2cv16FeatureEvaluatorE", "N2cv17CascadeClassifierE", "N2cv12LBPEvaluatorE", "N2cv12HOGEvaluatorE", "N2cv13HaarEvaluatorE", "rects", "tilted", "rect", "vector::reserve", "vector::_M_insert_aux", "vector::_M_fill_insert", "vector::_M_range_insert", "stageType", "BOOST", "featureType", "HAAR", "width", "height", "stageParams", "maxDepth", "featureParams", "maxCatCount", "stages", "stageThreshold", "weakClassifiers", "internalNodes", "leafValues", "features", "N2cv38HaarDetectObjects_ScaleCascade_InvokerE", "N2cv36HaarDetectObjects_ScaleImage_InvokerE", "size", "stages", "trees", "feature", "rects", "left_node", "left_val", "right_node", "right_val", "stage_threshold", "parent", "next", "tilted", "threshold", "vector::_M_insert_aux", "vector::_M_fill_insert", "N2cv10HOGInvokerE", "N2cv14HOGConfInvokerE", "N2cv13HOGDescriptorE", "N2cv8HOGCacheE", "readALTModel", "winSize", "blockSize", "blockStride", "cellSize", "nbins", "derivAperture", "winSigma", "histogramNormType", "L2HysThreshold", "gammaCorrection", "nlevels", "SVMDetector", "vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv7linemod8ModalityE", "N2cv7linemod16QuantizedPyramidE", "DepthNormal", "N2cv7linemod11DepthNormalE", "N2cv7linemod13ColorGradientE", "N2cv7linemod20ColorGradientPyramidE", "N2cv7linemod18DepthNormalPyramidE", "ColorGradient", "type", "distance_threshold", "difference_threshold", "num_features", "extract_threshold", "weak_threshold", "strong_threshold", "width", "height", "pyramid_level", "features", "ColorGradient", "DepthNormal", "pyramid_levels", "modalities", "class_id", "template_pyramids", "template_id", "templates", "vector::_M_insert_aux", "vector::_M_fill_insert", "vector::_M_range_insert", "N2cv11MOG2InvokerE", "N2cv24BackgroundSubtractorMOG2E", "vector::_M_fill_insert", "N2cv23BackgroundSubtractorGMGE", "history", "nmixtures", "backgroundRatio", "noiseSigma", "varThreshold", "detectShadows", "varThresholdGen", "fVarInit", "fVarMin", "fVarMax", "nShadowDetection", "fTau", "maxFeatures", "learningRate", "initializationFrames", "quantizationLevels", "backgroundPrior", "smoothingRadius", "decisionThreshold", "updateBackgroundModel", "N2cv6detail16LKTrackerInvokerE", "N2cv20BackgroundSubtractorE", "N2cv23BackgroundSubtractorMOGE", "N2cv16DenseOpticalFlowE", "lambda", "theta", "nscales", "warps", "epsilon", "iterations", "useInitialFlow", "vector::_M_fill_insert", "vector::_M_fill_insert", "num_components", "eigenvalues", "eigenvectors", "N2cv8colormap6AutumnE", "N2cv8colormap8ColorMapE", "N2cv8colormap3JetE", "N2cv8colormap4BoneE", "N2cv8colormap4CoolE", "N2cv8colormap3HotE", "N2cv8colormap3HSVE", "N2cv8colormap5OceanE", "N2cv8colormap4PinkE", "N2cv8colormap7RainbowE", "N2cv8colormap6SpringE", "N2cv8colormap6SummerE", "N2cv8colormap6WinterE", "N2cv9StereoVarE", "vector::_M_insert_aux", "vector::_M_range_insert", "N2cv14TemplateBufferIfEE", "St8valarrayIfE", "N2cv17BasicRetinaFilter24Parallel_localAdaptationE", "N2cv17BasicRetinaFilter40Parallel_horizontalCausalFilter_addInputE", "N2cv17BasicRetinaFilter35Parallel_horizontalAnticausalFilterE", "N2cv17BasicRetinaFilter29Parallel_verticalCausalFilterE", "N2cv17BasicRetinaFilter42Parallel_verticalAnticausalFilter_multGainE", "N2cv17BasicRetinaFilter45Parallel_horizontalAnticausalFilter_IrregularE", "N2cv17BasicRetinaFilter39Parallel_verticalCausalFilter_IrregularE", "N22CvAdaptiveSkinDetector9HistogramE", "N2cv17BasicRetinaFilterE", "N2cv21ImageLogPolProjectionE", "means", "vector::_M_fill_insert", "vector::reserve", "vector::_M_insert_aux", "N2cv17MagnoRetinaFilter31Parallel_amacrineCellsComputingE", "N2cv17MagnoRetinaFilterE", "OPLandIPLparvo", "colorMode", "normaliseOutput", "photoreceptorsLocalAdaptationSensitivity", "photoreceptorsTemporalConstant", "photoreceptorsSpatialConstant", "horizontalCellsGain", "hcellsTemporalConstant", "hcellsSpatialConstant", "ganglionCellsSensitivity", "IPLmagno", "parasolCells_beta", "parasolCells_tau", "parasolCells_k", "amacrinCellsTemporalCutFrequency", "V0CompressionParameter", "localAdaptintegration_tau", "localAdaptintegration_k", "Retina::setup", "Retina::run", "N2cv6RetinaE", "N2cv17SelfSimDescriptorE", "vector::_M_fill_insert", "vector::_M_fill_insert", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "hessianThreshold", "nOctaves", "N2cv3of211ChowLiuTreeE", "N2cv15FaceRecognizer2E", "N2cv14FaceRecognizerE", "N2cv4LBPHE", "N2cv11FisherfacesE", "N2cv10EigenfacesE", "label", "value", "num_components", "mean", "eigenvalues", "eigenvectors", "projections", "labels", "labelsInfo", "radius", "neighbors", "grid_x", "grid_y", "histograms", "ncomponents", "threshold", "OBJECT_DETECTOR", "vector::_M_fill_insert", "N21DetectionBasedTracker21SeparateDetectionWorkE", "N2cv6Mesh3D18EmptyMeshExceptionE", "Shape", "vector::reserve", "vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv3of29FabMapFBOE", "N2cv3of29FabMapLUTE", "N2cv3of27FabMap1E", "N2cv3of27FabMap2E", "N2cv3of26FabMapE", "vector::_M_insert_aux", "vector::_M_range_insert", "vector::_M_fill_insert", "N2cv17ParvoRetinaFilter31Parallel_OPL_OnOffWaysComputingE", "N2cv17ParvoRetinaFilterE", "N2cv11RetinaColor48Parallel_adaptiveHorizontalCausalFilter_addInputE", "N2cv11RetinaColor50Parallel_adaptiveVerticalAnticausalFilter_multGainE", "N2cv11RetinaColorE", "vector::_M_fill_insert", "N2cv3of213BOWMSCTrainerE", "N2cv13LevMarqSparseE", "N2cv6OctreeE", "vector::_M_fill_insert", "N2cv14ChamferMatcher13ImageIteratorE", "N2cv14ChamferMatcher10ImageRangeE", "N2cv14ChamferMatcher26LocationScaleImageIteratorE", "N2cv14ChamferMatcher21LocationImageIteratorE", "N2cv14ChamferMatcher23SlidingWindowImageRangeE", "templ", "vector::_M_insert_aux", "vector::_M_fill_insert", "vector::_M_range_insert", "vector::_M_range_check", "N2cv14ChamferMatcher26SlidingWindowImageIteratorE", "vector::_M_fill_insert", "N2cv14FernClassifierE", "N2cv21FernDescriptorMatcherE", "N2cv20PlanarObjectDetectorE", "nclasses", "patchSize", "signatureSize", "nstructs", "structSize", "nviews", "compressionMethod", "features", "posteriors", "radius", "threshold", "noctaves", "detector", "vector::_M_fill_insert", "vector::reserve", "vector::_M_insert_aux", "BlobTrackPostOne", "TimeAver", "Video", "VideoObj", "noise_gaussian", "noise_normal", "noise_uniform", "noise_speckle", "noise_salt_and_pepper", "Size", "auto", "File", "Trans", "Shift", "Mask", "FrameBegin", "FrameNum", "LastFrame", "frame", "NoiseAmp", "ffffi", "BlobDetector", "Simple", "Latency", "HMin", "WMin", "MinDistToBorder", "Clastering", "ROIScale", "OnlyROI", "vector::reserve", "vector::_M_insert_aux", "FGWeight", "Alpha", "MSFGS", "ffffi", "Collision", "BGImageUsing", "List", "affine_poses", "pca_components_number", "patch_width", "patch_height", "poseCount", "patchWidth", "patchHeight", "minScale", "maxScale", "stepScale", "pyrLevels", "pcaDimHigh", "pcaDimLow", "eigenvectors", "SURF", "hessianThreshold", "vector::_M_fill_insert", "N2cv23OneWayDescriptorMatcherE", "N2cv20OneWayDescriptorBaseE", "N2cv22OneWayDescriptorObjectE", "NearestBlob", "AverFG", "ConfidenceType", "ffffi", "Collision", "AlphaSize", "AlphaPos", "Alpha", "hessianThreshold", "nOctaves", "nOctaveLayers", "upright", "extended", "ffffi", "BlobTrackGen", "Gen1", "cvRandSetRange", "cvRandInit", "cvRand", "cvStartScanGraph", "cvEndScanGraph", "nclusters", "weights", "means", "vector::_M_fill_insert", "covs", "BlobTrackAnalysis", "HIST", "ffffi", "FrameBegin", "VideoObj", "Size", "BlobTrackGen", "BlobTrackPostOne", "ModelNoise", "DataNoisePos", "DataNoiseSize", "Kalman", "BlobTrackPredictor", "ffffi", "DebugWnd", "unknown", "FGDetector", "BlobTracker", "BlobList", "FrameCount", "NextBlobID", "FGDetector", "BlobTracker", "PostProcessing", "BlobDeleter", "BlobTrackerUpdate", "BlobDetector", "TrajectoryGeneration", "TrackAnalysis", "BlobTrackerAuto", "ffffi", "TimesFile", "BlobTrackerReal", "Auto1", "vector::_M_fill_insert", "vector::reserve", "vector::_M_insert_aux", "BlobNum", "BlobList", "Blob", "ffffi", "BlobPredict", "BlobPrev", "BlobHyp", "Collision", "Predictor", "Resolver", "DataNoisePos", "AlphaSize", "CCCR", "MSPF", "SizeVar", "abnormal", "BlobNum", "BlobList", "Blob", "ffffi", "LastFrame", "State", "Hist", "BlobTrackFVGen", "BlobTrackAnalysis", "AbnormalThreshold", "SmoothRadius", "SmoothKernel", "BinNum", "Blob", "ffffi", "Collision", "HistVolume", "Hist", "ParticleNum", "ParticlesPredicted", "ffffiffd", "ParticlesResampled", "FGWeight", "Alpha", "IterNum", "MSFG", "UseVel", "SizeVar", "PosVar", "MSPF", "abnormal", "BlobTrackAnalysis", "ffffi", "DebugAVI", "TraceLen", "AbnormalThreshold", "PosThreshold", "VelThreshold", "TrackDist", "BlobTrackAnalysis", "ffffi", "List", "BlobTrackPostProc", "ffffi", "List", "vector::reserve", "vector::_M_insert_aux", "vector::_M_fill_insert", "alpha1", "alpha2", "alpha3", "N1cc", "N2cc", "SaveName", "LoadName", "ObjWithoutHoles", "Morphology", "vector::_M_insert_aux", "level_up_message", "T_SHORT", "T_FLOAT", "data_step_down", "one_iteration", "output", "vector::_M_fill_insert", "comp_data", "columnSum", "N2cv3ocl16FilterEngine_GPUE", "N2cv3ocl14BaseFilter_GPUE", "N2cv3ocl17BaseRowFilter_GPUE", "N2cv3ocl20BaseColumnFilter_GPUE", "adaptiveBilateralFilter", "BORDER_CONSTANT", "BORDER_REPLICATE", "BORDER_REFLECT", "BORDER_REFLECT_101", "sep_filter_singlepass", "col_filter", "float", "uchar", "convert_uchar_sat", "float2", "uchar2", "convert_uchar2_sat", "float4", "uchar4", "convert_uchar4_sat", "convert_int_sat", "int4", "convert_int4_sat", "row_filter", "morph_C1_D0", "morph", "EXTRA_EXTRAPOLATION", "NO_EXTRA_EXTRAPOLATION", "BORDER_ISOLATED", "NO_BORDER_ISOLATED", "boxFilter", "vector::_M_fill_insert", "filter2D", "BORDER_WRAP", "vector::reserve", "uchar", "char", "ushort", "short", "float", "double", "uchar2", "char2", "ushort2", "short2", "int2", "float2", "double2", "uchar3", "char3", "ushort3", "short3", "int3", "float3", "double3", "uchar4", "char4", "ushort4", "short4", "int4", "float4", "double4", "convertC4C3", "copy_to_with_mask", "convertC3C4", "convert_to", "set_to_without_mask_C1_D0", "set_to_without_mask", "set_to_with_mask", "vector::_M_fill_insert", "lkSparse", "lkDense", "CL_DEVICE_NOT_FOUND", "CL_DEVICE_NOT_AVAILABLE", "CL_COMPILER_NOT_AVAILABLE", "CL_MEM_OBJECT_ALLOCATION_FAILURE", "CL_OUT_OF_RESOURCES", "CL_OUT_OF_HOST_MEMORY", "CL_PROFILING_INFO_NOT_AVAILABLE", "CL_MEM_COPY_OVERLAP", "CL_IMAGE_FORMAT_MISMATCH", "CL_IMAGE_FORMAT_NOT_SUPPORTED", "CL_BUILD_PROGRAM_FAILURE", "CL_MAP_FAILURE", "CL_MISALIGNED_SUB_BUFFER_OFFSET", "CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST", "CL_INVALID_VALUE", "CL_INVALID_DEVICE_TYPE", "CL_INVALID_PLATFORM", "CL_INVALID_DEVICE", "CL_INVALID_CONTEXT", "CL_INVALID_QUEUE_PROPERTIES", "CL_INVALID_COMMAND_QUEUE", "CL_INVALID_HOST_PTR", "CL_INVALID_MEM_OBJECT", "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR", "CL_INVALID_IMAGE_SIZE", "CL_INVALID_SAMPLER", "CL_INVALID_BINARY", "CL_INVALID_BUILD_OPTIONS", "CL_INVALID_PROGRAM", "CL_INVALID_PROGRAM_EXECUTABLE", "CL_INVALID_KERNEL_NAME", "CL_INVALID_KERNEL_DEFINITION", "CL_INVALID_KERNEL", "CL_INVALID_ARG_INDEX", "CL_INVALID_ARG_VALUE", "CL_INVALID_ARG_SIZE", "CL_INVALID_KERNEL_ARGS", "CL_INVALID_WORK_DIMENSION", "CL_INVALID_WORK_GROUP_SIZE", "CL_INVALID_WORK_ITEM_SIZE", "CL_INVALID_GLOBAL_OFFSET", "CL_INVALID_EVENT_WAIT_LIST", "CL_INVALID_EVENT", "CL_INVALID_OPERATION", "CL_INVALID_GL_OBJECT", "CL_INVALID_BUFFER_SIZE", "CL_INVALID_MIP_LEVEL", "CL_INVALID_GLOBAL_WORK_SIZE", "convert_float4", "pyrUp", "uchar", "char", "ushort", "short", "float", "updateFlow", "updateMatrices", "vector::_M_fill_insert", "gaussianBlur", "polynomialExpansion", "gaussianBlur5", "boxFilter5", "float", "double", "arithm_op_minMaxLoc_mask", "arithm_bitwise", "arithm_op_minMaxLoc", "FUNC_SUM", "FUNC_ABS_SUM", "FUNC_SQR_SUM", "arithm_op_sum", "_sat_rte", "_rte", "arithm_binary_op", "_mat", "_scalar", "_mask", "arithm_op_minMax", "arithm_compare", "arithm_absdiff_nonsaturate", "_binary", "arithm_flip_rows", "arithm_flip_cols", "arithm_flip_rows_cols", "arithm_exp", "arithm_log", "arithm_magnitude", "arithm_phase_indegrees", "arithm_phase_inradians", "arithm_cartToPolar", "arithm_polarToCart_mag", "arithm_polarToCart", "arithm_op_nonzero", "transpose_inplace", "transpose", "addWeighted", "arithm_pow", "setIdentity", "uchar", "char", "ushort", "short", "FUNC_ADD", "FUNC_SUB", "FUNC_MUL", "FUNC_DIV", "FUNC_ABS", "FUNC_ABS_DIFF", "FUNC_MIN", "FUNC_MAX", "ulong", "pyrDown", "CLAHE_OCL", "clipLimit", "tilesX", "tilesY", "integral_sum_cols", "integral_sum_rows", "Linear", "Cubic", "warpPerspective", "warpAffine", "medianFilter3", "medianFilter5", "threshold", "BORDER_CONSTANT", "BORDER_REFLECT101", "BORDER_REFLECT", "BORDER_REPLICATE", "convolve", "meanshiftproc_kernel", "meanshift_kernel", "integral_cols", "integral_rows", "_sat_rte", "remap", "_32FC2", "_16SC2", "_16UC1", "_2_32FC1", "sobel3", "sobel5", "sobel7", "calcMinEigenVal", "calcHarris", "copymakeborder", "calcLut", "transform", "bilateral", "bilateral2", "calc_sub_hist", "calc_sub_hist_border", "merge_hist", "calLUT", "resize", "_FAST", "THRESH_BINARY", "THRESH_BINARY_INV", "THRESH_TRUNC", "THRESH_TOZERO", "THRESH_TOZERO_INV", "uchar", "char", "ushort", "short", "float", "double", "INTER_NEAREST", "INTER_LINEAR", "INTER_CUBIC", "INTER_LANCZOS", "BORDER_WRAP", "BORDER_REFLECT_101", "BORDER_TRANSPARENT", "CUBIC", "AREA", "LAN4", "vector::reserve", "vector::_M_range_insert", "vector::_M_insert_aux", "BruteForceMatch_findBestMatch", "BruteForceMatch_Match", "BruteForceMatch_UnrollMatch", "BruteForceMatch_calcDistance", "BruteForceMatch_calcDistanceUnrolled", "BruteForceMatch_knnMatch", "BruteForceMatch_knnUnrollMatch", "BruteForceMatch_RadiusMatch", "BruteForceMatch_RadiusUnrollMatch", "vector::_M_fill_insert", "uchar", "char", "ushort", "short", "double", "buildWarpPerspectiveMaps", "buildWarpAffineMaps", "buildWarpSphericalMaps", "buildWarpCylindricalMaps", "buildWarpPlaneMaps", "init_message_", "compute_data_cost_", "compute_data_cost_reduce_", "init_data_cost_", "init_data_cost_reduce_", "get_first_k_initial_local_", "get_first_k_initial_global_", "compute_disp_", "compute_message_", "vector::_M_fill_insert", "NULL", "N2cv3ocl4MOG2E", "N2cv3ocl20BackgroundSubtractorE", "mog_withLearning_kernel", "mog_withoutLearning_kernel", "getBackgroundImage_kernel", "mog2_kernel", "getBackgroundImage2_kernel", "N2cv3ocl3MOGE", "gpuscaleclassifier", "vector::_M_fill_insert", "vector::_M_insert_aux", "gpuRunHaarClassifierCascade", "gpuRunHaarClassifierCascade_scaled2", "gpuRunHaarClassifierCascadePacked", "prefilter_xsobel", "stereoKernel", "textureness_kernel", "mat_dst", "split_vector", "Intel", "mat_src", "merge_vector", "vector::_M_fill_insert", "compute_hists_lut_kernel", "normalize_hists_36_kernel", "normalize_hists_kernel", "normalize_hists", "classify_hists_180_kernel", "classify_hists_252_kernel", "classify_hists_kernel", "extract_descrs_by_rows_kernel", "extract_descrs_by_cols_kernel", "compute_gradients_8UC1_kernel", "compute_gradients_8UC4_kernel", "vector::_M_insert_aux", "vector::_M_fill_insert", "OPENCV_OPENCL_BINARY", "clGetPlatformIDs", "clGetPlatformInfo", "clGetDeviceIDs", "clGetDeviceInfo", "clCreateSubDevices", "clRetainDevice", "clReleaseDevice", "clCreateContext", "clCreateContextFromType", "clRetainContext", "clReleaseContext", "clGetContextInfo", "clCreateCommandQueue", "clRetainCommandQueue", "clReleaseCommandQueue", "clGetCommandQueueInfo", "clCreateBuffer", "clCreateSubBuffer", "clCreateImage", "clRetainMemObject", "clReleaseMemObject", "clGetSupportedImageFormats", "clGetMemObjectInfo", "clGetImageInfo", "clSetMemObjectDestructorCallback", "clCreateSampler", "clRetainSampler", "clReleaseSampler", "clGetSamplerInfo", "clCreateProgramWithSource", "clCreateProgramWithBinary", "clCreateProgramWithBuiltInKernels", "clRetainProgram", "clReleaseProgram", "clBuildProgram", "clCompileProgram", "clLinkProgram", "clUnloadPlatformCompiler", "clGetProgramInfo", "clGetProgramBuildInfo", "clCreateKernel", "clCreateKernelsInProgram", "clRetainKernel", "clReleaseKernel", "clSetKernelArg", "clGetKernelInfo", "clGetKernelArgInfo", "clGetKernelWorkGroupInfo", "clWaitForEvents", "clGetEventInfo", "clCreateUserEvent", "clRetainEvent", "clReleaseEvent", "clSetUserEventStatus", "clSetEventCallback", "clGetEventProfilingInfo", "clFlush", "clFinish", "clEnqueueReadBuffer", "clEnqueueReadBufferRect", "clEnqueueWriteBuffer", "clEnqueueWriteBufferRect", "clEnqueueFillBuffer", "clEnqueueCopyBuffer", "clEnqueueCopyBufferRect", "clEnqueueReadImage", "clEnqueueWriteImage", "clEnqueueFillImage", "clEnqueueCopyImage", "clEnqueueCopyImageToBuffer", "clEnqueueCopyBufferToImage", "clEnqueueMapBuffer", "clEnqueueMapImage", "clEnqueueUnmapMemObject", "clEnqueueMigrateMemObjects", "clEnqueueNDRangeKernel", "clEnqueueTask", "clEnqueueNativeKernel", "clEnqueueMarkerWithWaitList", "clEnqueueBarrierWithWaitList", "clGetExtensionFunctionAddressForPlatform", "clCreateImage2D", "clCreateImage3D", "clEnqueueMarker", "clEnqueueWaitForEvents", "clEnqueueBarrier", "clUnloadCompiler", "clGetExtensionFunctionAddress", "vector::_M_insert_aux", "histogramRadixN", "permuteRadixN", "bitonicSort", "selectionSortLocal", "selectionSortFinal", "blockInsertionSort", "merge", "vector::_M_fill_insert", "uchar", "char", "ushort", "short", "float", "double", "memsetKernel", "normalizeKernel", "forwardWarpKernel", "blendFramesKernel", "vector::_M_fill_insert", "centeredGradientKernel", "estimateDualVariablesKernel", "estimateUKernel", "warpBackwardKernel", "N2cv3ocl15CvSVMKernel_oclE", "svm_linear", "svm_sigmod", "svm_poly", "svm_rbf", "my_svm", "N2cv3ocl9CvSVM_OCLE", "N2cv3ocl15CvSVMSolver_oclE", "vector::_M_fill_insert", "matchTemplate_Naive_SQDIFF", "matchTemplate_Naive_CCORR", "matchTemplate_Prepared_CCOFF", "normalizeKernel", "matchTemplate_Prepared_SQDIFF_NORMED", "extractFirstChannel", "caller", "matchTemplate_Prepared_CCOFF_NORMED", "custom_", "REVERSE", "ORDER", "RGBA2mRGBA", "mRGBA2RGBA", "RGB2RGB5x5", "RGB5x52RGB", "BGR5x52Gray", "Gray2BGR5x5", "RGB2Gray", "Gray2RGB", "RGB2YUV", "YUV2RGB", "YUV2RGBA_NV12", "RGB2YCrCb", "YCrCb2RGB", "RGB2XYZ", "XYZ2RGB", "RGB2", "_sat_rte", "blendLinear", "uchar", "char", "ushort", "short", "float", "double", "edgesHysteresisGlobal", "getEdges", "edgesHysteresisLocal", "calcMap", "calcMagnitude", "calcMagnitude_buf", "calcSobelRowPass", "distanceToCenters", "N2cv3ocl17KNearestNeighbourE", "knn_find_nearest", "N2cv7TLSDataINS_3ocl12CommandQueueEEE", "basic_string::substr", "cl_khr_fp64", "Intel", "vector::_M_fill_insert", "vector::_M_insert_aux", "OPENCV_OPENCL_DEVICE", "ACCELERATOR", "vector::_M_insert_aux", "vector::_M_fill_insert", "arithm_op_minMax", "arithm_op_minMax_final", "findCorners", "vector::reserve", "CvMoments", "contour", "icvContourMoments", "tvl1flow", "stereocsbp", "d203bd312e7d4f9915cdec480d0c54e1", "stereobp", "c1f26bdbf3637f3bf83d2d9b7adc3c2b", "stereobm", "split_mat", "pyrlk", "pyr_up", "pyr_down", "a852332a866d8849b7d1bfdd7017b87f", "optical_flow_farneback", "operator_setToM", "operator_setTo", "a19d7ffed8829cb4d606327c9d41db89", "operator_copyToM", "c6b06af957485640edb1940b4f8853fc", "operator_convertTo", "objdetect_hog", "moments", "merge_mat", "meanShift", "match_template", "knearest", "kmeans_kernel", "f860c405407c40547fd9e1af945944ad", "kernel_stablesort_by_key", "kernel_sort_by_key", "dcb847ed205163090b935d35efe4b6e6", "kernel_radix_sort_by_key", "interpolate_frames", "imgproc_warpPerspective", "imgproc_warpAffine", "imgproc_threshold", "imgproc_sobel3", "d91d5e7d7c63952c08769030655a5c90", "imgproc_resize", "dce4e0232bb7fd3e374f363a5311e3cc", "imgproc_remap", "imgproc_median", "imgproc_integral_sum", "e59da438d1e7b62e64504698acb985b2", "imgproc_integral", "imgproc_histogram", "c7700f9857976933b98297cf20dfc711", "imgproc_gftt", "imgproc_copymakeboder", "d7165bbf10e602973a40db33d5cfc4ad", "imgproc_convolve", "f7190f8357538986dbf934323c735bd8", "imgproc_columnsum", "b6c673aadf09dcda2c42262f9d0d8f40", "imgproc_clahe", "imgproc_canny", "imgproc_calcMinEigenVal", "af755a2a32c7b43016576fecac43fa29", "imgproc_calcHarris", "f2c0f92edc8f64eb31dc2f2034bc799f", "imgproc_bilateral", "haarobjectdetect_scaled2", "haarobjectdetect", "filtering_sep_filter_singlepass", "f48a37bd2a76b2d14666ef7fc1f6d88e", "filtering_morph", "filtering_filter2D", "ca32031fbf7bad598b8468e60df95be6", "filtering_boxFilter", "filtering_adaptive_bilateral", "filter_sep_row", "f8d165185422bdb2670abb440bc50225", "filter_sep_col", "cvt_color", "d8989aadab81f92a35b32db9740d9b62", "convertC3C4", "bb9cf383213d95e505f8677a285ee329", "build_warps", "brute_force_match", "blend_linear", "bgfg_mog", "arithm_transpose", "bd4ecb4b23c96b7c71399c6faa7a71f4", "arithm_sum", "arithm_setidentity", "bc19dcbca5a8d384082c7d000b806e1b", "arithm_pow", "a79b90c5a25fec8fe4d5af644308c7c5", "arithm_polarToCart", "arithm_phase", "arithm_nonzero", "arithm_minMaxLoc_mask", "a2ac711cf5b963637b561e0c868b7f04", "arithm_minMaxLoc", "a59ab29ff6ebd4dcab6304a7547f4cf3", "arithm_minMax", "d62572e14800b115334df5c2e2937529", "arithm_magnitude", "arithm_log", "arithm_flip", "arithm_exp", "arithm_compare", "arithm_cartToPolar", "a43471e45195c432df267f55f46bba02", "arithm_bitwise", "arithm_add_scalar_mask", "arithm_add_scalar", "arithm_add_mask", "arithm_addWeighted", "arithm_add", "arithm_absdiff_nonsaturate", "arithm_LUT", "afd02da735fe96c1be560841a0616208", "vector::_M_insert_aux", "vector::_M_fill_insert", "N2cv6detail19ExposureCompensatorE", "N2cv6detail18RotationWarperBaseINS0_18SphericalProjectorEEE", "N2cv6detail14RotationWarperE", "N2cv15SphericalWarperE", "N2cv13WarperCreatorE", "N2cv6detail9EstimatorE", "vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv6detail14FeaturesFinderE", "N2cv6detail15FeaturesMatcherE", "N2cv6detail18SurfFeaturesFinderE", "N2cv6detail17OrbFeaturesFinderE", "vector::reserve", "hessianThreshold", "nOctaves", "nOctaveLayers", "vector::_M_insert_aux", "vector::_M_fill_insert", "N2cv6detail21BestOf2NearestMatcherE", "vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv6detail21NoExposureCompensatorE", "N2cv6detail21BlocksGainCompensatorE", "vector::_M_fill_insert", "N2cv6detail15GainCompensatorE", "N2cv6detail10SeamFinderE", "N2cv6detail22GraphCutSeamFinderBaseE", "N2cv6detail18GraphCutSeamFinderE", "N2cv6detail18PairwiseSeamFinderE", "N2cv6detail12DpSeamFinderE", "N2cv6detail21GraphCutSeamFinderGpuE", "vector::reserve", "vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv6detail17VoronoiSeamFinderE", "N2cv6detail18GraphCutSeamFinder4ImplE", "N2cv6detail14FeatherBlenderE", "N2cv6detail7BlenderE", "N2cv6detail16MultiBandBlenderE", "vector::_M_fill_insert", "N2cv6detail18RotationWarperBaseINS0_26SphericalPortraitProjectorEEE", "N2cv6detail18RotationWarperBaseINS0_14PlaneProjectorEEE", "N2cv6detail23SphericalPortraitWarperE", "N2cv6detail15SphericalWarperE", "N2cv6detail11PlaneWarperE", "N2cv6detail17BundleAdjusterRayE", "N2cv6detail18BundleAdjusterBaseE", "N2cv6detail20BundleAdjusterReprojE", "N2cv6detail24HomographyBasedEstimatorE", "basic_string::substr", "vector::_M_insert_aux", "N2cv8superres15SuperResolutionE", "vector::_M_fill_insert", "scale", "iterations", "lambda", "alpha", "btvKernelSize", "blurKernelSize", "blurSigma", "temporalAreaRadius", "opticalFlow", "vector::_M_insert_aux", "buildMotionMapsKernel", "upscaleKernel", "diffSignKernel", "calcBtvRegularizationKernel", "scale", "iterations", "lambda", "alpha", "btvKernelSize", "blurKernelSize", "blurSigma", "temporalAreaRadius", "opticalFlow", "vector::_M_fill_insert", "N2cv8superres19DenseOpticalFlowExtE", "lambda", "theta", "nscales", "warps", "epsilon", "iterations", "useInitialFlow", "pyrScale", "numLevels", "winSize", "numIters", "polyN", "polySigma", "flags", "layers", "averagingBlockSize", "maxFlow", "sigmaDist", "sigmaColor", "postProcessWindow", "sigmaDistFix", "sigmaColorFix", "occThr", "upscaleAveragingRadius", "upscaleSigmaDist", "upscaleSigmaColor", "speedUpThr", "maxLevel", "N2cv8superres11FrameSourceE", "superres_btvl1", "inverse", "direct", "gold", "actual", "diff", "vector::reserve", "vector::_M_fill_insert", "BGR2BGRA", "BGRA2BGR", "BGR2RGBA", "RGBA2BGR", "BGR2RGB", "BGRA2RGBA", "BGR2GRAY", "RGB2GRAY", "GRAY2BGR", "GRAY2BGRA", "BGRA2GRAY", "RGBA2GRAY", "BGR2BGR565", "RGB2BGR565", "BGR5652BGR", "BGR5652RGB", "BGRA2BGR565", "RGBA2BGR565", "BGR5652BGRA", "BGR5652RGBA", "GRAY2BGR565", "BGR5652GRAY", "BGR2BGR555", "RGB2BGR555", "BGR5552BGR", "BGR5552RGB", "BGRA2BGR555", "RGBA2BGR555", "BGR5552BGRA", "BGR5552RGBA", "GRAY2BGR555", "BGR5552GRAY", "BGR2XYZ", "RGB2XYZ", "XYZ2BGR", "XYZ2RGB", "BGR2YCrCb", "RGB2YCrCb", "YCrCb2BGR", "YCrCb2RGB", "BGR2HSV", "RGB2HSV", "BGR2Lab", "RGB2Lab", "BayerBG2BGR", "BayerGB2BGR", "BayerRG2BGR", "BayerGR2BGR", "BGR2Luv", "RGB2Luv", "BGR2HLS", "RGB2HLS", "HSV2BGR", "HSV2RGB", "Lab2BGR", "Lab2RGB", "Luv2BGR", "Luv2RGB", "HLS2BGR", "HLS2RGB", "BayerBG2BGR_VNG", "BayerGB2BGR_VNG", "BayerRG2BGR_VNG", "BayerGR2BGR_VNG", "BGR2HSV_FULL", "RGB2HSV_FULL", "BGR2HLS_FULL", "RGB2HLS_FULL", "HSV2BGR_FULL", "HSV2RGB_FULL", "HLS2BGR_FULL", "HLS2RGB_FULL", "LBGR2Lab", "LRGB2Lab", "LBGR2Luv", "LRGB2Luv", "Lab2LBGR", "Lab2LRGB", "Luv2LBGR", "Luv2LRGB", "BGR2YUV", "RGB2YUV", "YUV2BGR", "YUV2RGB", "BayerBG2GRAY", "BayerGB2GRAY", "BayerRG2GRAY", "BayerGR2GRAY", "YUV2RGB_NV12", "YUV2BGR_NV12", "YUV2RGB_NV21", "YUV2BGR_NV21", "YUV2RGBA_NV12", "YUV2BGRA_NV12", "YUV2RGBA_NV21", "YUV2BGRA_NV21", "YUV2RGB_YV12", "YUV2BGR_YV12", "YUV2RGB_IYUV", "YUV2BGR_IYUV", "YUV2RGBA_YV12", "YUV2BGRA_YV12", "YUV2RGBA_IYUV", "YUV2BGRA_IYUV", "YUV2GRAY_420", "YUV2RGB_UYVY", "YUV2BGR_UYVY", "YUV2RGB_VYUY", "YUV2BGR_VYUY", "YUV2RGBA_UYVY", "YUV2BGRA_UYVY", "YUV2RGBA_VYUY", "YUV2BGRA_VYUY", "YUV2RGB_YUY2", "YUV2BGR_YUY2", "YUV2RGB_YVYU", "YUV2BGR_YVYU", "YUV2RGBA_YUY2", "YUV2BGRA_YUY2", "YUV2RGBA_YVYU", "YUV2BGRA_YVYU", "YUV2GRAY_UYVY", "YUV2GRAY_YUY2", "RGBA2mRGBA", "mRGBA2RGBA", "COLORCVT_MAX", "N6cvtest2TSE", "N6cvtest10BadArgTestE", "N6cvtest8BaseTestE", "OPENCV_TEST_DATA_PATH", "Succeeded", "Failed", "N6cvtest9ArrayTestE", "vector::_M_fill_insert", "min_log_array_size", "max_log_array_size", "test_case_count", "input", "output", "temporary", "mask", "N7testing11EnvironmentE", "N4perf8TestBase21PerfSkipTestExceptionE", "N4perf8TestBaseE", "OPENCV_TEST_DATA_PATH", "perf", "basic_string::substr", "_new", "undefined", "basic_string::erase", "last", "rng1", "rng2", "kind", "type", "cv_implementation", "cv_num_threads", "Failed", "cuda", "USRTYPE1", "vector::reserve", "expect_min", "actual_min", "expect_max", "actual_max", "expect_cols", "expect_rows", "expect_last", "actual_last", "expect_rng1", "actual_rng1", "expect_rng2", "actual_rng2", "expected_kind", "expected_type", "expected_length", "false", "true", "custom_status", "skipped", "bytesIn", "bytesOut", "term", "samples", "outliers", "frequency", "median", "gmean", "gstddev", "mean", "stddev", "test_start", "test_complete", "help", "perf_run_cpu", "plain", "perf_impl", "perf_strategy", "default", "base", "simple", "perf_max_outliers", "perf_min_samples", "perf_max_deviation", "perf_seed", "perf_time_limit", "perf_force_samples", "perf_write_sanity", "perf_verify_sanity", "perf_threads", "perf_affinity_mask", "perf_log_power_checkpoints", "perf_list_impls", "param_min_samples", "Succeeded", "N7testing31TestPartResultReporterInterfaceE", "N7testing8internal27OsStackTraceGetterInterfaceE", "N7testing8internal16DeathTestFactoryE", "N7testing17TestEventListenerE", "N7testing8internal9DeathTestE", "N7testing22EmptyTestEventListenerE", "N7testing8internal11ThreadLocalIPNS_31TestPartResultReporterInterfaceEE11ValueHolderE", "N7testing8internal26ThreadLocalValueHolderBaseE", "N7testing8internal26GoogleTestFailureExceptionE", "N7testing8internal11ThreadLocalISt6vectorINS0_9TraceInfoESaIS3_EEE11ValueHolderE", "N7testing8internal17StreamingListenerE", "N7testing8internal17StreamingListener12SocketWriterE", "N7testing8internal17StreamingListener20AbstractSocketWriterE", "GTEST_SHARD_INDEX", "catch_exceptions", "N7testing8internal24HasNewFatalFailureHelperE", "N7testing8TestCaseE", "N7testing8internal16ForkingDeathTestE", "N7testing8internal24XmlUnitTestResultPrinterE", "death_test_use_fork", "stream_result_to", "death_test_style", "fast", "break_on_failure", "N7testing8internal27PrettyUnitTestResultPrinterE", "N7testing8internal18OsStackTraceGetterE", "filter", "GTEST_SHARD_STATUS_FILE", "random_seed", "N7testing32ScopedFakeTestPartResultReporterE", "shuffle", "N7testing8internal13ExecDeathTestE", "N7testing8internal12UnitTestImplE", "N7testing8internal35DefaultGlobalTestPartResultReporterE", "N7testing8internal17TestEventRepeaterE", "internal_run_death_test", "stack_trace_depth", "TypeParam", "basic_string::substr", "gtest_", "vector::_M_range_check", "auto", "TERM", "xterm", "screen", "linux", "cygwin", "true", "gtest_internal_", "threadsafe", "Success", "test", "tests", "TEST", "TESTS", "stderr", "stdout", "NULL", "fast", "is_valid_", "false", "Failed", "TEST_PREMATURE_EXIT_FILE", "testsuites", "testsuite", "testcase", "notrun", "name", "value_param", "type_param", "status", "time", "classname", "failures", "disabled", "errors", "timestamp", "random_seed", "AllTests", "also_run_disabled_tests", "break_on_failure", "catch_exceptions", "color", "filter", "param_filter", "output", "print_time", "repeat", "shuffle", "stack_trace_depth", "stream_result_to", "throw_on_failure", "death_test_style", "death_test_use_fork", "param_filter", "N7testing8internal23DefaultDeathTestFactoryE", "N7testing8UnitTestE", "output", "N7testing8internal15NoExecDeathTestE", "list_tests", "N7testing8internal38DefaultPerThreadTestPartResultReporterE", "color", "throw_on_failure", "GTEST_TOTAL_SHARDS", "repeat", "print_time", "N7testing8internal13DeathTestImplE", "N7testing4TestE", "also_run_disabled_tests", "cv_version", "basic_string::substr", "cv_vcs_version", "cv_inner_vcs_version", "cv_build_type", "release", "cv_parallel_framework", "cv_cpu_features", "vector::_M_insert_aux", "vector::_M_fill_insert", "N2cv9videostab13InpainterBaseE", "N2cv9videostab18InpaintingPipelineE", "N2cv9videostab14ColorInpainterE", "N2cv9videostab21ColorAverageInpainterE", "N2cv9videostab25ConsistentMosaicInpainterE", "N2cv9videostab15MotionInpainterE", "N2cv9videostab12DeblurerBaseE", "N2cv9videostab17WeightingDeblurerE", "N2cv9videostab22IGlobalMotionEstimatorE", "N2cv9videostab23ISparseOptFlowEstimatorE", "N2cv9videostab26PyrLkRobustMotionEstimatorE", "vector::_M_fill_insert", "vector::_M_insert_aux", "vector::reserve", "vector::_M_fill_insert", "N2cv9videostab17IMotionStabilizerE", "N2cv9videostab16MotionFilterBaseE", "N2cv9videostab20GaussianMotionFilterE", "vector::_M_fill_insert", "N2cv9videostab25PyrLkOptFlowEstimatorBaseE", "N2cv9videostab27SparsePyrLkOptFlowEstimatorE", "N2cv9videostab4ILogE", "N2cv9videostab11LogToStdoutE", "N2cv9videostab12IFrameSourceE", "N2cv9videostab15VideoFileSourceE", "N2cv9videostab13NullInpainterE", "N2cv9videostab12NullDeblurerE", "N2cv9videostab15NullFrameSourceE", "N2cv9videostab7NullLogE", "N2cv9videostab14StabilizerBaseE", "N2cv9videostab17TwoPassStabilizerE", "vector::_M_fill_insert", "vector::_M_insert_aux", "N2cv9videostab17OnePassStabilizerE", "png_set_gAMA", "IDAT", "text", "version", "stream", "memory", "unknown", "png_set_background", "undefined", "TIFFUnlinkDirectory", "TIFFAdvanceDirectory", "_TIFFVSetField", "_TIFFVGetField", "DotRange", "Unknown", "TIFFSetField", "TIFFMergeFieldInfo", "_TIFFMergeFields", "TRUE", "FALSE", "_TIFFSetupFields", "TIFFFieldWithTag", "TIFFFieldWithName", "SubfileType", "OldSubfileType", "ImageWidth", "ImageLength", "BitsPerSample", "Compression", "PhotometricInterpretation", "Threshholding", "CellWidth", "CellLength", "FillOrder", "DocumentName", "ImageDescription", "Make", "Model", "StripOffsets", "Orientation", "SamplesPerPixel", "RowsPerStrip", "StripByteCounts", "MinSampleValue", "MaxSampleValue", "XResolution", "YResolution", "PlanarConfiguration", "PageName", "XPosition", "YPosition", "FreeOffsets", "FreeByteCounts", "GrayResponseUnit", "GrayResponseCurve", "ResolutionUnit", "PageNumber", "ColorResponseUnit", "TransferFunction", "Software", "DateTime", "Artist", "HostComputer", "WhitePoint", "PrimaryChromaticities", "ColorMap", "HalftoneHints", "TileWidth", "TileLength", "TileOffsets", "TileByteCounts", "SubIFD", "InkSet", "InkNames", "NumberOfInks", "DotRange", "TargetPrinter", "ExtraSamples", "SampleFormat", "SMinSampleValue", "SMaxSampleValue", "ClipPath", "XClipPathUnits", "YClipPathUnits", "YCbCrCoefficients", "YCbCrSubsampling", "YCbCrPositioning", "ReferenceBlackWhite", "XMLPacket", "Matteing", "DataType", "ImageDepth", "TileDepth", "ImageFullWidth", "ImageFullLength", "TextureFormat", "TextureWrapModes", "FieldOfViewCotangent", "MatrixWorldToScreen", "MatrixWorldToCamera", "Copyright", "RichTIFFIPTC", "Photoshop", "EXIFIFDOffset", "GPSIFDOffset", "FaxRecvParams", "FaxSubAddress", "FaxRecvTime", "FaxDcs", "StoNits", "InteroperabilityIFDOffset", "DNGVersion", "DNGBackwardVersion", "UniqueCameraModel", "LocalizedCameraModel", "CFAPlaneColor", "CFALayout", "LinearizationTable", "BlackLevelRepeatDim", "BlackLevel", "BlackLevelDeltaH", "BlackLevelDeltaV", "WhiteLevel", "DefaultScale", "BestQualityScale", "DefaultCropOrigin", "DefaultCropSize", "ColorMatrix1", "ColorMatrix2", "CameraCalibration1", "CameraCalibration2", "ReductionMatrix1", "ReductionMatrix2", "AnalogBalance", "AsShotNeutral", "AsShotWhiteXY", "BaselineExposure", "BaselineNoise", "BaselineSharpness", "BayerGreenSplit", "LinearResponseLimit", "CameraSerialNumber", "LensInfo", "ChromaBlurRadius", "AntiAliasStrength", "ShadowScale", "DNGPrivateData", "MakerNoteSafety", "CalibrationIlluminant1", "CalibrationIlluminant2", "RawDataUniqueID", "OriginalRawFileName", "OriginalRawFileData", "ActiveArea", "MaskedAreas", "AsShotICCProfile", "AsShotPreProfileMatrix", "CurrentICCProfile", "CurrentPreProfileMatrix", "PerSample", "ExposureTime", "FNumber", "ExposureProgram", "SpectralSensitivity", "ISOSpeedRatings", "OptoelectricConversionFactor", "ExifVersion", "DateTimeOriginal", "DateTimeDigitized", "ComponentsConfiguration", "CompressedBitsPerPixel", "ShutterSpeedValue", "ApertureValue", "BrightnessValue", "ExposureBiasValue", "MaxApertureValue", "SubjectDistance", "MeteringMode", "LightSource", "Flash", "FocalLength", "SubjectArea", "MakerNote", "UserComment", "SubSecTime", "SubSecTimeOriginal", "SubSecTimeDigitized", "FlashpixVersion", "ColorSpace", "PixelXDimension", "PixelYDimension", "RelatedSoundFile", "FlashEnergy", "SpatialFrequencyResponse", "FocalPlaneXResolution", "FocalPlaneYResolution", "FocalPlaneResolutionUnit", "SubjectLocation", "ExposureIndex", "SensingMethod", "FileSource", "SceneType", "CFAPattern", "CustomRendered", "ExposureMode", "WhiteBalance", "DigitalZoomRatio", "FocalLengthIn35mmFilm", "SceneCaptureType", "GainControl", "Contrast", "Saturation", "Sharpness", "DeviceSettingDescription", "SubjectDistanceRange", "ImageUniqueID", "TIFFFetchNormalTag", "MissingRequired", "TIFFReadDirectoryCheckOrder", "EstimateStripByteCounts", "TIFFFetchDirectory", "ReadDirEntryArray", "TIFFFetchNormalTag", "SubjectDistance", "tiles", "strips", "TileOffsets", "StripOffsets", "Compression", "ImageLength", "Colormap", "StripByteCounts", "TIFFFetchStripThing", "TIFFReadDirectory", "TIFFFetchSubjectDistance", "TIFFReadCustomDirectory", "BuildMapUaToAa", "BuildMapBitdepth16To8", "gtStripSeparate", "gtTileSeparate", "InkSet", "Compression", "Planarconfiguration", "initCIELabConversion", "PhotometricInterpretation", "TIFFClientOpen", "TIFFFillStrip", "TIFFReadRawTile", "TIFFFillTile", "TIFFReadRawStrip", "TIFFReadBufferSetup", "TIFFFillStripPartial", "TIFFReadEncodedStrip", "TIFFReadEncodedTile", "TIFFScanlineSize64", "TIFFVStripSize64", "TIFFRasterScanlineSize64", "TIFFScanlineSize", "TIFFVStripSize", "TIFFRawStripSize64", "TIFFRawStripSize", "TIFFRasterScanlineSize", "TIFFNumberOfStrips", "TIFFStripSize", "TIFFComputeStrip", "TIFFNumberOfTiles", "TIFFTileRowSize", "TIFFVTileSize64", "TIFFVTileSize", "TIFFTileSize", "TIFFWriteScanline", "TIFFWriteBufferSetup", "TIFFWriteEncodedStrip", "TIFFWriteRawStrip", "TIFFAppendToStrip", "TIFFWriteEncodedTile", "tile", "strip", "TIFFWriteRawTile", "TIFFOpen", "scanline", "strip", "tile", "TIFFRegisterCODEC", "TIFFUnRegisterCODEC", "TIFFWriteDirectoryTagSubifd", "TIFFWriteDirectorySec", "TIFFWriteDirectoryTagCheckedRationalArray", "TIFFWriteDirectoryTagData", "TIFFWriteDirectoryTagColormap", "TIFFResetField", "TIFFWriteDirectoryTagIfdIfd8Array", "TIFFWriteDirectoryTagSampleformatArray", "TIFFWriteDirectoryTagCheckedSrationalArray", "TIFFLinkDirectory", "TIFFWriteDirectoryTagTransferfunction", "TIFFRewriteDirectory", "TIFFWriteDirectoryTagShortPerSample", "TIFFWriteDirectoryTagLongLong8Array", "None", "PackBits", "ThunderScan", "NeXT", "JPEG", "Deflate", "AdobeDeflate", "PixarLog", "SGILog", "SGILog24", "LZMA", "DumpModeDecode", "Fax3DecodeRLE", "Fax3Decode1D", "Fax3Encode", "Fax3Decode2D", "InitCCITTFax3", "tile", "strip", "TIFFInitCCITTFax3", "TIFFInitCCITTFax4", "Group3Options", "FaxMode", "FaxFillFunc", "BadFaxLines", "CleanFaxData", "ConsecutiveBadFaxLines", "Group4Options", "InitCCITTFax3", "Fax4Encode", "Fax4Decode", "Fax3SetupState", "LogL16Decode", "LogLuvSetupEncode", "LogLuvInitState", "LogLuvDecode24", "TIFFInitSGILog", "SGILogDataFmt", "SGILogEncode", "LogLuvSetupDecode", "LogLuvVSetField", "LogL16InitState", "LogLuvDecode32", "LZWSetupEncode", "LZWDecodeCompat", "LZWPreDecode", "LZWDecode", "LZWSetupDecode", "NeXTDecode", "PackBitsDecode", "PixarLogVSetField", "PixarLogPreEncode", "PixarLogEncode", "PixarLogSetupEncode", "PixarLogSetupDecode", "PixarLogPreDecode", "PixarLogDecode", "TIFFInitPixarLog", "PixarLogPostEncode", "PredictorSetup", "TIFFPredictorInit", "Predictor", "PredictorEncodeTile", "ThunderDecodeRow", "ZIPPostEncode", "TIFFInitZIP", "ZIPSetupDecode", "ZIPVSetField", "ZIPPreDecode", "ZIPSetupEncode", "ZIPPreEncode", "ZIPDecode", "ZIPEncode", "Unknown", "FTYP", "JP2H", "IHDR", "BPCC", "COLR", "PCLR", "CMAP", "CDEF", "RESC", "RESD", "JP2C", "JP2I", "UUID", "UINF", "ULST", "maxlyrs", "maxpkts", "debug", "real", "lrcp", "rlcp", "rpcl", "pcrl", "cprl", "debug", "imgareatlx", "imgareatly", "tilegrdtlx", "tilegrdtly", "tilewidth", "tileheight", "prcwidth", "prcheight", "cblkwidth", "cblkheight", "mode", "nomct", "numrlvls", "lazy", "termall", "segsym", "vcausal", "pterm", "resetprob", "numgbits", "rate", "ilyrrates", "_jp2overhead", "UNKNOWN", "N3Iex7TypeExcE", "N3Imf14TypedAttributeINS_9LineOrderEEE", "N3Imf14TypedAttributeIN5Imath4Vec2IfEEEE", "N3Imf14TypedAttributeIfEE", "N3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IiEEEEEE", "N3Imf14TypedAttributeINS_11ChannelListEEE", "N3Iex6ArgExcE", "N3Imf14TypedAttributeINS_15TileDescriptionEEE", "N3Imf14TypedAttributeINS_12PreviewImageEEE", "N3Iex8InputExcE", "N3Imf14TypedAttributeIN5Imath4Vec3IiEEEE", "N3Imf14TypedAttributeIN5Imath4Vec3IfEEEE", "N3Imf14TypedAttributeIN5Imath4Vec3IdEEEE", "N3Imf14TypedAttributeIN5Imath4Vec2IiEEEE", "N3Imf14TypedAttributeIN5Imath4Vec2IdEEEE", "N3Imf14TypedAttributeINS_8TimeCodeEEE", "N3Imf14TypedAttributeISt6vectorISsSaISsEEEE", "N3Imf14TypedAttributeISsEE", "N3Imf14TypedAttributeINS_8RationalEEE", "N3Imf14TypedAttributeIN5Imath8Matrix44IfEEEE", "N3Imf14TypedAttributeIN5Imath8Matrix44IdEEEE", "N3Imf14TypedAttributeIN5Imath8Matrix33IfEEEE", "N3Imf14TypedAttributeIN5Imath8Matrix33IdEEEE", "N3Imf14TypedAttributeINS_7KeyCodeEEE", "N3Imf14TypedAttributeIiEE", "N3Imf14TypedAttributeINS_6EnvmapEEE", "N3Imf14TypedAttributeIdEE", "N3Imf14TypedAttributeINS_14ChromaticitiesEEE", "N3Imf14TypedAttributeIN5Imath3BoxINS1_4Vec2IfEEEEEE", "preview", "displayWindow", "dataWindow", "pixelAspectRatio", "screenWindowCenter", "screenWindowWidth", "channels", "lineOrder", "compression", "tiles", "timecode", "N3Imf15OpaqueAttributeE", "compression", "stringvector", "chromaticities", "whiteLuminance", "adoptedNeutral", "renderingTransform", "lookModTransform", "xDensity", "owner", "comments", "capDate", "utcOffset", "longitude", "latitude", "altitude", "focus", "expTime", "aperture", "isoSpeed", "envmap", "keyCode", "timeCode", "wrapmodes", "framesPerSecond", "multiView", "worldToCamera", "worldToNDC", "N3Iex7MathExcE", "N5Imath13SingMatrixExcE", "double", "N3Iex11OverflowExcE", "N3Imf10CompressorE", "box2i", "box2f", "N3Imf13B44CompressorE", "tiledesc", "N3Iex5IoExcE", "N3Iex8LogicExcE", "N3Imf10OutputFileE", "N3Imf10OutputFile4DataE", "tiles", "preview", "vector::_M_fill_insert", "chromaticities", "chlist", "N3Imf9AttributeE", "N3Imf9InputFileE", "N3Imf9InputFile4DataE", "N3Imf15Pxr24CompressorE", "lineOrder", "keycode", "basic_string::erase", "float", "N3Imf13ZipCompressorE", "preview", "N3Iex8ErrnoExcE", "N3Imf11StdOFStreamE", "N3Imf11StdOSStreamE", "N3Imf11StdIFStreamE", "m33f", "m33d", "m44f", "m44d", "N3Iex9EdquotExcE", "N3Iex12EcanceledExcE", "N3Iex12EremoteioExcE", "N3Iex9EisnamExcE", "N3Iex10EnavailExcE", "N3Iex10EnotnamExcE", "N3Iex10EucleanExcE", "N3Iex9EstaleExcE", "N3Iex14EinprogressExcE", "N3Iex11EalreadyExcE", "N3Iex15EhostunreachExcE", "N3Iex12EhostdownExcE", "N3Iex15EconnrefusedExcE", "N3Iex12EtimedoutExcE", "N3Iex15EtoomanyrefsExcE", "N3Iex12EshutdownExcE", "N3Iex11EnotconnExcE", "N3Iex10EisconnExcE", "N3Iex10EnobufsExcE", "N3Iex13EconnresetExcE", "N3Iex15EconnabortedExcE", "N3Iex12EnetresetExcE", "N3Iex14EnetunreachExcE", "N3Iex11EnetdownExcE", "N3Iex16EaddrnotavailExcE", "N3Iex13EaddrinuseExcE", "N3Iex15EafnosupportExcE", "N3Iex15EpfnosupportExcE", "N3Iex13EopnotsuppExcE", "N3Iex18EsocktnosupportExcE", "N3Iex18EprotonosupportExcE", "N3Iex14EnoprotooptExcE", "N3Iex13EprototypeExcE", "N3Iex11EmsgsizeExcE", "N3Iex15EdestaddrreqExcE", "N3Iex11EnotsockExcE", "N3Iex9EusersExcE", "N3Iex12EnotemptyExcE", "N3Iex11EstrpipeExcE", "N3Iex11ErestartExcE", "N3Iex8EloopExcE", "N3Iex9EnosysExcE", "N3Iex9EilseqExcE", "N3Iex11ElibexecExcE", "N3Iex10ElibmaxExcE", "N3Iex10ElibscnExcE", "N3Iex10ElibbadExcE", "N3Iex10ElibaccExcE", "N3Iex10EremchgExcE", "N3Iex9EbadfdExcE", "N3Iex11EnotuniqExcE", "N3Iex12EoverflowExcE", "N3Iex15EnametoolongExcE", "N3Iex10EbadmsgExcE", "N3Iex12EmultihopExcE", "N3Iex9EprotoExcE", "N3Iex8EcommExcE", "N3Iex9EsrmntExcE", "N3Iex7EadvExcE", "N3Iex10EnolinkExcE", "N3Iex10EremoteExcE", "N3Iex9EnopkgExcE", "N3Iex9EnonetExcE", "N3Iex8EnosrExcE", "N3Iex8EtimeExcE", "N3Iex10EnodataExcE", "N3Iex9EnostrExcE", "N3Iex9EbfontExcE", "N3Iex10EbadsltExcE", "N3Iex10EbadrqcExcE", "N3Iex9EnoanoExcE", "N3Iex9ExfullExcE", "N3Iex8EbadrExcE", "N3Iex8EbadeExcE", "N3Iex9EnolckExcE", "N3Iex10EdeadlkExcE", "N3Iex9El2hltExcE", "N3Iex10EunatchExcE", "N3Iex9ElnrngExcE", "N3Iex9El3rstExcE", "N3Iex9El3hltExcE", "N3Iex11El2nsyncExcE", "N3Iex9EchrngExcE", "N3Iex8EidrmExcE", "N3Iex9EnomsgExcE", "N3Iex9ErangeExcE", "N3Iex7EdomExcE", "N3Iex8EpipeExcE", "N3Iex9EmlinkExcE", "N3Iex8ErofsExcE", "N3Iex9EspipeExcE", "N3Iex9EnospcExcE", "N3Iex8EfbigExcE", "N3Iex10EtxtbsyExcE", "N3Iex9EnottyExcE", "N3Iex9EmfileExcE", "N3Iex9EnfileExcE", "N3Iex9EinvalExcE", "N3Iex9EisdirExcE", "N3Iex10EnotdirExcE", "N3Iex9EnodevExcE", "N3Iex8ExdevExcE", "N3Iex9EexistExcE", "N3Iex8EbusyExcE", "N3Iex10EnotblkExcE", "N3Iex9EfaultExcE", "N3Iex9EaccesExcE", "N3Iex9EnomemExcE", "N3Iex9EagainExcE", "N3Iex9EchildExcE", "N3Iex8EbadfExcE", "N3Iex10EnoexecExcE", "N3Iex8E2bigExcE", "N3Iex8EnxioExcE", "N3Iex6EioExcE", "N3Iex8EintrExcE", "N3Iex8EsrchExcE", "N3Iex9EnoentExcE", "N3Iex8EpermExcE", "N3Iex7BaseExcE", "N9IlmThread9SemaphoreE", "N9IlmThread5MutexE", "N9IlmThread4TaskE", "N9IlmThread10ThreadPoolE", "N9IlmThread6ThreadE", "rational", "envmap", "N3Imf7OStreamE", "N3Imf7IStreamE", "string", "vector::_M_fill_insert", "vector::_M_fill_insert", "N3Imf17ScanLineInputFile4DataE", "N3Imf17ScanLineInputFileE", "N3Imf13PizCompressorE", "N3Imf14TiledInputFileE", "N3Imf14TiledInputFile4DataE", "vector::_M_fill_insert", "N3Imf13RleCompressorE", "vector::_M_fill_insert", "OpenCV::camera", "libnative_camera", "initCameraConnectC", "closeCameraConnectC", "getCameraPropertyC", "setCameraPropertyC", "applyCameraPropertiesC", "St10ctype_base", "St5ctypeIcE", "St5ctypeIwE", "St8ios_base", "NSt8ios_base7failureE", "N9__gnu_cxx24__concurrence_lock_errorE", "N9__gnu_cxx26__concurrence_unlock_errorE", "NSt6locale5facetE", "__gnu_cxx::__concurrence_lock_error", "__gnu_cxx::__concurrence_unlock_error", "St13runtime_error", "St12out_of_range", "St11logic_error", "St12length_error", "St14error_category", "generic", "system", "POSIX", "space", "print", "cntrl", "upper", "lower", "alpha", "digit", "punct", "xdigit", "alnum", "graph", "true", "false", "LC_CTYPE", "LC_NUMERIC", "LC_TIME", "LC_COLLATE", "LC_MONETARY", "LC_MESSAGES", "St14basic_ifstreamIcSt11char_traitsIcEE", "St13basic_fstreamIcSt11char_traitsIcEE", "St13basic_filebufIcSt11char_traitsIcEE", "St14basic_ofstreamIcSt11char_traitsIcEE", "St9basic_iosIwSt11char_traitsIwEE", "St9basic_iosIcSt11char_traitsIcEE", "basic_ios::clear", "St13basic_istreamIwSt11char_traitsIwEE", "St9time_base", "St12codecvt_base", "St13messages_base", "St10money_base", "St7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St9money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St16__numpunct_cacheIcE", "St11__timepunctIcE", "St9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St18__moneypunct_cacheIcLb1EE", "St7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE", "St8messagesIcE", "St8numpunctIcE", "St10moneypunctIcLb0EE", "St8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE", "St7collateIcE", "St10moneypunctIcLb1EE", "St18__moneypunct_cacheIcLb0EE", "St17__timepunct_cacheIcE", "POSIX", "basic_string::erase", "St23__codecvt_abstract_baseIcc9mbstate_tE", "N9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE", "N9__gnu_cxx18stdio_sync_filebufIcSt11char_traitsIcEEE", "St13basic_ostreamIwSt11char_traitsIwEE", "St19basic_ostringstreamIcSt11char_traitsIcESaIcEE", "St18basic_stringstreamIcSt11char_traitsIcESaIcEE", "St15basic_stringbufIcSt11char_traitsIcESaIcEE", "St15basic_streambufIwSt11char_traitsIwEE", "St15basic_streambufIcSt11char_traitsIcEE", "basic_string::at", "basic_string::copy", "basic_string::compare", "basic_string::_S_create", "basic_string::assign", "basic_string::_M_replace_aux", "basic_string::replace", "basic_string::insert", "basic_string::erase", "basic_string::append", "basic_string::resize", "basic_string::basic_string", "basic_string::substr", "St10moneypunctIwLb0EE", "St10moneypunctIwLb1EE", "POSIX", "basic_string::erase", "St18__moneypunct_cacheIwLb0EE", "St9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St7collateIwE", "St17__timepunct_cacheIwE", "St7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St18__moneypunct_cacheIwLb1EE", "St23__codecvt_abstract_baseIwc9mbstate_tE", "St8messagesIwE", "St16__numpunct_cacheIwE", "St21__ctype_abstract_baseIwE", "St11__timepunctIwE", "St8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE", "St9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "St8numpunctIwE", "St8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE", "basic_string::at", "basic_string::copy", "basic_string::compare", "basic_string::_S_create", "basic_string::assign", "basic_string::_M_replace_aux", "basic_string::replace", "basic_string::insert", "basic_string::erase", "basic_string::append", "basic_string::resize", "basic_string::basic_string", "basic_string::substr", "std::bad_alloc", "St9bad_alloc", "St8bad_cast", "std::bad_cast", "std::bad_typeid", "St10bad_typeid", "N10__cxxabiv117__class_type_infoE", "N10__cxxabiv115__forced_unwindE", "N10__cxxabiv119__foreign_exceptionE", "std::exception", "std::bad_exception", "St9exception", "St13bad_exception", "N10__cxxabiv116__enum_type_infoE", "PKDs", "PKDi", "PKDf", "PKDd", "PKDe", "PKDn", "N10__cxxabiv123__fundamental_type_infoE", "N9__gnu_cxx24__concurrence_wait_errorE", "N9__gnu_cxx29__concurrence_broadcast_errorE", "__gnu_cxx::__concurrence_lock_error", "__gnu_cxx::__concurrence_unlock_error", "__gnu_cxx::__concurrence_broadcast_error", "__gnu_cxx::__concurrence_wait_error", "N10__cxxabiv119__pointer_type_infoE", "N10__cxxabiv120__si_class_type_infoE", "St9type_info", "N10__cxxabiv121__vmi_class_type_infoE", "St7codecvtIwc9mbstate_tE", "St7codecvtIcc9mbstate_tE", "AKST", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "January", "February", "March", "April", "June", "July", "August", "September", "October", "November", "December", "N10__cxxabiv117__pbase_type_infoE", "_GLOBAL_", "JArray", "_Accum", "_Fract", "operator", "false", "true", "bool", "boolean", "char", "byte", "double", "float", "__float128", "unsigned", "long", "__int128", "short", "void", "wchar_t", "decimal32", "decimal64", "decimal128", "half", "char16_t", "char32_t", "std::allocator", "allocator", "std::basic_string", "basic_string", "std::string", "std::istream", "basic_istream", "std::ostream", "basic_ostream", "std::iostream", "basic_iostream", "delete"], "debugstrings": ["module != 0 && module->name != 0 && module->version != 0", "<?xml version=\"1.0\" encoding=\"%s\"?>\n", "<?xml version=\"1.0\"?>\n", "Unsupported YAML version (it must be 1.x)", "virtual int EmptyDeviceInfoFuncTable::minorVersion(int) const", "virtual int EmptyDeviceInfoFuncTable::majorVersion(int) const", "Unknown/unsupported color conversion code", "JPEG2000 LOADER ERROR: colorspace conversion failed\n", "version?", "version doesnot match", "RetinaFilter::checkInput: input buffer does not match retina buffer size, conversion aborted", "RetinaColor::applyKrauskopfLMS2Acr1cr2Transform: input buffer does not match retina buffer size, conversion aborted", "RGB<->Grayscale conversion is not implemented for images stored in XML/YAML", "RGB<->Grayscale conversion is not implemented for matrices stored in XML/YAML", "oclMat's number of rows can not be changed for current version", "Unknown/unsupported color conversion code", "Skip unsupported version of OpenCL device: ", "gtest_streaming_protocol_version=1.0", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", "cv_version", "OpenCV version: ", "Version control", "cv_vcs_version", "OpenCV VCS version: ", "inner version", "cv_inner_vcs_version", "Inner VCS version: ", "Wrong JPEG library version: library is %d, caller expects %d", "Unsupported color conversion request", "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d", "JFIF APP0 marker: version %d.%02d, density %dx%d  %d", ") version error", "version", " libpng version 1.5.12 - July 11, 2012\n\n", "ASCII conversion buffer too small", "zlib version error", "PNG file corrupted by ASCII conversion", "DNGVersion", "DNGBackwardVersion", "OptoelectricConversionFactor", "ExifVersion", "FlashpixVersion", "No space for YCbCr->RGB conversion state", "No space for photometric conversion table", "No space for CIE L*a*b*->RGB conversion state.", "Failed to initialize CIE L*a*b*->RGB conversion state.", "initCIELabConversion", "Not a TIFF file, bad version number %d (0x%x)", "Creator: JasPer Version %s", "Cannot read version ", " image files.  Current file format version is ", "The file format version number's flag field contains unrecognized flags.", "basic_filebuf::_M_convert_to_external conversion error", "GCC: (GNU) 4.6 20120106 (prerelease)"], "localsymbols": [""], "dependencies": ["libc.so", "libdl.so", "libjnigraphics.so", "libz.so", "liblog.so", "libm.so"], "elfname": "libopencv_java.so"}